[{"figure_path": "9O2sVnEHor/figures/figures_1_1.jpg", "caption": "Figure 1: Visual depiction of r-lGIN: During preprocessing, we calculate the path neighborhoods Nr(v) for each node v in the graph G. Paths of varying lengths are processed separately using simple GINs, and their embeddings are pooled to obtain the final graph embedding. The forward complexity scales linearly with the sizes of Nr(v), enabling efficient computation on sparse graphs.", "description": "This figure shows the architecture of r-lGIN, a graph neural network (GNN) based on the r-loopy Weisfeiler-Leman test.  The input is a graph. The preprocessing step extracts the r-neighborhoods for each node, which are collections of paths of length up to r connecting neighbors of the node. These paths are processed by separate graph isomorphism networks (GINs), and their embeddings are pooled together to create a node embedding.  Node embeddings are then pooled to create a graph embedding. The process is designed to be computationally efficient, especially for sparse graphs, as the complexity scales linearly with the size of the r-neighborhoods. ", "section": "Main Contributions"}, {"figure_path": "9O2sVnEHor/figures/figures_3_1.jpg", "caption": "Figure 1: Visual depiction of r-lGIN: During preprocessing, we calculate the path neighborhoods Nr(v) for each node v in the graph G. Paths of varying lengths are processed separately using simple GINs, and their embeddings are pooled to obtain the final graph embedding. The forward complexity scales linearly with the sizes of N\u2084(v), enabling efficient computation on sparse graphs.", "description": "This figure illustrates the architecture of the r-loopy Graph Isomorphism Network (r-lGIN).  The input graph undergoes preprocessing where path neighborhoods of varying lengths (r-neighborhoods) are calculated for each node. These paths are then processed independently by using simple Graph Isomorphism Networks (GINs). The resulting embeddings are pooled together to create a final graph embedding. The linear scaling of the forward complexity with the size of r-neighborhoods ensures the efficiency of the model, particularly for sparse graphs.", "section": "Main Contributions"}, {"figure_path": "9O2sVnEHor/figures/figures_6_1.jpg", "caption": "Figure 3: Indistinguishable pairs at initialization, symlog scale. For GRAPH8C and EXP_ISO, we report the proportion of indistinguished pairs: 2 graphs are deemed indistinguishable if the L\u00b9 distance of their embeddings is less than 10\u207b\u00b3. For COSPECTRAL10 and SR16622, we report the L\u00b9 distance between graph embeddings. We report the mean and standard deviation over 100 seeds.", "description": "This figure shows the results of an experiment testing the expressive power of the r-lGIN model.  Four different datasets (GRAPH8C, EXP_ISO, COSPECTRAL10, SR16622) are used to compare the ability of the model to distinguish between pairs of graphs that are considered indistinguishable by other methods. The x-axis represents the proportion of indistinguishable pairs or the L\u00b9 distance between graph embeddings (depending on the dataset), and the y-axis shows the parameter 'r' used in the r-lGIN model.  The plot visually demonstrates how increasing 'r' improves the model's ability to distinguish between non-isomorphic graphs.", "section": "Expressive Power"}, {"figure_path": "9O2sVnEHor/figures/figures_7_1.jpg", "caption": "Figure 4: Test accuracy on synthetic classification task: (left) shared and (right) non-shared weights.", "description": "The figure shows the test accuracy on three synthetic classification tasks (EXP, CEXP, CSL) with different values of \\(r\\). The left panel shows results when the weights are shared among all \\(r\\) values, while the right panel shows results when the weights are not shared.  The results demonstrate that increasing \\(r\\) generally improves test accuracy, especially with non-shared weights.  This highlights the benefit of the proposed r-lGIN architecture in capturing higher-order structural information in graphs.", "section": "7 Experiments"}, {"figure_path": "9O2sVnEHor/figures/figures_15_1.jpg", "caption": "Figure 5: Examples of non-injective homomorphism (row 1), subgraph isomorphism (row 2), bijective homomorphism with non-homomorphic inverse (row 3), and isomorphism (row 4). For better clarity, the mappings h : V(F) \u2192 V(G) are visually represented with colors, where F is consistently on the left, and G is on the right in each row.", "description": "This figure shows four rows of graph pairs, illustrating the differences between homomorphism, subgraph isomorphism, bijective homomorphism and isomorphism.  The mappings between the graphs are visually represented with colors for clarity. In each row, the graph on the left is consistently F and the one on the right G. Row 1 shows a non-injective homomorphism. Row 2 is a subgraph isomorphism, indicating that F is a subgraph of G. Row 3 presents a bijective homomorphism with a non-homomorphic inverse, while the final row illustrates isomorphism where the graphs are identical.", "section": "3 Preliminaries"}, {"figure_path": "9O2sVnEHor/figures/figures_15_2.jpg", "caption": "Figure 1: Visual depiction of r-lGIN: During preprocessing, we calculate the path neighborhoods Nr (v) for each node v in the graph G. Paths of varying lengths are processed separately using simple GINs, and their embeddings are pooled to obtain the final graph embedding. The forward complexity scales linearly with the sizes of N\u2084(v), enabling efficient computation on sparse graphs.", "description": "This figure shows a visual representation of the r-loopy Graph Isomorphism Networks (r-lGIN) architecture. The preprocessing step involves calculating the path neighborhoods (Nr(v)) for each node in the input graph.  These paths, of varying lengths, are processed independently using Graph Isomorphism Networks (GINs). The resulting embeddings are then pooled together to create a final graph embedding. The architecture is designed for efficiency with sparse graphs because the forward pass scales linearly with the size of the path neighborhoods.", "section": "Main Contributions"}, {"figure_path": "9O2sVnEHor/figures/figures_16_1.jpg", "caption": "Figure 6: Example of two non-isomorphic graphs that are r-lWL equivalent but not (r+1)-lWL equivalent: a chordal cycle (left) and a cactus graph (right).", "description": "The figure shows two graphs that cannot be distinguished by r-lWL but can be distinguished by (r+1)-lWL. The graph on the left is a chordal cycle, while the graph on the right is a cactus graph. This illustrates that the expressiveness of r-lWL increases with r.", "section": "Additional Figures"}, {"figure_path": "9O2sVnEHor/figures/figures_16_2.jpg", "caption": "Figure 7: Example of graphs that Subgraph GNNs cannot separate but 1-lWL can: Subgraph GNNs cannot separate G(F) and H(F). However, since hom(F, G(F)) \u2260 hom(F, H(F)) and F is a cactus graph, 1-lWL can separate G(F) and H(F) by Theorem 2.", "description": "The figure shows three graphs. Graph (a) is the input graph F. Graphs (b) and (c) are G(F) and H(F) which are obtained by applying F\u00fcrer graph construction on the input graph F. These graphs can not be separated by Subgraph GNNs, but can be separated by 1-lWL because their homomorphism counts of the input graph F are different.", "section": "5 Expressivity of r-lWL"}, {"figure_path": "9O2sVnEHor/figures/figures_17_1.jpg", "caption": "Figure 2: Example of r-neighborhoods.", "description": "This figure visually depicts the concept of r-neighborhoods (N<sub>r</sub>(v)) around a node 'v' in a graph.  N<sub>0</sub>(v) represents the immediate neighbors of 'v'.  As 'r' increases, N<sub>r</sub>(v) includes paths of length 'r' connecting pairs of nodes in N<sub>0</sub>(v), without including node 'v' itself in the path.  Different colors highlight the distinct r-neighborhoods for different values of r, showing how the neighborhood expands with increasing path lengths.", "section": "4 Loopy Weisfeiler-Leman Algorithm"}, {"figure_path": "9O2sVnEHor/figures/figures_17_2.jpg", "caption": "Figure 2: Example of r-neighborhoods.", "description": "The figure shows an example of how r-neighborhoods are constructed around a central node (v).  For r=0, the neighborhood includes only directly connected nodes. As r increases, the neighborhood expands to include nodes connected by paths of length r, where each path starts and ends with a node directly connected to the central node. Different colors are used to visually distinguish the r-neighborhoods for different values of r.", "section": "4 Loopy Weisfeiler-Leman Algorithm"}, {"figure_path": "9O2sVnEHor/figures/figures_17_3.jpg", "caption": "Figure 6: Example of two non-isomorphic graphs that are r-lWL equivalent but not (r+1)-lWL equivalent: a chordal cycle (left) and a cactus graph (right).", "description": "The figure shows two graphs that cannot be distinguished by the r-loopy Weisfeiler-Leman (r-lWL) test but can be distinguished by the (r+1)-lWL test.  The left graph is a cycle with a chord added, while the right graph is a cactus graph (a graph where every edge belongs to at most one cycle).  This illustrates that increasing the parameter 'r' in the r-lWL test increases its ability to distinguish non-isomorphic graphs.", "section": "Additional Figures"}, {"figure_path": "9O2sVnEHor/figures/figures_18_1.jpg", "caption": "Figure 9: The input graphs cannot be distinguished by 1-WL, since the color distribution after convergence of the algorithm is equal. 3-WL can distinguish them at the cost of creating new dense graphs. Our proposed 1-lWL can distinguish the two graphs heeding the original graph sparsity.", "description": "This figure shows two graphs that cannot be distinguished by the 1-WL test because they have the same color distribution after convergence.  However, the 3-WL test can distinguish them but at the cost of creating new dense graphs. The proposed 1-lWL test can distinguish these graphs while preserving the original graph sparsity, demonstrating its advantage.", "section": "C Experimental Details"}, {"figure_path": "9O2sVnEHor/figures/figures_18_2.jpg", "caption": "Figure 8: Some synthetic datasets. The dotted lines are the common edges. The orange edges identifies N\u2081(v).", "description": "This figure shows three examples of synthetic datasets used to evaluate the expressive power of the proposed r-lGIN model.  The datasets are COSPECTRAL10, SR16622, and CSL, each designed to test the model's ability to distinguish graphs with subtle structural differences.  In each example, the graphs share a common core structure (represented by dotted lines), but differ in the additional edges connecting nodes. The orange edges highlight the 1-neighborhoods of a selected node (v).  This visualizes the paths of length up to r that are considered by the r-lWL algorithm. The aim is to illustrate the enhanced expressiveness of the proposed model beyond the limitations of the standard Weisfeiler-Leman test.", "section": "Additional Figures"}, {"figure_path": "9O2sVnEHor/figures/figures_18_3.jpg", "caption": "Figure 5: Examples of non-injective homomorphism (row 1), subgraph isomorphism (row 2), bijective homomorphism with non-homomorphic inverse (row 3), and isomorphism (row 4). For better clarity, the mappings h : V(F) \u2192 V(G) are visually represented with colors, where F is consistently on the left, and G is on the right in each row.", "description": "This figure shows four rows of examples demonstrating different types of mappings between two graphs, F and G, which are represented by different colors for their nodes. The mappings illustrate the differences between homomorphism, subgraph isomorphism, bijective homomorphism with non-homomorphic inverse, and isomorphism.", "section": "3 Preliminaries"}, {"figure_path": "9O2sVnEHor/figures/figures_26_1.jpg", "caption": "Figure 2: Example of r-neighborhoods.", "description": "The figure shows an example of how r-neighborhoods are constructed for a given node in a graph. For r=0, the neighborhood is simply the set of direct neighbors. For r=1, the r-neighborhood includes paths of length 1 between any two direct neighbors. For r=2, the r-neighborhood includes paths of length 2 between any two direct neighbors.", "section": "4 Loopy Weisfeiler-Leman Algorithm"}, {"figure_path": "9O2sVnEHor/figures/figures_27_1.jpg", "caption": "Figure 1: Visual depiction of r-lGIN: During preprocessing, we calculate the path neighborhoods Nr(v) for each node v in the graph G. Paths of varying lengths are processed separately using simple GINs, and their embeddings are pooled to obtain the final graph embedding. The forward complexity scales linearly with the sizes of Nr(v), enabling efficient computation on sparse graphs.", "description": "This figure shows the architecture of the r-loopy Graph Isomorphism Network (r-lGIN). The input is a graph.  The preprocessing step extracts the r-neighborhoods for each node, which are sets of paths of length r starting from that node and ending in its neighbors.  These paths are processed independently using Graph Isomorphism Networks (GINs), and their embeddings are pooled together to create the final graph embedding. The linear scaling of the forward complexity with the size of the r-neighborhoods is a key advantage of this method.", "section": "Main Contributions"}, {"figure_path": "9O2sVnEHor/figures/figures_30_1.jpg", "caption": "Figure 7: Example of graphs that Subgraph GNNs cannot separate but 1-lWL can: Subgraph GNNs cannot separate G(F) and H(F). However, since hom(F, G(F)) \u2260 hom(F, H(F)) and F is a cactus graph, 1-lWL can separate G(F) and H(F) by Theorem 2.", "description": "This figure shows an example where Subgraph GNNs fail to distinguish between two graphs, G(F) and H(F), while the 1-loopy Weisfeiler-Leman (1-lWL) test can.  The graphs G(F) and H(F) are constructed from a base graph F.  The key difference is that 1-lWL considers paths between nodes, enabling it to distinguish the graphs based on their different homomorphism counts (hom(F,G(F)) and hom(F,H(F))). This illustrates the increased expressive power of 1-lWL over Subgraph GNNs.", "section": "5 Expressivity of r-lWL"}, {"figure_path": "9O2sVnEHor/figures/figures_36_1.jpg", "caption": "Figure 5: Examples of non-injective homomorphism (row 1), subgraph isomorphism (row 2), bijective homomorphism with non-homomorphic inverse (row 3), and isomorphism (row 4). For better clarity, the mappings h : V(F) \u2192 V (G) are visually represented with colors, where F is consistently on the left, and G is on the right in each row.", "description": "This figure illustrates four different types of mappings between two graphs, F and G. Each row demonstrates a different type of mapping: non-injective homomorphism, subgraph isomorphism, bijective homomorphism (with non-homomorphic inverse), and isomorphism.  The mappings are visually represented using colors for clarity.", "section": "Additional Figures"}, {"figure_path": "9O2sVnEHor/figures/figures_40_1.jpg", "caption": "Figure 7: Example of graphs that Subgraph GNNs cannot separate but 1-lWL can: Subgraph GNNs cannot separate G(F) and H(F). However, since hom(F, G(F)) \u2260 hom(F, H(F)) and F is a cactus graph, 1-lWL can separate G(F) and H(F) by Theorem 2.", "description": "This figure shows an example where the 1-loopy Weisfeiler-Leman test (1-lWL) can distinguish between two graphs that Subgraph GNNs cannot.  It highlights the increased expressive power of 1-lWL, specifically in relation to counting homomorphisms of specific graph types (in this case, a cactus graph). The figure includes three subfigures: (a) an input graph F; (b) a F\u00fcrer graph G(F); and (c) a twisted F\u00fcrer graph H(F).  Subgraph GNNs cannot distinguish between G(F) and H(F), whereas 1-lWL can due to their differing homomorphism counts. This demonstrates that 1-lWL is more powerful.", "section": "5 Expressivity of r-lWL"}, {"figure_path": "9O2sVnEHor/figures/figures_40_2.jpg", "caption": "Figure 6: Example of two non-isomorphic graphs that are r-lWL equivalent but not (r+1)-lWL equivalent: a chordal cycle (left) and a cactus graph (right).", "description": "This figure shows two graphs that cannot be distinguished by the r-loopy Weisfeiler-Leman test (r-lWL), but can be distinguished by the (r+1)-lWL test.  The left graph is a cycle graph with a chord, while the right graph is a cactus graph.  This illustrates that increasing the value of 'r' in r-lWL increases its ability to distinguish non-isomorphic graphs.", "section": "5 Expressivity of r-lWL"}]