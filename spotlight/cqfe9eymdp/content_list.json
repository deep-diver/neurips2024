[{"type": "text", "text": "Neural Krylov Iteration for Accelerating Linear System Solving ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Jian Luo1 Jie Wang1\u2217 Hong Wang1 Huanshuo Dong1 Zijie Geng1 Hanzhu Chen1 Yufei Kuang1 ", "page_idx": 0}, {"type": "text", "text": "1MoE Key Laboratory of Brain-inspired Intelligent Perception and Cognition, University of Science and Technology of China {jianluo,wanghong1700}@mail.ustc.edu.cn jiewangx@ustc.edu.cn ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Solving large-scale sparse linear systems is essential in fields like mathematics, science, and engineering. Traditional numerical solvers, mainly based on the Krylov subspace iteration algorithm, suffer from the low-efficiency problem, which primarily arises from the less-than-ideal iteration. To tackle this problem, we propose a novel method, namely Neural Krylov Iteration (NeurKItt), for accelerating linear system solving. Specifically, NeurKItt employs a neural operator to predict the invariant subspace of the linear system and then leverages the predicted subspace to accelerate linear system solving. To enhance the subspace prediction accuracy, we utilize QR decomposition for the neural operator outputs and introduce a novel projection loss function for training. NeurKItt benefits the solving by using the predicted subspace to guide the iteration process, significantly reducing the number of iterations. We provide extensive experiments and comprehensive theoretical analyses to demonstrate the feasibility and efficiency of NeurKItt. In our main experiments, NeurKItt accelerates the solving of linear systems across various settings and datasets, achieving up to a $5.5\\times$ speedup in computation time and a $16.1\\times$ speedup in the number of iterations. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Solving linear systems is the cornerstone of scientific computing, with applications in various fields including mathematics, science, and engineering[28]. Traditional solvers rely on the Krylov subspace iteration algorithm to tackle large-scale sparse linear systems[59]. It starts with a random initial vector, which corresponds to a one-dimensional linear subspace, and progressively expands this subspace to approximate the solution by iteratively minimizing the residual error. ", "page_idx": 0}, {"type": "text", "text": "However, the convergence speed and stability of the Krylov subspace iteration algorithms are significantly influenced by the dimensions and characteristics of the employed subspaces in the iterations[3]. Computational inefficiency and instability often arise in scenarios involving highdimensional problems or large matrices, especially when the matrices exhibit poor conditioning[9]. This inefficiency primarily arises from the less-than-ideal iteration, which leads to a higher number of iterations and consequently longer solving time. To address these challenges, our key insight is that prior knowledge about the linear system\u2019s invariant subspace benefits the Krylov subspace iteration by guiding the iteration process, which reduces the required number of iterations[13]. ", "page_idx": 0}, {"type": "text", "text": "Motivated by this insight, we introduce Neural Krylov Iteration (NeurKItt), a novel method that leverages neural networks to accelerate linear system solving. NeurKItt comprises two modules: ", "page_idx": 0}, {"type": "image", "img_path": "cqfE9eYMdP/tmp/3f539e41f3b48d6496f2c06523793f77a5575c0896829bbb0bcff26a5da3b578.jpg", "img_caption": ["Figure 1: The variation in tolerance for NeurKItt compared to GMRES, where each line represents an experiment under a solving method and a specific preconditioning. Notably, the NeurKItt substantially enhances the efficiency of solving the linear systems, with a reduction in the number of iterations by up to a factor of 16 and achieving a speed-up of up to 5.5 times. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "the subspace prediction module and the acceleration module. The subspace prediction module uses a neural network to predict the invariant subspace of linear systems. Inspired by the concept that mapping a linear system to its invariant subspace can be viewed as an operator between two Hilbert spaces, we adopt the neural operator for subspace prediction. We also integrate thin QR decomposition and a projection loss function to optimize training, improving subspace prediction performance. For the acceleration module, it leverages the property that Krylov subspace iteration approximates an invariant subspace of the linear system. When partial information about this subspace is provided, our acceleration module utilizes it to reduce the iterations needed for precise solutions, effectively accelerating the process and addressing the challenges. ", "page_idx": 1}, {"type": "text", "text": "We provide comprehensive analyses to demonstrate NeurKItt\u2019s efficiency. Furthermore, extensive experiments conducted across various solver settings and different PDE problems validate the effectiveness of our approach. The results show that NeurKItt significantly accelerates linear systems solving, achieving up to a $5.5\\times$ speedup. Both our theoretical analyses and experimental results collectively demonstrate the efficiency of NeuralKItt. ", "page_idx": 1}, {"type": "text", "text": "We summarize our contributions as follows: ", "page_idx": 1}, {"type": "text", "text": "\u2022 To the best of our knowledge, our work is the first to apply the data-driven approach to optimize Krylov iteration algorithms for solving generic non-symmetric linear systems. \u2022 We introduce a novel strategy that predicts the invariant subspace of the linear system to accelerate Krylov iteration. To facilitate the subspace prediction, we design a projection loss for efficient training, in conjunction with QR decomposition for stable outputs. \u2022 Extensive experiments and theoretical analysis demonstrate that NeurKItt reduces the computational cost and the number of iterations for solving linear systems involving nonsymmetric matrices. ", "page_idx": 1}, {"type": "text", "text": "2 Related Work ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "2.1 Traditional Numerical Algorithms ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "In the field of computational mathematics, various algorithms have been devised to address the challenge of solving systems of linear equations. Among these, methods based on the Krylov subspace have garnered attention for their efficacy in handling large matrices[33, 43]. These methods notably mitigate computational complexity by seeking approximate solutions within a constrained, smaller subspace. Within this context, the Generalized Minimal Residual (GMRES) method [45, 14] plays a pivotal role, particularly in addressing non-symmetric matrices. ", "page_idx": 1}, {"type": "text", "text": "To enhance the efficiency of these Krylov subspace methods, a range of preconditioning methods are employed[9]. These methods aim to improve matrix conditioning, reduce iteration counts, and boost stability. Preconditioning varieties include Jacobi[46], Additive Schwarz Method (ASM)[64], and ", "page_idx": 1}, {"type": "text", "text": "Successive Over-Relaxation (SOR)[42]. They simplify the matrix structure for faster resolution, a significant advantage in large-scale problems. ", "page_idx": 2}, {"type": "text", "text": "Our methodology, NeurKItt, utilizes invariant subspaces to hasten convergence in Krylov subspaces, thereby expediting linear system resolutions. It is also engineered to integrate with existing preconditioning techniques, boosting its efficiency and applicability in complex computational scenarios. ", "page_idx": 2}, {"type": "text", "text": "2.2 Learning-based Acceleration Algorithms ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Although learning-based linear system solvers require training, the training time is negligible compared to the time saved over millions of calls. Thus, there has been a surge in learning-based acceleration efforts in recent years. Research in using neural networks for accelerating linear system solving [30, 23, 60] use neural networks to optimize the Conjugate Gradient algorithm, thereby accelerating the solution of symmetric positive definite linear systems. [37] accelerated the solution of the Poisson equation. [20] focused on accelerating algorithm iterations by learning better algorithm parameters. Recent studies have utilized neural networks for matrix preconditioning. [17, 38, 53] have focused on improving algebraic multigrid preconditioning algorithms. [15, 50] have applied CNNs and machine learning, respectively, to optimize block Jacobi and ILU precondition. Furthermore, specialized preconditioning research is being conducted in areas like physics[2, 7], engineering[47], and climate science[1], demonstrating the breadth of these applications. ", "page_idx": 2}, {"type": "text", "text": "However, these studies often face limitations due to specific matrix properties or mainly focus on reducing low-precision solving costs, with fewer advancements in accelerating high-precision solving. In contrast, our approach, NeurKItt, addresses all these limitations. It employs subspace prediction to refine iterative methods universally across Krylov subspace algorithms. This approach not only reduces the initial iterations but also significantly improves the speed and stability of subsequent iterations. ", "page_idx": 2}, {"type": "text", "text": "2.3 Neural Operators ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Numerical methods for solving PDEs commonly involves solving systems of linear equations, which require extensive computational resources. Recently, Neural operators (NOs), such as the Fourier Neural Operator (FNO)[31, 55, 12] and Deep Operator Network (DeepONet)[35, 36], have shown effectiveness in solving PDEs. Despite their effectiveness, NOs often grapple with challenges like diminished accuracy and stringent boundary condition prerequisites, which limit their applicability as standalone replacements for conventional algorithms in various scientific computing contexts[63, 19]. Given that mapping a matrix to its subspace is fundamentally an operator mapping task, NOs hold significant potential as tools for predicting matrix subspaces. ", "page_idx": 2}, {"type": "text", "text": "3 Preliminaries ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "3.1 Krylov Subspace Iteration ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In the realm of large-scale sparse linear systems, Krylov subspace methods are frequently employed as a standard solution strategy [46, 16]. At the heart of this methodology is the principle of utilizing the matrix involved in the linear system to iteratively construct a subspace. This subspace is crafted to approximate the actual solution space, with the iterative process continuing until the generated Krylov subspace sufficiently encompasses the real solution. Such an approach enables the iterative solutions within this confined subspace to progressively approximate the accurate solution vector $\\textbf{\\em x}$ , thereby efficiently converging towards it. ", "page_idx": 2}, {"type": "text", "text": "Suppose we now solve the system ", "page_idx": 2}, {"type": "equation", "text": "$$\nA x=b,\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $A\\in\\mathbb{C}^{n\\times n}$ . The $m$ -th Krylov subspace associated with the matrix $\\pmb{A}$ and the starting vector $r\\in\\mathbb{C}^{n}$ as follows: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathcal{K}_{m}(A,r)=\\operatorname{span}\\{r,A r,A^{2}r,\\dots,A^{m-1}r\\}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "Generally, ${\\pmb r}=A{\\pmb x}_{0}-{\\pmb b}$ represents the initial residual, where $\\pmb{x}_{0}$ is typically generated randomly or selected as an initial guess for the solution. The iterative process of the Krylov subspace leads to the Arnoldi relation: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\pmb{A}\\pmb{V_{m}}=\\pmb{V_{m+1}}\\pmb{H_{m}}=\\pmb{V_{m}}\\pmb{H_{m}}+\\pmb{v_{m+1}}\\pmb{h_{m+1,m}}\\pmb{e_{m}^{T}},}\\end{array}\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $V_{m}=\\left(\\pmb{v}_{1},\\dots,\\pmb{v}_{m}\\right)\\in\\mathbb{C}^{n\\times m}$ comprises unit vectors $\\pmb{v}_{i}\\,\\in\\,\\mathbb{C}^{n}$ for $i=1,\\hdots,m$ , mutually orthogonal, and $V_{m+1}=(V_{m},v_{m+1})$ extends this set. $\\underline{{H}}_{m}\\in\\mathbb{C}^{(m+1)\\times m}$ is an upper Hessenberg matrix. $\\pmb{H}_{m}\\in\\mathbb{C}^{m\\times m}$ is the first $m$ rows of $\\underline{{H}}_{m}$ , distinct due to an extra element $h_{m+1,m}$ at the $m+1$ -th row, $m$ -th column. $e_{m}$ is the $m$ -th unit column vector, with its $m$ -th element as 1. ", "page_idx": 3}, {"type": "text", "text": "Krylov algorithms reduce the computational effort needed for large linear systems by creating a Krylov subspace. However, starting this process with a random vector can be time-consuming. It\u2019s suggested that understanding the matrix\u2019s invariant subspace before beginning the iterative process, a warm-starting approach, could notably decrease the required iterations and improve convergence speed and stability. ", "page_idx": 3}, {"type": "text", "text": "3.2 Neural Operators ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "NeurKItt utilizes the framework of neural operator architectures, notably the FNO [26, 31, 27]. We begin by defining a spatial dimension $d\\in\\mathbb{N}$ and a corresponding domain $D\\subset\\mathbb{R}^{d}$ . Our focus is on approximating operators $\\mathcal{G}:\\mathcal{A}(D;\\mathbb{R}^{d_{a}})\\to\\mathcal{U}(D;\\mathbb{R}^{d_{u}}).$ . Here, $\\bar{a}\\in\\mathcal{A}(D;\\mathbb{R}^{d_{a}})$ and $u\\in\\mathcal{U}(D;\\mathbb{R}^{d_{u}})$ denote functions that map the domain $D$ to $\\mathbb{R}^{d_{a}}$ and $\\mathbb{R}^{d_{u}}$ , respectively, where $d_{a},d_{u}\\in\\mathbb{N}$ . Both spaces $\\mathcal{A}(D;\\mathbb{R}^{d_{a}})$ and $\\mathcal{U}(D;\\mathbb{R}^{d_{u}})$ are identified as Banach spaces. ", "page_idx": 3}, {"type": "text", "text": "In line with the definition provided by [32], a neural operator $N:A(D;\\mathbb{R}^{d_{a}})\\to\\mathcal{U}(D;\\mathbb{R}^{d_{u}})$ is conceptualized as a mapping expressed by ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathcal{N}(a)=\\mathcal{Q}\\circ\\mathcal{L}_{L}\\circ\\cdots\\circ\\mathcal{L}_{1}\\circ\\mathcal{R}(a),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "for a designated depth $L\\in\\mathbb N$ . In this formulation, $\\mathcal{R}:A(D;\\mathbb{R}^{d_{a}})\\to\\mathcal{U}(D;\\mathbb{R}^{d_{v}})$ , with $d_{v}\\geq d_{u}$ , functions as a lifting operator, while $\\mathcal{Q}:\\mathcal{U}(D;\\mathbb{R}^{d_{v}})\\to\\mathcal{U}(D;\\mathbb{R}^{d_{u}})$ serves as a local projection operator. ", "page_idx": 3}, {"type": "text", "text": "4 Method ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "NeurKItt\u2021 utilizes a neural operator to predict the invariant subspace K\u02c6 of the linear system, and then uses it to accelerate the Krylov subspace iteration. Generally, NeurKItt is broadly divided into two components. ", "page_idx": 3}, {"type": "text", "text": "Subspace Prediction Module: Inspired by operator learning, we employ the neural operator capable of predicting subspaces at a low cost, with the help of QR decomposition. The aim is to precisely predict the invariant subspace $\\hat{\\kappa}$ of the linear system. ", "page_idx": 3}, {"type": "text", "text": "Acceleration Module: Originating from the mathematical theories of Krylov iteration, we have developed a Krylov algorithm tailored to our problem. Utilizing the invariant subspace, this method expedites Krylov Subspace convergence and enhances stability. ", "page_idx": 3}, {"type": "text", "text": "4.1 Subspace Prediction Module ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "The mapping from the linear system to its corresponding invariant subspace can be considered an operator, i.e., a mapping between two Hilbert spaces. Solving such problems involves finding the corresponding solution operator. In our subspace prediction module, we choose the Fourier Neural Operator (FNO)[31] for subspace prediction. We give a brief introduction to FNO in Appendix C. Generally, for a linear system $A x=b$ derived from the parametric PDE problem, to predict its invariant subspace $\\hat{\\kappa}$ , the input to FNO is the input function $\\boldsymbol{a}\\in\\mathbb{R}^{d_{a}}$ from the given PDE, where $d_{a}\\in\\mathbb{N}$ . We provide a detailed discussion in Appendix $\\mathbf{B}$ about how to build a linear system problem from a PDE problem, and what is the input function. ", "page_idx": 3}, {"type": "text", "text": "Our task is to learn the mapping between two Hilbert spaces $\\mathcal{G}:\\mathbb{R}^{d_{a}}\\rightarrow\\mathbb{C}^{d\\times n}$ using FNO. For FNO, the lifting transformation $\\mathcal{R}$ first lifts the input $a$ to a higher dimensional representation $v_{0}\\in\\mathbb{C}^{d_{a}\\times c}$ , where $c$ is the number of channels. Then we feed the $v_{0}$ to Fourier layers. After $T$ Fourier layers forward, we have $v_{T}\\in\\mathbb{C}^{d_{a}\\times c}$ from the last Fourier layer, which keeps the same shape as $v_{0}$ . The FNO\u2019s output $X\\,=\\,Q(v_{T})$ is the projection of $v_{T}$ by the transformation $Q:\\mathbb{C}^{d_{a}\\,\\star\\circleddash\\,c}\\to\\mathbb{C}^{d_{A}\\,\\times\\,n}$ . NeurKItt then uses QR decomposition to orthogonalize the matrix $X$ , obtaining the predicted subspace $\\hat{\\kappa}$ . We provide more details about how to predict the subspace given the 2D Darcy flow problem in Appendix C. ", "page_idx": 3}, {"type": "image", "img_path": "cqfE9eYMdP/tmp/1c7e6fdbc1db38f23a1ee104cf654450a1ada65cd8f88a8276e9151afc0e0faa.jpg", "img_caption": ["Figure 2: Algorithm Flow Diagram: (a) Finding solution $\\textbf{\\em x}$ for given matrices $\\pmb{A}$ and $^{b}$ . (b) Traditional Algorithm: Krylov iterations from a random initial vector. (c1) NeurKItt Subspace Prediction Module: Utilizing a neural operator for estimating the invariant subspace of matrix $\\pmb{A}$ . (c2) NeurKItt Acceleration Module: Using the predicted invariant subspace of the matrix to guide the iteration, thereby accelerating the Krylov iteration process. "], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "", "page_idx": 4}, {"type": "text", "text": "We define the one \u2212sided distance[51] from the subspace $\\mathcal{Q}$ to the subspace $\\mathcal{C}$ as ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\delta(\\boldsymbol{\\mathcal{Q}},\\boldsymbol{\\mathcal{C}})=\\lVert(\\boldsymbol{I}-\\boldsymbol{\\pi}_{\\mathit{c}})\\boldsymbol{\\pi}_{\\mathcal{Q}}\\rVert_{2},\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $_{\\pi}$ represents the projection operator for the associated space. Its mathematical interpretation corresponds to the largest principal angle between the two subspaces $\\mathcal{Q}$ and $\\mathcal{C}[3]$ , and defining $P_{\\mathcal{Q}}$ as the spectral projector onto $\\mathcal{Q}$ . The objective of the subspace prediction task is to approximate the invariant subspace of the matrix $\\pmb{A}$ with our predicted subspace $\\hat{\\kappa}$ : ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\underset{\\theta}{\\arg\\operatorname*{min}}\\,\\delta(\\hat{\\mathcal{K}},S),\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\theta$ represents the parameters of NO, and $\\delta(\\hat{K},\\mathcal{S})$ is the distance between the two subspaces. Based on subsequent Theoretical Analysis 5.2, we choose $\\boldsymbol{S}$ as the invariant subspace associated with the smallest $n$ eigenvalues, assuming ${\\mathfrak{s}}=\\operatorname{span}\\,S=\\operatorname{span}\\{s_{1},s_{2},\\dotsc,s_{n}\\}$ , where $s_{i}$ is the eigenvector corresponding to the $i$ -th smallest eigenvalue of the given matrix $A$ , $i=1,2,\\dots,n$ . To reduce computational complexity, considering the norm equivalence theorem in Banach spaces, we optimize using the following loss function: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\arg\\operatorname*{min}_{\\theta}\\sum_{i=1}^{n}d(\\hat{\\mathcal{K}},s_{i}).\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "This norm transforms the computation of subspace distance into the computation of the distance from a vector to a subspace. According to the properties of the Hilbert space, there exists a unique orthogonal decomposition: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r}{s_{i}=x+y\\quad(x\\in\\hat{\\mathcal{K}},y\\in\\hat{\\mathcal{K}}^{\\perp}).}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "We represent the projection operator for $\\hat{\\kappa}$ by $Q$ , with $P_{\\mathcal{Q}}=Q Q^{*}$ , leading to the relationship: ", "page_idx": 4}, {"type": "equation", "text": "$$\nd(\\hat{\\mathcal{K}},s_{i})=\\lVert s_{i}-Q Q^{*}s_{i}\\rVert.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Consequently, our projection loss function $l(\\hat{\\boldsymbol{\\kappa}},\\boldsymbol{S})$ is defined as follows: ", "page_idx": 4}, {"type": "equation", "text": "$$\nl(\\hat{\\mathcal{K}},S)=\\sum_{i=1}^{n}\\|s_{i}-Q Q^{*}s_{i}\\|.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "We train our subspace module by optimizing the above formula. Experiments have shown that as the projection loss decreases, the principal angle of our predicted subspace also decreases. The principal angle is a mathematical indicator derived in Theoretical Analysis 5.1 that influences the acceleration. ", "page_idx": 4}, {"type": "text", "text": "4.2 Acceleration Module ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "For Krylov algorithms, the iteration count is a critical factor influencing computational load. Drawing inspiration from the Krylov recycling algorithms[40, 13, 6, 58, 41, 24], our approach NeurKItt utilizes the predicted invariant subspace $\\hat{\\kappa}$ as the deflation space within the Krylov iteration framework. We provide the pseudocode of the acceleration module in Appendix A.2. The key procedure of our implementation is outlined as follows: ", "page_idx": 5}, {"type": "text", "text": "Considering the linear system (1), we obtain a $k$ -dimensional invariant subspace $\\hat{\\kappa}$ from the subspace prediction module. Then, NeurKItt computes matrices $U_{k},C_{k}\\,\\in\\,\\mathbb{C}^{n\\times k}$ from $\\hat{\\kappa}$ and $\\pmb{A}$ such that $A U_{k}=C_{k}$ and ${\\cal C}_{k}^{H}{\\cal C}_{k}=I_{k}$ , the specific algorithm can be found in Appendix A.1. We can get the Arnoldi relation of our NeurKItt: ", "page_idx": 5}, {"type": "equation", "text": "$$\n(I-C_{k}C_{k}^{H})A V_{m-k}=V_{m-k+1}\\underline{{H}}_{m-k}.\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "This suggests that when the $k$ -dimensional invariant subspace is given, there is no need to start from scratch for constructing a new Krylov subspace $\\kappa(A,r)$ . Building upon this foundation, $\\kappa(A,r)$ can converge more rapidly to the subspace where the solution $\\textbf{\\em x}$ lies. This can significantly reduce the dimensionality of the final Krylov subspace, leading to a marked decrease in the number of iterations and resulting in accelerated performance. Compared to NeurKItt, GMRES can be intuitively conceptualized as the special case of our NeurKItt, where $k$ is initialized at zero[8, 39, 40]. ", "page_idx": 5}, {"type": "text", "text": "Existing Krylov recycling algorithms share the same Arnoldi relation with NeurKItt. However, they can only accelerate the linear systems solving when there are strongly correlated linear systems provided, which is not common in scientific computing. For example, when solving PDEs with finite element software, matrices vary in size and element positions due to discretization methods and different grids, which makes the recycling invariant subspace from previous matrices impossible. Additionally, storing subspaces from previous solving requires significant storage when the previous linear system is large. Thus, these methods are not widely used in general scenarios. In contrast, NeurKItt, which leverages neural operators to predict subspaces, is not affected by the lack of strongly correlated linear systems. ", "page_idx": 5}, {"type": "text", "text": "5 Theoretical Analysis ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "5.1 Convergence Analysis ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Let $\\mathcal{Q}$ be an $l$ -dimensional invariant subspace of matrix $\\pmb{A}$ , and let ${\\mathcal{C}}=\\mathrm{range}(C_{k})$ be a $k$ -dimensional space $[k\\geq l)$ selected to approximate $\\mathcal{Q}$ . We refer to Theorem 3.1 in [40] for an in-depth convergence analysis under NeurKItt. ", "page_idx": 5}, {"type": "text", "text": "Theorem 5.1. [40] Considering a space $\\mathcal{C}$ , define $\\nu=\\mathrm{range}(V_{m-k+1}\\underline{{H}}_{m-k})$ be the $(m-k)$ - dimensional Krylov subspace generated by NeurKItt as in $(I I)$ . Let $\\pmb{r}_{0}\\in\\mathbb{C}^{n}$ , and $\\dot{\\pmb r}_{1}=(\\pmb I-\\pmb I\\pmb{I}_{\\mathcal{C}})\\dot{\\pmb r}_{0}$ . Then, for each $\\mathcal{Q}$ such that $\\delta(\\mathcal{Q},\\mathcal{C})<1$ , ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\underset{\\pmb{d}_{1}\\in\\mathcal{V}\\oplus\\mathcal{C}}{\\operatorname*{min}}\\,\\|\\pmb{r}_{0}-\\pmb{d}_{1}\\|_{2}\\leq\\underset{\\pmb{d}_{2}\\in(I-P_{Q})\\mathcal{V}}{\\operatorname*{min}}\\,\\|(\\pmb{I}-\\pmb{P}_{\\mathcal{Q}})\\pmb{r}_{1}-\\pmb{d}_{2}\\|_{2}}\\\\ {+\\frac{\\gamma}{1-\\delta}\\|\\pmb{P}_{Q}\\|_{2}\\cdot\\|(\\pmb{I}-\\pmb{\\pi}_{\\mathcal{V}})\\pmb{r}_{1}\\|_{2},}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\gamma=\\|(\\pmb{I}-\\pmb{\\pi}_{c})\\pmb{P}_{\\mathcal{Q}}\\|_{2}$ and $\\delta=\\delta(\\mathcal{Q},\\mathcal{C})$ . ", "page_idx": 5}, {"type": "text", "text": "The left-hand side is the residual norm subsequent to $m-k$ iterations of NeurKItt, employing the predictive subspace $\\mathcal{C}$ . In contrast, on the right-hand side, the initial term epitomizes the convergence of a deflated problem, given that all components within the subspace $\\mathcal{Q}$ have been eradicated[39, 49]. The subsequent term on the right embodies a constant multiplied by the residual following $m-k$ iterations of NeurKItt, when solving for $r_{1}$ . Supposed that the predictive space $\\mathcal{C}$ encompass an invariant subspace $\\mathcal{Q}$ , then we have $\\delta=\\gamma=0$ for the given $\\mathcal{Q}$ , which ensures that the convergence rate of NeurKItt matches or surpasses that of the deflated problem. In most cases, $\\|P_{\\mathcal{Q}}\\|_{2}$ is numerically stable and not large, therefore a reduced value of $\\delta$ directly correlates with faster convergence in NeurKItt. ", "page_idx": 5}, {"type": "text", "text": "Now we compare two approaches to accelerating the linear systems solving[33]: ", "page_idx": 5}, {"type": "text", "text": "1. Providing an initial prediction for the solution, allows Krylov algorithms to start from this prediction. The solution involved might come from solutions to similar systems or predictions such as via neural networks[62].   \n2. Predicting the matrix invariant subspace, using this approximate subspace to speed up Krylov iterations. ", "page_idx": 6}, {"type": "text", "text": "For the first approach, particularly with large matrices derived from PDEs, the norm $\\|A\\|_{2}$ tends to be large. Our theoretical analysis in Appendix D suggests that FNO\u2019s direct solution prediction will not significantly accelerate the linear system solving, possibly only reducing a few Krylov subspace iterations. NeurKItt belongs to the second approach. This crucially speeds up the convergence of Krylov subspace iterations, markedly reducing total iterations and improving stability. ", "page_idx": 6}, {"type": "text", "text": "5.2 Subspace Property Analysis ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "The crucial questions about predicted subspace arise when accelerating Krylov subspace iterations: (1) What kind of subspace should be selected for acceleration? (2) Given the computational cost associated with employing neural networks, is it necessary to expend substantial computational resources to predict a highly accurate subspace? ", "page_idx": 6}, {"type": "text", "text": "Regarding the first question: As indicated by our convergence analysis 5.1, effectively accelerating the solution of linear systems only requires a predicted invariant subspace of matrix $\\pmb{A}$ . A matrix has many invariant subspaces, but which of these are easier to learn by the neural network[40]? ", "page_idx": 6}, {"type": "text", "text": "To investigate this problem, we simplify the specific scenario of the linear systems problem. The following definitions and assumptions for Theorem 5.2 are from the reference [24]. Specifically, We deal with a Hermitian positive definite matrix $\\pmb{A}$ and a corresponding Hermitian perturbation $\\pmb{E}$ , allowing $\\pmb{A}$ to have the eigendecomposition[24]: ", "page_idx": 6}, {"type": "equation", "text": "$$\nA=[Q_{1}Q_{2}Q_{3}]\\mathrm{diag}(\\Lambda_{1},\\Lambda_{2},\\Lambda_{3})[Q_{1}Q_{2}Q_{3}]^{H},\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "where $Q=[Q_{1}Q_{2}Q_{3}]$ is an orthogonal matrix, $\\mathbf{A}_{1}=\\mathrm{diag}(\\lambda_{1}^{(1)},\\dots,\\lambda_{j_{1}}^{(1)})$ , \u03bb(j11) ), \u039b2 and \u039b3 are defined in a similar fashion. Let the eigenvalues satisfy the following ordering\\*: ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\lambda_{1}^{(1)}\\le\\ldots\\le\\lambda_{j_{1}}^{(1)}<\\lambda_{1}^{(2)}\\le\\ldots\\le\\lambda_{j_{2}}^{(2)}<\\lambda_{1}^{(3)}\\le\\ldots\\le\\lambda_{j_{3}}^{(3)}.\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "We consider the change in the invariant subspace range $(Q_{1})$ under a symmetric perturbation $\\pmb{E}$ of $\\pmb{A}$ . Let $\\theta_{1}(\\cdot,\\cdot)$ denote the largest canonical angle between two spaces. We do not require that $||E||_{F}$ be small, but we assume that the projection of $\\pmb{E}$ onto the subspace range $\\bar{\\langle}[Q_{1}Q_{2}]\\rangle$ is small. We assume that $||(\\pmb{Q}_{1}\\pmb{Q}_{2}]^{H}\\pmb{E}||_{F}\\,\\le\\,\\epsilon$ and that $\\epsilon$ is small relative to $\\lambda_{1}^{(2)}-\\lambda_{j_{1}}^{(1)}$ \u2212\u03bb(j1). We also assume that $\\eta=||Q_{3}^{H}E||_{F}$ is small relative to $\\lambda_{1}^{(3)}-\\lambda_{j_{1}}^{(1)}$ . Note that we do not need to assume that $\\lambda_{j_{2}}^{(2)}-\\lambda_{j_{1}}^{(1)}$ is large. Also, let ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\begin{array}{c}{\\displaystyle\\mu\\equiv\\mathrm{min}(\\lambda_{1}^{(2)}-\\epsilon,\\lambda_{1}^{(3)}-\\eta)-2\\epsilon-(\\lambda_{j1}^{(1)}+\\epsilon)>2\\epsilon,\\,}\\\\ {\\displaystyle\\tilde{\\mu}\\equiv\\mu\\left(1-\\frac{2\\epsilon^{2}}{\\mu^{2}}\\right)+\\lambda_{j_{1}}^{(1)}+\\epsilon.\\,}\\end{array}\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "Theorem 5.2. [24] Let $\\pmb{A}$ be Hermitian positive definite and have the eigendecomposition given in (13), and let $E,\\,\\epsilon,\\,\\eta,\\,\\mu_{\\mathrm{r}}$ , and $\\tilde{\\mu}$ be defined as above. Then there exists a matrix $\\tilde{Q}_{1}$ conforming to $Q_{1}$ such that range $\\tilde{Q}_{1})$ is a simple invariant subspace of $A+E$ , and ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\tan\\theta_{1}(r a n g e({\\pmb Q}_{1}),r a n g e(\\tilde{\\pmb Q}_{1}))\\leq\\frac{\\epsilon}{\\tilde{\\mu}}.\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "The specific proof can be found in [24]. A similar bound applies to the perturbation of the eigenvalues associated with $Q_{1}$ . In the context of Theorem 5.1 and our NeurKItt, $Q_{1}$ corresponds to $Q$ , whereas $Q_{2}$ and $Q_{3}$ can be chosen to fit the theorem. ", "page_idx": 6}, {"type": "text", "text": "This theorem shows that if changes in a matrix occur in the subspace corresponding to larger eigenvalues, the subspace associated with the smallest eigenvalues is minimally affected, as long as the changes are smaller than the gap between the smallest and larger eigenvalues. To facilitate learning of matrix invariant subspaces, we use the subspace composed of eigenvectors corresponding to the smallest eigenvalues as the prediction target for our neural operator. ", "page_idx": 6}, {"type": "text", "text": "", "page_idx": 7}, {"type": "text", "text": "Regarding the second question: The analysis of the first question, along with the error convergence rate proved in Theorem 5.1, suggests that investing in substantial computational resources for predicting a high-precision subspace is unnecessary. As long as the predicted subspace shows a distinct correlation with the matrix invariant subspace, particularly when $\\delta$ is small, significant acceleration can be achieved without resorting to high precision[13]. This principle underpins our development of a low-precision, cost-effective subspace prediction framework. Although the subspace prediction may not be precise, the final algorithm has achieved remarkable acceleration results. ", "page_idx": 7}, {"type": "text", "text": "6 Experiment ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "6.1 Experiment Settings ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "To comprehensively evaluate the performance of NeurKItt, we conducted extensive experiments. Our analysis centers on two primary performance metrics viewed through three perspectives. These tests are conducted on 3 datasets. Specifically, the three Perspectives are: (i) Matrix preconditioning techniques, spanning 7 standard methods. (ii) Accuracy criteria for linear system solutions, emphasizing 8 distinct tolerances. (iii) Different matrix sizes, considering 3 variations. For more details, please refer to the Appendix F.1. ", "page_idx": 7}, {"type": "text", "text": "Baselines. NeurKItt focuses on solving linear systems that involve large sparse non-symmetric matrices. The GMRES algorithm is widely used for non-symmetric large sparse linear system solving, which serves as the predominant solution. And we set it as the benchmark for our study. We use GMRES from PETSc (version 3.19.4). ", "page_idx": 7}, {"type": "text", "text": "Datasets. To investigate the algorithm\u2019s adaptability to various types of matrices, we examined three different linear equation challenges, each rooted in a PDE: 1. Helmholtz Equation [62]. 2. Darcy Flow Problem [31, 44, 27, 36]; 3. Non-uniform Heat Conduction Equation [48, 25, 4, 18]. For an in-depth exposition of the dataset and its generation, kindly refer to the Appendix F.4. For the runtime environment, refer to Appendix F.2. ", "page_idx": 7}, {"type": "text", "text": "Metrics. We adopt time speedup for \"GMRES solving time / NeurKItt solving time\" and iteration speedup for \"GMRES iteration count / NeurKItt iteration count\". Speedup over 1 denotes better NeurKItt performance. We also provide the average time spent and average iteration count in Appendix H. We use principal angle in Equation 5 to show how close the predicted subspace and the target subspace are. ", "page_idx": 7}, {"type": "text", "text": "Table 1: Comparison of our NeurKItt and GMRES computation time and iterations across datasets, preconditioning, and tolerances. The first column lists datasets with matrix size, and the next details tolerances. Results are displayed as \"time speedup / iteration speedup\". ", "page_idx": 7}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/f80c8ed50b5916055f33cc64a6861a32a5f3ff584e61e1b8711f3a54abf228a9.jpg", "table_caption": [], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "6.2 Main Experiment ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We compare NeurKItt with GMRES under various preconditioners and tolerance, and Table 1 presents main experimental results. More detailed experimental results about time and number of iterations can be found in Appendix H. ", "page_idx": 8}, {"type": "text", "text": "The results show that across all tolerances and preconditioning techniques, NeurKIt has been effective in accelerating the linear system solving and reducing the number of iterations required by the Krylov subspace method, achieving up to a $5.5\\times$ speedup in computation time and a $16.1\\times$ speedup in the number of iterations. These results demonstrate that the invariant subspace predicted by NeurKIt greatly enhances the convergence speed of the Krylov algorithms, thereby reducing the iteration count and accelerating the solving. ", "page_idx": 8}, {"type": "text", "text": "With the solution accuracy increasing, the acceleration does not significantly decrease. Though the acceleration effect of NeurKItt varies under different preconditioning, the minimum time speedup is no less than 1.67 in the Darcy flow problem, which suggests NeurKItt can be effectively combined with various preconditioning methods. ", "page_idx": 8}, {"type": "text", "text": "6.3 Generalization of Matrix Size ", "text_level": 1, "page_idx": 8}, {"type": "image", "img_path": "cqfE9eYMdP/tmp/57a57ea1e1270b54976bcae1d8b60740abc9acc9601248c0f0e5b3723843543c.jpg", "img_caption": ["Figure 3: Experiments on the Darcy Flow problem with varying matrix sizes. The results indicate that as the matrix size increases, both time speedup and iteration speedup increase. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "We conducted experiments on the Darcy Flow problem with varying matrix sizes under different preconditioning methods and tolerances. We provide the results in Figure 3. The experimental results show that our method consistently improves its acceleration effect as the matrix size increases, across different preconditioning methods and tolerances, which indicates that NeurKItt especially benefits solving large sparse linear systems. ", "page_idx": 8}, {"type": "text", "text": "6.4 Ablation Study ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We conducted ablation experiments to further validate the performance of FNO and demonstrate the effectiveness of the designed projection loss. The results of the ablation experiments are shown in Table 2. The results demonstrate that FNO significantly outperforms MLP when using the same projection loss. This indicates that FNO is indeed capable of learning a better mapping from the parameter matrix to the subspace, resulting in predicted subspaces that are closer to the target subspaces. ", "page_idx": 8}, {"type": "text", "text": "In addition, we also attempted to utilize the Mean Squared Error (MSE) Loss for subspace prediction. The experimental results show that applying the MSE Loss on subspace learning ", "page_idx": 8}, {"type": "text", "text": "Table 2: Comparison of different settings on principal Angle (rad) for the Darcy flow problem, with a matrix size of 32,400. We replace the FNO with MLP for \"w/o FNO\" and replace the projection loss with MSE loss for \"w/o Projection Loss\". ", "page_idx": 8}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/5b8a24a19a695060ab1db174a3b6209f633ae7c9031b2faf02517eed5d09c6e3.jpg", "table_caption": [], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "is merely ineffective. Since we report the principal angle in radians, it implies that the predicted subspace K\u02c6 is merely orthogonal to the target subspace $\\boldsymbol{S}$ . Such subspace K\u02c6 cannot be effectively utilized to accelerate linear system solving. Besides, it can be inferred that QR decomposition we have employed plays an important role in subspace prediction. These results verifies that the projection loss and QR decomposition enable the model to better predict subspace. ", "page_idx": 8}, {"type": "text", "text": "", "page_idx": 9}, {"type": "text", "text": "7 Limitation and Conclusions ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "Limitation Our method only considers solving non-symmetric matrices, but for matrices with specific structures, we need to tail our method to achieve faster solving. Furthermore, we have not considered the potential impact of different preconditioning techniques on the subspace and have not optimized for different preconditioning techniques, though the influence caused by preconditioning has little impact based on the observation of our experiments. ", "page_idx": 9}, {"type": "text", "text": "Conclusions We propose NeurKItt, a novel method for accelerating linear systems solving through subspace prediction. To the best of our knowledge, this is the first attempt to apply a data-driven approach to optimize the Krylov subspace algorithm for non-symmetric linear systems. Specifically, we employ FNO to predict the invariant subspace and design a projection loss function for this task. By utilizing the predicted invariant subspace, we achieve accelerated Krylov subspace iterations. Theoretical analysis and extensive experiments demonstrate that NeurKItt effectively reduces computational costs and iteration counts. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgements ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We would like to thank all the anonymous reviewers for their insightful comments. This work was supported in part by National Key R&D Program of China under contract 2022ZD0119801, National Nature Science Foundations of China grants U23A20388 and 62021001. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Jan Ackmann, Peter D D\u00fcben, Tim N Palmer, and Piotr K Smolarkiewicz. Machine-learned preconditioners for linear solvers in geophysical fluid flows. arXiv preprint arXiv:2010.02866, 2020.   \n[2] Yael Azulay and Eran Treister. Multigrid-augmented deep learning preconditioners for the helmholtz equation. SIAM Journal on Scientific Computing, (0):S127\u2013S151, 2022.   \n[3] Christopher Beattie, Mark Embree, and John Rossi. Convergence of restarted krylov subspaces to invariant subspaces. SIAM Journal on Matrix Analysis and Applications, 25(4):1074\u20131109, 2004.   \n[4] James V Beck, Ben Blackwell, and Charles R St Clair. Inverse heat conduction: Ill-posed problems. James Beck, 1985.   \n[5] Michele Benzi, Carl D Meyer, and Miroslav Tma. A sparse approximate inverse preconditioner for the conjugate gradient method. SIAM Journal on Scientific Computing, 17(5):1135\u20131149, 1996.   \n[6] Philipp Birken, Jurjen Duintjer Tebbens, Andreas Meister, and Miroslav Tma. Preconditioner updates applied to cfd model problems. Applied Numerical Mathematics, 58(11):1628\u20131641, 2008.   \n[7] Salvatore Cal\u00ec, Daniel C Hackett, Yin Lin, Phiala E Shanahan, and Brian Xiao. Neural-network preconditioners for solving the dirac equation in lattice gauge theory. Physical Review D, 107(3):034508, 2023.   \n[8] Luiz Mariano Carvalho, Serge Gratton, Rafael Lago, and Xavier Vasseur. A flexible generalized conjugate residual method with inner orthogonalization and deflated restarting. SIAM Journal on Matrix Analysis and Applications, 32(4):1212\u20131235, 2011.   \n[9] Ke Chen. Matrix preconditioning techniques and applications, volume 19. Cambridge University Press, 2005.   \n[10] Lu Cheng and Kuan Xu. Solving time-dependent pdes with the ultraspherical spectral method, 2023.   \n[11] Eric De Sturler. Truncation strategies for optimal krylov subspace methods. SIAM Journal on Numerical Analysis, 36(3):864\u2013889, 1999.   \n[12] Wenhan Gao, Ruichen Xu, Hong Wang, and Yi Liu. Coordinate transform fourier neural operators for symmetries in physical modelings. Transactions on Machine Learning Research, 2024.   \n[13] Andr\u00e9 Gaul. Recycling krylov subspace methods for sequences of linear systems. 2014.   \n[14] Gene H Golub and Charles F Van Loan. Matrix computations. JHU press, 2013.   \n[15] Markus G\u00f6tz and Hartwig Anzt. Machine learning-aided numerical linear algebra: Convolutional neural networks for the efficient preconditioner generation. In 2018 IEEE/ACM 9th Workshop on Latest Advances in Scalable Algorithms for Large-Scale Systems (scalA), pages 49\u201356. IEEE, 2018.   \n[16] Anne Greenbaum. Iterative methods for solving linear systems. SIAM, 1997.   \n[17] Daniel Greenfeld, Meirav Galun, Ronen Basri, Irad Yavneh, and Ron Kimmel. Learning to optimize multigrid pde solvers. In International Conference on Machine Learning, pages 2415\u20132423. PMLR, 2019.   \n[18] Stefan G\u00fcttel and Fran\u00e7oise Tisseur. The nonlinear eigenvalue problem. Acta Numerica, 26:1\u201394, 2017.   \n[19] Zhongkai Hao, Songming Liu, Yichi Zhang, Chengyang Ying, Yao Feng, Hang Su, and Jun Zhu. Physics-informed machine learning: A survey on problems, methods and applications. arXiv preprint arXiv:2211.08064, 2022.   \n[20] Jun-Ting Hsieh, Shengjia Zhao, Stephan Eismann, Lucia Mirabella, and Stefano Ermon. Learning neural pde solvers with convergence guarantees. arXiv preprint arXiv:1906.01200, 2019.   \n[21] Thomas JR Hughes. The finite element method: linear static and dynamic finite element analysis. Courier Corporation, 2012.   \n[22] Claes Johnson. Numerical solution of partial differential equations by the finite element method. Courier Corporation, 2012.   \n[23] Ayano Kaneda, Osman Akar, Jingyu Chen, Victoria Alicia Trevino Kala, David Hyde, and Joseph Teran. A deep conjugate direction method for iteratively solving linear systems. In International Conference on Machine Learning, pages 15720\u201315736. PMLR, 2023.   \n[24] Misha E Kilmer and Eric De Sturler. Recycling subspace information for diffuse optical tomography. SIAM Journal on Scientific Computing, 27(6):2140\u20132166, 2006.   \n[25] Seid Koric and Diab W Abueidda. Data-driven and physics-informed deep learning operators for solution of heat conduction equation with parametric heat source. International Journal of Heat and Mass Transfer, 203:123809, 2023.   \n[26] Nikola Kovachki, Samuel Lanthaler, and Siddhartha Mishra. On universal approximation and error bounds for fourier neural operators. The Journal of Machine Learning Research, 22(1):13237\u201313312, 2021.   \n[27] Nikola Kovachki, Zongyi Li, Burigede Liu, Kamyar Azizzadenesheli, Kaushik Bhattacharya, Andrew Stuart, and Anima Anandkumar. Neural operator: Learning maps between function spaces. arXiv preprint arXiv:2108.08481, 2021.   \n[28] Steven J Leon, Lisette G De Pillis, and Lisette G De Pillis. Linear algebra with applications. Pearson Prentice Hall Upper Saddle River, NJ, 2006.   \n[29] Randall J LeVeque. Finite volume methods for hyperbolic problems, volume 31. Cambridge university press, 2002.   \n[30] Yichen Li, Peter Yichen Chen, Wojciech Matusik, et al. Learning preconditioner for conjugate gradient pde solvers. arXiv preprint arXiv:2305.16432, 2023.   \n[31] Zongyi Li, Nikola Kovachki, Kamyar Azizzadenesheli, Burigede Liu, Kaushik Bhattacharya, Andrew Stuart, and Anima Anandkumar. Fourier neural operator for parametric partial differential equations. arXiv preprint arXiv:2010.08895, 2020.   \n[32] Zongyi Li, Nikola Kovachki, Kamyar Azizzadenesheli, Burigede Liu, Kaushik Bhattacharya, Andrew Stuart, and Anima Anandkumar. Neural operator: Graph kernel network for partial differential equations. arXiv preprint arXiv:2003.03485, 2020.   \n[33] J\u00f6rg Liesen and Zdenek Strakos. Krylov subspace methods: principles and analysis. Numerical Mathematics and Scie, 2013.   \n[34] Chih-Jen Lin and Jorge J Mor\u00e9. Incomplete cholesky factorizations with limited memory. SIAM Journal on Scientific Computing, 21(1):24\u201345, 1999.   \n[35] Lu Lu, Pengzhan Jin, and George Em Karniadakis. Deeponet: Learning nonlinear operators for identifying differential equations based on the universal approximation theorem of operators. arXiv preprint arXiv:1910.03193, 2019.   \n[36] Lu Lu, Xuhui Meng, Shengze Cai, Zhiping Mao, Somdatta Goswami, Zhongqiang Zhang, and George Em Karniadakis. A comprehensive and fair comparison of two neural operators (with practical extensions) based on fair data. Computer Methods in Applied Mechanics and Engineering, 393:114778, 2022.   \n[37] Kevin Luna, Katherine Klymko, and Johannes P Blaschke. Accelerating gmres with deep learning in real-time. arXiv preprint arXiv:2103.10975, 2021.   \n[38] Ilay Luz, Meirav Galun, Haggai Maron, Ronen Basri, and Irad Yavneh. Learning algebraic multigrid using graph neural networks. In International Conference on Machine Learning, pages 6489\u20136499. PMLR, 2020.   \n[39] Ronald B Morgan. Gmres with deflated restarting. SIAM Journal on Scientific Computing, 24(1):20\u201337, 2002.   \n[40] Michael L Parks, Eric De Sturler, Greg Mackey, Duane D Johnson, and Spandan Maiti. Recycling krylov subspaces for sequences of linear systems. SIAM Journal on Scientific Computing, 28(5):1651\u20131674, 2006.   \n[41] Michael Lawrence Parks. The iterative solution of a sequence of linear systems arising from nonlinear finite element analysis, 2005.   \n[42] William H Press. Numerical recipes 3rd edition: The art of scientific computing. Cambridge university press, 2007.   \n[43] Ouyuan Qin and Kuan Xu. Solving nonlinear odes with the ultraspherical spectral method. arXiv preprint arXiv:2306.17688, 2023.   \n[44] Md Ashiqur Rahman, Zachary E Ross, and Kamyar Azizzadenesheli. U-no: U-shaped neural operators. arXiv preprint arXiv:2204.11127, 2022.   \n[45] Youcef Saad and Martin H Schultz. Gmres: A generalized minimal residual algorithm for solving nonsymmetric linear systems. SIAM Journal on scientific and statistical computing, 7(3):856\u2013869, 1986.   \n[46] Yousef Saad. Iterative methods for sparse linear systems. SIAM, 2003.   \n[47] Johannes Sappl, Laurent Seiler, Matthias Harders, and Wolfgang Rauch. Deep learning of preconditioners for conjugate gradient solvers in urban water related problems. arXiv preprint arXiv:1906.06925, 2019.   \n[48] Rishi Sharma, Amir Barati Farimani, Joe Gomes, Peter Eastman, and Vijay Pande. Weaklysupervised deep learning of heat transport via physics informed loss. arXiv preprint arXiv:1807.11374, 2018.   \n[49] Valeria Simoncini and Daniel B Szyld. On the occurrence of superlinear convergence of exact and inexact krylov subspace methods. SIAM review, 47(2):247\u2013272, 2005.   \n[50] Rita Stanaityte. ILU and Machine Learning Based Preconditioning for the Discretized Incompressible Navier-Stokes Equations. PhD thesis, University of Houston, 2020.   \n[51] G. W. Stewart and Ji guang Sun. Matrix Perturbation Theory. Academic Press, 1990.   \n[52] John C Strikwerda. Finite difference schemes and partial differential equations. SIAM, 2004.   \n[53] Ali Taghibakhshi, Scott MacLachlan, Luke Olson, and Matthew West. Optimization-based algebraic multigrid coarsening using reinforcement learning. Advances in neural information processing systems, 34:12129\u201312140, 2021.   \n[54] Andrea Toselli and Olof Widlund. Domain decomposition methods-algorithms and theory, volume 34. Springer Science & Business Media, 2004.   \n[55] Alasdair Tran, Alexander Mathews, Lexing Xie, and Cheng Soon Ong. Factorized fourier neural operators. In The Eleventh International Conference on Learning Representations.   \n[56] Lloyd N Trefethen. Spectral methods in MATLAB. SIAM, 2000.   \n[57] Lloyd N Trefethen. Spectra and pseudospectra: the behavior of nonnormal matrices and operators. 2020.   \n[58] Hong Wang, Zhongkai Hao, Jie Wang, Zijie Geng, Zhen Wang, Bin Li, and Feng Wu. Accelerating data generation for neural operators via krylov subspace recycling. arXiv preprint arXiv:2401.09516, 2024.   \n[59] David S Watkins. The matrix eigenvalue problem: GR and Krylov subspace methods. SIAM, 2007.   \n[60] Cheng Yang, Xubo Yang, and Xiangyun Xiao. Data-driven projection method in fluid simulation. Computer Animation and Virtual Worlds, 27(3-4):415\u2013424, 2016.   \n[61] David Young. Iterative methods for solving partial difference equations of elliptic type. Transactions of the American Mathematical Society, 76(1):92\u2013111, 1954.   \n[62] Enrui Zhang, Adar Kahana, Eli Turkel, Rishikesh Ranade, Jay Pathak, and George Em Karniadakis. A hybrid iterative numerical transferable solver (hints) for pdes based on deep operator network and relaxation methods. arXiv preprint arXiv:2208.13273, 2022.   \n[63] Xuan Zhang, Limei Wang, Jacob Helwig, Youzhi Luo, Cong Fu, Yaochen Xie, Meng Liu, Yuchao Lin, Zhao Xu, Keqiang Yan, Keir Adams, Maurice Weiler, Xiner Li, Tianfan Fu, Yucheng Wang, Haiyang Yu, YuQing Xie, Xiang Fu, Alex Strasser, Shenglong Xu, Yi Liu, Yuanqi Du, Alexandra Saxton, Hongyi Ling, Hannah Lawrence, Hannes St\u00e4rk, Shurui Gui, Carl Edwards, Nicholas Gao, Adriana Ladera, Tailin Wu, Elyssa F. Hofgard, Aria Mansouri Tehrani, Rui Wang, Ameya Daigavane, Montgomery Bohde, Jerry Kurtin, Qian Huang, Tuong Phung, Minkai Xu, Chaitanya K. Joshi, Simon V. Mathis, Kamyar Azizzadenesheli, Ada Fang, Al\u00e1n Aspuru-Guzik, Erik Bekkers, Michael Bronstein, Marinka Zitnik, Anima Anandkumar, Stefano Ermon, Pietro Li\u00f2, Rose Yu, Stephan G\u00fcnnemann, Jure Leskovec, Heng Ji, Jimeng Sun, Regina Barzilay, Tommi Jaakkola, Connor W. Coley, Xiaoning Qian, Xiaofeng Qian, Tess Smidt, and Shuiwang Ji. Artificial intelligence for science in quantum, atomistic, and continuum systems. arXiv preprint arXiv:2307.08423, 2023. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "[64] Xuejun Zhang. Multilevel schwarz methods. Numerische Mathematik, 63(1):521\u2013539, 1992. ", "page_idx": 12}, {"type": "text", "text": "A Algorithmic Details ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "A.1 computes matrices $U_{k}$ and $C_{k}$ ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "NeurKItt can be modified to solve (1) by carrying over subspace $\\hat{\\mathcal{K}}=\\operatorname{span}\\{y_{1},y_{2},\\ldots,y_{k}\\}$ with respect to $\\pmb{A}$ as follows [11, 40]: ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\begin{array}{c}{{[Q,R]=\\mathrm{thin~QR~decomposition~of}}}\\\\ {{C_{k}=Q;\\quad U_{k}=Y_{k}R^{-1},}}\\end{array}\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "where the matrix $\\pmb{Y}_{k}=[\\pmb{y}_{1},\\pmb{y}_{2},\\dots,\\pmb{y}_{k}]$ . The matrices $U_{k}$ and $C_{k}$ to satisfy ", "page_idx": 13}, {"type": "equation", "text": "$$\nA U_{k}=C_{k};\\quad C_{k}^{H}C_{k}=I_{k}.\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "A.2 NeurKItt Pseudocode ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Algorithm 1: NeurKItt Krylov subspace iteration ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "1 Select $m$ , the maximum size of the Krylov subspace. Define $k$ as the dimension of the predicted invariant subspace $\\hat{\\kappa}$ , where $\\hat{\\mathcal{K}}=\\operatorname{span}\\{y_{1},y_{2},\\ldots,y_{k}\\}$ .   \n2 Given matrix $A$ , use subspace prediction module to predict the matrix $\\pmb{Y}_{k}=[\\pmb{y}_{1},\\pmb{y}_{2},\\dots,\\pmb{y}_{k}]$ and set tol as the convergence tolerance. Choose an initial guess $\\pmb{x}_{0}$ . Calculate $\\pmb{r}_{\\mathrm{0}}=\\pmb{b}-\\pmb{A}\\pmb{x}_{\\mathrm{0}}$ , and initialize $i=1$ .   \n3 Let $[Q,R]$ be the reduced QR-factorization of $A Y_{k}$ .   \n4 $C_{k}=Q$   \n5 $U_{k}=Y_{k}R^{-1}$ $\\pmb{x}_{1}=\\pmb{x}_{0}+\\pmb{U}_{k}\\pmb{C}_{k}^{\\phantom{\\dagger}}t\\pmb{r}_{0}$   \n7 $r_{1}=r_{0}-C_{k}C_{k}{}^{H}r_{0}$   \n8 while $\\|\\pmb{r}_{i}\\|_{2}>t o l$ do   \n9 $i=i+1$   \n10 Perform $m-k$ Arnoldi steps with the linear operator $(\\boldsymbol{I}-\\boldsymbol{C}_{k}\\boldsymbol{C}_{k}^{H})\\boldsymbol{A}$ , letting $v_{1}=r_{i-1}/\\|r_{i-1}\\|_{2}$ and generating $V_{m-k+1},\\underline{{H}}_{m-k}$ and $B_{m-k}$ .   \n11 Let $D_{k}$ be a diagonal scaling matrix such that $\\widetilde{\\cal U}_{k}=U_{k}{\\cal D}_{k}$ , where the columns of $\\smash{\\widetilde{U}}_{k}$ have unit norm.   \n12 V m = [U k Vm\u2212k]   \n13 W m+1 = [Ck Vm\u2212k+1]   \n14 $\\underline{{\\mathbf{G}}}_{m}=\\left[\\begin{array}{c c}{D_{k}}&{B_{m-k}}\\\\ {0}&{\\widetilde{H}_{m-k}}\\end{array}\\right]$   \n15 Solve min $||\\widehat{\\pmb{W}}_{m+1}^{H}\\pmb{r}_{i-1}-\\underline{{{G}}}_{m}\\pmb{y}||_{2}\\;\\mathrm{for}$ $\\textit{\\textbf{y}}$ .   \n16 xi = xi\u22121 +V my   \n17 $\\begin{array}{r}{\\pmb{r}_{i}=\\pmb{r}_{i-1}-\\widehat{\\pmb{W}}_{m+1}\\pmb{G}_{m}\\pmb{y}}\\end{array}$   \n18 Compute the $k$ eigenvectors ${\\widetilde{z}}_{i}$ of $\\underline{{{G}}}_{m}^{H}\\underline{{{G}}}_{m}\\widetilde{z}_{i}=\\widetilde{\\theta}_{i}\\underline{{{G}}}_{m}^{H}\\widehat{W}_{m+1}^{H}\\widehat{V}_{m}\\widetilde{z}_{i}$ associated with smallest magnitude eigenvalues ${\\widetilde{\\theta}}_{i}$ and store in $P_{k}$ .   \n19 $\\tilde{Y}_{k}=\\hat{V}_{m}P_{k}$   \n20 Let $[Q,R]$ be the reduced QR-factorization of $\\underline{{G}}_{m}P_{k}$ .   \n21 $\\begin{array}{l}{{C_{k}=\\widehat{W}_{m+1}Q}}\\\\ {{U_{k}=\\widetilde{Y}_{k}R^{-1}}}\\end{array}$   \n22   \n23 $\\pmb{x}_{i}$ as the numerical solution, $\\pmb{r}_{i}$ as the residual, $i$ as the iteration count. ", "page_idx": 13}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "B From Partial Differential Equation to Linear System ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "We model a steady-state PDE problem as a corresponding system of linear equations using discrete numerical methods such as FDM, FEM, and FVM [52, 21, 22, 29, 10]. Numerical methods discretize a partial differential equation problem by mapping it from an infinite-dimensional function space to a finite-dimensional space, resulting in a system of linear equations. ", "page_idx": 14}, {"type": "text", "text": "We take the process of discretizing the two-dimensional inhomogeneous Helmholtz equation using the Finite Difference Method (FDM) as an example to illustrate how to transform a PDE into a system of linear equations: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\nabla^{2}u(x,y)+k^{2}(x,y)u(x,y)=f(x,y).\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "This equation could be approximated as: ", "page_idx": 14}, {"type": "equation", "text": "$$\n{\\frac{\\iota(x+\\Delta t,y)+u(x-\\Delta t,y)+u(x,y+\\Delta t)+u(x,y-\\Delta t)-4u(x,y)}{\\Delta t^{2}}}+k^{2}(x,y)u(x,y)=f(x,y)\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "We use a $2\\times2$ internal grid (i.e., $N_{x}=N_{y}=2$ and $\\Delta x=\\Delta y$ ), the unknowns $u_{i,j}$ can be arranged in row-major order as follows: $u_{1,1},u_{1,2},u_{2,1},u_{2,2}$ . For central differencing on a $2\\times2$ grid, the vector $^{b}$ will contain the values of $f_{i,j}=f(x_{i},y_{j})$ and the linear equation system $A x=b$ can be expressed as: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left[\\!\\!\\begin{array}{c c c c c}{-4+k_{1,1}^{2}}&{1}&{1}&{0}\\\\ {1}&{-4+k_{1,2}^{2}}&{0}&{1}\\\\ {1}&{0}&{-4+k_{2,1}^{2}}&{1}\\\\ {0}&{1}&{1}&{-4+k_{2,2}^{2}}\\end{array}\\!\\!\\right]\\left[\\!\\!\\begin{array}{c}{u_{1,1}}\\\\ {u_{1,2}}\\\\ {u_{2,1}}\\\\ {u_{2,2}}\\end{array}\\!\\!\\right]=\\left[\\!\\!\\begin{array}{c}{f_{1,1}}\\\\ {f_{1,2}}\\\\ {f_{2,1}}\\\\ {f_{2,2}}\\end{array}\\!\\!\\right].}\\end{array}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "In this example, we call the discretization of function $k^{2}(x,y)$ the input function, corresponding to a $2\\times2$ grid. The function inputs vary from PDE problems. ", "page_idx": 14}, {"type": "text", "text": "C A Brief Introduction to Fourier Neural Operator ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "The Fourier Neural Operator (FNO) aims to map a continuous input function $\\boldsymbol{\\mathcal{A}}$ to its corresponding continuous output function $\\boldsymbol{\\mathcal{U}}$ within the Fourier domain. For end-to-end training on FNO, the function pairs $(\\mathcal{A},\\mathcal{U})$ are discretized into instance pairs $(a,u)$ . The purpose is to learn a mapping $\\mathcal{N}$ between $(a,u)$ , which can be expressed as: ", "page_idx": 14}, {"type": "equation", "text": "$$\nu=\\mathcal{N}(a)\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "The mapping $\\mathcal{N}$ consists of several sequential steps: first, the input channel is lifted using $\\mathcal{R}$ ; next, the mapping is performed through $L$ Fourier layers $\\{\\mathcal{L}_{1},\\mathcal{L}_{2},\\ldots,\\mathcal{L}_{L}\\}$ ; finally, the output is projected back to the original channel using $\\mathcal{Q}$ . ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathcal{N}(a)=\\mathcal{Q}\\circ\\mathcal{L}_{L}\\circ\\cdots\\circ\\mathcal{L}_{1}\\circ\\mathcal{R}(a),\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "$\\mathcal{Q}$ and $\\mathcal{R}$ are pixel-wise transformations that can be implemented using models like MLP. ", "page_idx": 14}, {"type": "text", "text": "A typical Fourier layer consists of a pixel-wise linear transformation, characterized by weight $W$ and bias $b$ , along with an integral kernel operator $\\kappa$ : ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathcal{L}(x)=\\sigma(W x+b+K(x)),}\\end{array}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "where $\\sigma$ is the nonlinear activation function. The integral kernel operator $\\kappa$ composes three steps: Fast Fourier Transformation (FFT), spectral linear transformation, and inverse FFT. ", "page_idx": 14}, {"type": "text", "text": "In the subspace prediction task, we use projection layer $\\mathcal{Q}$ mapping the last fno layer output to the target space. Each channel in the FNO output represents one of the basic vector of the predicted invariant subspace. We then apply QR decomposition to the output. Let the input function be $\\boldsymbol{a}\\in\\mathbb{R}^{d_{a}\\times d_{a}}$ from the Darcy flow problem, where $d_{a}\\,\\in\\,\\mathbb{N}$ is the resolution of the input function, which yields a linear system $A x=b$ for numerical solving, where matrix $A\\in\\mathbb{R}^{d_{A}\\times d_{A}^{\\star}}$ . We aim to predict a subspace $\\hat{\\kappa}$ , as a matrix $X\\in\\mathbb{C}^{d_{A}\\times n}$ , for matrix $A$ in the linear system. First, the FNO\u2019s lifting layer $\\mathcal{R}$ transforms $a$ to a higher-dimensional representation $v_{0}\\in\\mathbb{C}^{d_{a}\\times d_{a}\\times c}$ , while the 3rd dimension is channel dimension. After $T$ Fourier layers forward, we have the $v_{T}\\;\\in\\;\\mathbb{C}^{d_{a}\\times d_{a}\\times c}$ . Because Fourier layers keep the shape unchanged, we apply a transformation $Q$ to map the $v_{T}$ to the desired space, $\\hat{K}=Q(v_{T})$ , with $Q:\\mathbb{C}^{d_{a}\\times d_{a}\\times c}\\rightarrow\\mathbb{C}^{d_{A}\\times n}$ . ", "page_idx": 14}, {"type": "text", "text": "", "page_idx": 15}, {"type": "text", "text": "In practice, transformation $Q$ is a stack of transformation layers. It first flattens the first and second dimension of $v_{T}$ , obtaining $q_{0}\\in\\mathbb{C}^{d_{a}^{2}\\times c}$ . Then a fully-connected neural network (FNN) applies the mapping $\\mathbb{C}^{d_{a}^{2}\\times c}\\rightarrow\\mathbb{C}^{d_{a}^{2}\\times n}$ to $q_{0}$ , obtaining $q_{1}\\,\\in\\,\\mathbb{C}^{d_{a}^{2}\\times n}$ . And another FNN applies the mapping $\\mathbb{C}^{d_{a}^{2}\\times n}\\rightarrow\\mathbb{C}^{d_{A}\\times n}$ to $q_{1}$ , obtaining the output $X\\in\\mathbb{C}^{d_{A}\\times n}$ . Finally, we apply QR decomposition to $X$ for orthogonalizing, obtaining $\\hat{\\mathcal{K}}=\\operatorname{span}\\{X\\}$ . ", "page_idx": 15}, {"type": "text", "text": "D Analyzing the Efficiency of Using FNO Predictions as Initial Solutions in Linear System Solvers ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "D.1 Theoretical Analysis ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "The central premise of this discussion hinges on the potential application of Neural Operators (NOs), such as the Fourier Neural Operator (FNO) [31], in addressing Partial Differential Equation (PDE) problems. Specifically, it explores the feasibility of utilizing these neural operators to predict solutions to PDE problems. Such predictions could serve as preliminary solution vectors for Krylov subspace methods in the resolution of corresponding linear systems. This approach holds promise for expediting the solution process. ", "page_idx": 15}, {"type": "text", "text": "However, the practicality of this concept, particularly in contexts where FNO is commonly discussed, warrants careful consideration. This is especially true in scenarios involving large matrix linear systems that emerge from Finite Difference Methods (FDM) [52], spectral methods [56], and similar approaches. A significant obstacle to the application of this method is the disparity between the type of relative error typically discussed in the context of neural operators and the relative error conventionally employed in computational mathematics. This divergence is further complicated by the impact of the norm of the PDE discretization matrix, which exhibits a tendency to increase with the refinement of the grid. ", "page_idx": 15}, {"type": "text", "text": "In the context of linear systems derived from PDEs, we consider the following standard formulation: ", "page_idx": 15}, {"type": "equation", "text": "$$\nA x=b.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Within the framework of NOs, the prevalent metric for error assessment is the Mean Squared Error (MSE) of the solution function or solution vector $\\textbf{\\em x}$ , designated as $r t o l_{N O}$ : ", "page_idx": 15}, {"type": "equation", "text": "$$\nr t o l_{N O}=\\frac{||\\hat{\\mathbf{x}}_{N O}-\\mathbf{x}||}{||\\mathbf{x}||},\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "where $\\hat{\\pmb{x}}_{N O}$ represents the solution as predicted by the NO, while $\\textbf{\\em x}$ denotes the precise solution. ", "page_idx": 15}, {"type": "text", "text": "In the domain of computational mathematics, the relative residual $r t o l$ is commonly utilized as the error metric for resolving linear systems: ", "page_idx": 15}, {"type": "equation", "text": "$$\nr t o l=\\frac{\\|A\\hat{\\pmb{x}}-\\pmb{b}\\|}{\\|\\pmb{x}\\|},\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "where $\\hat{\\pmb x}$ represents the solution as predicted by the Krylov subspace method. ", "page_idx": 15}, {"type": "text", "text": "Utilizing orthogonal polynomial grid theory, specifically Theorem 30.1 in Trefethen\u2019s work [57], page 290, offers crucial insights for this analysis. ", "page_idx": 15}, {"type": "text", "text": "Theorem D.1. [57, P. 290] For any $N$ , $\\|D_{N}\\|_{2}>N^{2}/3$ . ", "page_idx": 15}, {"type": "text", "text": "In this context, $N$ denotes the count of discretization points in a one-dimensional Ordinary Differential Equation (ODE), and $D_{N}$ represents the discretization matrix constructed using Chebyshev orthogonal polynomial zeros as grid points, with the matrix dimension being $N$ . This assertion holds similarly for other orthogonal polynomial grids, and a uniformly divided grid can be analogized to a grid defined by the zeros of Fourier polynomials. ", "page_idx": 15}, {"type": "text", "text": "The theorem suggests that with an increase in the number of grid points, resulting in a larger matrix size, the norm of the matrix $||A||_{2}$ associated with the discretized PDE also escalates. Then We consider the following equation: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\frac{r t o l_{N O}}{r t o l}=\\frac{\\|\\hat{\\mathbf{x}}_{N O}-\\mathbf{x}\\|}{\\|\\mathbf{A}\\hat{\\mathbf{x}}-\\pmb{b}\\|}=\\frac{\\|\\hat{\\mathbf{x}}_{N O}-\\mathbf{x}\\|}{\\|\\mathbf{A}(\\hat{\\mathbf{x}}-\\mathbf{x})\\|}.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Consequently, when $\\|A\\|_{2}$ is substantially large, there emerges a notable discrepancy between rtolNO and rtol. Generally, the predictive accuracy $r t o l_{N O}$ of the FNO lies in the range of $10^{-2}$ to $10^{-4}$ . However, if the norm $\\|A\\|_{2}$ approaches the magnitude of $10^{5}$ , the relative tolerance rtol as per computational mathematics algorithms may only range between $10^{0}$ and $10^{2}$ . In such instances, leveraging the FNO\u2019s predicted solution as the initial vector for solving the linear system may not substantially expedite the solution process. ", "page_idx": 16}, {"type": "text", "text": "D.2 Experimental Analysis ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "To empirically corroborate the theoretical framework presented, we delve into the Heat dataset F.4.3 utilized in this study, characterized by a matrix size of 52900. The experimental results underscore several noteworthy observations. ", "page_idx": 16}, {"type": "text", "text": "Employing the original FNO for training, we observed $r t o l_{N O}\\sim6*10^{-3}$ , which is in line with the benchmarks reported in the foundational FNO paper. However, because $\\|A\\|_{2}\\sim1.2*10^{6}$ , it results in $r t o l\\sim60\\$ . This empirical finding is consistent with our theoretical predictions. In such a context, utilizing the FNO-derived solution as the initial vector for the linear system does not markedly expedite the resolution process. ", "page_idx": 16}, {"type": "text", "text": "This analysis implicitly suggests that utilizing predicted solutions as initial vectors in iterative algorithms mandates a high level of precision in the neural network model. Nonetheless, it is observed that in standard application scenarios, the impact on accelerating the process is marginal. ", "page_idx": 16}, {"type": "text", "text": "In contrast to this method, our algorithm NeurKItt, by predicting the invariant subspace, not only reduces the initial number of iterations but also, more importantly, substantially improves the convergence rate in subsequent iterations, As demonstrated in the convergence analysis 5.1. This marks a pivotal deviation from former techniques that focus on expediting the process by merely predicting initial solutions. Our theoretical analysis 5.2 shows that the predicted invariant subspace does not require high precision to accelerate the solution of linear systems and significantly reduce the number of iterations. ", "page_idx": 16}, {"type": "text", "text": "E Thin QR Decomposition ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "In our research, we utilize the Thin QR decomposition algorithm, a prevalent technique in numerical linear algebra [14]. The essence of Thin QR decomposition lies in its capacity to factorize a matrix into two distinct components: an orthogonal matrix $Q$ and an upper triangular matrix $\\boldsymbol{R}$ . This factorization is instrumental in diminishing both the computational complexity and the storage demands. ", "page_idx": 16}, {"type": "text", "text": "For a matrix $\\pmb{A}$ belonging to $\\mathbb{C}^{n\\times m}$ with the condition $n\\,\\geq\\,m$ , the Thin QR decomposition is mathematically articulated as: ", "page_idx": 16}, {"type": "equation", "text": "$$\nA=Q R,\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where $Q$ is an $n\\times m$ orthogonal matrix that complies with $Q^{*}Q=I$ , and $\\boldsymbol{R}$ is an $m\\times m$ upper triangular matrix. In our study, the integration of QR decomposition within the neural network architecture is strategically employed to effectively resolve the orthogonal basis of a subspace. ", "page_idx": 16}, {"type": "text", "text": "F Details of Experimental Data and Setup ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "F.1 Specific parameters of the main experiment ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Model Training and Predicting: We employ the 5 FNO layers with modes from $\\{20,32,40\\}$ and the width from {32, 50, 64}. The learning rate is fix at $1\\times10^{-3}$ while the batch size is selected from {16, 32}. The number of subspace dimensions is fixed at 10 in all experiments. For darcy flow and heat datasets, we generate 8000 samples for training and 1600 samples for testing. For Helmholtz, we generate 1000 samples for training and 200 samples for testing. ", "page_idx": 16}, {"type": "text", "text": "", "page_idx": 17}, {"type": "text", "text": "Baseline: To achieve maximum efficiency, we initiated our process by creating linear equation systems of PDEs using either Python. These were subsequently processed within the C programming environment. For the GMRES solver, we employed the most recent version of PETSc, specifically 3.19.4. ", "page_idx": 17}, {"type": "text", "text": "Three Perspectives: ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "1. Precondition: The act of preconditioning is vital when tackling large matrix equations, as it significantly speeds up the resolution process and augments algorithmic stability. Given the variety of scenarios that may arise, we explored over 10 prevalent preconditioning methods, adapting them to suit different contexts. ", "page_idx": 17}, {"type": "text", "text": "2. Tolerance: The precision threshold of a solution directly influences both the number of iterations required and the overall computational time. Different algorithms manifest varying rates of convergence, and specific NOs hold unique tolerance standards. Our comprehensive evaluation encompassed a range of tolerances, with a focus on pinpointing 5-8 levels of optimal error precision for our analyses. ", "page_idx": 17}, {"type": "text", "text": "3. Matrix Dimensionality: The efficiency of an algorithm can vary with changes in matrix size. Furthermore, different NOs often require matrices of various sizes. Therefore, our investigation included the study of 5 distinct matrix sizes. ", "page_idx": 17}, {"type": "text", "text": "Two Performance Metrics: 1. Computational Time: This metric provides a clear and direct measure of an algorithm\u2019s performance. 2. Iteration Count: The count of iterations required reflects the algorithm\u2019s numerical sensitivity and stability, offering valuable insights into its performance characteristics. ", "page_idx": 17}, {"type": "text", "text": "F.2 Environment ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "To ensure consistency in our evaluations, all comparative experiments were conducted under uniform computing environments. Specifically, the environments used are detailed as follows: ", "page_idx": 17}, {"type": "text", "text": "CPU: Intel\u00ae Xeon\u00ae Gold 6246R CPU $@$ 3.40GHz GPU: NVIDIA GeForce RTX 3090 ", "page_idx": 17}, {"type": "text", "text": "F.3 Precondition ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "In this study, we implemented a series of preconditioning methods for our experiments, which are outlined below. ", "page_idx": 17}, {"type": "text", "text": "1. None: In scenarios where \u2019none\u2019 is selected for preconditioning, the linear system is addressed directly in its original form. This means that no preliminary transformations or adjustments are applied to the system before the iterative solving process.   \n2. Diagonal Preconditioning (Jacobi) [46]: This technique focuses solely on the diagonal components of the coefficient matrix. The preconditioner in this approach is essentially the inverse of these diagonal elements, offering a straightforward preconditioning solution.   \n3. Block Jacobi (BJacobi) [5]: A more advanced form of Jacobi preconditioning, Block Jacobi divides the coefficient matrix into smaller, manageable blocks, each representing a specific subdomain or a separate problem. These blocks are then preconditioned individually using their diagonal elements. 4. Successive Over-relaxation (SOR) [61]: SOR, a modification of the Gauss-Seidel method, incorporates a relaxation factor to enhance the process of convergence. This method reformulates the original problem by applying a weight, often improving the convergence rate for certain iterative algorithms. 5. Additive Schwarz Method (ASM) [54]: ASM operates on the principle of domain decomposition, partitioning the main problem into several smaller subdomains. Each subdomain\u2019s problem is solved independently, and the local solutions are then aggregated to form the overall solution.   \n6. Incomplete Cholesky (ICC) [34]: ICC is a preconditioning method based on the Cholesky decomposition, but drops certain off-diagonal elements during the decomposition, making it \"incomplete\". It\u2019s utilized for symmetric positive definite problems. ", "page_idx": 17}, {"type": "text", "text": "7. Incomplete LU (ILU) [46]: ILU is based on LU decomposition, but like ICC, drops certain off-diagonal elements during the decomposition. ILU can be applied to nonsymmetric problems. ", "page_idx": 18}, {"type": "text", "text": "F.4 Datasets ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "F.4.1 Helmholtz Equation ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "We consider a two-dimensional Helmholtz equation, which can be described by the following equation [62]: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\Delta u(x,y)+k^{2}(x,y)u(x,y)=f(x,y),\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where $u(x,y)$ is the wave function, and $k(x,y)$ denotes the spatially varying wavenumber, with $f$ representing the source term, corresponding to origins of electromagnetic or acoustic waves. This equation is pivotal in several physical realms, notably in Acoustics, Electromagnetism, and Quantum Mechanics. Within these fields, the Helmholtz equation models phenomena such as wave propagation and vibration patterns. ", "page_idx": 18}, {"type": "text", "text": "In the context of the Helmholtz equation, the wavenumber $k(x,y)$ is intimately connected to the frequency of the wave and the characteristics of the medium through which the wave propagates. In our experimental setup, the value of $k(x,y)$ is determined using the GRF method [35] while the $f(x,y)$ is the constant. ", "page_idx": 18}, {"type": "text", "text": "F.4.2 Darcy Flow problem ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "We consider two-dimensional Darcy flows, which can be described by the following equation [31, 44, 27, 36]: ", "page_idx": 18}, {"type": "equation", "text": "$$\n-\\nabla\\cdot(K(x,y)\\nabla h(x,y))=f(x,y),\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where $K$ is the permeability field, $h$ is the pressure, and $f$ is a source term which can be either a constant or a space-dependent function. ", "page_idx": 18}, {"type": "text", "text": "In our experiment, $K(x,y)$ is derived using the GRF method [35]. The term $f(x,y)$ is consistently set as a constant $f$ . ", "page_idx": 18}, {"type": "text", "text": "F.4.3 Non-uniform Heat Conduction Equation ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "We consider a two-dimensional heat conduction equation in a non-uniform medium, which is formulated as follows [4, 18]: ", "page_idx": 18}, {"type": "equation", "text": "$$\nk(\\frac{\\partial^{2}T}{\\partial x^{2}}+\\frac{\\partial^{2}T}{\\partial y^{2}})+\\frac{\\partial k}{\\partial x}\\frac{\\partial T}{\\partial x}+\\frac{\\partial k}{\\partial y}\\frac{\\partial T}{\\partial y}+q T=f,\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where $T(x,y)$ is the temperature, $k(x,y)$ represents the spatially varying thermal conductivity, and $q(x,y)T(x,y)$ models internal or external heat sources/sinks. The term $f(x,y)$ acts as an external heat influence. ", "page_idx": 18}, {"type": "text", "text": "This equation is crucial for studying heat distribution in materials with varying properties, such as in the thermal management of electronic devices. Solving this equation helps predict temperature variations, essential for designing effective cooling or heating systems. ", "page_idx": 18}, {"type": "text", "text": "In our experiment, $k(x,y)$ is derived using the GRF [35]. And $q(x,y)$ is samples from $U(0,1)$ . The term $f(x,y)$ is consistently set as a constant $f$ . ", "page_idx": 18}, {"type": "text", "text": "G Analysis of Hyperparameters ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "G.1 Hyperparameters of Fourier Neural Operator ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Fourier Neural Operator has three key hyperparameters: model layers, mode and width for fourier layer. We conduct experiments to investigate the impacts of these hyperparameters. Results in Table 8 suggest that a proper combination of these hyper-parameters will improve the performance. ", "page_idx": 18}, {"type": "text", "text": "Table 8: Performance of NeurKItt with changes in layers, modes, and widths. We use Darcy Flow problem with matrix size of 32400 in these experiments, where the tolerance is fixed to 1e-5 and the preconditioning is None. Subspace dimension is fixed to 20. ", "page_idx": 19}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/c24bb53835ccfbe742d387d945468feedc638b9dd81809825c936168abc11883.jpg", "table_caption": [], "table_footnote": [], "page_idx": 19}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/f9991f2f288d6c043663fcf2a39a2f77795d3416c529377f8b34eae4edbff236.jpg", "table_caption": [], "table_footnote": [], "page_idx": 19}, {"type": "image", "img_path": "cqfE9eYMdP/tmp/8eea9fe6b9d0fdc984a8b19548ab7e74772b6f2c5ae53a443434e4c372838f6d.jpg", "img_caption": ["Figure 4: Experiments on the Darcy Flow problem with varying subspace dimensions. The matrix size is fixed to 32400. "], "img_footnote": [], "page_idx": 19}, {"type": "text", "text": "G.2 Impact of Invariant Subspace Dimension ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "We conduct extensive experiments investigate the acceleration impact of subspace dimension. Results in Figure 4 shows that with the subspace dimension increasing, iteration speedup increase as well. ", "page_idx": 19}, {"type": "text", "text": "However, the time speedup does not consistently increase with the subspace dimension. As shown in the left figure of Figure 4, the time speedup reaches its maximum when the subspace dimension is 8. When the subspace dimension increase from 8, the time speedup decreases. This may be influenced by the subspace size since the subspaces are dense matrices. Recalling the Arnoldi relation in Section 4.2, larger subspaces mean larger dense matrix multiplications. When the subspace dimension is sufficiently large, the additional time cost of dense matrix operations will offset the time savings from reduced iterations, thereby reducing the overall time speedup. This indicates that a larger subspace dimension is not necessarily better. ", "page_idx": 19}, {"type": "text", "text": "H Detailed experimental results ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "H.1 Time Efficiency Analysis for Subspace Prediction Module ", "text_level": 1, "page_idx": 20}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/15539944a37fa09f0a846de6afd448312c541fa5aafa890492ecda8ac122f944.jpg", "table_caption": ["Table 9: The inference time spent of subspace prediction module "], "table_footnote": [], "page_idx": 20}, {"type": "text", "text": "Table 9 shows the time cost of the subspace prediction module for a single pass. The first row lists datasets with matrix side lengths. It\u2019s obvious that across various datasets, the computational cost of the subspace prediction module is extremely low, typically taking only a few milliseconds. ", "page_idx": 20}, {"type": "text", "text": "For comparison, in Darcy Flow problem, solving a linear system using GMRES without preconditioning at a tolerance of 1e-12 requires 34.8 seconds. While the neural network\u2019s inference cost is much more lower, which is negligible. ", "page_idx": 20}, {"type": "text", "text": "H.2 Training Time Analysis ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Table 10: The 120 epochs training cost for subspace prediction module. ", "page_idx": 20}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/c647250158a1f371540e3b148dd8e3e6a1c74925f09241c37150e0dc42be9425.jpg", "table_caption": [], "table_footnote": [], "page_idx": 20}, {"type": "image", "img_path": "cqfE9eYMdP/tmp/be8f2cd64c24e17bf2fdfaf384765bdc06606fdd4c99099c7b3464cb4b5118dd.jpg", "img_caption": ["Figure 5: Training time costs for main experiments. "], "img_footnote": [], "page_idx": 20}, {"type": "text", "text": "We train each dataset for 120 epochs, and list the training costs in Table 10. The total training time for the Helmholtz dataset is shorter compared to the other two datasets. This is because the problem is simple, allowing us to train on a dataset with fewer samples, and the matrix size involved in the problem is smaller than Darcy Flow and Heat problem. ", "page_idx": 20}, {"type": "text", "text": "As shown in the Figure 5, the training typically converges within $100\\,\\mathrm{min}$ . For the Helmholtz problem, it converges in $10\\;\\mathrm{min}$ ; for the Darcy Flow dataset and Heat dataset, it converges less than $100\\;\\mathrm{min}$ However, in scientific computing software, where solving linear systems is frequently required and often time-consuming, the time saved by our approach will add-up to pay off the training costs. ", "page_idx": 20}, {"type": "text", "text": "H.3 Darcy Flow problem ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Table 11: Comparison of time and iteration counts for two algorithms, with varying preconditioners and tolerances ", "page_idx": 21}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/e99d58046972f8a2dca2660d4556c7a46b5c2e5751bfb12a95925c6cbb986543.jpg", "table_caption": [], "table_footnote": [], "page_idx": 21}, {"type": "text", "text": "H.4 Non-uniform Heat Conduction Equation ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Table 12: Comparison of time and iteration counts for two algorithms, with varying preconditioners and tolerances ", "page_idx": 22}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/e69456951d34a4053d7f3489e9bd842fc6dc8e29079668a7f707705f39cbdbcd.jpg", "table_caption": [], "table_footnote": [], "page_idx": 22}, {"type": "text", "text": "H.5 Helmholtz Equation ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Table 13: Comparison of time and iteration counts for two algorithms, with varying preconditioners and tolerances ", "page_idx": 23}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/9a41681ea21d3929396fd2c25f16f970c7e5584d34e1c418c67a88668a6ffc8e.jpg", "table_caption": [], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "Table 14: Experiments on using subspace prediction module trained on 9604 Darcy Flow dataset to accelerate the datasets with different matrix sizes. Results indicate that NeurKItt is able to accelerate linear systems with different sizes of the matrix when the parametric PDE is given. ", "page_idx": 24}, {"type": "table", "img_path": "cqfE9eYMdP/tmp/421ed0c2946641192bafd0242e37fa660f89b624c8f1ac2f37d997fe4aedd9c2.jpg", "table_caption": ["I Do we need to learn the neural network for matrices of a fixed size? "], "table_footnote": [], "page_idx": 24}, {"type": "text", "text": "An important question is whether a model trained on a fixed-size dataset can be used to predict other matrices under the same PDE problem, which is common in scientific computing. In this section, we attempt to address this question using Darcy Flow dataset. First, we downsample the input function of the larger Darcy Flow dataset to generate new Darcy Flow datasets according to the discretization method mentioned in B. Specifically, we downsample the original dataset with a matrix size of 158,404 to obtain Darcy Flow datasets with matrix sizes of 39,204 and 9,604. ", "page_idx": 24}, {"type": "text", "text": "Next, we use the subspace prediction module trained on the Darcy Flow dataset with a matrix size of 9,604 to predict the subspaces of larger datasets. The input to the module is the input function from the larger matrix dataset, which is downsampled to the same size as the input function of the 9,604 matrix dataset, and the output is the predicted subspace of the original matrix dataset size, recovered using cubic spline interpolation. ", "page_idx": 24}, {"type": "text", "text": "In our experiments, the principal angles obtained through this method are generally small. For example, the model trained on the 9,604 matrix dataset predicted a principal angle of 0.07 for the test set of the 39,204 matrix dataset and 0.08 for the test set of the 158,404 matrix dataset. The experimental results in Table 14 are based on the acceleration results using the predicted invariant subspaces. ", "page_idx": 24}, {"type": "text", "text": "These results indicate that our method can scale across different matrix sizes for the given parametric PDE, which demonstrates that NeurKItt is practical. Additionally, using this approach for subspace prediction significantly reduces the required training time. ", "page_idx": 24}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: The main claims in the abstract and introduction accurately reflect the contribution and scope of the paper. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 25}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Justification: We refer to Section 7 for the discussion of our limitations ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 25}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: We have cite the specific paper with the assumptions and proofs for the Theorems used in our paper. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 26}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: We provide the pseudocode for our algorithm in Appendix A, and provide the details about experimental settings and hyperparameter of our model in Appendix F. The dataset generation method is provided in Appendix F.4. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 26}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We refer to Section 4 for code repo. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 27}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We provide details about our experiments and settings in Appendix F Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 27}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We provide the stand deviation of average time cost and average iteration count in Appendix H. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 27}, {"type": "text", "text": "", "page_idx": 28}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: We provide the details about experiments compute recources in Appendix F.2. Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 28}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: The research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics. ", "page_idx": 28}, {"type": "text", "text": "Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 28}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: Contents in our paper focus on accelerating the linear system solving, which could have potential help to the industry or other field involving linear system solving. ", "page_idx": 28}, {"type": "text", "text": "Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed. \u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. ", "page_idx": 28}, {"type": "text", "text": "\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 29}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 29}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 29}, {"type": "text", "text": "Justification: Our data and model focus on linear system solving, especially PDE problems, which have no high risk for misuse. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 29}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 29}, {"type": "text", "text": "Justification: We have checked this and confirmed the paper poses no such risks. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 29}, {"type": "text", "text": "", "page_idx": 30}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 30}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 30}, {"type": "text", "text": "Justification: We provide the instruction in supplemental material about our code and data. Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 30}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 30}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 30}, {"type": "text", "text": "Justification: Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 30}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "page_idx": 30}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 30}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 30}, {"type": "text", "text": "Justification: ", "page_idx": 30}, {"type": "text", "text": "Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 30}, {"type": "text", "text": "", "page_idx": 31}]