[{"figure_path": "5pnhGedG98/figures/figures_1_1.jpg", "caption": "Figure 1: (a) ArithTreeRL framework. Two agents optimize prefix and compressor trees, respectively, modeling the tasks as AddGame for adders and MultGame for multipliers. (b) Prefix tree. (c) Compressor tree. Different tree structures lead to different qualities of adder and multiplier designs.", "description": "This figure illustrates the ArithTreeRL framework and different tree structures used for adder and multiplier designs. (a) shows the overall framework where two reinforcement learning agents optimize prefix and compressor trees separately.  (b) shows the structure of a prefix tree used in adder design, illustrating how different configurations can affect the final adder design. (c) shows the structure of a compressor tree used in multiplier design, again highlighting how different configurations lead to varying outcomes. The different tree structures are directly related to the efficiency and area of the final adder or multiplier designs.", "section": "1 Introduction"}, {"figure_path": "5pnhGedG98/figures/figures_2_1.jpg", "caption": "Figure 2: Comparison of design processes. (a) Default design process. The synthesis tool automatically generates a default multiplier when using multiplication commands (x*y) in Verilog HDL code. (b) Enhanced design process in ArithTreeRL. ArithTreeRL discovers an optimized multiplier structure and generates specialized Verilog HDL code for this improved structure, reducing delay and area after synthesis.", "description": "This figure compares two design processes for multipliers: the default process using a synthesis tool and the enhanced process using ArithTreeRL. The default process directly generates a multiplier from Verilog code, resulting in a design with higher delay and area.  ArithTreeRL enhances this process by discovering an optimized multiplier structure, generating specialized Verilog code for that structure, which results in a significant reduction in both delay and area after the synthesis process.  It demonstrates the impact of ArithTreeRL's optimized tree structure in improving hardware efficiency.", "section": "1 Introduction"}, {"figure_path": "5pnhGedG98/figures/figures_4_1.jpg", "caption": "Figure 3: Method for designing prefix trees with MCTS. Four phases in the search process are executed iteratively, gradually building a search tree.", "description": "This figure shows the four phases of the Monte Carlo Tree Search (MCTS) method used for designing prefix trees in adders and multipliers.  The phases are:\n\n1. **Selection:**  The agent selects the most promising node in the search tree based on a combination of exploration and exploitation. The example shows deleting cell 2.\n2. **Expansion:** A new child node is added to the tree representing a new prefix tree design. The example shows deleting cell 1.\n3. **Simulation:**  A simulation is run from the new node to evaluate the quality of the new design. This involves making more modifications based on a default policy. Add or delete cells is shown.\n4. **Backpropagation:** The result of the simulation is used to update the scores of all nodes along the path from the root to the new node. The score is determined by a weighted combination of delay and area (theoretical metrics) or delay and area (practical metrics). The figure illustrates how these phases iteratively build a search tree to discover optimal prefix tree structures for adders and multipliers.", "section": "3.1 AddGame"}, {"figure_path": "5pnhGedG98/figures/figures_5_1.jpg", "caption": "Figure 4: Designing compressor trees with PPO. Three representations are illustrated. (a) Dot notation. Each dot represents an output bit, with the number inside indicating the estimated delay for selecting adder input bits. The agent's actions involve adding full or half adders to compress the bits until each binary digit contains no more than two bits. The final reward, rT, is defined as the inverse of the delay, encouraging designs with lower delays. (b) Binary bit notation. 0/1 are values of bits for the example multiplication. (c) Logic gate notation. The actual logic gate circuit design for each state.", "description": "This figure illustrates three representations of the process of designing compressor trees using Proximal Policy Optimization (PPO).  The dot notation (a) shows each bit with an estimated delay, guiding the agent's choices in adding half or full adders to reduce bits to at most two per digit, maximizing the final reward (inverse of delay). Binary bit notation (b) demonstrates the process with example multiplication values.  Logic gate notation (c) shows the circuit designs generated at each step.", "section": "3.2 MultGame"}, {"figure_path": "5pnhGedG98/figures/figures_7_1.jpg", "caption": "Figure 5: Some first discovered prefix trees for 128-bit adders with the smallest sizes.", "description": "This figure shows three different prefix tree structures discovered by the ArithTreeRL algorithm for 128-bit adders. Each tree represents a different design with varying levels and sizes, achieving the smallest sizes for their corresponding levels.  The visual representation uses nodes to depict the (i,j) intervals in the prefix tree, highlighting how these intervals are merged to compute the final sum.  These trees showcase the algorithm's ability to find optimal or near-optimal solutions in the vast search space of adder designs, leading to improvements in both theoretical and practical metrics like delay and area.", "section": "4.1 Adder Design"}, {"figure_path": "5pnhGedG98/figures/figures_7_2.jpg", "caption": "Figure 6: Comparison of adders in delay and area. Each point represents one adder and line segments connect Pareto-optimal adders. 'PrefixRL (2-level retr.)' is the raw PrefixRL method improved by our two-level retrieval strategy. Sklansky, Brent-Kung, and Kogge-Stone refer to human-designed adders. ArithTreeRL can significantly improve the delay and area, particularly for high-bit adders. Furthermore, it can discover adders with minimal delays. Our two-level retrieval strategy can effectively find superior designs.", "description": "This figure compares the performance of different adder designs in terms of delay and area.  It shows that the proposed ArithTreeRL method significantly outperforms existing methods, especially for larger adders (64-bit and 128-bit). The two-level retrieval strategy used in ArithTreeRL further enhances its performance by efficiently exploring the design space.", "section": "4.1 Adder Design"}, {"figure_path": "5pnhGedG98/figures/figures_8_1.jpg", "caption": "Figure 3: Method for designing prefix trees with MCTS. Four phases in the search process are executed iteratively, gradually building a search tree.", "description": "This figure illustrates the Monte Carlo Tree Search (MCTS) algorithm used for designing prefix trees in adders and multipliers. The MCTS algorithm iteratively cycles through four phases: selection, expansion, simulation, and backpropagation to build a search tree. Each node in the tree represents a prefix tree, and the algorithm progressively refines the tree structure by selecting actions that maximize a performance score based on delay and area metrics. The actions include adding or deleting cells in the prefix tree.", "section": "3.1 AddGame"}, {"figure_path": "5pnhGedG98/figures/figures_9_1.jpg", "caption": "Figure 8: Comparison of multipliers. The designs were tested in 45nm and 7nm. Each segmented line represents the performance of one multiplier under different timing constraints. \u2018Method (our flow)\u2019 are methods with our improved flow. The \u2018Default\u2019 multipliers are those generated by the synthesis tool by default. \u2018ArithTreeRL\u2019 is our co-design method combining PPO and MCTS, while \u2018PPO (our)\u2019 optimizes only the compressor tree. We apply 45nm designs to the 7nm library without modifications, showcasing the transferability.", "description": "This figure compares the performance of different multiplier designs, including the proposed ArithTreeRL method, across various bit widths (8-bit, 16-bit, 32-bit, and 64-bit).  The performance is evaluated using delay and area metrics under different timing constraints, showcasing the Pareto optimality of the designs.  The figure demonstrates the effectiveness of the co-design approach and the transferability of 45nm designs to 7nm technology.", "section": "4.2 Multiplier Design"}, {"figure_path": "5pnhGedG98/figures/figures_9_2.jpg", "caption": "Figure 9: Design flow time consumption. (average of 1000 runs)", "description": "This figure compares the time consumption of the full synthesis flow and the fast synthesis flow (proposed in ArithTreeRL) for both adder and multiplier designs. For adders, the fast flow shows a significant reduction in time consumption compared to the full flow, especially for larger bit sizes. Similarly, for multipliers, the fast flow proposed by ArithTreeRL is faster than the raw flow, especially at larger bit sizes. This demonstrates the efficiency improvement achieved by using the two-level retrieval strategy in ArithTreeRL, enabling faster design exploration.", "section": "4 Experiments"}, {"figure_path": "5pnhGedG98/figures/figures_15_1.jpg", "caption": "Figure 10: Level upper bound L for optimizing theoretical metrics of adders. The example is for 64-bit adder design. The search is divided into stages, and the level upper bound L increases one at a time. The initial state for each search is set to the best adder found in the last search iteration.", "description": "This figure illustrates the process of optimizing adders using a stratified search based on level upper bounds. The search starts with a specified level, and the best adder is then used as the starting point for the next search with a higher level. This iterative process helps to efficiently find optimal adders.", "section": "A.1 Level Upper Bound"}, {"figure_path": "5pnhGedG98/figures/figures_16_1.jpg", "caption": "Figure 11: Select adders in two-level retrieval. After the first stage of the two-level retrieval process, each adder is represented by a 2D point based on its delay and area. When selecting the top K adders for the second stage, we sort them according to their distances from these points to the Pareto boundary. The K adders with the smallest distances are selected. The threshold distance, denoted as D, is defined by the distance of the K-th adder to the Pareto boundary.", "description": "This figure illustrates the selection process in the two-level retrieval strategy used for adder design.  After a first stage of fast synthesis, adders are plotted on a graph with delay on the y-axis and area on the x-axis.  The Pareto front (optimal tradeoff between delay and area) is identified.  The K (in this case, 8) adders closest to the Pareto front are selected for a second stage of full (more accurate but slower) synthesis. The distance D represents the threshold distance used for selection.", "section": "A.2 Two-Level Retrieval"}, {"figure_path": "5pnhGedG98/figures/figures_16_2.jpg", "caption": "Figure 1: (a) ArithTreeRL framework. Two agents optimize prefix and compressor trees, respectively, modeling the tasks as AddGame for adders and MultGame for multipliers. (b) Prefix tree. (c) Compressor tree. Different tree structures lead to different qualities of adder and multiplier designs.", "description": "This figure illustrates the ArithTreeRL framework, showing how two reinforcement learning agents optimize the prefix and compressor trees for adders and multipliers.  It also provides visual representations of a prefix tree and a compressor tree, highlighting how different tree structures impact the performance of the resulting adder and multiplier designs.", "section": "3 Our Approach"}, {"figure_path": "5pnhGedG98/figures/figures_18_1.jpg", "caption": "Figure 14: Comparison of 8-bit multipliers.", "description": "The figure compares the performance of different multiplier designs for an 8-bit multiplier in terms of delay and area.  The designs compared include Wallace, GOMIL, SA, RL-MUL, PPO (our), Default, ArithTreeRL (our).  The results are shown for both 45nm and 7nm technologies. ArithTreeRL shows improvements over existing methods, especially in terms of delay.", "section": "4.2 Multiplier Design"}, {"figure_path": "5pnhGedG98/figures/figures_18_2.jpg", "caption": "Figure 15: Correlation of theoretical and practical metrics. The fitted lines indicate strong correlations in delay-level and area-size. The data are derived from 6k adders for each.", "description": "This figure shows the strong correlation between theoretical metrics (level and size) and practical metrics (delay and area) for adders.  The plots demonstrate that adders with lower levels (tree height) and smaller sizes tend to have lower delays and smaller areas.  This validates the use of theoretical metrics as a proxy for practical performance in the optimization process.", "section": "4.1 Adder Design"}]