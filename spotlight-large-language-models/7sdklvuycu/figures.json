[{"figure_path": "7sdkLVuYCU/figures/figures_1_1.jpg", "caption": "Figure 1: QTIP performs ultra-high dimensional (> 100) quantization by using Trellis Coded Quantization, which has linear cost in dimension. This enables QTIP to outperform Vector Quantization-based approaches (QuIP#, AQLM) that are limited to low dimensions. With QTIP, 2 bit models scale better than theoretically optimal 4 bit models.", "description": "This figure demonstrates QTIP's ability to perform ultra-high dimensional quantization using Trellis Coded Quantization (TCQ).  The left side shows a diagram of the QTIP architecture, highlighting the use of an incoherent weight matrix and a 'bitshift' trellis quantizer to achieve this. The right side presents a graph showing the Wikitext-2 perplexity of Llama 2 models quantized using different methods (QTIP with varying bit depths, QuIP#, AQLM, and FP16) as a function of model size.  This graph highlights QTIP's superior performance in achieving better perplexity (lower is better) with lower bit depths compared to other quantization techniques, especially as the model size grows.  The graph shows that 2-bit QTIP models perform better than theoretically optimal 4-bit models, demonstrating the effectiveness of the ultra-high dimensional approach.", "section": "QTIP"}, {"figure_path": "7sdkLVuYCU/figures/figures_4_1.jpg", "caption": "Figure 2: A bitshift trellis code with L = 2, k = 1, V = 1. Nodes 0, 1, 2, and 3 have code values 0.5, 0.1, 0.8, and 0.3, respectively. Each node can only transition to the 2kV = 2 nodes that share their top L \u2013 kV = 1 bit with its bottom L \u2013 kV = 1 bit. In this example, \u015c can be stored as 0010110. \u015c is also tail-biting, so the last L \u2013 kV = 1 bits can be dropped to give \u015c = 001011.", "description": "This figure illustrates a simple bitshift trellis with parameters L=2, k=1, V=1. It shows how nodes are connected based on overlapping bits, enabling parallel decoding and efficient storage. The example demonstrates how a sequence is quantized using trellis walks, minimizing squared error.", "section": "3.1 \"Bitshift\" Trellis and Codebook Design"}, {"figure_path": "7sdkLVuYCU/figures/figures_5_1.jpg", "caption": "Figure 3: Set of representable neighboring values in a bitshift trellis with L = 16, k = 2, V = 1 for (far left) a code with strong correlations, (left center) algorithm 1 (\u201c1MAD\u201d), (right center) algorithm 2 (\u201c3INST\u201d), and (far right) a random Gaussian code. Note that while 1MAD has minor correlations, both 1MAD and 3INST are close to a random Gaussian, resulting in good quantization quality.", "description": "This figure compares the distribution of quantized values produced by different methods in a bitshift trellis.  It shows that while a naive approach leads to strong correlations, the proposed algorithms (1MAD and 3INST) generate values closer to a random Gaussian distribution, thus improving quantization quality.", "section": "3.1 \"Bitshift\" Trellis and Codebook Design"}]