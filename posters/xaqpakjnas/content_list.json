[{"type": "text", "text": "Beyond Redundancy: Information-aware Unsupervised Multiplex Graph Structure Learning ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Zhixiang Shen,\u2217 Shuo Wang,\u2217 Zhao Kang\u2020 ", "page_idx": 0}, {"type": "text", "text": "School of Computer Science and Engineering, University of Electronic Science and Technology of China, Chengdu, Sichuan, China zhixiang.zxs@gmail.com zkang@uestc.edu.cn ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Unsupervised Multiplex Graph Learning (UMGL) aims to learn node representations on various edge types without manual labeling. However, existing research overlooks a key factor: the reliability of the graph structure. Real-world data often exhibit a complex nature and contain abundant task-irrelevant noise, severely compromising UMGL\u2019s performance. Moreover, existing methods primarily rely on contrastive learning to maximize mutual information across different graphs, limiting them to multiplex graph redundant scenarios and failing to capture viewunique task-relevant information. In this paper, we focus on a more realistic and challenging task: to unsupervisedly learn a fused graph from multiple graphs that preserve sufficient task-relevant information while removing task-irrelevant noise. Specifically, our proposed Information-aware Unsupervised Multiplex Graph Fusion framework (InfoMGF) uses graph structure refinement to eliminate irrelevant noise and simultaneously maximizes view-shared and view-unique task-relevant information, thereby tackling the frontier of non-redundant multiplex graph. Theoretical analyses further guarantee the effectiveness of InfoMGF. Comprehensive experiments against various baselines on different downstream tasks demonstrate its superior performance and robustness. Surprisingly, our unsupervised method even beats the sophisticated supervised approaches. The source code and datasets are available at https://github.com/zxlearningdeep/InfoMGF. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Multiplex graph (multiple graph layers span across a common set of nodes), as a special type of heterogeneous graph, provides richer information and better modeling capabilities, leading to challenges in learning graph representation [1]. Recently, unsupervised multiplex graph learning (UMGL) has attracted significant attention due to its exploitation of more detailed information from diverse sources [2, 3], using graph neural networks (GNNs) [4] and self-supervised techniques [5]. UMGL has become a powerful tool in numerous real-world applications [6, 7], e.g., social network mining and biological network analysis, where multiple relationship types exist or various interaction types occur. ", "page_idx": 0}, {"type": "text", "text": "Despite the significant progress made by UMGL, a substantial gap in understanding how to take advantage of the richness of the multiplex view is still left. In particular, a fundamental issue is largely overlooked: the reliability of graph structure. Typically, the messaging-passing mechanism in GNNs assumes the reliability of the graph structure, implying that the connected nodes tend to have similar labels. All UMGL methods are graph-fixed, assuming that the original structure is sufficiently reliable for learning [3, 8\u201310]. Unfortunately, there has been evidence that practical ", "page_idx": 0}, {"type": "image", "img_path": "xaqPAkJnAS/tmp/8afc7b0064e947a008d6d61cc3c3de42d19bfb44602c8488b9bb0625ad18e3c4.jpg", "img_caption": ["(a) Multiplex graph non-redundancy (b) Non-redundancy example (c) Empirical study on ACM "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "Figure 1: (a) and (b) illustrate that in a non-redundant multiplex graph, view-specific task-relevant edges exist in certain graphs. The color of nodes represents class, edges between nodes of the same class are considered relevant edges, and \"unique\" indicates that the edge exists only in one graph. (c) The unique relevant edge ratio $=$ (the number of unique relevant edges) / (the total number of relevant edges in this graph). Each graph contains a significant amount of unique task-relevant information. ", "page_idx": 1}, {"type": "text", "text": "graph structures are not always reliable [11]. Multiplex graphs often contain substantial amounts of less informative edges characterized by irrelevant, misleading, and missing connections. For example, due to the heterophily in the graphs, GNNs generate poor performance [12\u201314]. Another representative example is adversarial attacks [15], where attackers tend to add edges between nodes of different classes. Then, aggregating information from neighbors of different classes degrades UMGL performance. Diverging from existing approaches to node representation learning, we focus on structure learning of a new graph from multiplex graphs to better suit downstream tasks. Notably, existing Graph Structure Learning (GSL) overwhelmingly concentrated on a single homogeneous graph [16], marking our endeavor as pioneering in the realm of multiplex graphs. ", "page_idx": 1}, {"type": "text", "text": "Given the unsupervised nature, the majority of UMGL methods leverage contrastive learning mechanism [8\u201310], a typical self-supervised technique, for effective training. However, recent research has demonstrated that standard contrastive learning, maximizing mutual information between different views, is limited to capturing view-shared task-relevant information [17]. This approach is effective only in multi-view redundant scenarios, thereby overlooking unique task-relevant information specific to each view. In practice, the multiplex graph is inherently non-redundant. As illustrated in Figure 1, task-relevant information resides not only in shared areas across different graph views but also in specific view-unique regions. For instance, in the real citation network ACM [18], certain papers on the same subject authored by different researchers may share categories and thematic relevance. This characteristic, compared to the co-author view, represents view-unique task-relevant information within the co-subject view. It exposes a critical limitation in existing UMGL methods, which potentially cannot capture sufficient task-relevant information. ", "page_idx": 1}, {"type": "text", "text": "Motivated by the above observations, our research goal can be summarized as follows: how can we learn a fused graph from the original multiplex graph in an unsupervised manner, mitigating taskirrelevant noise while retaining sufficient task-relevant information? To handle this new task, we propose a novel Information-aware Unsupervised Multiplex Graph Fusion framework (InfoMGF). Graph structure refinement is first applied to each view to achieve a more suitable graph with less task-irrelevant noise. Confronting multiplex graph non-redundancy, InfoMGF simultaneously maximizes the view-shared and view-unique task-relevant information to realize sufficient graph learning. A learnable graph augmentation generator is also developed. Finally, InfoMGF maximizes the mutual information between the fused graph and each refined graph to encapsulate clean and holistic task-relevant information from a range of various interaction types. Theoretical analyses guarantee the effectiveness of our approach in capturing task-relevant information and graph fusion. The unsupervised learned graph and node representations can be applied to various downstream tasks. In summary, our main contributions are three-fold: ", "page_idx": 1}, {"type": "text", "text": "\u2022 Problem. We pioneer the investigation of the multiplex graph reliability problem in a principled way, which is a more practical and challenging task. To our best knowledge, we are the first to attempt unsupervised graph structure learning in multiplex graphs. ", "page_idx": 1}, {"type": "image", "img_path": "xaqPAkJnAS/tmp/293811f02127c06dd9b4862cee7ecba852bfda03f6e797a1c9ba128e57b36860.jpg", "img_caption": ["Figure 2: The overall framework of the proposed InfoMGF. Specifically, InfoMGF first generates refined graphs and the fused graph through the graph learner. Subsequently, it maximizes shared and unique task-relevant information within the multiplex graph and facilitates graph fusion. The learned fused graph and node representations are used for various downstream tasks. "], "img_footnote": [], "page_idx": 2}, {"type": "text", "text": "\u2022 Algorithm. We propose InfoMGF, a versatile multiplex graph fusion framework that steers the fused graph learning by concurrently maximizing both view-shared and view-unique task-relevant information under the multiple graphs non-redundancy principle. Furthermore, we develop two random and generative graph augmentation strategies to capture view-unique task information. Theoretical analyses ensure the effectiveness of InfoMGF. \u2022 Evaluation. We perform extensive experiments against various types of state-of-the-art methods on different downstream tasks to comprehensively evaluate the effectiveness and robustness of InfoMGF. Particularly, our developed unsupervised approach even outperforms supervised methods. ", "page_idx": 2}, {"type": "text", "text": "2 Preliminaries ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Notation. The multiplex graph is represented by $G=\\{G_{1},...,G_{V}\\}$ , where $G_{v}\\,=\\,\\{A_{v},X\\}$ is the $v$ -th graph. $A_{v}\\in\\{0,1\\}^{N\\times N}$ is the corresponding adjacency matrix and $X\\in\\mathbb{R}^{N\\times d_{f}}$ is the shared feature matrix across all graphs. $X_{i}\\,\\in\\,\\mathbb{R}^{d_{f}}$ is the $i$ -th row of $X$ , representing the feature vector of node $i$ . $N$ is the number of nodes and $D_{v}$ is a diagonal matrix denoting the degree matrix of $A_{v}$ . $Y$ is label information. For convenience, we use \u201cview\u201d to refer to each graph in the multiplex graph. ", "page_idx": 2}, {"type": "text", "text": "Multiplex graph non-redundancy. Task-relevant information exists not only in the shared information between graphs but also potentially within the unique information of certain graphs. Following the non-redundancy principle [17], we provide the formal definition of Multiplex Graph Non-redundancy: ", "page_idx": 2}, {"type": "text", "text": "Definition 1. $G_{i}$ is considered non-redundant with $G_{j}$ for $Y$ if and only if there exists $\\epsilon>0$ such that the conditional mutual information $I(G_{i};Y\\mid G_{j})^{\\prime}>\\epsilon$ or $I(G_{j};Y\\mid G_{i})>\\epsilon$ . ", "page_idx": 2}, {"type": "text", "text": "Graph structure learning. Existing GSL methods primarily focus on a single graph. Their pipeline can be summarized as a two-stage framework [16]: a Graph Learner takes in the original graph $G=\\{A,X\\}$ to generate a refined graph $G^{s}=\\{A^{s},X\\}$ with a new structure; a Graph Encoder uses the refined graph as input to obtain node representations. Note that node features generally do not change in GSL, only the graph structure is optimized. Related work is in Appendix B. ", "page_idx": 2}, {"type": "text", "text": "3 Methodology ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "As illustrated in Figure 2, our proposed InfoMGF consists of two modules: the Graph Structure Refinement module and the Task-Relevant Information Maximization module. ", "page_idx": 2}, {"type": "text", "text": "3.1 Graph Structure Refinement ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "We first use a graph learner to generate each view\u2019s refined graph $G_{v}^{s}\\,=\\,\\{A_{v}^{s},X\\}$ . To retain node features and structure information simultaneously, we apply the widely used Simple Graph Convolution (SGC) [19] to perform aggregation in each view, resulting in view-specific node features $X^{v}$ . A view-specific two-layer attentive network is employed to model the varying contributions of different features to structure learning: ", "page_idx": 3}, {"type": "equation", "text": "$$\nX^{v}=(\\tilde{D}_{v}^{-\\frac{1}{2}}\\tilde{A}_{v}\\tilde{D}_{v}^{-\\frac{1}{2}})^{r}X,\\quad H^{v}=\\sigma(X^{v}\\odot W_{1}^{v})\\odot W_{2}^{v}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\tilde{D}_{v}\\,=\\,D_{v}+I$ and $\\tilde{A}_{v}\\,=\\,A_{v}+I$ . $r$ represents the order of graph aggregation. $\\sigma(\\cdot)$ is the non-linear activation function and $\\odot$ denotes the Hadamard product. All rows of $W_{1}^{v}$ are identical, representing a learnable attention vector shared by all nodes. This strategy enables us to acquire view-specific features before training, thereby circumventing the time-consuming graph convolution operations typically required by GNN-based graph learners during training, which significantly boosts our model\u2019s scalability. ", "page_idx": 3}, {"type": "text", "text": "Like existing GSL methods [16, 20], we apply post-processing techniques to ensure that the adjacency matrix $A_{v}^{s}$ satisfies properties such as sparsity, non-negativity, symmetry, and normalization. Specifically, we use $H^{v}$ to construct the similarity matrix and then sparsify it using $k$ -nearest neighbors $(k\\mathsf{N N})$ . For large-scale graphs, we utilize locality-sensitive approximation during $k\\mathrm{NN}$ sparsification to reduce time complexity [21]. Afterward, operations including Symmetrization, Activation, and Normalization are used sequentially to generate the final $A_{v}^{s}$ . Following the refinement of each view, we employ a shared Graph Convolutional Network (GCN) [22] as the graph encoder to obtain the node representations $Z^{v}\\in\\mathbb{R}^{N\\times d}$ of each view, computed by $Z^{v}=\\mathrm{GCN}(\\bar{A}_{v}^{s},X)$ . ", "page_idx": 3}, {"type": "text", "text": "3.2 Maximizing Shared Task-Relevant Information ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "$G_{v}^{s}$ should contain not only view-shared but also view-unique task-relevant information. Following standard contrastive learning [23, 24], for each pair of distinct views (e.g., $i$ and $j$ ), our approach seeks to maximize the mutual information $0.5\\bar{I}(G_{i}^{s};G_{j})+0.5I(G_{j}^{s};G_{i}^{-})$ to capture shared taskrelevant information between views. ", "page_idx": 3}, {"type": "text", "text": "Proposition 1. For any view i and $j$ , $2I(G_{i}^{s};G_{j}^{s})$ is the lower bound of $I(G_{i}^{s};G_{j})+I(G_{j}^{s};G_{i}).$ ", "page_idx": 3}, {"type": "text", "text": "Detailed proofs are provided in the Appendix D. According to Proposition 1, the maximization objective can be transformed to a tractable lower bound $I(G_{i}^{s};G_{j}^{s})$ . Considering the addition of mutual information for each pair, the loss term for minimization can be expressed as follows: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathcal{L}_{s}=-\\frac{2}{V(V-1)}\\sum_{i=1}^{V}\\sum_{j=i+1}^{V}I(G_{i}^{s};G_{j}^{s})\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "3.3 Maximizing Unique Task-Relevant Information ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Maximizing view-unique task-relevant information can be rigorously expressed as maximizing $I(G_{i}^{s};Y|\\cup_{j\\neq i}G_{j})$ . Then, we relax the optimization objective to the total task-relevant information within the view, $I(G_{i}^{s};Y)$ . This decision is based on the following considerations: on the one hand, deliberately excluding shared task-relevant information is unnecessary and would complicate the optimization process. On the other hand, repeated emphasis on shared task-relevant information encourages the model to focus more on it in the early training stage. ", "page_idx": 3}, {"type": "text", "text": "The unsupervised nature of our task dictates that we cannot directly optimize $I(G_{i}^{s};Y)$ using label information. Some typical graph learning methods often reconstruct the graph structure to preserve the maximum amount of information from the original data [25\u201327]. In the context of our task, this reconstruction-based optimization objective is equivalent to maximizing the mutual information with the original graph structure [28, 29], i.e., $I(G_{i}^{s};G_{i})$ . However, such methods have significant drawbacks: they retain task-irrelevant information from the original data, and the graph reconstruction also entails high complexity. In contrast, we leverage graph augmentation to reduce task-irrelevant information and retain task-relevant information without accessing $Y$ . Following the optimal augmentation assumption [17, 30], we define optimal graph augmentation as: ", "page_idx": 3}, {"type": "text", "text": "Definition 2. $G_{i}^{\\prime}$ is an optimal augmented graph of $G_{i}$ if and only if ${\\cal I}(G_{i}^{\\prime};G_{i})={\\cal I}(Y;G_{i}).$ , implying that the only information shared between $G_{i}$ and $G_{i}^{\\prime}$ is task-relevant without task-irrelevant noise. ", "page_idx": 4}, {"type": "text", "text": "Theorem 1. If $G_{i}^{\\prime}$ is the optimal augmented graph of $G_{i}$ , then $I(G_{i}^{s};G_{i}^{\\prime})=I(G_{i}^{s};Y)$ holds. ", "page_idx": 4}, {"type": "text", "text": "Theorem 2. The maximization of $I(G_{i}^{s};G_{i}^{\\prime})$ yields a discernible reduction in the task-irrelevant information relative to the maximization of $I(G_{i}^{s};G_{i})$ . ", "page_idx": 4}, {"type": "text", "text": "Theorem 1 theoretically guarantees that maximizing $I(G_{i}^{s};G_{i}^{\\prime})$ would provide clean and sufficient task-relevant guidance for learning $G_{i}^{s}$ . Theorem 2 demonstrates the superiority of our optimization objective over typical methods in removing task-irrelevant information. Therefore, given $G_{i}^{\\prime}\\ =$ $\\{\\bar{A}_{i}^{\\prime},X^{\\prime}\\}$ for each view, where $A_{i}^{\\prime}$ and $X^{\\prime}$ denote the augmented adjacency matrix and node features, respectively, the loss term $\\mathcal{L}_{u}$ is defined as: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\mathcal{L}_{u}=-\\frac{1}{V}\\sum_{i=1}^{V}I(G_{i}^{s};G_{i}^{\\prime})\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "The key to the above objective lies in ensuring that $G_{i}^{\\prime}$ satisfies the optimal graph augmentation. However, given the absence of label information, achieving truly optimal augmentation is not feasible; instead, we can only rely on heuristic techniques to simulate it. Consistent with most existing graph augmentations, we believe that task-relevant information in graph data exists in both structure and feature, necessitating augmentation in both aspects. We use random masking, a simple yet effective method, to perform feature augmentation. For graph structure, we propose two versions: random edge dropping and learnable augmentation through a graph generator. ", "page_idx": 4}, {"type": "text", "text": "Random feature masking. For node features, we randomly select a fraction of feature dimensions and mask them with zeros. Formally, we sample a random vector $\\vec{m}\\;\\in\\;\\{0,1\\}^{d_{f}}$ where each dimension is drawn from a Bernoulli distribution independently, i.e., $\\vec{m}_{i}\\sim B e r n(1-\\rho)$ . Then, the augmented node features $X^{\\prime}$ is computed by $X^{\\prime}=[X_{1}\\odot\\vec{m};X_{2}\\odot\\vec{m};...;X_{N}\\odot\\vec{m}]^{\\intercal}$ . ", "page_idx": 4}, {"type": "text", "text": "Random edge dropping (InfoMGF-RA). For a given $A_{v}$ , a masking matrix $M\\,\\in\\,\\{0,1\\}^{N\\times N}$ is randomly generated, where each element $M_{i j}$ is sampled from a Bernoulli distribution. Afterward, the augmented adjacency matrix can be computed as $A_{v}^{\\prime}=A_{v}\\odot M$ . ", "page_idx": 4}, {"type": "text", "text": "Learnable generative augmentation (InfoMGF-LA). Random edge dropping may lack reliability and interpretability. A low dropping probability might not suffice to eliminate task-irrelevant information, while excessive deletions could compromise task-relevant information. Therefore, we opt to use a learnable graph augmentation generator. To avoid interference from inappropriate structure information, we compute personalized sampling probabilities for existing edges in each view by employing a Multilayer Perceptron (MLP) in the node features. To ensure the differentiability of the sampling operation for end-to-end training, we introduce the Gumbel-Max reparametrization trick [31, 32] to transform the discrete binary (0-1) distribution of edge weights into a continuous distribution. Specifically, for each edge $e_{i,j}$ in view $v$ , its edge weight $\\omega_{i,j}^{v}$ in the corresponding augmented view is computed as follows: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\theta_{i,j}^{v}=\\mathrm{MLP}\\left([W X_{i};W X_{j}]\\right),\\quad\\omega_{i,j}^{v}=\\mathrm{Sigmoid}\\left((\\log\\delta-\\log(1-\\delta)+\\theta_{i,j}^{v})/\\tau\\right)}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $[\\cdot;\\cdot]$ denotes the concatenation operation and $\\delta\\,\\sim\\,\\mathrm{Uniform}(0,1)$ is the sampled Gumbel random variate. We can control the temperature hyper-parameter $\\tau$ approaching 0 to make $\\omega_{i,j}^{v}$ tend towards a binary distribution. For an effective augmented graph generator, it should eliminate task-irrelevant noise while retaining task-relevant information. Therefore, we design a suitable loss function for augmented graph training: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\mathcal{L}_{g e n}=\\frac{1}{N V}\\sum_{i=1}^{V}\\sum_{j=1}^{N}\\left(1-\\frac{(X_{j}^{i})^{\\top}\\hat{X}_{j}^{i}}{\\|X_{j}^{i}\\|\\cdot\\|\\hat{X}_{j}^{i}\\|}\\right)+\\lambda\\ast\\frac{1}{V}\\sum_{i=1}^{V}I(G_{i}^{s};G_{i}^{\\prime})\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\lambda$ is a positive hyper-parameter. The first term reconstructs view-specific features using the cosine error, guaranteeing that the augmented views preserve crucial task-relevant information while having lower complexity compared to reconstructing the entire graph structure. The reconstructed features ${\\hat{X}}^{i}$ are obtained using an MLP-based Decoder on the node representations $Z^{i^{\\prime}}$ of the augmented view. The second term minimizes $I(G_{i}^{s};G_{i}^{\\prime})$ to regularize the augmented views simultaneously, ensuring that the augmented graphs would provide only task-relevant information as guidance with less task-irrelevant noise when optimizing the refined graph $G_{i}^{s}$ through Eq.(3). Note that for InfoMGF-LA, we adopt an iterative optimization strategy to update $G_{i}^{s}$ and $G_{i}^{\\prime}$ alternatively, as described in Section 3.4. ", "page_idx": 4}, {"type": "text", "text": "", "page_idx": 5}, {"type": "text", "text": "Although previous work also employs similar generative graph augmentation [33], we still possess irreplaceable advantages in comparison. Firstly, they merely minimize mutual information to generate the augmented graph, lacking the crucial information retention component, which may jeopardize task-relevant information. Furthermore, an upper bound should ideally be used for minimization, whereas they utilize a lower bound estimator for computation, which is incorrect in optimization practice. In contrast, we use a rigorous upper bound of mutual information for the second term of $\\mathcal{L}_{g e n}$ , which is demonstrated later. ", "page_idx": 5}, {"type": "text", "text": "3.4 Multiplex Graph Fusion ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "The refined graph retains task-relevant information from each view while eliminating task-irrelevant noise. Afterward, we learn a fused graph that encapsulates sufficient task-relevant information from all views. Consistent with the approach in Section 3.1, we leverage a scalable attention mechanism as the fused graph learner: ", "page_idx": 5}, {"type": "equation", "text": "$$\nH=\\sigma([X;X^{1};X^{2};\\cdot\\cdot\\cdot;X^{V}]\\odot W^{1})\\odot W^{2},\\quad\\mathcal{L}_{f}=-\\frac{1}{V}\\sum_{i=1}^{V}I(G^{s};G_{i}^{s})\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where the node features are concatenated with all view-specific features as input. The same postprocessing techniques are sequentially applied to generate the fused graph $G^{s}\\,=\\,\\{A^{s},X\\}$ . The node representations $Z$ of the fused graph are also obtained through the same GCN. We maximize the mutual information between the fused graph and each refined graph to incorporate task-relevant information from all views, denoted as loss $\\mathcal{L}_{f}$ . The total loss $\\mathcal{L}$ of our model can be expressed as the sum of three terms: $\\mathcal{L}=\\mathcal{L}_{s}+\\mathcal{L}_{u}+\\mathcal{L}_{f}$ . ", "page_idx": 5}, {"type": "text", "text": "Theorem 3. The learned fused graph $G^{s}$ contains more task-relevant information than the refined graph $G_{i}^{s}$ from any single view. Formally, we have: ", "page_idx": 5}, {"type": "equation", "text": "$$\nI(G^{s};Y)\\geq\\operatorname*{max}_{i}I(G_{i}^{s};Y)\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "Theorem 3 theoretically proves that the fused graph $G^{s}$ can incorporate more task-relevant information than considering each view individually, thus ensuring the effectiveness of multiplex graph fusion. ", "page_idx": 5}, {"type": "text", "text": "Optimization. Note that all the loss terms require calculating mutual information. However, directly computing mutual information between two graphs is impractical due to the complexity of graph-structured data. Since we focus on node-level tasks, we assume the optimized graph should guarantee that each node\u2019s neighborhood substructure contains sufficient task-relevant information. Therefore, this requirement can be transferred into mutual information between node representations [34], which can be easily computed using a sample-based differentiable lower/upper bound. For any view $i$ and $j$ , the lower bound $I_{l b}$ and upper bound $I_{u b}$ of the mutual information ${\\bar{I}}(Z^{i};Z^{j})$ are [17]: ", "page_idx": 5}, {"type": "equation", "text": "$$\nI_{l b}(Z^{i};Z^{j})=\\mathbb{E}_{z^{i},z^{j+}\\sim p(z^{i},z^{j})}\\left[l o g\\frac{e x p f(z^{i},z^{j+})}{\\sum_{N}e x p f(z^{i},z^{j})}\\right]\n$$", "text_format": "latex", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r}{I_{u b}(Z^{i};Z^{j})=\\mathbb{E}_{z^{i},z^{j}+\\sim p(z^{i},z^{j})}\\left[f^{*}(z^{i},z^{j+})\\right]-\\mathbb{E}_{z^{i}\\sim p(z^{i})}\\left[f^{*}(z^{i},z^{j})\\right]}\\\\ {z^{j}\\sim p(z^{j})\\ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $f(\\cdot,\\cdot)$ is a score critic approximated by a neural network and $f^{*}(\\cdot,\\cdot)$ is the optimal critic from $I_{l b}$ plugged into the $I_{u b}$ objective. $p(z^{i},z^{j})$ denotes the joint distribution of node representations from views $i$ and $j$ , while $\\bar{p(z^{i})}$ denotes the marginal distribution. $z^{i}$ and $z^{j+}$ are mutually positive samples, representing the representations of the same node in views $i$ and $j$ respectively. ", "page_idx": 5}, {"type": "text", "text": "To avoid too many extra parameters, the function $f(z^{i},z^{j})$ is implemented using non-linear projection and cosine similarity. Each term in the total loss $\\mathcal{L}$ maximizes mutual information, so we use the lower bound estimator for the calculation. In contrast, we use the upper bound estimator for the generator loss $\\mathcal{L}_{g e n}$ in InfoMGF-LA, which minimizes mutual information. These two losses can ", "page_idx": 5}, {"type": "text", "text": "be expressed as follows: ", "page_idx": 6}, {"type": "equation", "text": "$$\n{\\mathcal{L}}=-{\\frac{2}{V(V-1)}}\\sum_{i=1}^{V}\\sum_{j=i+1}^{V}I_{l b}(Z^{i};Z^{j})-{\\frac{1}{V}}\\sum_{i=1}^{V}I_{l b}(Z^{i};Z^{i^{\\prime}})-{\\frac{1}{V}}\\sum_{i=1}^{V}I_{l b}(Z;Z^{i})\n$$", "text_format": "latex", "page_idx": 6}, {"type": "equation", "text": "$$\n\\mathcal{L}_{g e n}=\\frac{1}{N V}\\sum_{i=1}^{V}\\sum_{j=1}^{N}\\left(1-\\frac{(X_{j}^{i})^{\\top}\\hat{X}_{j}^{i}}{\\lVert X_{j}^{i}\\rVert\\cdot\\lVert\\hat{X}_{j}^{i}\\rVert}\\right)+\\lambda*\\frac{1}{V}\\sum_{i=1}^{V}I_{u b}(Z^{i};Z^{i^{\\prime}})\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "Finally, we provide the InfoMGF-LA algorithm in Appendix C.1. In Step 1 of each epoch, we keep the augmented graph fixed and optimize both the refined graphs and the fused graph using the total loss $\\mathcal{L}$ , updating the parameters of Graph Learners and GCN. In Step 2, we keep the refined graphs fixed and optimize each augmented graph using $\\mathcal{L}_{g e n}$ , updating the parameters of the Augmented Graph Generator and Decoder. After training, $G^{s}$ and $Z$ are used for downstream tasks. ", "page_idx": 6}, {"type": "text", "text": "4 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "In this section, our aim is to answer three research questions: RQ1: How effective is InfoMGF for different downstream tasks in unsupervised settings? RQ2: Does InfoMGF outperform baselines of various types under different adversarial attacks? RQ3: How do the main modules influence the performance of InfoMGF? ", "page_idx": 6}, {"type": "text", "text": "4.1 Experimental Setups ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Downstream tasks. We evaluate the learned graph on node clustering and node classification tasks. For node clustering, following [8], we apply the K-means algorithm on the node representations $Z$ of $G^{s}$ and use the following four metrics: Accuracy (ACC), Normalized Mutual Information (NMI), F1 Score (F1), and Adjusted Rand Index (ARI). For node classification, following the graph structure learning settings in [16], we train a new GCN on $G^{s}$ for evaluation and use the following two metrics: Macro-F1 and Micro-F1. ", "page_idx": 6}, {"type": "text", "text": "Datasets. We conduct experiments on four real-world benchmark multiplex graph datasets, which consist of two citation networks (i.e., ACM [18] and DBLP [18]), one review network Yelp [35] and a large-scale citation network MAG [36]. Details of datasets are shown in Appendix E.1. ", "page_idx": 6}, {"type": "text", "text": "Baselines. For node clustering, we compare InfoMGF with two single-graph methods (i.e., VGAE [25] and DGI [37]) and seven multiplex graph methods (i.e., O2MAC [26], MvAGC [38], MCGC [39], HDMI [8], MGDCR [9], DMG [3], and BTGF [10]). All the baselines are unsupervised clustering methods. For a fair comparison, we conduct single-graph methods separately for each graph and present the best results. ", "page_idx": 6}, {"type": "text", "text": "For node classification, we compare InfoMGF with baselines of various types: three supervised structure-fixed GNNs (i.e., GCN [22], GAT [40] and HAN [41]), six supervised GSL methods (i.e., LDS [42], GRCN [43], IDGL [44], ProGNN [11], GEN [45] and NodeFormer [46]), three unsupervised GSL methods (i.e., SUBLIME [20], STABLE [47] and GSR [48]), and three structure-fixed UMGL methods (i.e., HDMI [8], DMG [3] and BTGF [10]). GCN, GAT, and all GSL methods are single-graph approaches. For unsupervised GSL methods, following [20], we train a new GCN on the learned graph for node classification. For UMGL methods, following [8], we train a linear classifier on the learned representations. Implementation details can be found in Appendix E.2. ", "page_idx": 6}, {"type": "text", "text": "4.2 Effectiveness Analysis (RQ1) ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Table 1 presents the results of node clustering. Firstly, multiplex graph clustering methods outperform single graph methods overall, demonstrating the advantages of leveraging information from multiple sources. Secondly, compared to other multiplex graph methods, both versions of our approach surpass existing state-of-the-art methods. This underscores the efficacy of our proposed graph structure learning, which eliminates task-irrelevant noise and extracts task-relevant information from all graphs, to serve downstream tasks better. Finally, InfoMGF-LA achieves notably superior results, owing to the exceptional capability of the learnable generative graph augmentation in capturing view-unique task-relevant information. ", "page_idx": 6}, {"type": "table", "img_path": "xaqPAkJnAS/tmp/754a1b4ce6fcb519b553cf3ae134fc4b6ac51ddd238ac805ada212d4368e918f.jpg", "table_caption": ["Table 1: Quantitative results $(\\%)$ on node clustering. The top 3 highest results are highlighted with red boldface, red color and boldface, respectively. The symbol \u201cOOM\u201d means out of memory. "], "table_footnote": [], "page_idx": 7}, {"type": "table", "img_path": "xaqPAkJnAS/tmp/d531d43d4256ec422c2f7ae44c673207339b6f5095b5667b15ebdb7b5f00bf52.jpg", "table_caption": ["Table 2: Quantitative results with standard deviation $(\\%\\pm\\sigma)$ on node classification. Available data for GSL during training is shown in the first column, supervised methods depend on Y for GSL. The symbol \u201c-\u201d indicates that the method is structure-fixed, which does not learn a new structure. "], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "Table 2 reports the node classification results. Overall, GSL methods outperform structure-fixed methods, demonstrating the unreliability of the original structure in real-world data and the significance of graph structure learning. Particularly for various carefully designed UMGL methods, the original graphs with rich task-irrelevant noise severely limit their performance. Compared to existing single-graph GSL methods, both versions of InfoMGF outperform the supervised methods. By capturing shared and unique information from multiplex graphs, InfoMGF can integrate more comprehensive task-relevant information. Finally, we can observe that the proposed InfoMGF-LA with learnable augmentation indeed surpasses the random augmentation version, once again highlighting its advantage in exploring task-relevant information. ", "page_idx": 7}, {"type": "text", "text": "We select a subgraph from the ACM dataset with nodes in two classes (database (C1) and data mining (C2)) and visualize the edge weights in the original multiplex graphs and the fused graph learned by InfoMGF-LA. From Figure 3, the learned graph mainly consists of intra-class edges. Compared to the nearly fully connected PSP view, InfoMGF significantly reduces inter-class edges, reflecting our effective removal of task-irrelevant noise. Compared to the PAP view, InfoMGF introduces more intra-class edges, benefiting from capturing shared and unique task-relevant information from all graphs. Furthermore, varying edge weights in $G^{s}$ represent different importance levels, better serving downstream tasks. In summary, the above experiment results across various downstream tasks demonstrate the effectiveness of InfoMGF. We use the InfoMGF-LA version in the subsequent sections to conduct more comprehensive analyses. ", "page_idx": 7}, {"type": "image", "img_path": "xaqPAkJnAS/tmp/89123264651725172fa149d3878d2614832c39b71a130af45a1d642df2b3606d.jpg", "img_caption": ["Figure 3: Heatmaps of the subgraph adjacency matrices of the original and learned graphs on ACM. "], "img_footnote": [], "page_idx": 7}, {"type": "image", "img_path": "xaqPAkJnAS/tmp/5e1d2f9135916994c911abc0bbfd43ac585e0b33b95ef56563ebcc8dec5b216b.jpg", "img_caption": ["Figure 4: Robustness analysis on ACM. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "4.3 Robustness Analysis (RQ2) ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "To evaluate the robustness of InfoMGF against random noise, we perturb each graph on the ACM dataset by randomly adding edges, deleting edges, and masking features. We compare InfoMGF against various baselines: structure-fixed method (GCN), GSL method (SUBLIME), and UMGL method (HDMI). From Figure 4a and 4b, it is evident that with increasing rates of edge perturbing, the performance of each method deteriorates, while the GSL methods (i.e., InfoMGF and SUBLIME) exhibit better robustness. Notably, InfoMGF consistently outperforms all other methods across both experimental settings, especially when the perturbation rate is extremely high. ", "page_idx": 8}, {"type": "text", "text": "Figure $4\\mathrm{c}$ shows the performance of InfoMGF and various baselines when injecting random feature noise. It can be observed that InfoMGF exhibits excellent robustness against feature noise, while the performance of SUBLIME degrades rapidly. As a single graph structure learning method, SUBLIME\u2019s performance heavily relies on the quality of node features. In contrast, our method can directly optimize task-relevant information in multi-view graph structures (e.g., edges shared across multiple graphs are likely to share task-relevant information, which can be directly learned through $\\mathcal{L}_{s}$ ), thus reducing dependence on node features. Consequently, InfoMGF demonstrates superior robustness against various types of noise. ", "page_idx": 8}, {"type": "text", "text": "4.4 Ablation Study (RQ3) ", "text_level": 1, "page_idx": 8}, {"type": "table", "img_path": "xaqPAkJnAS/tmp/7f05ba7444f079a8b6acb7b27e42d4fe288c4618786c0f7480eee1db058a4a6d.jpg", "table_caption": ["Table 3: Performance $(\\%\\pm\\sigma)$ of InfoMGF and its variants. "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "To verify the effectiveness of each part of InfoMGF, we design four variants and compare the classification performance against InfoMGF. ", "page_idx": 8}, {"type": "text", "text": "Effectiveness of loss components. Recall InfoMGF maximizes view-shared and unique task-relevant information by $\\mathcal{L}_{s}$ and $\\mathcal{L}_{u}$ . Thus, we design two variants (w/o $\\mathcal{L}_{s}$ and w/o $\\mathcal{L}_{u}$ ). Table 3 shows the necessity of each component. Furthermore, we can observe that the removal of $\\mathcal{L}_{u}$ has a greater impact compared to $\\mathcal{L}_{s}$ , which can be explained by the fact that optimization of $\\mathcal{L}_{u}$ actually maximizes the overall task-relevant information of each view, rather than the unique aspects of the view. ", "page_idx": 8}, {"type": "image", "img_path": "xaqPAkJnAS/tmp/cf81680bd0799553698eda6391f6aeb41427ad8b8316e08c3f382d115ad95ebf.jpg", "img_caption": ["Figure 5: Node correlation maps of representations reordered by node labels. "], "img_footnote": [], "page_idx": 9}, {"type": "text", "text": "Effectiveness of augmentation module. The InfoMGF-LA framework incorporates learnable generative augmentation and maximizes the mutual information $I(G_{i}^{s};G_{i}^{\\prime})$ to mine the task-relevant information. We first compare InfoMGF with maximizing the mutual information $I(G_{i}^{s};G_{i})$ with the original graph structure without augmentation (w/o Aug.). Furthermore, we remove the reconstruction loss term (w/o Rec.) of $\\mathcal{L}_{g e n}$ to analyze the necessity of preserving crucial information. The results show that maximizing $\\check{I(G_{i}^{s};G_{i})}$ leads to poorer performance compared to $I(G_{i}^{s};G_{i}^{\\prime})$ , consistent with Theorem 2. Meanwhile, deleting the reconstruction term from $\\mathcal{L}_{g e n}$ also results in the augmented graph lacking task-relevant information, thus hurting model performance. ", "page_idx": 9}, {"type": "text", "text": "4.5 Node Correlation Visualization ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We further visualize the node correlation in the learned representations $Z$ of the fused graph, which is used in the clustering task. Figure 5 shows the node correlation heatmaps of the representations, where both rows and columns are reordered by the node labels. In the heatmap, warmer colors signify a higher correlation between nodes. It is evident that the correlation among nodes of the same class is significantly higher than that of nodes from different classes. This is due to $G^{s}$ mainly containing intra-class edges without irrelevant inter-class edges, which validates the effectiveness of InfoMGF in unsupervised graph structure learning. ", "page_idx": 9}, {"type": "text", "text": "5 Conclusion and Limitation ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "This paper delves into the unsupervised graph structure learning within multiplex graphs for the first time. The proposed InfoMGF refines the graph structure to eliminate task-irrelevant noise, while simultaneously maximizing both the shared and unique task-relevant information across different graphs. The fused graph applied to downstream tasks is optimized to incorporate clean and comprehensive task-relevant information from all graphs. Theoretical analyses and extensive experiments ensure the effectiveness of InfoMGF. A limitation of our research lies in its focus solely on the pure unsupervised scenario. In some real-world scenarios where partial node labels are available, label information can be used to learn a better structure of multiplex graphs. Such supervised or semi-supervised problems are left for future exploration. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgments and Disclosure of Funding ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "This work was supported by the National Natural Science Foundation of China (No. 62276053). ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Zhixiang Shen, Haolan He, and Zhao Kang. Balanced multi-relational graph clustering. In ACM Multimedia 2024. ", "page_idx": 9}, {"type": "text", "text": "[2] Chanyoung Park, Donghyun Kim, Jiawei Han, and Hwanjo Yu. Unsupervised attributed multiplex network embedding. In Proceedings of the AAAI conference on artificial intelligence, volume 34, pages 5371\u20135378, 2020.   \n[3] Yujie Mo, Yajie Lei, Jialie Shen, Xiaoshuang Shi, Heng Tao Shen, and Xiaofeng Zhu. Disentangled multiplex graph representation learning. In International Conference on Machine Learning, pages 24983\u201325005. PMLR, 2023.   \n[4] Zonghan Wu, Shirui Pan, Fengwen Chen, Guodong Long, Chengqi Zhang, and S Yu Philip. A comprehensive survey on graph neural networks. IEEE Transactions on Neural Networks and Learning Systems, 32(1):4\u201324, 2020.   \n[5] Xiao Liu, Fanjin Zhang, Zhenyu Hou, Li Mian, Zhaoyu Wang, Jing Zhang, and Jie Tang. Selfsupervised learning: Generative or contrastive. IEEE Transactions on Knowledge and Data Engineering, 35(1):857\u2013876, 2021.   \n[6] Weifeng Zhang, Jingwen Mao, Yi Cao, and Congfu Xu. Multiplex graph neural networks for multi-behavior recommendation. In Proceedings of the 29th ACM international conference on information & knowledge management, pages 2313\u20132316, 2020.   \n[7] Xunqiang Jiang, Tianrui Jia, Yuan Fang, Chuan Shi, Zhe Lin, and Hui Wang. Pre-training on large-scale heterogeneous graph. In Proceedings of the 27th ACM SIGKDD conference on knowledge discovery & data mining, pages 756\u2013766, 2021.   \n[8] Baoyu Jing, Chanyoung Park, and Hanghang Tong. Hdmi: High-order deep multiplex infomax. In Proceedings of the Web Conference 2021, pages 2414\u20132424, 2021.   \n[9] Yujie Mo, Yuhuan Chen, Yajie Lei, Liang Peng, Xiaoshuang Shi, Changan Yuan, and Xiaofeng Zhu. Multiplex graph representation learning via dual correlation reduction. IEEE Transactions on Knowledge and Data Engineering, 2023.   \n[10] Xiaowei Qian, Bingheng Li, and Zhao Kang. Upper bounding barlow twins: A novel filter for multi-relational clustering. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 38, pages 14660\u201314668, 2024.   \n[11] Wei Jin, Yao Ma, Xiaorui Liu, Xianfeng Tang, Suhang Wang, and Jiliang Tang. Graph structure learning for robust graph neural networks. In Proceedings of the 26th ACM SIGKDD international conference on knowledge discovery & data mining, pages 66\u201374, 2020.   \n[12] Erlin Pan and Zhao Kang. Beyond homophily: Reconstructing structure for graph-agnostic clustering. In International Conference on Machine Learning, pages 26868\u201326877. PMLR, 2023.   \n[13] Jiong Zhu, Junchen Jin, Donald Loveland, Michael T Schaub, and Danai Koutra. How does heterophily impact the robustness of graph neural networks? theoretical connections and practical implications. In Proceedings of the 28th ACM SIGKDD Conference on Knowledge Discovery and Data Mining, pages 2637\u20132647, 2022.   \n[14] Bingheng Li, Erlin Pan, and Zhao Kang. Pc-conv: Unifying homophily and heterophily with two-fold filtering. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 38, pages 13437\u201313445, 2024.   \n[15] Daniel Z\u00fcgner, Oliver Borchert, Amir Akbarnejad, and Stephan G\u00fcnnemann. Adversarial attacks on graph neural networks: Perturbations and their patterns. ACM Transactions on Knowledge Discovery from Data (TKDD), 14(5):1\u201331, 2020.   \n[16] Zhixun Li, Xin Sun, Yifan Luo, Yanqiao Zhu, Dingshuo Chen, Yingtao Luo, Xiangxin Zhou, Qiang Liu, Shu Wu, Liang Wang, et al. Gslb: The graph structure learning benchmark. Advances in Neural Information Processing Systems, 36, 2023.   \n[17] Paul Pu Liang, Zihao Deng, Martin Q Ma, James Y Zou, Louis-Philippe Morency, and Ruslan Salakhutdinov. Factorized contrastive learning: Going beyond multi-view redundancy. Advances in Neural Information Processing Systems, 36, 2023.   \n[18] Seongjun Yun, Minbyul Jeong, Raehyun Kim, Jaewoo Kang, and Hyunwoo J Kim. Graph transformer networks. Advances in neural information processing systems, 32, 2019.   \n[19] Felix Wu, Amauri Souza, Tianyi Zhang, Christopher Fifty, Tao Yu, and Kilian Weinberger. Simplifying graph convolutional networks. In International conference on machine learning, pages 6861\u20136871. PMLR, 2019.   \n[20] Yixin Liu, Yu Zheng, Daokun Zhang, Hongxu Chen, Hao Peng, and Shirui Pan. Towards unsupervised deep graph structure learning. In Proceedings of the ACM Web Conference 2022, pages 1392\u20131403, 2022.   \n[21] Bahare Fatemi, Layla El Asri, and Seyed Mehran Kazemi. Slaps: Self-supervision improves structure learning for graph neural networks. Advances in Neural Information Processing Systems, 34:22667\u201322681, 2021.   \n[22] Thomas N Kipf and Max Welling. Semi-supervised classification with graph convolutional networks. In International Conference on Learning Representations, 2016.   \n[23] Christopher Tosh, Akshay Krishnamurthy, and Daniel Hsu. Contrastive learning, multi-view redundancy, and linear models. In Algorithmic Learning Theory, pages 1179\u20131206. PMLR, 2021.   \n[24] Yao-Hung Hubert Tsai, Yue Wu, Ruslan Salakhutdinov, and Louis-Philippe Morency. Selfsupervised learning from a multi-view perspective. In International Conference on Learning Representations, 2020.   \n[25] Thomas N Kipf and Max Welling. Variational graph auto-encoders. In Bayesian Deep Learning Workshop (NIPS), 2016.   \n[26] Shaohua Fan, Xiao Wang, Chuan Shi, Emiao Lu, Ken Lin, and Bai Wang. One2multi graph autoencoder for multi-view graph clustering. In proceedings of the web conference 2020, pages 3070\u20133076, 2020.   \n[27] Yawen Ling, Jianpeng Chen, Yazhou Ren, Xiaorong Pu, Jie Xu, Xiaofeng Zhu, and Lifang He. Dual label-guided graph refinement for multi-view graph clustering. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 37, pages 8791\u20138798, 2023.   \n[28] Haoqing Wang, Xun Guo, Zhi-Hong Deng, and Yan Lu. Rethinking minimal sufficient representation in contrastive learning. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 16041\u201316050, 2022.   \n[29] Jintang Li, Ruofan Wu, Wangbin Sun, Liang Chen, Sheng Tian, Liang Zhu, Changhua Meng, Zibin Zheng, and Weiqiang Wang. What\u2019s behind the mask: Understanding masked graph modeling for graph autoencoders. In Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data Mining, pages 1268\u20131279, 2023.   \n[30] Yonglong Tian, Chen Sun, Ben Poole, Dilip Krishnan, Cordelia Schmid, and Phillip Isola. What makes for good views for contrastive learning? Advances in neural information processing systems, 33:6827\u20136839, 2020.   \n[31] Chris J Maddison, Andriy Mnih, and Yee Whye Teh. The concrete distribution: A continuous relaxation of discrete random variables. In International Conference on Learning Representations, 2016.   \n[32] Eric Jang, Shixiang Gu, and Ben Poole. Categorical reparametrization with gumble-softmax. In International Conference on Learning Representations (ICLR 2017), 2017.   \n[33] Susheel Suresh, Pan Li, Cong Hao, and Jennifer Neville. Adversarial graph augmentation to improve graph contrastive learning. Advances in Neural Information Processing Systems, 34:15920\u201315933, 2021.   \n[34] Yixin Liu, Kaize Ding, Qinghua Lu, Fuyi Li, Leo Yu Zhang, and Shirui Pan. Towards selfinterpretable graph-level anomaly detection. Advances in Neural Information Processing Systems, 36, 2024.   \n[35] Yuanfu Lu, Chuan Shi, Linmei Hu, and Zhiyuan Liu. Relation structure-aware heterogeneous information network embedding. In Proceedings of the AAAI conference on artificial intelligence, volume 33, pages 4456\u20134463, 2019.   \n[36] Kuansan Wang, Zhihong Shen, Chiyuan Huang, Chieh-Han Wu, Yuxiao Dong, and Anshul Kanakia. Microsoft academic graph: When experts are not enough. Quantitative Science Studies, 1(1):396\u2013413, 2020.   \n[37] Petar Velic\u02c7kovic\u00b4, William Fedus, William L Hamilton, Pietro Li\u00f2, Yoshua Bengio, and R Devon Hjelm. Deep graph infomax. In International Conference on Learning Representations, 2018.   \n[38] Zhiping Lin, Zhao Kang, Lizong Zhang, and Ling Tian. Multi-view attributed graph clustering. IEEE Transactions on Knowledge & Data Engineering, 35(02):1872\u20131880, 2023.   \n[39] Erlin Pan and Zhao Kang. Multi-view contrastive graph clustering. Advances in neural information processing systems, 34:2148\u20132159, 2021.   \n[40] Meng Qu, Jian Tang, Jingbo Shang, Xiang Ren, Ming Zhang, and Jiawei Han. An attentionbased collaboration framework for multi-view network representation learning. In Proceedings of the 2017 ACM on Conference on Information and Knowledge Management, pages 1767\u2013 1776, 2017.   \n[41] Xiao Wang, Houye Ji, Chuan Shi, Bai Wang, Yanfang Ye, Peng Cui, and Philip S Yu. Heterogeneous graph attention network. In The world wide web conference, pages 2022\u20132032, 2019.   \n[42] Luca Franceschi, Mathias Niepert, Massimiliano Pontil, and Xiao He. Learning discrete structures for graph neural networks. In International conference on machine learning, pages 1972\u2013 1982. PMLR, 2019.   \n[43] Donghan Yu, Ruohong Zhang, Zhengbao Jiang, Yuexin Wu, and Yiming Yang. Graph-revised convolutional network. In Machine Learning and Knowledge Discovery in Databases: European Conference, ECML PKDD 2020, Ghent, Belgium, September 14\u201318, 2020, Proceedings, Part III, pages 378\u2013393. Springer, 2021.   \n[44] Yu Chen, Lingfei Wu, and Mohammed Zaki. Iterative deep graph learning for graph neural networks: Better and robust node embeddings. Advances in neural information processing systems, 33:19314\u201319326, 2020.   \n[45] Ruijia Wang, Shuai Mou, Xiao Wang, Wanpeng Xiao, Qi Ju, Chuan Shi, and Xing Xie. Graph structure estimation neural networks. In Proceedings of the web conference 2021, pages 342\u2013 353, 2021.   \n[46] Qitian Wu, Wentao Zhao, Zenan Li, David P Wipf, and Junchi Yan. Nodeformer: A scalable graph structure learning transformer for node classification. Advances in Neural Information Processing Systems, 35:27387\u201327401, 2022.   \n[47] Kuan Li, Yang Liu, Xiang Ao, Jianfeng Chi, Jinghua Feng, Hao Yang, and Qing He. Reliable representations make a stronger defender: Unsupervised structure refinement for robust gnn. In Proceedings of the 28th ACM SIGKDD Conference on Knowledge Discovery and Data Mining, pages 925\u2013935, 2022.   \n[48] Jianan Zhao, Qianlong Wen, Mingxuan Ju, Chuxu Zhang, and Yanfang Ye. Self-supervised graph structure refinement for graph neural networks. In Proceedings of the Sixteenth ACM International Conference on Web Search and Data Mining, pages 159\u2013167, 2023.   \n[49] Ylli Sadikaj, Justus Rass, Yllka Velaj, and Claudia Plant. Semi-supervised embedding of attributed multiplex networks. In Proceedings of the ACM Web Conference 2023, pages 578\u2013 587, 2023.   \n[50] Erlin Pan and Zhao Kang. High-order multi-view clustering for generic data. Information Fusion, 100:101947, 2023.   \n[51] Shima Khoshraftar and Aijun An. A survey on graph representation learning methods. ACM Transactions on Intelligent Systems and Technology, 15(1):1\u201355, 2024.   \n[52] Liang Liu, Zhao Kang, Jiajia Ruan, and Xixu He. Multilayer graph contrastive clustering network. Information Sciences, 613:256\u2013267, 2022.   \n[53] Liang Peng, Xin Wang, and Xiaofeng Zhu. Unsupervised multiplex graph learning with complementary and consistent information. In Proceedings of the 31st ACM International Conference on Multimedia, pages 454\u2013462, 2023.   \n[54] Cheng Yang, Deyu Bo, Jixi Liu, Yufei Peng, Boyu Chen, Haoran Dai, Ao Sun, Yue Yu, Yixin Xiao, Qi Zhang, et al. Data-centric graph learning: A survey. arXiv preprint arXiv:2310.04987, 2023.   \n[55] Jianan Zhao, Xiao Wang, Chuan Shi, Binbin Hu, Guojie Song, and Yanfang Ye. Heterogeneous graph structure learning for graph neural networks. In Proceedings of the AAAI conference on artificial intelligence, volume 35, pages 4697\u20134705, 2021.   \n[56] Ashish Jaiswal, Ashwin Ramesh Babu, Mohammad Zaki Zadeh, Debapriya Banerjee, and Fillia Makedon. A survey on contrastive self-supervised learning. Technologies, 9(1):2, 2020.   \n[57] Xinlei Chen and Kaiming He. Exploring simple siamese representation learning. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 15750\u2013 15758, 2021.   \n[58] Tianyu Gao, Xingcheng Yao, and Danqi Chen. Simcse: Simple contrastive learning of sentence embeddings. In 2021 Conference on Empirical Methods in Natural Language Processing, EMNLP 2021, pages 6894\u20136910. Association for Computational Linguistics (ACL), 2021.   \n[59] Steffen Schneider, Alexei Baevski, Ronan Collobert, and Michael Auli. wav2vec: Unsupervised pre-training for speech recognition. Interspeech 2019, 2019.   \n[60] Hassan Akbari, Liangzhe Yuan, Rui Qian, Wei-Hong Chuang, Shih-Fu Chang, Yin Cui, and Boqing Gong. Vatt: Transformers for multimodal self-supervised learning from raw video, audio and text. Advances in Neural Information Processing Systems, 34:24206\u201324221, 2021.   \n[61] Alec Radford, Jong Wook Kim, Chris Hallacy, Aditya Ramesh, Gabriel Goh, Sandhini Agarwal, Girish Sastry, Amanda Askell, Pamela Mishkin, Jack Clark, et al. Learning transferable visual models from natural language supervision. In International conference on machine learning, pages 8748\u20138763. PMLR, 2021.   \n[62] Yijie Lin, Yuanbiao Gou, Zitao Liu, Boyun Li, Jiancheng Lv, and Xi Peng. Completer: Incomplete multi-view clustering via contrastive prediction. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 11174\u201311183, 2021.   \n[63] Marco Federici, Anjan Dutta, Patrick Forr\u00e9, Nate Kushman, and Zeynep Akata. Learning robust representations via multi-view information bottleneck. In 8th International Conference on Learning Representations, 2020.   \n[64] Liangjian Wen, Yiji Zhou, Lirong He, Mingyuan Zhou, and Zenglin Xu. Mutual information gradient estimation for representation learning. In International Conference on Learning Representations, 2020.   \n[65] Liangjian Wen, Xiasi Wang, Jianzhuang Liu, and Zenglin Xu. Mveb: Self-supervised learning with multi-view entropy bottleneck. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2024.   \n[66] Yixin Liu, Ming Jin, Shirui Pan, Chuan Zhou, Yu Zheng, Feng Xia, and $\\textsf{S Y}\\mathbf{u}$ Philip. Graph self-supervised learning: A survey. IEEE Transactions on Knowledge and Data Engineering, 35(6):5879\u20135900, 2022.   \n[67] Tong Zhao, Yozen Liu, Leonardo Neves, Oliver Woodford, Meng Jiang, and Neil Shah. Data augmentation for graph neural networks. In Proceedings of the AAAI conference on artificial intelligence, volume 35, pages 11015\u201311023, 2021.   \n[68] Alessandro Achille and Stefano Soatto. Emergence of invariance and disentanglement in deep representations. Journal of Machine Learning Research, 19(50):1\u201334, 2018.   \n[69] Aseem Baranwal, Kimon Fountoulakis, and Aukosh Jagannath. Effects of graph convolutions in multi-layer networks. In The Eleventh International Conference on Learning Representations, 2022. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "", "page_idx": 14}, {"type": "table", "img_path": "xaqPAkJnAS/tmp/37b152b88776ee2cbde436002f06a0ee1dbc224bc04e21183c81052fcf624ab6.jpg", "table_caption": ["Table 4: Frequently used notations. "], "table_footnote": [], "page_idx": 15}, {"type": "text", "text": "B Related Work ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Unsupervised Multiplex Graph Learning (UMGL). Unlike supervised methods such as HAN [41] and SSAMN [49] which rely on label information, UMGL tackles unsupervised tasks in multiplex graphs by using node features and graph structures [50]. Early UMGL methods such as MvAGC [38] and MCGC [39] combine graph filtering with unsupervised techniques such as spectral and subspace clustering to uncover underlying patterns in complex networks. With the rise of deep representation learning [51], UMGL has embraced a new paradigm: Unsupervised learning of low-dimensional node representations using graph neural networks (GNN) [4] and self-supervised techniques [5] for downstream tasks such as node classification, node clustering, and similarity search. O2MAC [26] pioneered the use of GNNs in UMGL, selecting the most informative graph and reconstructing all graph structures to capture shared information. DMGI [2] and HDMI [8] maximize mutual information between local and global contexts, then fuse representations from different relations. MGCCN [52], MGDCR [9], and BTGF [10] employ various contrastive losses to align representations of diverse relations and prevent dimension collapse. CoCoMG [53] and DMG [3] capture complete information by learning consistency and complementarity between graphs. Despite these advances, a critical factor that limits the performance of UMGL is overlooked: the reliability of graph structures, which is the focus of our research. ", "page_idx": 15}, {"type": "text", "text": "Graph Structure Learning (GSL). With the advancement of graph neural networks, instead of designing complex neural architectures as model-centric approaches, some data-centric research has focused on the graph data itself [54], with graph structure learning (GSL) gaining widespread attention for studying the reliability of graph structures. GSL, based on empirical analysis of graph data, recognizes that real-world graph structures are often unreliable, thus opting to learn new structures. GSLB [16] summarizes the general framework of graph structure learning: a Graph Learner takes in the original graph $G\\;=\\;\\{A,X\\}$ and generates a refined graph $G^{s}\\,=\\,\\{A^{s},{\\bar{X}}\\}$ ; then, a Graph Encoder uses the refined graph to obtain node representations or perform class prediction. Consequently, GSL can be broadly categorized into supervised and unsupervised methods based on whether label information is utilized to learn the new structure. For supervised GSL, probabilistic models like LDS [42] and GEN [45] are employed to generate graph structures; GRCN [43], IDGL [44], and NodeFormer [46] calculate node similarities through metric learning or scalable attention mechanisms; while ProGNN [11] directly treats all elements in the adjacency matrix as learnable parameters. Meanwhile, methods like SUBLIME [20], STABLE [47], and GSR [48] introduce self-supervised signals through contrastive learning to learn graph structures without requiring label information. Almost all existing GSL studies concentrate on a single homogeneous graph, with only a handful of works such as GTN [18] and HGSL [55] attempting supervised structure learning on heterogeneous graphs containing multiple types of nodes. There is still a lack of research concerning more practically significant unsupervised graph structure learning within multiplex graphs. ", "page_idx": 15}, {"type": "text", "text": "", "page_idx": 16}, {"type": "text", "text": "Contrastive Learning and Information Theory. Contrastive learning, as an effective paradigm of self-supervised learning, enables representation learning without labeled information [56]. It has found widespread applications across various modalities [57\u201359], particularly effective in multiview or multi-modal tasks [60\u201362]. Its theoretical foundation is rooted in multi-view information theory [63, 30, 64]. Standard contrastive learning is based on the assumption of multi-view redundancy: shared information between views is almost exactly what is relevant for downstream tasks [17, 23, 24, 65]. They capture shared task-relevant information between views through contrastive pre-training, thus achieving data compression and sufficient representation learning. To successfully apply contrastive learning to multi-modal data with task-relevant unique information, some studies have improved the framework of contrastive learning and extended it to multi-view non-redundancy [17, 28]. Recent efforts also attempt to apply contrastive learning to graph learning tasks [66]. They generate contrastive views through graph data augmentation [67] or directly utilize different relations within graph data [39]. However, existing multi-view graph contrastive learning still suffers from the limitation of multi-view redundancy, failing to extract view-unique task-relevant information effectively. ", "page_idx": 16}, {"type": "text", "text": "C Algorithm and Methodology Details ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "C.1 Algorithm ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Algorithm 1: The optimization of InfoMGF-RA ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Input: Original graph structure $G=\\{G_{1},...,G_{V}\\}$ ; Number of nearest neighbors $k$ ; Random masking probability $\\rho$ ; Number of epochs $E$ ", "page_idx": 16}, {"type": "text", "text": "Output: Learned fused graph $G^{s}$ and node representations $Z$ Initialize parameters; ", "page_idx": 16}, {"type": "text", "text": "2 Obtain view-specific node features $\\{X^{1},\\cdot\\cdot\\cdot,X^{V}\\}$ by Eq.(1);   \n3 for $e=1,2,3,...,E$ do   \n4 for each view $v$ in $\\{1,\\cdot\\cdot\\cdot,V\\}$ do   \n5 Generate refined graph $G_{v}^{\\bar{s}}=\\{A_{v}^{s},X\\}$ with graph learner by Eq.(1) and   \npost-processors;   \n6 Generate augmented graph $G_{v}^{\\prime}=\\{A_{v}^{\\prime},X^{\\prime}\\}$ with random feature masking and edge   \ndropping;   \n7 end   \n8 Generate fused graph $G^{s}=\\{A^{s},X\\}$ with graph learner by Eq.(6) and post-processors;   \n9 Obtain node representations $\\{Z^{1},\\cdot\\cdot\\cdot,Z^{V},Z^{1^{\\prime}},\\cdot\\cdot\\cdot,Z^{V^{\\prime}},Z\\}$ through graph encoder GCN;   \n0 Calculate the total loss $\\mathcal{L}$ by Eq.(10) and update parameters in GCN and graph learners;   \n11 end ", "page_idx": 16}, {"type": "text", "text": "", "page_idx": 16}, {"type": "text", "text": "Input: Original graph structure $G=\\{G_{1},...,G_{V}\\}$ ; Number of nearest neighbors $k$ ; Feature masking probability $\\rho$ ; Hyper-parameter $\\lambda$ ; Number of epochs $E$ Output: Learned fused graph $G^{s}$ and node representations $Z$ 1 Initialize parameters; 2 Obtain view-specific node features $\\{X^{1},\\cdot\\cdot\\cdot,X^{V}\\}$ by Eq.(1); 3 for $e=1,2,3,...,E$ do // Step 1: Fix augmented graphs $\\left\\{G_{1}^{\\prime},\\cdot\\cdot\\cdot,G_{V}^{\\prime}\\right\\}$ 4 for each view $v$ in $\\{1,\\cdot\\cdot\\cdot,V\\}$ do 5 Generate refined graph $G_{v}^{\\bar{s}}=\\{A_{v}^{s},X\\}$ with graph learner by Eq.(1) and post-processors; 6 end 7 Generate fused graph $G^{s}=\\{A^{s},X\\}$ with graph learner by Eq.(6) and post-processors; 8 Obtain node representations $\\{Z^{1},\\cdot\\cdot\\cdot,Z^{V},Z^{1^{\\prime}},\\cdot\\cdot\\cdot,Z^{V^{\\prime}},Z\\}$ through graph encoder GCN; 9 Calculate the total loss $\\mathcal{L}$ by Eq.(10) and update parameters in GCN and graph learners; // Step 2: Fix refined graphs and fused graph $\\{G_{1}^{s},\\cdot\\cdot\\cdot,G_{V}^{s},G^{s}\\}$ 10 for each view $v$ in $\\{1,\\cdot\\cdot\\cdot,V\\}$ do 11 Generate augmented graph $G_{v}^{\\prime}=\\{A_{v}^{\\prime},X^{\\prime}\\}$ with random feature masking and augmented graph generator in Section 3.3 12 end 13 Obtain node representations $\\{Z^{1},\\cdot\\cdot\\cdot,Z^{V},Z^{1^{\\prime}},\\cdot\\cdot\\cdot,Z^{V^{\\prime}}\\}$ through graph encoder GCN; 14 Obtain reconstructed features $\\{\\hat{X}^{1},\\cdot\\cdot\\cdot,\\hat{X}^{V}\\}$ through decoder; 15 Calculate $\\mathcal{L}_{g e n}$ by Eq.(11) and update parameters in augmented graph generator and decoder; 16 end 17 return fused graph $G^{s}$ and node representations $Z$ ; ", "page_idx": 17}, {"type": "text", "text": "C.2 Complexity Analysis ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "First, we analyze the time complexity of each component in InfoMGF. In this paragraph, let $V,\\ N$ , and $m$ represent the numbers of graphs, nodes, and edges, while $b_{1}$ and $b_{2}$ denote the batch sizes of the locality-sensitive $k$ NN and contrastive loss computation. The layer numbers of graph learner, graph encoder GCN, and non-linear projector are denoted as $L_{1},\\ L_{2}$ , and $L_{3}$ , respectively. The feature, hidden layer, and representation dimensions are denoted as $d_{f},~d_{h}$ , and $d$ , respectively. We analyze the complexity of $k\\mathrm{NN}$ and GCN in scalable versions. Before training, scalable SGC is applied with a complexity of $\\mathcal{O}(V m r d_{f})$ related to the aggregation order $r$ . During training, we first perform a graph learner with scalable $k$ NN that requires $\\mathcal{O}(V N L_{1}d_{f}+V N\\bar{b}_{1}d_{f})$ . For the GCN encoder and non-linear projector, the total complexity is $\\mathcal{O}\\left(V m L_{2}\\dot{d}_{h}+V m d+V N L_{2}d_{h}^{2}+V N d_{h}(d+d_{f})+V N L_{3}d^{2}\\right)$ . Within the graph augmentation module, the complexity of feature masking is $O(N d_{f})$ . The learnable generative graph augmentation in InfoMGF-LA has a complexity of $\\mathcal{O}(V\\dot{N}d_{f}\\dot{d}_{h}+V m d_{h}+V\\dot{N}d_{f}d)$ , where the first two terms are contributed by the augmented graph generator and the last one is for the decoder. For InfoMGF-RA, the random edge drop requires $\\bar{\\mathcal{O}}(V m)$ time complexity. For the loss computation, the complexity is $O(V^{2}N b_{2}d)$ . ", "page_idx": 17}, {"type": "text", "text": "To simplify the overall complexity, we denote the larger terms within $L_{1},L_{2}$ , and $L_{3}$ as $L$ , the larger terms between $d_{h}$ and $d$ as $\\hat{d}.$ , the larger terms between $b_{1}$ and $b_{2}$ as $B$ . Since the scalable SGC operation only needs to be performed once before training, its impact on training time is negligible. Therefore, we only consider total complexity during the training process. The overall complexity of both InfoMGF-RA and InfoMGF-LA is $\\mathcal{O}(\\dot{V}m L\\hat{d}+V N L\\hat{d}^{2}+\\dot{V}N d_{f}(\\hat{d}+L)+V N B(\\dot{d_{f}}+\\dot{V}\\hat{d}))$ , which is comparable to the mainstream unsupervised GSL models, including our baselines. For example, SUBLIME [20] needs to be trained on each graph in a multiplex graph dataset, and its time complexity is $\\mathcal{O}(V m L\\hat{d}+V N L\\hat{d}^{2}+V N d_{f}(\\hat{d}+L)+V N B(d_{f}+\\hat{d}))$ , which only has a slight difference in the last term compared to the time complexity of our method. ", "page_idx": 17}, {"type": "text", "text": "C.3 Details of Post-processing Techniques ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "After constructing the cosine similarity matrix of $H^{v}$ , we employ the postprocessor to ensure that $A_{v}^{s}$ is sparse, nonnegative, symmetric and normalized. For convenience, we omit the subscript $v$ in the discussion below. ", "page_idx": 18}, {"type": "text", "text": "$k\\mathbf{N}\\mathbf{N}$ for sparsity. The fully connected adjacency matrix usually makes little sense for most applications and results in expensive computation cost. Hence, we conduct the $k$ -nearest neighbors $(k\\mathsf{N N})$ operation to sparsify the learned graph. We keep the edges with top- $k$ values and otherwise to 0 for each node and get the sparse adjacency matrix $A^{s p}$ . ", "page_idx": 18}, {"type": "text", "text": "Symmetrization and Activation. As real-world connections are often bidirectional, we make the adjacency matrix symmetric. Additionally, the weight of each edge should be non-negative. With the input $A^{s p}$ , they can be expressed as follows: ", "page_idx": 18}, {"type": "equation", "text": "$$\nA^{s y m}={\\frac{\\sigma(A^{s p})+\\sigma(A^{s p})^{\\top}}{2}}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where $\\sigma(\\cdot)$ is a non-linear activation implemented by the ReLU function. ", "page_idx": 18}, {"type": "text", "text": "Normalization. The normalized adjacency matrix with self-loop can be obtained as follows: ", "page_idx": 18}, {"type": "equation", "text": "$$\nA^{s}=(\\tilde{D}^{s y m})^{-\\frac{1}{2}}\\tilde{A}^{s y m}(\\tilde{D}^{s y m})^{-\\frac{1}{2}}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where $\\tilde{D}^{s y m}$ is the degree matrix of $\\tilde{A}^{s y m}$ with self-loop. Afterward, we can obtain the adjacency matrix $A_{v}^{s}$ for each view, which possesses the desirable properties of sparsity, non-negativity, symmetry, and normalization. ", "page_idx": 18}, {"type": "text", "text": "C.4 Details of Loss Functions ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "For each view $i$ and $j$ , the lower and upper bound of $I(Z^{i};Z^{j})$ in Eq.(8) and Eq.(9) can be calculated for the node $m$ : ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\ell_{l b}(Z_{m}^{i},Z_{m}^{j})=l o g\\frac{e^{s i m(\\tilde{Z}_{m}^{i},\\tilde{Z}_{m}^{j})/\\tau_{c}}}{\\sum_{n=1}^{N}e^{s i m(\\tilde{Z}_{m}^{i},\\tilde{Z}_{n}^{j})/\\tau_{c}}}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "equation", "text": "$$\n\\ell_{u b}(Z_{m}^{i},Z_{m}^{j})=s i m(\\tilde{Z}_{m}^{i},\\tilde{Z}_{m}^{j})/\\tau_{c}-\\frac{1}{N}\\sum_{n=1}^{N}s i m(\\tilde{Z}_{m}^{i},\\tilde{Z}_{n}^{j})/\\tau_{c},\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where ${\\tilde{Z}}_{m}^{i}$ is the non-linear projection of $Z_{m}^{i}$ through MLP, $s i m(\\cdot)$ refers to the cosine similarity and $\\tau_{c}$ is the temperature parameter in contrastive loss. The loss $\\mathcal{L}_{s}$ is computed as follows: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathcal{L}_{s}=-\\frac{1}{N V(V-1)}\\sum_{i=1}^{V}\\sum_{j=i+1}^{V}\\sum_{m=1}^{N}(\\ell_{l b}(Z_{m}^{i},Z_{m}^{j})+\\ell_{l b}(Z_{m}^{j},Z_{m}^{i})).\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Likewise, we can compute $\\mathcal{L}_{f}$ and $\\mathcal{L}_{u}$ in the total loss $\\mathcal{L}$ with the same approach. Upon optimizing $\\mathcal{L}$ , our objective also entails the minimization of $\\mathcal{L}_{g e n}$ , which incorporates $\\lambda*\\mathcal{L}_{u}$ (here we compute $\\mathcal{L}_{u}$ using the upper bound) and the loss term of the reconstruction. $\\mathcal{L}_{g e n}$ can be represented by: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathcal{L}_{g e n}=\\lambda*\\frac{1}{2N V}\\sum_{i=1}^{V}\\sum_{j=1}^{N}(\\ell_{u b}(Z_{j}^{i},Z_{j}^{i^{\\prime}})+\\ell_{u b}(Z_{j}^{i^{\\prime}},Z_{j}^{i}))+\\frac{1}{N V}\\sum_{i=1}^{V}\\sum_{j=1}^{N}\\left(1-\\frac{(X_{j}^{i})^{\\top}\\hat{X}_{j}^{i}}{\\|X_{j}^{i}\\|\\cdot\\|\\hat{X}_{j}^{i}\\|}\\right)\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "D Proofs of Theorems ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "D.1 Properties of multi-view mutual information and representations ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "In this section, we enumerate some basic properties of mutual information used to prove the theorems. For any random variables $x,y$ and $z$ , we have: ", "page_idx": 18}, {"type": "text", "text": "$(P_{1})$ Non-negativity: ", "page_idx": 18}, {"type": "equation", "text": "$$\nI(x;y)\\geq0,I(x;y|z)\\geq0\n$$", "text_format": "latex", "page_idx": 18}, {"type": "equation", "text": "$$\nI(x,y;z)=I(y;z)+I(x;z|y)\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "$(P_{3})$ ) Chain rule (Multivariate Mutual Information): ", "page_idx": 19}, {"type": "equation", "text": "$$\nI(x;y;z)=I(y;z)-I(y;z|x)\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "We also introduce the property of representation: ", "page_idx": 19}, {"type": "text", "text": "Lemma 1. [63, 68] If $z$ is a representation of $v$ , then: ", "page_idx": 19}, {"type": "equation", "text": "$$\nI(z;a|v,b)=0\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "for any variable (or groups of variables) a and $b$ in the system. Whenever a random variable $z$ is defined as a representation of $v$ , we state that $z$ is conditionally independent of any other variable in the system given $v$ . This does not imply that $z$ must be a deterministic function of $v$ , but rather that the source of $z$ \u2019s stochasticity is independent of the other random variables. ", "page_idx": 19}, {"type": "text", "text": "D.2 Proof of Proposition 1 ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Proof of Proposition $^{\\,l}$ : Due to each $G_{i}^{s}$ is obtained from $G_{i}$ through a deterministic function, which is independent of other variables. Thus, here $G_{i}^{s}$ can be regarded as a representation of $G_{i}$ . For any two different views $G_{i}$ and $G_{j}$ , we have: ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{I(G_{i}^{s};G_{j})\\overset{(P_{2})}{=}I(G_{i}^{s};G_{j}^{s},G_{j})-I(G_{i}^{s};G_{j}^{s}|G_{j})}\\\\ &{\\quad\\quad\\quad\\quad=\\ast I(G_{i}^{s};G_{j}^{s},G_{j})}\\\\ &{\\quad\\quad\\quad\\quad=I(G_{i}^{s};G_{j}^{s})+I(G_{i}^{s};G_{j}|G_{j}^{s})}\\\\ &{\\quad\\quad\\quad\\quad\\geq I(G_{i}^{s};G_{j}^{s})}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "where $^*$ follows from Lemma 1. The bound reported in this equation is tight when $I(G_{i}^{s};G_{\\underline{{{j}}}}|G_{j}^{s})=$ 0, this happens whenever $G_{j}^{s}$ contains all the information regarding $G_{i}^{s}$ (and therefore $G_{i}$ ). Symmetrically, we can also prove $I(G_{j}^{s};G_{i})\\geq I(G_{i}^{s};G_{j}^{s})$ , then we have ", "page_idx": 19}, {"type": "equation", "text": "$$\nI(G_{i}^{s};G_{j})+I(G_{j}^{s};G_{i})\\geq2I(G_{i}^{s};G_{j}^{s})\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Proposition 1 holds. ", "page_idx": 19}, {"type": "text", "text": "D.3 Proof of Theorem 1 ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Proof of Theorem 1. From the definition of optimal augmentation graph, we have ", "page_idx": 19}, {"type": "equation", "text": "$$\nI(G_{i}^{\\prime};G_{i})=I(Y;G_{i})\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Similar to the proof of Proposition 1, as $G_{i}^{s}$ is regarded as a representation of $G_{i}$ , therefore: ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r}{I(G_{i}^{s};Y|G_{i})=0}\\\\ {I(G_{i}^{s};G_{i}^{\\prime}|G_{i})=0}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Based on Eq.(24) and the above two equations, then ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{I(G_{i}^{s};G_{i}^{\\prime})=I(G_{i};G_{i}^{s};G_{i}^{\\prime})+I(G_{i}^{s};G_{i}^{\\prime}|G_{i})}\\\\ &{\\qquad\\qquad\\quad\\xrightarrow{E q.(26)}I(G_{i};G_{i}^{\\prime})-I(G_{i};G_{i}^{\\prime}|G_{i}^{s})}\\\\ &{\\qquad\\qquad\\quad\\xrightarrow{E q.(24)}I(G_{i};Y)-I(G_{i};Y|G_{i}^{s})}\\\\ &{\\qquad\\quad\\xrightarrow{(P_{3})}I(G_{i};Y;G_{i}^{s})}\\\\ &{\\qquad\\quad\\xrightarrow{E q.(25)}I(G_{i};Y;G_{i}^{s})+I(G_{i}^{s};Y|G_{i})}\\\\ &{\\qquad\\quad\\xrightarrow{(P_{3})}I(G_{i}^{s};Y)}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "It shows that maximizing $I(G_{i}^{s};G_{i}^{\\prime})$ and maximizing $I(G_{i}^{s};Y)$ are equivalent. Theorem 1 holds. ", "page_idx": 19}, {"type": "text", "text": "D.4 Proof of Theorem 2 ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Proof of Theorem 2. Here we theoretically compare $I(G_{i}^{s};G_{i})$ with $I(G_{i}^{s};G_{i}^{\\prime})$ . Discussion $^{\\,l}$ . For $I(G_{i}^{s};G_{i})$ , we have: ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{I(G_{i}^{s};G_{i})=I(G_{i};Y;G_{i}^{s})+I(G_{i}^{s};G_{i}|Y)}\\\\ &{\\qquad\\qquad=I(G_{i}^{s};Y)-I(G_{i}^{s};Y|G_{i})+I(G_{i}^{s};G_{i}|Y)}\\\\ &{\\qquad\\qquad=I(G_{i}^{s};Y)+I(G_{i}^{s};G_{i}|Y)}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "In the process of maximizing $I(G_{i}^{s};G_{i})$ , not only is task-relevant information (the first term) maximized, but task-irrelevant information (the second term) is also maximized. ", "page_idx": 20}, {"type": "text", "text": "Discussion 2. For $I(G_{i}^{s};G_{i}^{\\prime})$ , based on Theorem 1, we have: ", "page_idx": 20}, {"type": "equation", "text": "$$\nI(G_{i}^{s};G_{i}^{\\prime})=I(G_{i}^{s};Y)\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Obviously, no task-irrelevant information is maximized. Theorem 2 holds. ", "page_idx": 20}, {"type": "text", "text": "D.5 Proof of Theorem 3 ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Proof of Theorem 3. To prove the theorem, we need to use the following three properties of entropy: $\\left(H_{1}\\right)$ Relationship between the mutual information and entropy: ", "page_idx": 20}, {"type": "equation", "text": "$$\nI(x;y)=H(x)-H(x|y)\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "$(H_{2})$ Relationship between the conditional entropy and entropy: ", "page_idx": 20}, {"type": "equation", "text": "$$\nH(x|y)=H(x,y)-H(y)\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "$(H_{3})$ Relationship between the conditional mutual information and entropy: ", "page_idx": 20}, {"type": "equation", "text": "$$\nI(x;y|z)=H(x|z)-H(x|y,z)\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "By maximizing the mutual information with each refined graph, the optimized fused graph $G^{s}$ would contain all information from every $G_{i}^{s}$ . For any $G_{i}^{s}$ , we denote $G_{c}^{s}$ as the fused graph of all views except view $i$ . Thus we have: ", "page_idx": 20}, {"type": "equation", "text": "$$\nH(G^{s})=H(G_{i}^{s}|G_{c}^{s})+H(G_{c}^{s}|G_{i}^{s})+I(G_{i}^{s};G_{c}^{s})\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "where $H(G_{i}^{s}|G_{c}^{s})$ and $H(G_{c}^{s}|G_{i}^{s})$ indicate the specific information of $G_{c}^{s}$ and $G_{i}^{s}$ respectively, and $I(G_{i}^{s};G_{c}^{s})$ indicates the consistent information between $G_{c}^{s}$ and $G_{i}^{s}$ . ", "page_idx": 20}, {"type": "text", "text": "Then we have: ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{H(G^{s})=H(G_{i}^{s}|G_{c}^{s})+H(G_{c}^{s}|G_{i}^{s})+I(G_{i}^{s};G_{c}^{s})}\\\\ &{\\qquad\\overset{(H_{1})}{=}H(G_{i}^{s}|G_{c}^{s})+H(G_{c}^{s}|G_{i}^{s})+H(G_{i}^{s})-H(G_{i}^{s}|G_{c}^{s})}\\\\ &{\\qquad\\overset{(H_{2})}{=}H(G_{c}^{s}|G_{i}^{s})+H(G_{i}^{s},G_{c}^{s})-H(G_{c}^{s}|G_{i}^{s})}\\\\ &{\\qquad=H(G_{i}^{s},G_{c}^{s})}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Therefore, for any downstream task $Y$ , we further have: ", "page_idx": 20}, {"type": "equation", "text": "$$\nH(G^{s},Y)=H(G_{i}^{s},G_{c}^{s},Y).\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Based on the properties of mutual information and entropy, we can prove: ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{I(G^{s};Y)=H(G^{s})-H(G^{s}|Y)}\\\\ &{\\qquad\\qquad=H(G^{s})-H(G^{s},Y)+H(Y)}\\\\ &{\\qquad\\qquad\\overset{E q.(34)}{=}H(G_{c}^{s},G_{i}^{s})-H(G_{i}^{s},G_{c}^{s},Y)+H(Y)}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Based on the properties of entropy, we have the proofs as follows: ", "page_idx": 20}, {"type": "equation", "text": "$$\nI(G_{i}^{s};Y)=H(G_{i}^{s})-H(G_{i}^{s}|Y)\n$$", "text_format": "latex", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{I(G_{c}^{s};Y|G_{i}^{s})=H(G_{c}^{s}|G_{i}^{s})-H(G_{c}^{s}|G_{i}^{s},Y)}\\\\ &{\\qquad\\qquad\\qquad=H(G_{i}^{s},G_{c}^{s})-H(G_{i}^{s})-H(G_{c}^{s}|G_{i}^{s},Y)}\\end{array}\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "With the equations above, we can obtain ", "page_idx": 21}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{I(G_{i}^{s};Y)+I(G_{c}^{s};Y|G_{i}^{s})=H(G_{i}^{s})-H(G_{i}^{s}|Y)+H(G_{i}^{s},G_{c}^{s})-H(G_{i}^{s})-H(G_{c}^{s}|G_{i}^{s},Y)}\\\\ &{\\quad\\quad\\quad\\quad\\quad\\quad=H(G_{i}^{s},G_{c}^{s})-H(G_{i}^{s}|Y)-H(G_{c}^{s}|G_{i}^{s},Y)}\\\\ &{\\quad\\quad\\quad\\quad\\quad\\quad=H(G_{i}^{s},G_{c}^{s})-H(G_{i}^{s},Y)+H(Y)-H(G_{c}^{s}|G_{i}^{s},Y)}\\\\ &{\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad}\\\\ &{\\stackrel{(H_{2})}{=}H(G_{i}^{s},G_{c}^{s})-H(G_{i}^{s},Y)+H(Y)-H(G_{i}^{s},G_{c}^{s},Y)+H(G_{i}^{s},Y)}\\\\ &{\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad=H(G_{i}^{s},G_{c}^{s})+H(Y)-H(G_{i}^{s},G_{c}^{s},Y)}\\end{array}\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "According to Eq.(36) and Eq.(39), we have: ", "page_idx": 21}, {"type": "equation", "text": "$$\nI(G^{s};Y)=I(G_{i}^{s};Y)+I(G_{c}^{s};Y|G_{i}^{s}).\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "As $I(G_{c}^{s};Y|G_{i}^{s})\\geq0\\,(P_{1})$ , then we can get ", "page_idx": 21}, {"type": "equation", "text": "$$\nI(G^{s};Y)\\geq I(G_{i}^{s};Y).\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "Similarly, we can also obtain ", "page_idx": 21}, {"type": "equation", "text": "$$\nI(G^{s};Y)\\ge I(G_{c}^{s};Y).\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "As Eq.(41) holds for any $i$ , thus ", "page_idx": 21}, {"type": "equation", "text": "$$\nI(G^{s};Y)\\geq\\operatorname*{max}_{i}I(G_{i}^{s};Y).\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "Theorem 3 holds. ", "page_idx": 21}, {"type": "text", "text": "E Experimental Settings ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "E.1 Datasets ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "We consider 4 benchmark datasets in total. The statistics of the datasets are provided in Table 5. Through the value of \u201cUnique relevant edge ratio\u201d, we can observe a significant amount of viewunique task-relevant information present in each real-world multiplex graph dataset. It should be noted that MAG is a subset of OGBN-MAG [36], consisting of the four largest classes. This dataset was first organized into its current subset version in the following paper [1]. ", "page_idx": 21}, {"type": "table", "img_path": "xaqPAkJnAS/tmp/6b520d851d63b8556d4e254bce5451a1cbba854f554e43ccf0486f60ccc2cd12.jpg", "table_caption": ["Table 5: Statistics of datasets. "], "table_footnote": [], "page_idx": 21}, {"type": "text", "text": "E.2 Hyper-parameters Settings and Infrastructure ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "We implement all experiments on the platform with PyTorch 1.10.1 and DGL 0.9.1 using an Intel(R) Xeon(R) Platinum 8457C 20 vCPU and an L20 48GB GPU. We perform 5 runs of all experiments and report the average results. In the large MAG data set, InfoMGF-RA takes 80 minutes to complete 5 runs, whereas, on other datasets, both versions of InfoMGF require less than 5 minutes. ", "page_idx": 21}, {"type": "text", "text": "Our model is trained with the Adam optimizer, and Table 6 presents the hyper-parameter settings on all datasets. Here, $E$ represents the number of epochs for training, and $l r$ denotes the learning rate. The hidden-layer dimension $d_{h}$ and representation dimension $d$ of graph encoder GCN are tuned from $\\{32,64,128,256\\}$ . The number of neighbors $k$ for $k\\mathrm{NN}$ is searched from $\\{5,10,15,20,30\\}$ The order of graph aggregation $r$ and the number of layers $L$ in GCN are set to 2 or 3, aligning with the common layer count of GNN models [69]. The probability $\\rho$ of random feature masking is set to 0.5 or 0, and the temperature parameter $\\tau_{c}$ in contrastive loss is fixed at 0.2. For InfoMGF-RA using random graph augmentation, the probability $\\rho_{s}$ of random edge dropping is fixed at 0.5. For InfoMGF-LA with learnable generative graph augmentation, the generator\u2019s learning rate $l r_{g e n}$ is fixed at 0.001, the temperature parameter $\\tau$ in Gumbel-Max is set to 1, and the hyper-parameter $\\lambda$ controlling the minimization of mutual information is fine-tuned from $\\{0.001,0.01,0.1,1,10\\}$ . For the large dataset MAG, we compute the contrastive loss for estimating mutual information in batches, with a batch size of 2560. ", "page_idx": 21}, {"type": "table", "img_path": "xaqPAkJnAS/tmp/abfab5e691b03e7876af8d8f20d02edfec27a6e04569c75a3746d923f066568e.jpg", "table_caption": ["Table 6: Details of the hyper-parameters settings. "], "table_footnote": [], "page_idx": 22}, {"type": "text", "text": "", "page_idx": 22}, {"type": "text", "text": "F Additional Experiments ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "F.1 Sensitivity Analysis ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "We analyze the impact of two important hyper-parameters: the number of neighbors $k$ in $k\\mathrm{NN}$ and hyper-parameter $\\lambda$ controlling the influence of mutual information minimization to generate augmented graphs. The performance change of InfoMGF-LA with respect to $k$ is illustrated in Figure 6a. Overall, InfoMGF shows low sensitivity to changes in $k$ . The model achieves optimal performance when $k$ is set to 10 or 15. However, when $k$ is very small $(k=5)$ ), detrimental effects may arise, possibly due to the limited number of beneficial neighbors. As $k$ increases, the performance can still be maintained high. Figure 6b shows the results to $\\lambda$ from $\\{0.001,0.01,0.1,1,10\\}$ . Our proposed model shows low sensitivity to changes in $\\lambda$ in general, while the $\\lambda$ corresponding to achieving the best performance varies across different datasets. ", "page_idx": 22}, {"type": "text", "text": "F.2 Graph Visualization ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Figures 7 and 8, respectively, present the visualizations of the subgraph adjacency matrices of the original multiplex graphs and the learned fused graph $G^{s}$ on the DBLP and Yelp datasets. In DBLP, the two categories are machine learning (C1) and information retrieval (C2), while in Yelp, the categories are Mexican flavor (C1) and hamburger type (C2). It can be observed that $G^{s}$ not only removes the inter-class edges in the original structure but also retains key intra-class edges with weights, not just the shared edges. This further demonstrates the effectiveness of InfoMGF in eliminating task-irrelevant noise while preserving sufficient task-relevant information. ", "page_idx": 22}, {"type": "image", "img_path": "xaqPAkJnAS/tmp/852b0472dae04b3ee289b8ae6d300ce90b13e1aebbfed3f8795ce07576fd5da4.jpg", "img_caption": ["Figure 6: Additional experiments on sensitivity analysis. "], "img_footnote": [], "page_idx": 22}, {"type": "image", "img_path": "xaqPAkJnAS/tmp/bca194466d566c6044d0fb148d97dd2b769fda8fea05431912b2a89d14913d07.jpg", "img_caption": ["Figure 7: Heatmaps of the subgraph adjacency matrices of the original and learned graphs on DBLP. "], "img_footnote": [], "page_idx": 23}, {"type": "image", "img_path": "xaqPAkJnAS/tmp/cd30ae4beb72b26ec84448884cfe0d0186c658e74f3f7867c24f10a85aed035c.jpg", "img_caption": ["Figure 8: Heatmaps of the subgraph adjacency matrices of the original and learned graphs on Yelp. "], "img_footnote": [], "page_idx": 23}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: All our main works and contributions are included in the introduction part, Section 1. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 23}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Justification: The limitations of our work are discussed in Section 5. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper. \u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper. \u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be. ", "page_idx": 23}, {"type": "text", "text": "", "page_idx": 24}, {"type": "text", "text": "\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 24}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: Our assumptions, theorems, and their proofs are provided in Appendix D.   \nBesides, we properly reference the theorems which have been proven. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 24}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: All experimental setups and details of hyper-parameters are in Appendix E.2. Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 24}, {"type": "text", "text": "", "page_idx": 25}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Justification: The code and data of our research are released through a Github link, which can be found in our abstract. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so No is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 25}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: Experimental details and other supplements are summarized in Appendix E.2. Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 26}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: The experimental results with standard deviation for our method and baselines are presented in Table 2. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 26}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: The computer resources used in our experiments including compute workers, memory, and execution time are provided in Section E.2. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 26}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We have reviewed the NeurIPS Code of Ethics and ensure to preserve anonymity. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 27}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: A new problem on the reliability of real-world multiplex graph structures is proposed in our paper. The broader impacts of our work lie in the contributions to promote the development of the graph learning community, summarized in the introduction part. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 27}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 27}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 27}, {"type": "text", "text": "Justification: Our work poses no such risks, however, we still take this into account. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks. ", "page_idx": 27}, {"type": "text", "text": "\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 28}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: Only released datasets are used in our paper. We cite the original paper in the Section 4.1. ", "page_idx": 28}, {"type": "text", "text": "Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 28}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: Code for our model is provided through a Github link. Explanations for our research and code are provided in an explanatory document in the GitHub repository. ", "page_idx": 28}, {"type": "text", "text": "Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 28}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 28}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 29}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 29}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 29}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 29}]