[{"type": "text", "text": "BitDelta: Your Fine-Tune May Only Be Worth One Bit ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "James ${\\bf L i u^{1*}}$ Guangxuan Xiao1 Kai Li2 Jason D. Lee2 Song Han1,3 Tri Dao2,4 Tianle $\\mathbf{Cai^{2,4*}}$ ", "page_idx": 0}, {"type": "text", "text": "1MIT 2Princeton University 3NVIDIA 4Together AI ", "page_idx": 0}, {"type": "text", "text": "https://github.com/FasterDecoding/BitDelta ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Large Language Models (LLMs) are typically trained in two phases: pre-training on large internet-scale datasets, and fine-tuning for downstream tasks. Given the higher computational demand of pre-training, it is intuitive to assume that finetuning adds less new information to the model, and is thus more compressible. We explore this assumption by decomposing the weights of fine-tuned models into their pre-trained components and an additional delta. We introduce a simple postfine-tuning method, BitDelta, which successfully quantizes this delta down to 1 bit without compromising performance. This interesting finding not only highlights the potential redundancy of information added during fine-tuning, but also has significant implications for the multi-tenant serving and multi-tenant storage of fine-tuned models. By enabling the use of a single high-precision base model accompanied by multiple 1-bit deltas, BitDelta dramatically reduces GPU memory requirements by more than $10\\times$ , thus reducing per-user generation latency by more than $10\\times$ in multi-tenant settings. We validate BitDelta through experiments across Llama-2, Mistral and MPT model families, and on models up to 70B parameters, showcasing minimal performance degradation in all tested settings. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "After large-scale pretraining, foundation models are typically fine-tuned for specific downstream tasks [16, 43, 44]. This pretrain-finetune paradigm has revolutionized machine learning; LLMs have not only proven effective for critical tasks such as instruction following and alignment [39], but are also performant on a wide array of niche yet highly impactful applications [61, 42]. Through fine-tuning, LLMs are adeptly equipped to align with distinct user preferences or specialized task requirements, showcasing an unprecedented level of adaptability. Thus, the prospect of serving millions of uniquely fine-tuned models, each tailored to individual tasks and user needs, presents a promising vision for the future of machine learning. ", "page_idx": 0}, {"type": "text", "text": "Realizing this vision is challenging due to two key reasons: 1) Expensive Storage. Each new fine-tuned model is large, even if we have relatively few base models, making them expensive to store and challenging to manage on disk. 2) Expensive Serving. Distinct fine-tuned models each demand significant GPU memory, making it difficult and expensive to concurrently serve such models without noticeable downtime. To tackle these issues, we decompose the fine-tuned model weights into the weights of the base pre-trained model and a delta induced by the fine-tuning process. By compressing this delta while maintaining model performance, we aim to sidestep the prohibitive costs associated with storage and GPU memory demands. ", "page_idx": 0}, {"type": "text", "text": "From the delta decomposition point of view, parameter-efficient fine-tuning (PEFT) methods like LoRA [25, 24, 46, 15, 9] effectively enforce a highly structured and compressed form of delta during fine-tuning, a powerful insight for model serving of PEFT-based fine-tunes. Sheng et al. [49] and Chen et al. [7] explore multi-tenant serving of LoRA-based fine-tunes. ", "page_idx": 1}, {"type": "image", "img_path": "XuWWq3gy7W/tmp/bb45b5a221bf174ce1dc4a5de77a1d0c0ef0376a31c5eb22f66a962b44ddb11d.jpg", "img_caption": ["#params \u00d7 #models \u00d7 16bits\u2192#params \u00d7 (#models \u00d7 1bit + 16bits) "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "Figure 1: Overview of BitDelta. BitDelta applies 1-bit quantization to the weight delta between fine-tuned and base models. For each weight matrix, we quantize its delta as its sign bits and a trainable high-precision scale factor. The scale factor is initialized to achieve the best approximation error in $L_{2}$ norm and further refined with a few distillation steps. BitDelta shows minimal degradation in model performance and reduces memory consumption in multi-tenancy serving by representing multiple fine-tuned models with a single high-precision base model and multiple 1-bit deltas. ", "page_idx": 1}, {"type": "text", "text": "Nevertheless, recent work has shown that PEFT methods may not yet match the model quality of full parameter fine-tuning, especially on high resource tasks [6], and are fairly sensitive to hyperparameter choice and prompting methods [38]. Biderman et al. [2] show that LoRA\u2019s reduced expressivity, although providing desirable regularization, leads to significantly worse performance compared to full fine-tuning in math and programming tasks. As a result, we notice that among the 2307 LLMs (as of time of writing) on the Open LLM Leaderboard [1] with a valid README file, only $<20\\%$ indicate that they exclusively use LoRA. Most models are full parameter fine-tunes, model merges [64, 28, 59] of full parameter fine-tunes, or model merges of LoRA based fine-tunes (which are effectively high-rank). ", "page_idx": 1}, {"type": "text", "text": "It is also attractive to approximate general deltas with low-rank matrices post-training (in particular, post-fine-tuning). However, experimental results show that this is challenging (Table 1), as deltas from full parameter fine-tunes tend to be fairly high-rank (Figure 2). ", "page_idx": 1}, {"type": "text", "text": "We instead draw from the insight that motivates PEFT methods in general: Given the higher computational demand of pre-training, it is intuitive to assume that fine-tuning adds less new information to the model, and is thus much more compressible. In fact, we find that we can efficiently quantize the delta to merely 1 bit with almost no performance drop. We propose BitDelta, an efficient post-training quantization (PTQ) solution that acts on the weight delta between a finetuned model and its underlying base model. ", "page_idx": 1}, {"type": "image", "img_path": "XuWWq3gy7W/tmp/78887e5ed15a85250253f1846ab52dad2b078c522fa2ab7155e53e78adfa991a.jpg", "img_caption": ["Figure 2: Cumulative Explained Variance (CEV) plot of a $4096\\times4096$ weight delta between Llama $_{2-7B}$ and Vicuna- $7B\\ \\nu I.5$ . Deltas from full parameter fine-tuning are fairly high rank, making low-rank approximations difficult. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "BitDelta consists of two stages: 1) We quantize the delta between a fine-tuned model\u2019s weight matrix and base model\u2019s weight matrix into a scaling factor multiplied by a binary matrix. Specifically, we take the sign of the weight delta to form the binary matrix and initialize the scaling factor as the average of the absolute values of the delta, minimizing $L_{2}$ quantization error. 2) We further calibrate the scaling factors through model distillation over a small calibration dataset while keeping the binary matrices frozen. Despite the small number of trainable parameters and calibration steps, we find that this distillation process is effective in further recovering model quality. Our experiments over 17 popular fine-tuned models affirm that BitDelta can be applied across various model types and model sizes with minimal impact on performance. ", "page_idx": 1}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/813e9ac90c095eeaea859bb17866afde3d9d5f4bdc0f8e79e1f276d40be7cb67.jpg", "table_caption": ["Table 1: Comparison between BitDelta and a SVD based method, with Llama $_{2-7B}$ and Llama 2-7B Chat as the base and fine-tuned models. BitDelta is performant across the board, whereas the SVD-based method fails to sufficiently capture the fine-tuned information. "], "table_footnote": [], "page_idx": 2}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "BitDelta creates opportunities to efficiently serve multiple fine-tuned models with shared servers: By only storing a single full-precision base model, and (dynamically) loading and performing batched inference over multiple 1-bit deltas, we can efficiently represent multiple fine-tuned models. Compared to naively using full precision fine-tuned models, deltas compressed by BitDelta are more than $10\\times$ smaller, and can therefore be loaded faster. This addresses the storage challenge. Moreover, since LLM inference is memory-bound [32, 5, 3], the latency of each decoding step is proportional to the GPU memory consumption of the model weights. With an efficient CUDA kernel implementation, we can translate this memory reduction into a latency reduction, similar to other quantization methods [19, 33]. Using the $W_{I N T1}A_{F P16}$ kernel from BitBLAS [58], we improve the multi-tenant serving latency of full-parameter fine-tuned models by more than $10\\times$ . ", "page_idx": 2}, {"type": "text", "text": "Finally, we study a few extensions of BitDelta, where we quantize the base model and where we iteratively apply BitDelta. Experimental results show that our method is quite general and can be applied to various use cases. ", "page_idx": 2}, {"type": "text", "text": "2 Related Work ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "2.1 Full Model Compression ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Quantization. Quantization techniques are widely used to reduce memory consumption and improve LLMs\u2019 generation latency. Xiao et al. [60] implement a technique that rescales between activations and parameters, effectively mitigating outlier activations to facilitate smoother quantization. Dettmers et al. [14] develop an approach that decomposes matrix multiplications into 8-bit computations, with an additional 16-bit process for handling outliers. Exploring further, Frantar et al. [19] introduce a method that iteratively rounds weight columns to 3-4 bits of precision. Similarly, Lin et al. [33] propose an activation-aware quantization scheme that selectively preserves crucial weights while compressing the majority to 3-4 bits. Kim et al. [29] devise a sparse, low-precision pattern focusing on a small yet significant set of weights. Chee et al. [4] utilize incoherence processing to quantize model weights to as low as 2 bits with minimal impact on performance. ", "page_idx": 2}, {"type": "text", "text": "Pruning. Pruning also aims to reduce the memory consumption of neural networks. It accomplishes this by pushing certain parameter values to zero, inducing sparsity in the model [31, 21, 22, 67]. However, these methods may fail to take advantage of modern hardware like GPUs unless using certain structured sparsity patterns like 2:4 $(50\\%)$ sparsity [36]. Frantar and Alistarh [18] demonstrate a pruning method on LLMs that successfully utilizes the 2:4 sparsity pattern and achieves a $50\\%$ sparsity ratio. It is challenging to obtain higher sparsity while being hardware-friendly. ", "page_idx": 2}, {"type": "text", "text": "", "page_idx": 3}, {"type": "text", "text": "Early work on post-training delta compression. Most related to our work, a few studies explore the idea of post-training delta compression by adopting existing compression techniques like GPTQ, unstructured pruning [22], or even classic lossless compression algorithms. Isik et al. [26] focus on reducing the delta size to save storage. Yu et al. [64] utilize pruning to improve model merging applications. Yadav et al. [62] reduces the size of PEFT modules to save storage. Ryu et al. [47] combines quantization with a low-rank approximation to reduce the delta size. The concurrent and independent work by Yao and Klimovic [63] also explores using delta compression to improve multitenant serving, but focuses more on reducing the model loading time from disk to GPU. Compared to existing work, we offer a much simpler and faster method, BitDelta, achieving a compression ratio of more than $10\\times$ while also being friendly to modern accelerators. ", "page_idx": 3}, {"type": "text", "text": "3 BitDelta ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "3.1 Method ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "BitDelta consists of two stages: 1) We quantize each weight matrix into a scalar multiplied by a binary matrix\u2020. 2) We further calibrate the scalar factors using model distillation. We describe each stage in this section: ", "page_idx": 3}, {"type": "text", "text": "1-bit quantization. Let $W_{\\mathrm{base}}$ , $W_{\\mathrm{fine}}\\in\\mathbb{R}^{n\\times m}$ be weight matrices from the base model and finetuned model respectively. We define the weight delta as $\\Delta\\,=\\,W_{\\mathrm{fine}}\\,-\\,W_{\\mathrm{base}}$ , representing the modification in weights post-fine-tuning. For efficient representation of this weight delta, we aim to obtain a binarized estimator by encoding its sign bits, denoted as $\\hat{\\Delta}$ : ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\hat{\\Delta}=\\alpha\\odot\\mathrm{Sign}(\\Delta),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathrm{Sign}(W_{i j})=\\left\\{\\begin{array}{l l}{+1,}&{\\mathrm{if}\\ W_{i j}>0,}\\\\ {-1,}&{\\mathrm{if}\\ W_{i j}\\le0,}\\end{array}\\right.\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "and $\\alpha$ is a high-precision scaling factor for the entire matrix. To minimize the quantization error of $\\Delta$ in $L_{2}$ norm: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\left\\|\\Delta-\\hat{\\Delta}\\right\\|_{2}^{2}=\\sum_{i j}(|W_{i j}|-\\alpha)^{2},\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "we initialize $\\alpha$ as follows: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\alpha=\\frac{1}{n m}\\sum_{i j}|\\Delta_{i j}|.\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Surprisingly, we find that the above quantization approach already does quite well and retains most of the fine-tuned models\u2019 performance. ", "page_idx": 3}, {"type": "text", "text": "Scale distillation. The scaling factor $\\alpha$ intuitively plays a more significant role in the low-bit regime. Additionally, per-matrix $L_{2}$ weight error is not a perfect measure of degradation in overall model quality. We further optimize these scales by performing model distillation to align the output logits of the quantized model to that of the original fine-tuned model. More concretely, we freeze the model weights and optimize for the following objective: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\alpha^{*}=\\arg\\operatorname*{min}_{\\alpha}\\mathbb{E}_{x\\sim{\\bf X}}\\left[\\|{\\bf Z}_{\\mathrm{fine}}(x)-{\\bf Z}_{\\mathrm{bin}}(x;\\alpha)\\|^{2}\\right]\n$$", "text_format": "latex", "page_idx": 3}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/55f2f50d9428c62c517e19bb92c9c42114f1ee2d8e83e8efefd5cc152684a4c7.jpg", "table_caption": ["Table 2: BitDelta works on Llama-2 and Mistral families and on a wide range of model sizes ranging from 7B to 70B parameters. BitDelta works for many types of fine-tuned information, including SFT-based methods, RLHF-based methods, and context extension methods (RoPE scaling). Scale distillation is effective, raising TruthfulQA/GSM8K scores to within 1-2 points of the baseline fine-tune, and MT-Bench scores to within 0.1-0.2 points. "], "table_footnote": [], "page_idx": 4}, {"type": "text", "text": "where X is a calibration dataset, and $\\mathbf{Z}(\\cdot)$ are the logits of the respective models. Scale distillation is fairly robust to choice $\\mathbf{X}$ , as 1) the process is extremely parameter efficient, and 2) the crucial aspect of the process is to logit match with the fine-tuned model, regardless of the actual text content. ", "page_idx": 4}, {"type": "text", "text": "For our experiments, we distill on the C4 dataset [45], consisting of generic internet data, using 800 samples of length 128. We use the same subset of C4 over all models to control for seed-based variations. We use the Adam optimizer [30] with $l r=10^{-4}$ , $\\beta=(0.9,0.999)$ , $\\epsilon=10^{-8}$ . 1x80 GB A100 GPU is used to distill 7B and 13B models, and 6x80GB A100 GPUs are used to distill 70B models (2x for finetune, 4x for binarized). Scale distillation is fast; we can compress 70B models in roughly 10 minutes. ", "page_idx": 4}, {"type": "text", "text": "3.2 Methodology Cost ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "Compared to full parameter and parameter efficient fine-tuning methods, BitDelta is extremely cheap. While fine-tuning methods require training thousands to millions of parameters, BitDelta only necessitates training a single parameter per weight matrix. Moreover, BitDelta operates efficiently with input sequences of length 128, unlike fine-tuning methods that demand longer sequences to saturate the context window (4k, 8k, etc.). Crucially, BitDelta requires only 200 training steps (assuming a batch size of 4), which is significantly less compared to the 10000-1000000 steps at higher batch sizes needed by fine-tuning methods. Thus, in terms of methodology cost, we liken BitDelta more to post-training quantization (PTQ) schemes like GPTQ [19] and AWQ [33], rather than full parameter or parameter efficient fine-tuning, while being faster than most PTQ schemes. ", "page_idx": 4}, {"type": "text", "text": "3.3 Implication ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "The ability to compress the delta to merely 1-bit opens up multiple opportunities for improving efficiency, enabling more effective model storage [26] \u2013 where a single base model can be maintained alongside multiple compressed deltas \u2013 and facilitating model hot-swapping [7, 49]. With hotswapping, the base model remains in GPU memory, and compressed deltas are dynamically loaded in accordance to incoming requests. In both cases, the compression ratio can be directly translated into reductions in storage needs and loading times. ", "page_idx": 4}, {"type": "text", "text": "Moreover, BitDelta enables the possibility of a multi-tenant serving system like Punica [7] or SLoRA [49] but for general fine-tuned models instead of just LoRA models. Concretely, we consider the scenario where multiple models fine-tuned from the same base model are served with the same server. This setting greatly exploits the GPU resource and saves each fine-tuned model\u2019s inference cost when their traffic is low or unbalanced. With BitDelta, we can keep one high-precision base model with multiple compressed deltas in the GPU memory. Compared to directly serving multiple fine-tuned models, this approach greatly saves memory consumption. ", "page_idx": 4}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/1d6b89b732af2b0f372821ba88625efc5792f843c319cafb6ccc79db4f02b96a.jpg", "table_caption": ["Table 3: Continuation of Table 2. "], "table_footnote": [], "page_idx": 5}, {"type": "text", "text": "", "page_idx": 5}, {"type": "text", "text": "Since LLM inference follows the memory-bound computation pattern where the generation latency is proportional to the GPU memory used by the model weights, the lower memory consumption also suggests the opportunity to improve the serving latency. For example, Punica and S-LoRA exploit LoRA\u2019s structure and memory saving by computing the activation product between the shared base weight, and low-rank fine-tuned delta weights separately. Similarly, we decompose the forward pass of each linear layer as follows: ", "page_idx": 5}, {"type": "equation", "text": "$$\nX_{i}^{\\prime}=W_{\\mathrm{fine},i}X_{i}\\approx W_{\\mathrm{base}}X_{i}+\\underbrace{\\hat{\\Delta}_{i}X_{i}}_{\\mathrm{Kernel}}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $X_{i}$ and $X_{i}^{\\prime}$ represent input and output features to the $i$ -th fine-tuned model, and the base model weight and the 1-bit delta are computed separately. For a batch of requests, $W_{\\mathrm{base}}X_{i}$ can be computed with the classic batched GEMM kernel. We utilize the BitBLAS [58] $W_{I N T1}A_{F P16}$ kernel that allows us to calculate $\\hat{\\Delta}_{i}X$ in a batched setting while keeping the 1-bit deltas quantized until they are transferred to the GPU cache. This kernel fuses the dequantization operation with the GEMM calculation, reducing the data moving overhead by a large factor. ", "page_idx": 5}, {"type": "text", "text": "4 Experiments ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "4.1 Setup", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Baselines. Our primary baselines are the original fine-tuned models without compression. We also compare with 8-bit RTN, 4-bit GPTQ [19], and 2-bit QuIP# [54] on evaluations where we run BitDelta on quantized base models. ", "page_idx": 5}, {"type": "text", "text": "Models and datasets. We benchmark fine-tuned models based on the Llama-2 [53], Mistral [27], and MPT [51] model families: Vicuna, Xwin-LM, Solar-70B, Zephyr, OpenChat 3.5, Dolphin 2.2.1, and OpenOrca [10, 52, 56, 55, 57, 23, 37]. We evaluate on eight tasks: MT-Bench, 25-shot ARC Challenge, 5-shot BBH, 10-shot HellaSwag, zero-shot TruthfulQA, zero-shot LAMBADA, zero-shot ", "page_idx": 5}, {"type": "text", "text": "Table 4: Comparison of model responses from Zephyr-7B- $\\beta$ for Question 9 in MT-Bench, a concise advertisement task. BitDelta-Initial is unable to follow the instructions, producing an advertisement that is overly formal and makes no attempt to adhere to the word limit. With the addition of scale distillation, BitDelta successfully produces a concise, catchy advertisement slightly over the word limit. \\*Prompt slightly modified for clarity. ", "page_idx": 6}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/272b3b1562c46618c7453e8e4984b96aa3c853fa39f7c7c823d4edb747f11cc4.jpg", "table_caption": [], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "Winogrande, and 5-shot GSM8K [66, 12, 50, 65, 34, 40, 48, 13]. We use FastChat [66] to evaluate on MT-Bench, and use lm-evaluation-harness [20] to evaluate on the other tasks. We denote our methodology before scale distillation is applied as BitDelta-Initial. ", "page_idx": 6}, {"type": "text", "text": "We primarily focus on high-margin metrics where fine-tuning is significantly impactful and aggregate the other metrics. See Tables 7 to 10 in the Appendix for full results. BitDelta performs quite well on the aggregated metrics, even outperforming the baseline in many cases. However, it\u2019s important to contextualize these results with regard to the base model itself, which is also performant on these metrics. It\u2019s difficult to attribute performance to our methodology or to the underlying base model in such cases. Because of this, we highlight TruthfulQA, GSM8K, and MT-Bench, which base models tend to struggle on, to show that BitDelta accurately preserves fine-tune information. ", "page_idx": 6}, {"type": "text", "text": "4.2 Accurate Quantization ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "SVD comparison. We compare BitDelta to a low rank approx. of the weight delta on Vicuna$7B\\,\\nu I.5$ . For the low rank approx., we decompose $\\Delta\\,=\\,U\\Sigma V$ and approximate $\\hat{\\Delta}\\,=\\,A B$ where $A=U\\sqrt{\\hat{\\Sigma}}$ , $B=\\bar{\\sqrt\\Sigma}V$ . During distillation, we treat all entries of the low rank matrices as trainable parameters. We compare against two settings: $r\\,=\\,16$ (most commonly used) and $r\\,=\\,128$ (memory equivalence with BitDelta). We find that the low rank approx. fails to fully capture the fine tune information, and ", "page_idx": 6}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/a18dc4b0b0a13b72cd6a23502dbc529b18b67cf6dcbbeb9680623eb9442266ed.jpg", "table_caption": ["Table 5: BitDelta achieves over $10\\times$ compression. We can further compress the embedding and LM head layers, but leave this to future work due to inconsistencies in tokenizer vocabularies. "], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "underperforms across the board (Table 1). In particular, the low rank approx. heavily underperforms on MT-Bench [10], a difficult multi-turn instruction following dataset fairly indicative of real world performance. Interestingly, distillation is not as effective for the low rank approx. compared to BitDelta. ", "page_idx": 6}, {"type": "text", "text": "Main Results. BitDelta is performant across various model families, across a wide range of model sizes, and across many fine-tuning techniques. We benchmark on Llama-2, Mistral, and MPT, families, and on models ranging from 7B to 70B parameters. Shown in Table 2, we find that BitDelta is very general and can recover all types of finetune information, including SFT-based methods [43] on Mistral-7B v0.1 Instruct, RLHF-based methods [11] on Llama 2 Chat, and context extension methods (RoPE scaling) [8, 41] on Vicuna-7B v1.5 16k. ", "page_idx": 6}, {"type": "text", "text": "We note that GSM8K for BitDelta-Initial on Mistral- $7B\\;\\nu O.I$ Instruct and Zephyr-7B- $\\cdot\\beta$ is abnormally high; we attribute this to how performant the base model Mistral- $7B\\,\\nu O.I$ is on this task in comparison. Scale distillation is effective, raising TruthfulQA and GSM8K scores to within 1-2 points of the baseline fine-tune, and generally raising MT-Bench scores to within 0.1-0.2 points. ", "page_idx": 6}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/3b056b4c6c63d55f795f1f43e61897de4e835b96b3be91b2abe5b309b11c2b61.jpg", "table_caption": ["Table 6: We apply BitDelta to Llama 2-7B Chat (with corresponding base model Llama 2-7B), and find it holds up when the underlying base model is quantized at various levels. "], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "Case Study. We present a sample response from Zephyr-7B- $\\beta$ in Table 4, highlighting the efficacy of scale distillation. BitDelta-Initial does not have a casual tone, and makes no attempt to adhere to the word limit. With the introduction of scale distillation, BitDelta exhibits greater instruction following capabilities, producing a catchy response that slightly exceeds the word limit. ", "page_idx": 7}, {"type": "text", "text": "Quantized base models. Because 8-bit RTN, GPTQ, and QuIP# work with 16-bit activations, we can keep the fine-tune weights $W_{\\mathrm{fine}}$ and scaling factors $\\alpha$ in high precision in the compression process, only quantizing the base weights $W_{\\mathrm{base}}$ . As shown in Table 6, we find that BitDelta is still performant when applied to quantized base models. ", "page_idx": 7}, {"type": "text", "text": "Ablation over fidelity of $\\Delta$ . By successively applying BitDelta, treating the compressed model from the previous iteration as our base model, we can vary the granularity over the delta, associating it with multiple 1-bit masks. One advantage of doing this is the ability to assign arbitrary scale factors to each 1-bit mask. In contrast, when increasing the bit size, scale factors are implicitly fixed with respect to each other. Figure 3 shows how the TruthfulQA of Llama 2-7B plus an increasingly granular delta approaches that of Vicuna-7B v1.5. Full results are in Table 9. ", "page_idx": 7}, {"type": "text", "text": "4.3 Latency Improvement ", "text_level": 1, "page_idx": 7}, {"type": "image", "img_path": "XuWWq3gy7W/tmp/b2e4a6c545a42972270797a569a1999dbcad5a89fd4aa0522e6e7e764f94d025.jpg", "img_caption": ["Figure 3: As the fidelity of $\\Delta$ increases, the TruthfulQA scores of Llama $2{-}7B+\\Delta$ approaches that of Vicuna- $7B\\,\\nu I.5$ . "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "For simplicity, we consider the setting where each model receives one distinct request simultaneously. It would be insightful to develop more sophisticated serving systems, which we leave to future work. Following the decomposition in Eq. (6), the $W_{I N T1}A_{F P16}$ kernel is used to compute the batched matrix multiplication between $B$ binary matrices $(N\\times M)$ and $B$ high-precision activations $(L\\times N)$ where $N,M$ are intermediate dimensions and $L$ is the sequence length. We focus on decoding latency which dominates runtime, as opposed to prefill latency. Tokens are generated one by one when decoding, meaning $L$ is always 1. For all latency experiments we use a single A100 80GB with power limit set to 500W. ", "page_idx": 7}, {"type": "text", "text": "Kernel latency. We benchmark the decoding latency of our kernel, a batched linear operation over multiple 1-bit deltas, corresponding to the delta component of Eq. (6). We compare this to the S-LoRA kernel, a batched linear operation over multiple low-rank deltas, and also compare this to the base weight backbone shared over all deltas. We set $r=128$ for S-LoRA, to maintain memory equivalence with BitDelta at $N=M=4096$ . ", "page_idx": 7}, {"type": "text", "text": "We proflie the latency of the backbone $(W_{\\mathrm{base}}X)$ and deltas $(\\Delta X)$ separately. Although $X$ \u2019s memory footprint scales with batch size, it is negligible compared to $W_{\\mathrm{base}}$ , which remains constant. For typical low to medium batch settings, which is typical for $B\\times N\\ll N\\times M$ . In such settings, the overall memory footprint of the backbone is effectively independent of batch size, as shown in Figure 4 (left). This is in contrast with that of the deltas, which scales with the batch size, as each additional client in the batch adds an additional delta. At batch size 1 (Figure 4, right), backbone latency dominates over delta latency (BitDelta and S-LoRA) due to $W_{\\mathrm{base}}$ \u2019s $16\\times$ larger memory footprint compared to a single delta. As the batch size increases (Figure 4, left), the combined memory footprint of multiple deltas exceeds $W_{\\mathrm{base}}$ around $B=6$ to $B=8$ . ", "page_idx": 7}, {"type": "image", "img_path": "XuWWq3gy7W/tmp/202ba4135e02402d2f8ddf52b19be827cb74e46e7849a38145d70bb3c368b1f9.jpg", "img_caption": ["Figure 4: Decoding latency of a linear layer, as in Eqn. 6. Black: Shared base weight backbone $W_{\\mathrm{base}}X$ . Blue: Batched activation-product with $B$ 1-bit deltas, as in BitDelta. Red: Batched activation-product with $B$ low-rank deltas, as in S-LoRA. Left: Ablation over hidden size, assuming $N=M$ and $B=1$ . Right: Ablation over batch size, assuming $N=M=4096$ . "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "BitDelta underperforms slightly compared to S-LoRA in large-batch settings as the LoRA kernel is highly optimized for GPU. We emphasize that closing or even surpassing the gap is tractable. For example, Ma et al. [35] point out that $W_{I N T1}A_{F P16}$ requires no multiplication operations and that new hardware can be co-designed with this in mind to drastically reduce energy/latency costs. ", "page_idx": 8}, {"type": "image", "img_path": "XuWWq3gy7W/tmp/096f67a9e323cc2a6f91ee1e712d82fc47a3b66e3025b23c0789cc519c59d66c.jpg", "img_caption": ["Figure 5: Memory usage of Llama $_{2-7B}$ , assuming each sequence in the batch has a length of 128. Blue: Memory usage of the naive method, separately storing $B$ distinct fine-tuned models. Orange: Projected values for the naive method. Green: Memory usage of BitDelta. The naive forward pass succumbs to GPU memory issues at higher batch sizes. "], "img_footnote": [], "page_idx": 8}, {"type": "image", "img_path": "XuWWq3gy7W/tmp/06f24598d652342b61a91ae1486ddfcea1e1f8b4dd32a9193f76e0587777bdf9.jpg", "img_caption": ["Figure 6: End-to-end decoding latency of Llama $_{2-7B}$ . Blue: Naive forward pass with $B$ distinct fine-tuned models. Orange: Projected values for the naive forward pass. Green: Batched forward pass with BitDelta. Gray: Batched forward pass with S-LoRA. The naive forward pass succumbs to GPU memory issues at higher batch sizes. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "End-to-end latency. We benchmark the end-to-end decoding latency on Llama 2-7B variants with an input length of 128 (we find the decoding latency is less sensitive to the input length), ablated across batch size. For BitDelta and S-LoRA, the forward pass consists of the addition of two components: a single backbone pass (batch independent) and a delta pass (scales with batch size). ", "page_idx": 8}, {"type": "text", "text": "We compare BitDelta and S-LoRA with a naive method that computes each $W_{i}X_{i}$ separately in the forward pass. This naive approach scales poorly with batch size as it effectively maintains a separate backbone $(W_{i})$ for each client in the batch. Given the substantial memory footprint of the backbone, this leads to significant memory usage as batch size increases. In contrast, BitDelta and S-LoRA share a single backbone across all clients in the batch, with only the $16\\times$ smaller deltas scaling with batch size. This allows for more efficient memory utilization and better performance at larger batch sizes. ", "page_idx": 8}, {"type": "text", "text": "We find that BitDelta and S-LoRA introduce overhead when the batch size is low. However, BitDelta and S-LoRA scale better and successfully translate the saved GPU memory to improved decoding latency, starting at $B\\,=\\,2$ . This is exacerbated at larger batch sizes, where the naive approach succumbs to out-of-memory issues and BitDelta and S-LoRA are still performant. In the $B\\geq16$ regime, used in modern serving solutions, BitDelta has a ${>}10\\,\\times$ lower per-user decoding latency than the naive method. ", "page_idx": 9}, {"type": "text", "text": "5 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We propose BitDelta, a simple but effective approach to efficiently quantifyings the weight delta arising from the fine-tuning of LLMs down to 1 bit. BitDelta encodes the sign bits of the weight delta and a per-weight matrix scaling factor, which is calibrated further through distillation. This allows for representing multiple full-parameter fine-tuned models with one base model and multiple 1-bit deltas, enhancing applications in multi-tenancy serving by reducing GPU memory requirements and improving generation latency. BitDelta is fast and accurate, showcasing minimal performance degradation, and opens new avenues for efficient model deployment and resource utilization in machine learning. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgments and Disclosure of Funding ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We thank Together AI, MyShell AI, National Science Foundation (NSF), MIT-IBM Watson AI Lab, MIT AI Hardware Program, and MIT Amazon Science Hub for supporting this research. JDL acknowledges support of NSF CCF 2002272, NSF IIS 2107304, NSF CIF 2212262, ONR Young Investigator Award, and NSF CAREER Award 214494. KL acknowledges the support from Meta, DataX grant from Princeton University\u2019s Center for Statistics and Machine Learning, and innovation grant from Princeton\u2019s School of Engineering and Applied Science. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Edward Beeching, Cl\u00e9mentine Fourrier, Nathan Habib, Sheon Han, Nathan Lambert, Nazneen Rajani, Omar Sanseviero, Lewis Tunstall, and Thomas Wolf. Open llm leaderboard. https: //huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard, 2023.   \n[2] Dan Biderman, Jose Gonzalez Ortiz, Jacob Portes, Mansheej Paul, Philip Greengard, Connor Jennings, Daniel King, Sam Havens, Vitaliy Chiley, Jonathan Frankle, Cody Blakeney, and John P. Cunningham. Lora learns less and forgets less, 2024.   \n[3] Tianle Cai, Yuhong Li, Zhengyang Geng, Hongwu Peng, Jason D. Lee, Deming Chen, and Tri Dao. Medusa: Simple llm inference acceleration framework with multiple decoding heads. arXiv preprint arXiv: 2401.10774, 2024.   \n[4] Jerry Chee, Yaohui Cai, Volodymyr Kuleshov, and Christopher De Sa. Quip: 2-bit quantization of large language models with guarantees. arXiv preprint arXiv:2307.13304, 2023.   \n[5] Charlie Chen, Sebastian Borgeaud, Geoffrey Irving, Jean-Baptiste Lespiau, Laurent Sifre, and John Jumper. Accelerating large language model decoding with speculative sampling. February 2023. doi: 10.48550/ARXIV.2302.01318.   \n[6] Guanzheng Chen, Fangyu Liu, Zaiqiao Meng, and Shangsong Liang. Revisiting parameterefficient tuning: Are we really there yet?, 2022.   \n[7] Lequn Chen, Zihao Ye, Yongji Wu, Danyang Zhuo, Luis Ceze, and Arvind Krishnamurthy. Punica: Multi-tenant lora serving, 2023.   \n[8] Shouyuan Chen, Sherman Wong, Liangjian Chen, and Yuandong Tian. Extending context window of large language models via positional interpolation, 2023.   \n[9] Yukang Chen, Shengju Qian, Haotian Tang, Xin Lai, Zhijian Liu, Song Han, and Jiaya Jia. Longlora: Efficient fine-tuning of long-context large language models, 2023.   \n[10] Wei-Lin Chiang, Zhuohan Li, Zi Lin, Ying Sheng, Zhanghao Wu, Hao Zhang, Lianmin Zheng, Siyuan Zhuang, Yonghao Zhuang, Joseph E. Gonzalez, Ion Stoica, and Eric P. Xing. Vicuna: An open-source chatbot impressing gpt-4 with $90\\%^{*}$ chatgpt quality, March 2023. URL https://lmsys.org/blog/2023-03-30-vicuna/.   \n[11] Paul Christiano, Jan Leike, Tom B. Brown, Miljan Martic, Shane Legg, and Dario Amodei. Deep reinforcement learning from human preferences, 2023.   \n[12] Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. Think you have solved question answering? try arc, the ai2 reasoning challenge, 2018.   \n[13] Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, et al. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168, 2021.   \n[14] Tim Dettmers, Mike Lewis, Younes Belkada, and Luke Zettlemoyer. Llm. int8 (): 8-bit matrix multiplication for transformers at scale. arXiv preprint arXiv:2208.07339, 2022.   \n[15] Tim Dettmers, Artidoro Pagnoni, Ari Holtzman, and Luke Zettlemoyer. Qlora: Efficient finetuning of quantized llms. arXiv preprint arXiv:2305.14314, 2023.   \n[16] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pre-training of deep bidirectional transformers for language understanding. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pages 4171\u20134186, 2019.   \n[17] Ning Ding, Yulin Chen, Bokai Xu, Yujia Qin, Zhi Zheng, Shengding Hu, Zhiyuan Liu, Maosong Sun, and Bowen Zhou. Enhancing chat language models by scaling high-quality instructional conversations, 2023.   \n[18] Elias Frantar and Dan Alistarh. Sparsegpt: Massive language models can be accurately pruned in one-shot, 2023.   \n[19] Elias Frantar, Saleh Ashkboos, Torsten Hoefler, and Dan Alistarh. Gptq: Accurate post-training quantization for generative pre-trained transformers. arXiv preprint arXiv:2210.17323, 2022.   \n[20] Leo Gao, Jonathan Tow, Baber Abbasi, Stella Biderman, Sid Black, Anthony DiPof,i Charles Foster, Laurence Golding, Jeffrey Hsu, Alain Le Noac\u2019h, Haonan Li, Kyle McDonell, Niklas Muennighoff, Chris Ociepa, Jason Phang, Laria Reynolds, Hailey Schoelkopf, Aviya Skowron, Lintang Sutawika, Eric Tang, Anish Thite, Ben Wang, Kevin Wang, and Andy Zou. A framework for few-shot language model evaluation, 12 2023. URL https://zenodo.org/records/ 10256836.   \n[21] Song Han, Jeff Pool, John Tran, and William J. Dally. Learning both weights and connections for efficient neural networks, 2015.   \n[22] Song Han, Huizi Mao, and William J. Dally. Deep compression: Compressing deep neural networks with pruning, trained quantization and huffman coding, 2016.   \n[23] Eric Hartford. Cognitivecomputations/dolphin-2.2.1-mistral-7b, hugging face, 2023. URL https://huggingface.co/cognitivecomputations/dolphin-2.2.1-mistral-7b.   \n[24] Neil Houlsby, Andrei Giurgiu, Stanislaw Jastrzebski, Bruna Morrone, Quentin De Laroussilhe, Andrea Gesmundo, Mona Attariyan, and Sylvain Gelly. Parameter-efficient transfer learning for nlp. In International Conference on Machine Learning, pages 2790\u20132799. PMLR, 2019.   \n[25] Edward J. Hu, Yelong Shen, Phillip Wallis, Zeyuan Allen-Zhu, Yuanzhi Li, Shean Wang, and Weizhu Chen. Lora: Low-rank adaptation of large language models. ICLR, 2021.   \n[26] Berivan Isik, Hermann Kumbong, Wanyi Ning, Xiaozhe Yao, Sanmi Koyejo, and Ce Zhang. GPT-zip: Deep compression of finetuned large language models. In Workshop on Efficient Systems for Foundation Models $@$ ICML2023, 2023. URL https://openreview.net/ forum?id=hO0c2tG2xL.   \n[27] Albert Q. Jiang, Alexandre Sablayrolles, Arthur Mensch, Chris Bamford, Devendra Singh Chaplot, Diego de las Casas, Florian Bressand, Gianna Lengyel, Guillaume Lample, Lucile Saulnier, L\u00e9lio Renard Lavaud, Marie-Anne Lachaux, Pierre Stock, Teven Le Scao, Thibaut Lavril, Thomas Wang, Timoth\u00e9e Lacroix, and William El Sayed. Mistral 7b, 2023.   \n[28] Xisen Jin, Xiang Ren, Daniel Preotiuc-Pietro, and Pengxiang Cheng. Dataless knowledge fusion by merging weights of language models, 2023.   \n[29] Sehoon Kim, Coleman Hooper, Amir Gholami, Zhen Dong, Xiuyu Li, Sheng Shen, Michael W Mahoney, and Kurt Keutzer. Squeezellm: Dense-and-sparse quantization. arXiv preprint arXiv:2306.07629, 2023.   \n[30] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization, 2017.   \n[31] Yann LeCun, John Denker, and Sara Solla. Optimal brain damage. In D. Touretzky, editor, Advances in Neural Information Processing Systems, volume 2. MorganKaufmann, 1989. URL https://proceedings.neurips.cc/paper_files/paper/1989/ file/6c9882bbac1c7093bd25041881277658-Paper.pdf.   \n[32] Yaniv Leviathan, Matan Kalman, and Yossi Matias. Fast inference from transformers via speculative decoding. November 2022. doi: 10.48550/ARXIV.2211.17192.   \n[33] Ji Lin, Jiaming Tang, Haotian Tang, Shang Yang, Xingyu Dang, and Song Han. Awq: Activation-aware weight quantization for llm compression and acceleration. arXiv preprint arXiv:2306.00978, 2023.   \n[34] Stephanie Lin, Jacob Hilton, and Owain Evans. Truthfulqa: Measuring how models mimic human falsehoods, 2022.   \n[35] Shuming Ma, Hongyu Wang, Lingxiao Ma, Lei Wang, Wenhui Wang, Shaohan Huang, Li Dong, Ruiping Wang, Jilong Xue, and Furu Wei. The era of 1-bit llms: All large language models are in 1.58 bits, 2024.   \n[36] Asit Mishra, Jorge Albericio Latorre, Jeff Pool, Darko Stosic, Dusan Stosic, Ganesh Venkatesh, Chong Yu, and Paulius Micikevicius. Accelerating sparse deep neural networks. arXiv preprint arXiv: 2104.08378, 2021.   \n[37] Subhabrata Mukherjee, Arindam Mitra, Ganesh Jawahar, Sahaj Agarwal, Hamid Palangi, and Ahmed Awadallah. Orca: Progressive learning from complex explanation traces of gpt-4, 2023.   \n[38] Artur Niederfahrenhorst, Kourosh Hakhamaneshi, and Rehaan Ahmad. Fine-tuning llms: In-depth analysis with llama-2, Sep 2023. URL https://www.anyscale.com/blog/ fine-tuning-llms-lora-or-full-parameter-an-in-depth-analysis-with-llama  \n[39] Long Ouyang, Jeff Wu, Xu Jiang, Diogo Almeida, Carroll L Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, et al. Training language models to follow instructions with human feedback. arXiv preprint arXiv:2203.02155, 2022.   \n[40] Denis Paperno, Germ\u00e1n Kruszewski, Angeliki Lazaridou, Quan Ngoc Pham, Raffaella Bernardi, Sandro Pezzelle, Marco Baroni, Gemma Boleda, and Raquel Fern\u00e1ndez. The lambada dataset: Word prediction requiring a broad discourse context, 2016.   \n[41] Ofir Press, Noah A. Smith, and Mike Lewis. Train short, test long: Attention with linear biases enables input length extrapolation, 2022.   \n[42] Jianing Qiu, Lin Li, Jiankai Sun, Jiachuan Peng, Peilun Shi, Ruiyang Zhang, Yinzhao Dong, Kyle Lam, Frank P.-W. Lo, Bo Xiao, Wu Yuan, Ningli Wang, Dong Xu, and Benny Lo. Large ai models in health informatics: Applications, challenges, and the future. IEEE Journal of Biomedical and Health Informatics, 27(12):6074\u20136087, 2023. doi: 10.1109/JBHI.2023. 3316750.   \n[43] Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. Improving language understanding by generative pre-training. 2018.   \n[44] Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, et al. Language models are unsupervised multitask learners. OpenAI blog, 1(8):9, 2019.   \n[45] Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J. Liu. Exploring the limits of transfer learning with a unified text-to-text transformer, 2023.   \n[46] Sylvestre-Alvise Rebuff,i Hakan Bilen, and Andrea Vedaldi. Learning multiple visual domains with residual adapters. Advances in neural information processing systems, 30, 2017.   \n[47] Simo Ryu, Seunghyun Seo, and Jaejun Yoo. Efficient storage of fine-tuned models via low-rank approximation of weight residuals, 2023.   \n[48] Keisuke Sakaguchi, Ronan Le Bras, Chandra Bhagavatula, and Yejin Choi. Winogrande: An adversarial winograd schema challenge at scale, 2019.   \n[49] Ying Sheng, Shiyi Cao, Dacheng Li, Coleman Hooper, Nicholas Lee, Shuo Yang, Christopher Chou, Banghua Zhu, Lianmin Zheng, Kurt Keutzer, Joseph E. Gonzalez, and Ion Stoica. S-lora: Serving thousands of concurrent lora adapters. arXiv preprint arXiv:2311.03285, 2023.   \n[50] Mirac Suzgun, Nathan Scales, Nathanael Sch\u00e4rli, Sebastian Gehrmann, Yi Tay, Hyung Won Chung, Aakanksha Chowdhery, Quoc V Le, Ed H Chi, Denny Zhou, et al. Challenging bigbench tasks and whether chain-of-thought can solve them. arXiv preprint arXiv:2210.09261, 2022.   \n[51] MosaicML NLP Team. Introducing mpt-7b: A new standard for open-source, commercially usable llms., 2023. URL https://www.databricks.com/blog/mpt-7b.   \n[52] Xwin-LM Team. Xwin-lm, 9 2023. URL https://github.com/Xwin-LM/Xwin-LM.   \n[53] Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288, 2023.   \n[54] Albert Tseng, Jerry Chee, Qingyao Sun, Volodymyr Kuleshov, and Christopher De Sa. Quip#: Even better llm quantization with hadamard incoherence and lattice codebooks, 2024.   \n[55] Lewis Tunstall, Edward Beeching, Nathan Lambert, Nazneen Rajani, Kashif Rasul, Younes Belkada, Shengyi Huang, Leandro von Werra, Cl\u00e9mentine Fourrier, Nathan Habib, Nathan Sarrazin, Omar Sanseviero, Alexander M. Rush, and Thomas Wolf. Zephyr: Direct distillation of lm alignment, 2023.   \n[56] Upstage. Upstage/solar-0-70b-16bit $\\cdot$ hugging face, 2023. URL https://huggingface.co/ upstage/SOLAR-0-70b-16bit.   \n[57] Guan Wang, Sijie Cheng, Xianyuan Zhan, Xiangang Li, Sen Song, and Yang Liu. Openchat: Advancing open-source language models with mixed-quality data, 2023.   \n[58] Lei Wang, Lingxiao Ma, Shijie Cao, Quanlu Zhang, Jilong Xue, Yining Shi, Ningxin Zheng, Ziming Miao, Fan Yang, Ting Cao, Yuqing Yang, and Mao Yang. Ladder: Enabling efficient low-precision deep learning computing through hardware-aware tensor transformation. In 18th USENIX Symposium on Operating Systems Design and Implementation (OSDI 24), pages 307\u2013323, Santa Clara, CA, July 2024. USENIX Association. ISBN 978-1-939133-40-3. URL https://www.usenix.org/conference/osdi24/presentation/wang-lei.   \n[59] Mitchell Wortsman, Gabriel Ilharco, Samir Yitzhak Gadre, Rebecca Roelofs, Raphael GontijoLopes, Ari S. Morcos, Hongseok Namkoong, Ali Farhadi, Yair Carmon, Simon Kornblith, and Ludwig Schmidt. Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time, 2022.   \n[60] Guangxuan Xiao, Ji Lin, Mickael Seznec, Hao Wu, Julien Demouth, and Song Han. Smoothquant: Accurate and efficient post-training quantization for large language models. In International Conference on Machine Learning, pages 38087\u201338099. PMLR, 2023.   \n[61] Minrui Xu, Hongyang Du, Dusit Niyato, Jiawen Kang, Zehui Xiong, Shiwen Mao, Zhu Han, Abbas Jamalipour, Dong In Kim, Xuemin Shen, Victor C. M. Leung, and H. Vincent Poor. Unleashing the power of edge-cloud generative ai in mobile networks: A survey of aigc services. IEEE Communications Surveys & Tutorials, pages 1\u20131, 2024. doi: 10.1109/COMST.2024. 3353265.   \n[62] Prateek Yadav, Leshem Choshen, Colin Raffel, and Mohit Bansal. Compeft: Compression for communicating parameter efficient updates via sparsification and quantization, 2023.   \n[63] Xiaozhe Yao and Ana Klimovic. Deltazip: Multi-tenant language model serving via delta compression. arXiv preprint arXiv:2312.05215, 2023.   \n[64] Le Yu, Bowen Yu, Haiyang Yu, Fei Huang, and Yongbin Li. Language models are super mario: Absorbing abilities from homologous models as a free lunch. arXiv preprint arXiv:2311.03099, 2023.   \n[65] Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. Hellaswag: Can a machine really finish your sentence?, 2019.   \n[66] Lianmin Zheng, Wei-Lin Chiang, Ying Sheng, Siyuan Zhuang, Zhanghao Wu, Yonghao Zhuang, Zi Lin, Zhuohan Li, Dacheng Li, Eric. P Xing, Hao Zhang, Joseph E. Gonzalez, and Ion Stoica. Judging llm-as-a-judge with mt-bench and chatbot arena, 2023.   \n[67] Michael Zhu and Suyog Gupta. To prune, or not to prune: exploring the efficacy of pruning for model compression. International Conference on Learning Representations, 2017. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "A Appendix ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "A.1 Societal Impact ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Democratization of Fine-tuned Models. By dramatically reducing the hardware requirements for serving fine-tuned models, BitDelta enables smaller entities to deploy state-of-the-art models more feasibly. This can accelerate innovation and application development across various industries and academic fields, making fine-tuned models accessible to a wider audience. ", "page_idx": 14}, {"type": "text", "text": "Dealignment Mitigation. BitDelta is a lossy compression method on the fine-tune information in LLMs. As such, crucial alignment information may be lost in the process of compression. We believe this is an important consequence to highlight, as BitDelta democratizes multi-tenant applications which may exacerbate this dealignment concern. We encourage further work on evaluation techniques to detect alignment loss in BitDelta, which can lead to the creation of robust methods for its mitigation. ", "page_idx": 14}, {"type": "text", "text": "A.2 Additional Experiments ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Table 7: We train a $r=16$ LoRA finetune of Llama $_{2-7B}$ on 1 epoch of UltraChat [17] and apply BitDelta with minimal performance degradation. This further shows the generality of BitDelta, which works on parameter-efficient fine-tunes in addition to full-parameter fine-tunes. ", "page_idx": 14}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/5d70c47f58c370d8982043b1f99adbfc7e917c42d936bd95d00852f707bcdf4b.jpg", "table_caption": [], "table_footnote": [], "page_idx": 14}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/b36a75c77c69e7063bc4a20e2b189218c1836f999d7b824cb46c6458746c5a8a.jpg", "table_caption": ["Table 8: Full results of the application of BitDelta to quantized base models, corresponding to Table 6. "], "table_footnote": [], "page_idx": 14}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/4ea7f414a9387584b4fcfcd69d51fdecd96e6b26fd41e68f72ebf71dec1ec766.jpg", "table_caption": ["Table 9: Full results of the ablation over the fidelity of $\\Delta$ , corresponding to Figure 3. "], "table_footnote": [], "page_idx": 14}, {"type": "table", "img_path": "XuWWq3gy7W/tmp/93a898b34f470301cdc2a29d08fc513a563e06e79f2cbebf39c2a824322b75d7.jpg", "table_caption": ["Table 10: Full results of BitDelta applied to fine-tuned models in the Llama-2 and Mistral families, corresponding to Table 2. "], "table_footnote": [], "page_idx": 15}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 16}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 16}, {"type": "text", "text": "Justification: The effectiveness of BitDelta is supported by accuracy experiments, performance benchmarks on the kernel and model level, and through ablations like quantizing the base model and repeatedly applying BitDelta. ", "page_idx": 16}, {"type": "text", "text": "Guidelines: ", "page_idx": 16}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 16}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 16}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Justification: One discussed limitation is how Section 4.3 assumes a toy scenario where all $B$ models simultaneously receive a different request, which is indicative of the worst case scenario of a multi-tenant serving system, but is not necessarily the most representative scenario. ", "page_idx": 16}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 16}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 17}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 17}, {"type": "text", "text": "Justification: The paper does not include theoretical results. Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 17}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 17}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 17}, {"type": "text", "text": "Justification: The paper fully discusses the BitDelta methodology on an algorithmic level, and how to replicate the experiments in Section 4. ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 17}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 18}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 18}, {"type": "text", "text": "Justification: The paper provides the source code to reproduce the main results. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 18}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 18}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 18}, {"type": "text", "text": "Justification: The paper provides training details in Section 3.1. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 18}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 18}, {"type": "text", "text": "Answer: [No] ", "page_idx": 18}, {"type": "text", "text": "Justification: The paper does not report error bars / statistical significant tests as of now. Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 18}, {"type": "text", "text": "", "page_idx": 19}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: The authors describe the compute resources they used to apply BitDelta to models of varying sizes in Section 3.1. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 19}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: The authors have reviewed the NeurIPS Code of Ethics and confirm that there are no major ethical concerns with BitDelta. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 19}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: The authors describe both positive and negative societal impacts of BitDelta in Section A.1. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed. \u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. ", "page_idx": 19}, {"type": "text", "text": "\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 20}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 20}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 20}, {"type": "text", "text": "Justification: The paper poses no such risks. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 20}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Justification: We have cited the creators/original owners of assets the paper uses/references. Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 20}, {"type": "text", "text": "", "page_idx": 21}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: The source code associated with the paper is well documented. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 21}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 21}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 21}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing/research with human subjects. Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 21}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 21}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 21}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing/research with human subjects. Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 21}]