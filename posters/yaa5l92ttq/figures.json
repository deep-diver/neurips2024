[{"figure_path": "yAa5l92TtQ/figures/figures_1_1.jpg", "caption": "Figure 1: Comparison between the step-by-step proof and the recursive proof. (a) A step-by-step proving approach ignores the hierarchical structure inherent in the proof, treating it merely as a sequence of proof steps. The proof cannot be verified as valid until it is fully complete. (b) The recursive proving method decomposes the structured proof into different levels of verifiable proof sketches. Each proof sketch attempts to prove the target theorem or conjecture by outlining the primary steps at the current level and postponing the proof of intermediate conjectures to the next level.", "description": "This figure compares two different approaches for proving theorems: step-by-step and recursive.  The step-by-step method (a) treats the proof as a linear sequence of steps, only verifiable upon completion. The recursive method (b), in contrast, breaks down the proof into smaller, independently verifiable \"proof sketches\". Each sketch proves a sub-goal, temporarily replacing the detailed proof of intermediate conjectures with placeholders ('sorry'). This allows for incremental verification and potentially discovering longer proofs.", "section": "1 Introduction"}, {"figure_path": "yAa5l92TtQ/figures/figures_4_1.jpg", "caption": "Figure 2: A walkthrough example of recursive BFS. Each node in the proof tree is a proof state and each edge is a proof step. (a) The proof search begins by finding the proof sketch at the first level using BFS. The search is paused upon identifying a successful proof path, marked with P and HP nodes. This proof path contains a sorry edge, indicating that it includes skipped conjectures or subgoals that must be addressed in the next level. (b) Recursive BFS enters the next level of proof search to attempt to prove the skipped subgoal from the first level. Unfortunately, the proof search for this subgoal fails due to a lack of valid nodes to explore, and the search returns to the first level. (c) After the failed attempt to prove the subgoal, the previously established proof path at the first level becomes invalid. Consequently, we backpropagate the failure from the second level's root node up to the first-level root node, updating all the HP nodes to an O node. (d) At the first level, with the status set to open for searching proofs, we continued to explore new proof paths. Fortunately, we discovered another proof path. However, this path also contained a sorry edge with a skipped conjecture that needs to be proved at the next level. (e) Similar to (b), the recursive BFS proceeds to the next level to search for a proof for the previously skipped conjecture. It successfully finds a proof path without any \"sorry\" edges (denoted as P nodes), indicating that the conjecture has been proven successfully without any skipped intermediate conjectures or subgoals in the proof path. (f) After finding the sub-level proof, the recursive BFS returns to the first level and backpropagates the PROVED message to the root, completing the proof.", "description": "This figure illustrates the recursive best-first search (BFS) algorithm used in POETRY. It walks through a complete walkthrough example, showing how the algorithm searches for proof sketches at each level, handles failures, backpropagates information, and ultimately completes the proof by recursively solving intermediate conjectures.", "section": "3.2 Recursive Best-First Search"}, {"figure_path": "yAa5l92TtQ/figures/figures_7_1.jpg", "caption": "Figure 3: (a)&(b) Proof length comparison between POETRY and GPT-f Baseline. The y-axis is shown in the log scale. (a) Proof length's histogram of found proof in miniF2F dataset. most of the proof found is within 3 steps long, especially for GPT-f Baselines, but POETRY managed to find longer proof up to 18 proof steps in one proof. (b) Proof length's histogram of found proof in the PISA dataset. POETRY discovers a lot more proofs with longer proof lengths. (c), (d) and (e) Number of problems solved by GPT-f Baseline and POETRY based on the length of the ground truth proofs. (a) The distribution in the entire PISA dataset. POETRY has a clear tendency to solve problems with longer ground truth proofs. (b) The distribution in the single-level subset. In this subset, POETRY and GPT-f Baseline should behave nearly identically; therefore, there are not many differences as expected. (c) The distribution in the multi-level subset. POETRY has a distinctive advantage over GPT-f Baseline. This is the subset where all the complex theorems exist.", "description": "This figure compares the proof lengths found by POETRY and GPT-f Baseline on miniF2F and PISA datasets.  It shows that POETRY finds significantly longer proofs than GPT-f Baseline, especially for more complex problems (multi-level subset of PISA). The y-axis uses a logarithmic scale to better visualize the distribution of proof lengths. Histograms illustrate the number of problems solved by each method for different ground truth proof lengths, highlighting POETRY's superior performance on longer, more challenging proofs.", "section": "4.3 Analysis"}, {"figure_path": "yAa5l92TtQ/figures/figures_8_1.jpg", "caption": "Figure 4: Case comparison between POETRY and GPT-f Baseline. (a) Recursive proof found by POETRY in 71.2 seconds, the proof contains two proof levels. (b) Failure-proof paths found by the GPT-f Baseline. GPT-f Baseline failed to find proof due to timeout after 600 seconds. We select two different failure proof paths found by GPT-f Baseline.", "description": "This figure compares the performance of POETRY and GPT-f Baseline on a specific theorem. POETRY successfully finds a recursive proof within 71.2 seconds, demonstrating its ability to decompose complex proofs into manageable subproblems. In contrast, GPT-f Baseline fails to find a proof within 600 seconds, highlighting the limitations of its step-by-step approach.  The figure showcases two different failure paths taken by GPT-f Baseline, illustrating how it gets stuck exploring unproductive paths. This comparison emphasizes POETRY's efficiency and capability to handle challenging theorems that are difficult for traditional methods.", "section": "4.3 Analysis"}, {"figure_path": "yAa5l92TtQ/figures/figures_15_1.jpg", "caption": "Figure 3: (a)&(b) Proof length comparison between POETRY and GPT-f Baseline. The y-axis is shown in the log scale. (a) Proof length's histogram of found proof in miniF2F dataset. most of the proof found is within 3 steps long, especially for GPT-f Baselines, but POETRY managed to find longer proof up to 18 proof steps in one proof. (b) Proof length's histogram of found proof in the PISA dataset. POETRY discovers a lot more proofs with longer proof lengths. (c), (d) and (e) Number of problems solved by GPT-f Baseline and POETRY based on the length of the ground truth proofs. (a) The distribution in the entire PISA dataset. POETRY has a clear tendency to solve problems with longer ground truth proofs. (b) The distribution in the single-level subset. In this subset, POETRY and GPT-f Baseline should behave nearly identically; therefore, there are not many differences as expected. (c) The distribution in the multi-level subset. POETRY has a distinctive advantage over GPT-f Baseline. This is the subset where all the complex theorems exist.", "description": "This figure compares the proof lengths found by POETRY and GPT-f Baseline on miniF2F and PISA datasets.  The histograms show that POETRY finds significantly more proofs with longer lengths, especially in the PISA dataset's multi-level subset (more complex problems).  The additional plots show the number of problems solved successfully, categorized by the ground truth proof lengths, highlighting POETRY's ability to solve problems with longer ground truth proofs.", "section": "4.3 Analysis"}, {"figure_path": "yAa5l92TtQ/figures/figures_16_1.jpg", "caption": "Figure 2: A walkthrough example of recursive BFS. Each node in the proof tree is a proof state and each edge is a proof step. (a) The proof search begins by finding the proof sketch at the first level using BFS. The search is paused upon identifying a successful proof path, marked with P and HP nodes. This proof path contains a sorry edge, indicating that it includes skipped conjectures or subgoals that must be addressed in the next level. (b) Recursive BFS enters the next level of proof search to attempt to prove the skipped subgoal from the first level. Unfortunately, the proof search for this subgoal fails due to a lack of valid nodes to explore, and the search returns to the first level. (c) After the failed attempt to prove the subgoal, the previously established proof path at the first level becomes invalid. Consequently, we backpropagate the failure from the second level's root node up to the first-level root node, updating all the HP nodes to an O node. (d) At the first level, with the status set to open for searching proofs, we continued to explore new proof paths. Fortunately, we discovered another proof path. However, this path also contained a sorry edge with a skipped conjecture that needs to be proved at the next level. (e) Similar to (b), the recursive BFS proceeds to the next level to search for a proof for the previously skipped conjecture. It successfully finds a proof path without any \"sorry\" edges (denoted as P nodes), indicating that the conjecture has been proven successfully without any skipped intermediate conjectures or subgoals in the proof path. (f) After finding the sub-level proof, the recursive BFS returns to the first level and backpropagates the PROVED message to the root, completing the proof.", "description": "This figure illustrates the recursive best-first search (BFS) algorithm used in POETRY. It shows how the algorithm searches for proof sketches level by level, pausing when a sketch is found and recursively proving the skipped conjectures or subgoals at the next level.  The figure uses different node states (OPEN, FAILED, PROVED, HALF-PROVED) and edge types (normal, sorry) to visually represent the search process and its progression.", "section": "3.2 Recursive Best-First Search"}, {"figure_path": "yAa5l92TtQ/figures/figures_17_1.jpg", "caption": "Figure 1: Comparison between the step-by-step proof and the recursive proof. (a) A step-by-step proving approach ignores the hierarchical structure inherent in the proof, treating it merely as a sequence of proof steps. The proof cannot be verified as valid until it is fully complete. (b) The recursive proving method decomposes the structured proof into different levels of verifiable proof sketches. Each proof sketch attempts to prove the target theorem or conjecture by outlining the primary steps at the current level and postponing the proof of intermediate conjectures to the next level.", "description": "This figure compares two approaches to theorem proving: step-by-step and recursive.  The step-by-step approach (a) treats a proof as a linear sequence, only verifiable upon completion.  The recursive approach (b) breaks the proof into verifiable sketches at each level, temporarily replacing sub-proofs with placeholders ('sorry') until later levels. This allows for incremental verification and potentially longer proofs.", "section": "1 Introduction"}, {"figure_path": "yAa5l92TtQ/figures/figures_18_1.jpg", "caption": "Figure 1: Comparison between the step-by-step proof and the recursive proof. (a) A step-by-step proving approach ignores the hierarchical structure inherent in the proof, treating it merely as a sequence of proof steps. The proof cannot be verified as valid until it is fully complete. (b) The recursive proving method decomposes the structured proof into different levels of verifiable proof sketches. Each proof sketch attempts to prove the target theorem or conjecture by outlining the primary steps at the current level and postponing the proof of intermediate conjectures to the next level.", "description": "This figure compares two approaches to proving theorems: step-by-step and recursive.  The step-by-step method (a) linearly constructs a proof, only verifying its validity once complete.  This can lead to exploring unproductive subgoals. The recursive method (b) incrementally builds a proof, creating verifiable \"sketches\" at each level.  Intermediate steps are temporarily marked as \"solved\" (using a placeholder), deferring their proof to a later level. This allows for a more focused search at each level and can ultimately lead to longer, more complex proofs.", "section": "1 Introduction"}, {"figure_path": "yAa5l92TtQ/figures/figures_18_2.jpg", "caption": "Figure 1: Comparison between the step-by-step proof and the recursive proof. (a) A step-by-step proving approach ignores the hierarchical structure inherent in the proof, treating it merely as a sequence of proof steps. The proof cannot be verified as valid until it is fully complete. (b) The recursive proving method decomposes the structured proof into different levels of verifiable proof sketches. Each proof sketch attempts to prove the target theorem or conjecture by outlining the primary steps at the current level and postponing the proof of intermediate conjectures to the next level.", "description": "This figure compares step-by-step and recursive proof approaches.  The step-by-step method (a) treats proof generation as a linear sequence of steps, only verifiable upon completion.  The recursive method (b), in contrast, breaks the proof into verifiable sketches at different levels. Each level focuses on proving the current theorem or conjecture, temporarily deferring the proofs of intermediate steps (using placeholders like 'sorry') to subsequent levels. This incremental approach allows for more manageable proof construction and potential for finding longer, more complex proofs.", "section": "1 Introduction"}, {"figure_path": "yAa5l92TtQ/figures/figures_19_1.jpg", "caption": "Figure 1: Comparison between the step-by-step proof and the recursive proof. (a) A step-by-step proving approach ignores the hierarchical structure inherent in the proof, treating it merely as a sequence of proof steps. The proof cannot be verified as valid until it is fully complete. (b) The recursive proving method decomposes the structured proof into different levels of verifiable proof sketches. Each proof sketch attempts to prove the target theorem or conjecture by outlining the primary steps at the current level and postponing the proof of intermediate conjectures to the next level.", "description": "This figure compares step-by-step and recursive proof approaches.  The step-by-step method treats a proof as a linear sequence of steps, only verifiable upon completion.  In contrast, the recursive method breaks the proof into verifiable sketches at each level. Each level focuses on proving the current theorem or conjecture, temporarily replacing detailed proofs of intermediate conjectures with placeholders ('sorry').  This incremental approach allows for tackling complex theorems by deferring sub-proofs to deeper levels, enhancing verifiability and potentially efficiency.", "section": "1 Introduction"}, {"figure_path": "yAa5l92TtQ/figures/figures_19_2.jpg", "caption": "Figure 1: Comparison between the step-by-step proof and the recursive proof. (a) A step-by-step proving approach ignores the hierarchical structure inherent in the proof, treating it merely as a sequence of proof steps. The proof cannot be verified as valid until it is fully complete. (b) The recursive proving method decomposes the structured proof into different levels of verifiable proof sketches. Each proof sketch attempts to prove the target theorem or conjecture by outlining the primary steps at the current level and postponing the proof of intermediate conjectures to the next level.", "description": "This figure compares two approaches for proving theorems: step-by-step and recursive.  The step-by-step approach (a) treats the proof as a linear sequence, only verifiable at the end.  The recursive approach (b) breaks the proof down into verifiable levels, with intermediate steps ('sorry' tactics) deferred to later levels.  This incremental approach allows for tackling complex proofs more efficiently.", "section": "1 Introduction"}, {"figure_path": "yAa5l92TtQ/figures/figures_20_1.jpg", "caption": "Figure 1: Comparison between the step-by-step proof and the recursive proof. (a) A step-by-step proving approach ignores the hierarchical structure inherent in the proof, treating it merely as a sequence of proof steps. The proof cannot be verified as valid until it is fully complete. (b) The recursive proving method decomposes the structured proof into different levels of verifiable proof sketches. Each proof sketch attempts to prove the target theorem or conjecture by outlining the primary steps at the current level and postponing the proof of intermediate conjectures to the next level.", "description": "This figure compares two approaches to theorem proving: step-by-step and recursive. The step-by-step approach (a) treats the proof as a linear sequence of steps, delaying verification until completion.  The recursive approach (b) breaks the proof down into verifiable sub-proofs (levels), each focusing on the current level's theorem or conjecture, with more complex proofs deferred to subsequent levels, improving verifiability and potentially efficiency.  This is done by using placeholder tactic \"sorry\" for intermediate conjectures. ", "section": "1 Introduction"}, {"figure_path": "yAa5l92TtQ/figures/figures_20_2.jpg", "caption": "Figure 1: Comparison between the step-by-step proof and the recursive proof. (a) A step-by-step proving approach ignores the hierarchical structure inherent in the proof, treating it merely as a sequence of proof steps. The proof cannot be verified as valid until it is fully complete. (b) The recursive proving method decomposes the structured proof into different levels of verifiable proof sketches. Each proof sketch attempts to prove the target theorem or conjecture by outlining the primary steps at the current level and postponing the proof of intermediate conjectures to the next level.", "description": "This figure compares step-by-step and recursive proof approaches for theorem proving. The step-by-step method treats the proof as a linear sequence, making verification impossible until completion. In contrast, the recursive method breaks the proof into verifiable sketches at each level, deferring subproofs to subsequent levels, thus enabling incremental progress and verification.", "section": "1 Introduction"}, {"figure_path": "yAa5l92TtQ/figures/figures_21_1.jpg", "caption": "Figure 2: A walkthrough example of recursive BFS. Each node in the proof tree is a proof state and each edge is a proof step. (a) The proof search begins by finding the proof sketch at the first level using BFS. The search is paused upon identifying a successful proof path, marked with P and HP nodes. This proof path contains a sorry edge, indicating that it includes skipped conjectures or subgoals that must be addressed in the next level. (b) Recursive BFS enters the next level of proof search to attempt to prove the skipped subgoal from the first level. Unfortunately, the proof search for this subgoal fails due to a lack of valid nodes to explore, and the search returns to the first level. (c) After the failed attempt to prove the subgoal, the previously established proof path at the first level becomes invalid. Consequently, we backpropagate the failure from the second level\u2019s root node up to the first-level root node, updating all the HP nodes to an O node. (d) At the first level, with the status set to open for searching proofs, we continued to explore new proof paths. Fortunately, we discovered another proof path. However, this path also contained a sorry edge with a skipped conjecture that needs to be proved at the next level. (e) Similar to (b), the recursive BFS proceeds to the next level to search for a proof for the previously skipped conjecture. It successfully finds a proof path without any \u201csorry\u201d edges (denoted as P nodes), indicating that the conjecture has been proven successfully without any skipped intermediate conjectures or subgoals in the proof path. (f) After finding the sub-level proof, the recursive BFS returns to the first level and backpropagates the PROVED message to the root, completing the proof.", "description": "This figure illustrates the recursive best-first search algorithm used in POETRY. It shows how the algorithm searches for proof sketches level by level, pausing when a sketch is found and recursively searching for proofs of intermediate conjectures.  The figure uses a tree structure to visualize the search process, with nodes representing proof states and edges representing proof steps. Different node colors represent the status of each node (OPEN, FAILED, PROVED, HALF-PROVED), and a 'sorry' edge indicates that a conjecture has been deferred to a lower level.", "section": "3.2 Recursive Best-First Search"}]