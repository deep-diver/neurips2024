[{"type": "text", "text": "QuanTA: Efficient High-Rank Fine-Tuning of LLMs with Quantum-Informed Tensor Adaptation ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Zhuo Chen12 Rumen Dangovski13 Charlotte Loh13 ", "page_idx": 0}, {"type": "text", "text": "Owen Dugan12 Di Luo124\u2217 Marin Soljac\u02c7ic\u00b412 ", "page_idx": 0}, {"type": "text", "text": "1NSF AI Institute for Artificial Intelligence and Fundamental Interactions 2Department of Physics, Massachusetts Institute of Technology   \n3Department of Department of EECS, Massachusetts Institute of Technology 4Department of Physics, Harvard University ", "page_idx": 0}, {"type": "text", "text": "{chenzhuo,rumenrd,cloh,odugan,diluo,soljacic}@mit.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "We propose Quantum-informed Tensor Adaptation (QuanTA), a novel, easy-toimplement, fine-tuning method with no inference overhead for large-scale pretrained language models. By leveraging quantum-inspired methods derived from quantum circuit structures, QuanTA enables efficient high-rank fine-tuning, surpassing the limitations of Low-Rank Adaptation (LoRA)\u2014low-rank approximation may fail for complicated downstream tasks. Our approach is theoretically supported by the universality theorem and the rank representation theorem to achieve efficient high-rank adaptations. Experiments demonstrate that QuanTA significantly enhances commonsense reasoning, arithmetic reasoning, and scalability compared to traditional methods. Furthermore, QuanTA shows superior performance with fewer trainable parameters compared to other approaches and can be designed to integrate with existing fine-tuning algorithms for further improvement, providing a scalable and efficient solution for fine-tuning large language models and advancing state-of-the-art in natural language processing. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Pre-trainied large language models (LLMs) have revolutionized natural language processing (NLP) by achieving state-of-the-art performance across various tasks [1, 2]. Traditionally, these models are adapted to specific downstream applications via full fine-tuning, where all model parameters are retrained. However, as model sizes increase, the computational cost and memory requirements for full fine-tuning become prohibitive, especially with models like GPT-3 [3] with 175 billion parameters, Mixtral [4] with $8\\times22$ billion parameters, and more recently the LLaMA series [5\u20137], containing soon up to 400 billion parameters [8]. These constraints have spurred the development of parameter-efficient fine-tuning (PEFT) methods, which aim to adapt LLMs by updating only a small subset of parameters, thereby reducing resource demands [9, 10]. ", "page_idx": 0}, {"type": "text", "text": "Among PEFT methods, Low-Rank Adaptation (LoRA) [10] has gained prominence due to its simplicity and effectiveness. LoRA fine-tunes LLMs by introducing low-rank matrices into the pre-trained model\u2019s weight updates, pragmatically reducing the number of trainable parameters while maintaining performance close to full fine-tuning in many tasks. However, LoRA\u2019s reliance on low-rank approximations can sometimes lead to a performance gap compared to full fine-tuning, particularly for complex tasks, as it may not capture all necessary task-specific adaptations [11]. ", "page_idx": 0}, {"type": "text", "text": "Recently, there have been many attempts to generalize LoRA using tensor-based methods [12, 13]. However, these approaches primarily focus on reducing the number of trainable parameters within the low-rank framework yet they continue to face the same limitations of restricted representation. In Quantum mechanics, quantum circuit provides a natural realization of unitary matrix which is full rank, motivating us to develop new schemes for high-rank fine-tuning. ", "page_idx": 0}, {"type": "image", "img_path": "EfpZNpkrm2/tmp/7a9381a7922cbb3dd39cef8018d3c172717d98f12b3c95cec84c5743e481635a.jpg", "img_caption": ["Figure 1: Conceptual comparison of QuanTA and LoRA methods. LoRA parameterizes the weight matrix update as a outer product of two low-rank matrices, limiting its capacity. QuanTA, inspired by quantum circuits, uses tensors that operate on specific axes of the (reshaped) input, enabling high-rank parameterization. Supported by the universality theorem and rank representation theorem, QuanTA can represent arbitrary matrices effectively, allowing it to achieve performance comparable to or sometimes even better than full fine-tuning, with only a fraction of the parameters. Note: the performance graph is a conceptual illustration. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "Inspired by these advancements, we propose Quantum-informed Tensor Adaptation (QuanTA) \\* a novel, easy-to-implement, fine-tuning method with no inference overhead inspired by quantum circuits (Fig. 1). QuanTA enables efficient high-rank adaptations by utilizing tensor operations analogous to those in quantum circuits, addressing the limitations inherent in low-rank methods like LoRA. ", "page_idx": 1}, {"type": "text", "text": "In summary, our contributions are as follows: ", "page_idx": 1}, {"type": "text", "text": "1. We introduce QuanTA, a novel, easy-to-implement, PEFT method with no inference overhead inspired by quantum circuits, enabling efficient high-rank fine-tuning without additional inference latency and offering the potential for integration with other existing PEFT methods for further enhancement.   \n2. We present the universality theorem and the rank representation theorem, theoretically proving that QuanTA can efficiently parameterize high-rank matrices, overcoming the limitations of low-rank methods.   \n3. We validate QuanTA\u2019s performance through extensive experiments, demonstrating significant improvements in various reasoning tasks and efficiency compared to traditional methods. ", "page_idx": 1}, {"type": "text", "text": "2 Related Works ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Parameter-Efficient Fine-Tuning (PEFT) methods aim to address the computational burdens associated with fine-tuning large-scale models by adjusting a relatively small fraction of the total parameters to fti a specific downstream task. Roughly speaking, there are three existing categories of PEFT methods: ", "page_idx": 1}, {"type": "text", "text": "1. Adapter-based methods. These methods introduce additional trainable modules into the structure of a pre-trained, otherwise frozen, model. These modules can be integrated in various ways: series adapters are interposed between existing layers like attention or MLP components [9, 14\u201316], while parallel adapters coexist alongside these components [17]. In general, these methods tend to increase the inference load due to the extra components that are not readily integrated into the original model weights. ", "page_idx": 1}, {"type": "text", "text": "2. Prompt/Prefix-based methods. These methods employ additional prompts or soft tokens at the beginning of the input sequence, focusing fine-tuning efforts on these newly introduced vector embeddings while maintaining the original model weights static [18, 19]. However, this approach can suffer from suboptimal performance and increased inference times. In addition, the soft tokens take up space of real tokens and therefore reduce the effective context size available for the model. ", "page_idx": 2}, {"type": "text", "text": "3. Reparameterization-based methods. These methods modify the existing weights with some parameter-efficient parameterization during the fine-tuning phase. Among these methods, Low-Rank Adaptation (LoRA) [10] and its variants, such as DoRA [20] and VeRA [21], are particularly noteworthy for their widespread adoption and robust performance across various tasks. In addition to LoRA, many other PEFT methods also belong to this category, including more sophisticated approaches such as Hadamard [22], Kronecker product [23] reparameterizations as well as many other methods [24\u201327]. Crucially, methods in this category do not impose additional inference burdens after fine-tuning as the modified weights can be merged into the pre-trained model weights prior to deployment. ", "page_idx": 2}, {"type": "text", "text": "Besides these three categories, there are additional PEFT methods such as LoTA [12], where tensor decompositions are performed across multiple weights, LoRETTA [13], which uses tensor train decomposition for each weight matrix and has both adapter-based and reparameterization-based variants, MPO-based fine-tuning [28], and very recently LISA [29], ReFT [30] and MoRA [31]. ", "page_idx": 2}, {"type": "text", "text": "Physics-inspired machine learning In parallel, there have been various attempts to integrate physicsbased priors into machine learning for many years. Symmetries and physics structure have been incorporated into the neural networks architecture and training in various applications to achieve notable performance [32\u201339]. Various classical and quantum physics processes have been utilized to design new neural networks [40, 41] and generative models [42\u201348]. ", "page_idx": 2}, {"type": "text", "text": "3 Motivation: Low Rank is not Always Sufficient ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "LoRA operates under the hypothesis that parameter updates during fine-tuning exhibit a low \u201cintrinsic rank.\u201d For a pretrained weight matrix $W_{0}\\in\\mathbb{R}^{d\\times k}$ , LoRA parameterizes the weight update as $W^{\\prime}\\,=$ $W_{0}+\\Delta W=W_{0}+B A$ , where $A\\in\\mathbb{R}^{r\\times k}$ and $B\\in$ $\\mathbb{R}^{d\\times r}$ are low-rank matrices. In this configuration, only $A$ and $B$ are trainable, while $W_{0}$ remains fixed. Consequently, the rank of the weight update $\\Delta W$ is limited to $r$ . ", "page_idx": 2}, {"type": "text", "text": "Although the original LoRA paper shows empirical evidence to support the low-rank hypothesis, recently it has been found that this hypothesis may still fail for more complex tasks, especially for those that significantly differ from the pre-training dataset, leading to suboptimal performance [11, 31]. To assess the general applicability of the low-rank hypothesis, we examine two datasets of varying difficulties: the RTE dataset [49], a classification task where the model is tasked to verify the correctness of statements, and the DROP dataset [50], a generation task where the model performs discrete reasoning over paragraphs. We posit that the RTE dataset is simpler, thus more likely to conform to the low-rank hypothesis, whereas the DROP dataset presents a greater challenge. ", "page_idx": 2}, {"type": "text", "text": "As shown in Table 1, the LLaMA2-7B model [6] in general can achieve a better score on the RTE dataset than the DROP dataset. In addition, as we increase the rank from 64 to 128, LoRA\u2019s performance on the ", "page_idx": 2}, {"type": "image", "img_path": "EfpZNpkrm2/tmp/ab89b1455e697ee073cdb0b2603056028128765fa41681471816ecc238e4cef0.jpg", "img_caption": [], "img_footnote": [], "page_idx": 2}, {"type": "text", "text": "Figure 2: Subspace similarities between two LoRA experiments of different ranks (64 and 128) for two datasets. Each point $(i,j)$ represents the subspace similarity between the first $i$ right singular vectors of the $r=64$ experiment, and the first $j$ right singular vectors of the $r=128$ experiment. Only points for $i\\leq j$ are plotted. DROP dataset has a significantly high \u201cintrinsic rank\u201d than RTE dataset. ", "page_idx": 2}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/fac5a8bb450cc186ffb4b44e662ec270aa4d8925e40208178c81322a1fa91ea2.jpg", "table_caption": [], "table_footnote": [], "page_idx": 2}, {"type": "text", "text": "Table 1: Performance of base and LoRA finetuned LLaMA2-7B on RTE [49] and DROP [50] datasets. We use accuracy and $F_{1}$ -score as the metrics for them respectively. ", "page_idx": 2}, {"type": "text", "text": "RTE dataset remains the same, consistent with ", "page_idx": 2}, {"type": "text", "text": "the low-rank hypothesis, while the performance on the DROP dataset improves, suggesting the DROP dataset may require a higher \u201cintrinsic rank.\u201d ", "page_idx": 3}, {"type": "text", "text": "To further measure the \u201cintrinsic rank\u201d of weight updates for these datasets, we follow the methodology outlined in [10] and compare the subspace spanned by the right singular vectors of the resulting weight updates between the $r=64$ and $r=128$ experiments. Figure 2 shows the subspace similarities between the query weight updates of the two ranks at layer 16 for both datasets. In the figure, each point $(i,j)$ represents the subspace similarity between the first $i$ singular vectors of the $r=64$ experiment and the first $j$ singular vectors of the $r=128$ experiment. A subspace similarity close to 1 indicates significant overlap, suggesting that the subspace is crucial for fine-tuning, while a similarity close to 0 suggests orthogonality, implying that the vectors represent noise. For the RTE dataset, subspace similarity is large only for very small $i$ values, and quickly decays to 0 for larger $i$ , indicating that fine-tuning on the RTE dataset has a low \u201cintrinsic rank.\u201d Conversely, for the DROP dataset, subspace similarity remains large across all 64 singular vectors, demonstrating a high \u201cintrinsic rank.\u201d Additional details of subspace similarity and addition data are provide in Appendix A ", "page_idx": 3}, {"type": "text", "text": "These findings demonstrate the necessity of high-rank fine-tuning in complex tasks, challenging the effectiveness of LoRA. This naturally prompts the following question: How can we design efficient methods to facilitate high-rank updates during fine-tuning? ", "page_idx": 3}, {"type": "text", "text": "4 Preliminary: Quantum Circuit ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "The behavior of quantum mechanical systems, especially those involving particles with discrete degrees of freedom, is well described by matrix theory. Quantum circuits naturally realize unitary matrices whose sizes grow exponentially with the number of particles, providing a potent framework for high-rank representation. Here, we review some fundamental concepts of quantum states and quantum circuits to motivate our approach. ", "page_idx": 3}, {"type": "text", "text": "Quantum state and vector representation. An $N$ -qubit quantum state $\\begin{array}{r}{|\\psi\\rangle=\\sum_{i}\\psi_{i}\\,|i\\rangle\\in\\mathbb{C}^{2^{N}}}\\end{array}$ is a $2^{N}$ -dimensional complex-valued vector in Hilbert space, with $\\psi_{i}$ the components and $|i\\rangle$ the basis vectors (similar to ${\\bf{e}}_{i}$ in vector notation). Since quantum states typically consist of qubits with local dimensions of 2, it is instructive to view the quantum state as a multi-dimensional tensor with different indices labeling different qubits: $|\\psi\\rangle=\\bar{\\psi_{i_{1},i_{2},\\ldots,i_{N}}}\\,|i_{1},i_{2},\\ldots,i_{N}\\rangle$ , where $i_{1},i_{2},\\ldots,i_{N}$ is the binary representation of $i$ . This can be equivalently viewed as reshaping the quantum state from a vector in $\\mathbb{C}^{2^{N}}$ to a tensor in C2\u00d72\u00d7\u00b7\u00b7\u00b7\u00d72. ", "page_idx": 3}, {"type": "text", "text": "Quantum circuit and matrix representation. A quantum circuit is a unitary matrix $\\mathcal{U}\\in\\mathbb{U}(2^{N})\\subset\\mathbb{C}^{2^{N}\\times2^{N}}$ that transforms one quantum state into another: $\\left|\\phi\\right\\rangle=\\mathcal{U}\\left|\\psi\\right\\rangle$ . These circuits are constructed from smaller unitary matrices known as quantum \u201cgates,\u201d which operate on one or two qubits. A one-qubit gate is a unitary matrix $U^{(1)}\\,\\in\\,\\mathbb{U}(2^{1})$ , while a two-qubit gate is a unitary matrix $U^{(2)}\\,\\in\\,\\mathbb{U}(2^{2})^{\\dagger}$ . These gates are applied to specific qubits as follows: ", "page_idx": 3}, {"type": "image", "img_path": "EfpZNpkrm2/tmp/fb77b332e7facd5e6f80c0caa84b01197e179665e33a799525ac9b62c0c4f7b6.jpg", "img_caption": ["Figure 3: Any unitary matrix can be decomposed into a quantum circuit using one- and two-qubit gates. "], "img_footnote": [], "page_idx": 3}, {"type": "equation", "text": "$$\nU^{(1)}\\left|\\psi\\right\\rangle=\\sum_{j_{n}}U_{i_{n};j_{n}}^{(1)}\\psi_{i_{1},i_{2},\\ldots,j_{n},\\ldots,i_{N}}\\left|i_{1},i_{2},\\ldots,i_{N}\\right\\rangle\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "for a one-qubit gate applied to qubit $n$ , and ", "page_idx": 3}, {"type": "equation", "text": "$$\nU^{(2)}\\left|\\psi\\right\\rangle=\\sum_{j_{m},j_{n}}U_{i_{m},i_{n};j_{m},j_{n}}^{(2)}\\psi_{i_{1},i_{2},\\ldots,j_{m},\\ldots,j_{n},\\ldots,i_{N}}\\left|i_{1},i_{2},\\ldots,i_{N}\\right\\rangle\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "for a two-qubit gate applied to qubits $m$ and $n$ . (Note that $m$ and $n$ do not need to be consecutive qubits.) ", "page_idx": 3}, {"type": "text", "text": "A quantum circuit comprises a series of these one- and two-qubit gates $\\{U^{(\\alpha)}\\}$ applied sequentially to the quantum state: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathcal{U}\\left|\\psi\\right\\rangle=\\prod_{\\alpha}U^{(\\alpha)}\\left|\\psi\\right\\rangle.\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Since quantum circuits are unitary, they inherently represent full-rank matrices in finite-dimensional systems. ", "page_idx": 4}, {"type": "text", "text": "Universality of quantum circuit. Similar to the universal approximation theorem for neural networks, it has been established that any quantum circuit on $N$ qubits can be decomposed into a quantum circuit using only one- and two-qubit gates [51\u201353], as shown in Figure 3. This is particularly relevant for reparameterization-based fine-tuning methods, where we aim to parameterize a matrix matching the shape of the base model\u2019s weight matrix using a small number of parameters. ", "page_idx": 4}, {"type": "text", "text": "5 Quantum-informed Tensor Adaptation ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "Since quantum circuits offer an elegant parameterization for large unitary matrices of shape $2^{N}\\times2^{N}$ , by relaxing the unitarity constraint and allowing for arbitrary local dimensions, we can develop an effective tool for high-rank, parameter-efficient fine-tuning. Inspired by this, we propose QuanTA: Quantum-informed Tensor Adaptation, which parameterizes the parameter updates in a way analogous to a quantum circuit. ", "page_idx": 4}, {"type": "text", "text": "Construction. To illustrate the construction of QuanTA, we focus on the case of square weight matrices $W\\in\\mathbb{R}^{d\\times d}$ in the main paper and defer the general case to Appendix B. In addition, we assume the hidden dimension $d$ can be decomposed as $d=d_{1}\\times d_{2}\\times\\bar{\\cdots}\\times d_{N}\\dddot{^{*}}$ . This condition is often satisfied for large language models. By reshaping $\\boldsymbol{x}\\in\\mathbb{R}^{d}$ to $\\boldsymbol{x}\\in\\mathbb{R}^{d_{1}\\times d_{2}\\times\\cdots\\times d_{N}}$ , the hidden vector can be interpreted as a quantum state with $N$ \u201cqudits,\u201d with the nth axis corresponding to a qudit with local dimension $d_{n}$ . ", "page_idx": 4}, {"type": "text", "text": "Similar to a quantum circuit, QuanTA consists of \u201cgates\u201d (or tensors) that apply to only specific axes. Since single-axis gates are subsets of two-axis gates, it suffices to consider parameterizations using only two-axis gates. Let $T^{(\\alpha)}$ be a tensor of shape $T^{(\\alpha)}\\in\\mathbb{R}^{d_{m^{(\\alpha)}}d_{n^{(\\alpha)}}\\times d_{m^{\\stackrel{\\cdot}{(\\alpha)}}}d_{n^{(\\alpha)}}}$ that operates on the $\\bar{m}^{(\\alpha)}$ th and $n^{(\\alpha)}$ th axes with corresponding dimensions $d_{m^{(\\alpha)}}$ and $d_{n^{(\\alpha)}}$ . Analogous to applying a two-qubit gate to a quantum state, applying this tensor to the hidden vector is defined as ", "page_idx": 4}, {"type": "equation", "text": "$$\n(T^{(\\alpha)}x)_{i_{1},\\dots,i_{m},\\dots,i_{n},\\dots,i_{N}}:=\\sum_{j_{m},j_{n}}T_{i_{m},i_{n};j_{m},j_{n}}^{(\\alpha)}x_{i_{1},\\dots,j_{m},\\dots,j_{n},\\dots,i_{N}},\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where the $\\alpha$ labels are dropped for simplicity, but it should be noted that different $T^{(\\alpha)}$ \u2019s can be defined on different axes. Equivalently, this operation can be viewed as a matrix-vector multiplication with all but the $m^{(\\alpha)}\\mathrm{th}$ and $\\bar{n}^{(\\alpha)}$ th axes created as batch dimensions. ", "page_idx": 4}, {"type": "text", "text": "QuanTA is then constructed by sequentially applying a collection of such tensors $\\{T^{(\\alpha)}\\}$ in the same manner as a quantum circuit: ", "page_idx": 4}, {"type": "equation", "text": "$$\n{\\cal T}x:=\\prod_{\\alpha}{\\cal T}^{(\\alpha)}x.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Although it is difficult to write the full Eq. (5) in index notation for an arbitrary set of tensors, we demonstrate in Appendix $\\mathrm{G}$ that the einsum expression for this operation can be systematically generated. ", "page_idx": 4}, {"type": "text", "text": "As a concrete example of translating Eq. (5) to index notations and einsum, consider the case of $N=3$ ; $\\{T^{(\\alpha)}\\}$ consists of three tensors, each applied to two axes (as depicted in Fig. 1). In this case, it is easy to express in index notation the application of the QuanTA operator to the hidden vector; ", "page_idx": 4}, {"type": "equation", "text": "$$\n(\\mathcal T x)_{i_{1},i_{2},i_{3}}=\\sum_{k_{1},k_{2}}T_{i_{1},i_{2};k_{1},k_{2}}^{(1)}\\sum_{j_{1},k_{3}}T_{k_{1},i_{3};j_{1},k_{3}}^{(2)}\\sum_{j_{2},j_{3}}T_{k_{2},k_{3};j_{2},j_{3}}^{(3)}x_{j_{1},j_{2},j_{3}}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "as well as the calculation of the full QuanTA matrix; ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\mathcal{T}_{i;j}=\\mathcal{T}_{i_{1},i_{2},i_{3};j_{1},j_{2},j_{3}}=\\sum_{k_{1},k_{2}}T_{i_{1},i_{2};k_{1},k_{2}}^{(1)}\\sum_{k_{3}}T_{k_{1},i_{3};j_{1},k_{3}}^{(2)}T_{k_{2},k_{3};j_{2},j_{3}}^{(3)}.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Although Eq. 6 and 7 may look complex in their formulation, in practice they can be easily implemented respectively using einsum as ", "page_idx": 4}, {"type": "text", "text": "and ", "page_idx": 5}, {"type": "text", "text": "torch.einsum(\"efbc,diaf,ghde->ghiabc\", T_3, T_2, T_1) ", "page_idx": 5}, {"type": "text", "text": "Initialization method. At initialization, the adapted model should be the same as the base model and all the weight updates should be 0. However, enforcing $\\tau_{x}=0$ requires setting one or more $T^{(\\alpha)}\\,=\\,0$ , impeding gradient propagation through the tensors and negatively impacting training performance. ", "page_idx": 5}, {"type": "text", "text": "To address this issue, we use another set of tensors $\\{S^{(\\alpha)}\\}$ (with the corresponding QuanTA operator $\\boldsymbol{S}$ ) that are initialized to the same value as $\\{T^{(\\alpha)}\\}$ but remain frozen throughout fine-tuning. We then define the adapted layer as ", "page_idx": 5}, {"type": "equation", "text": "$$\ny=W_{\\theta}x:=W_{0}x+\\mathcal{T}_{\\theta}x-S x,\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where we use the subscript $\\theta$ to denote tranable paraemters. At initialization, the terms $\\tau_{\\theta}x$ and $-S x$ exactly cancel out, ensuring the adapted layer reduces to the base model. ", "page_idx": 5}, {"type": "text", "text": "It is important to note that this initialization method does not introduce additional costs. After initialization, the full $\\boldsymbol{S}$ matrix can be explicitly constructed, allowing us to redefine $W_{0}^{\\prime}=W_{0}+S$ and simplify the adapted layer to ", "page_idx": 5}, {"type": "equation", "text": "$$\ny=W_{\\theta}x=W_{0}^{\\prime}x+\\mathcal{T}_{\\theta}x.\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "6 Theoretical Results ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Here, we list a few important theorem and provide the proofs in Appendix C ", "page_idx": 5}, {"type": "text", "text": "Theorem 6.1 (Universality of QuanTA). Let $W$ be an arbitrary matrix of shape $2^{M}\\times2^{M}$ . For any collection of local dimensions $\\{d_{n}\\}$ such that each $d_{n}$ is a power of 2 and $\\prod_{n}{\\hat{d}}_{n}=2^{M}$ , it is always possible to decompose $W$ into a finite sequence of tensors $\\{T^{(\\alpha)}\\}$ , where each tensor applies on two axes with local dimensions $d_{m^{(\\alpha)}}$ and $d_{n(\\alpha)}$ . ", "page_idx": 5}, {"type": "text", "text": "We note that the fine-tuning method KronA [23] can be incorporated into our framework and considered as a special case of QuanTA. ", "page_idx": 5}, {"type": "text", "text": "Theorem 6.2 (Rank representation). Let $R\\;=\\;r(\\mathcal{T})$ be the rank of the full QuanTA operator, $R^{(\\alpha)}=r(T^{(\\alpha)})$ be the rank of individual tensors, $d$ be the total dimension of $\\tau$ , $d^{(\\alpha)}=d_{m^{(\\alpha)}}d_{n^{(\\alpha)}}$ be the total dimension of the individual tensor $T^{(\\alpha)}$ , and $N_{T}$ be the total number of tensors. The following inequality always holds ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\sum_{\\alpha}\\frac{d R^{(\\alpha)}}{d^{(\\alpha)}}-d(N_{T}-1)\\le R\\le\\operatorname*{min}_{\\alpha}\\frac{d R^{(\\alpha)}}{d^{(\\alpha)}}.\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "In the special case when all the tensors are full rank ( $R^{\\alpha}=d^{(\\alpha)}$ for all $\\alpha$ ), the full QuanTA operator is also full rank $[R=d]$ ). ", "page_idx": 5}, {"type": "text", "text": "Theorem 6.3 (Composition openness). There exists a set $\\mathbb{S}=\\{\\mathcal{M}_{k}\\}$ of matrices generated from a fixed QuanTA structure and two matrices $\\mathcal{M}_{1},\\mathcal{M}_{2}\\in\\mathbb{S}$ such that $\\bar{\\mathcal{M}}_{1}\\bar{\\mathcal{M}}_{2}\\notin\\mathbb{S}$ . ", "page_idx": 5}, {"type": "text", "text": "We note that the composition openness condition is not satisfied by low-rank matrix decomposition because, for any two low-rank matrices of the same rank, their composition remains of the same rank. While LoRA may mitigate this limitation by introducing nonlinearity, its expressivity is still constrained by closure under composition. In contrast, QuanTA satisfies the composition openness condition even in the absence of nonlinearity, which suggests that its expressivity can continue to grow as the depth of the neural network increases, even if the network is nearly linear. ", "page_idx": 5}, {"type": "text", "text": "No inference overhead. As reparameterization-based methods, QuanTA does not impose any inference latency, since the trained $\\tau$ operator can be explicitly constructed as a matrix and merged into the base model weight matrix. ", "page_idx": 6}, {"type": "text", "text": "Memory and computational complexity during fine-tuning. In the forward pass, only a hidden vector of size $d$ is kept in the memory as we sequentially apply the tensors to it. Each tensor operation can be viewed as a batched matrix-vector multiplication and has a computational complexity of $d\\cdot d_{m}d_{n}$ for tensor applying on the mth and nth axes, so the total computational complexity for a QuanTA layer is $d\\cdot\\sum_{\\alpha}d_{m^{(\\alpha)}}d_{n^{(\\alpha)}}$ . In addition, each tensor contains $(\\dot{d_{m}}d_{n})^{2}$ elements. Therefore, each QuanTA layer contains $\\textstyle\\sum_{\\alpha}(d_{m^{(\\alpha)}}d_{n^{(\\alpha)}})^{2}$ trainable parameters that need to be stored in the optimizer. As an illustrative example, suppose $d_{m}\\,=\\,d^{1/N}$ for all $m$ and there is one tensor for every two axes, the computational complexity can be simplified to $N(N-1)/2\\cdot d^{1+2/N}$ , and the parameter count becomes $N(N-1)/2\\cdot d^{4/N}$ . When $N=2$ , QuanTA reduces to full fine-tuning. ", "page_idx": 6}, {"type": "text", "text": "7 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "To benchmark QuanTA against other fine-tuning methods, we performed experiments on a wide range of datasets (see Appendix $\\mathrm{D}$ for details). For all experiments, we avoid optimizing the hyperparameters on the test set. Instead, we create a validation set from the train set and optimize the hyperparameters on the validation set. All the results reported in this section are averaged over multiple experiments with varying random seeds, and the term \u201cparameters\u201d and \u201c# params\u201d in this section always refer to the trainable parameters. Details on the experiments and hyperparameters are shown in Appendix E. ", "page_idx": 6}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/9128944625defd500d594657385fcb995522257328f652aa31c71f43fffd7dc5.jpg", "table_caption": [], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "Table 2: Benchmark of various fine-tuning methods on Figure 4: Benchmark of different finethe DROP dataset using LLaMA2 7-70 billion parame- tuning methods on the DROP dataset as ter models as the base model. In each case, we report a function of training parameters using the average of $F_{1}$ score over 2-4 experiments with dif- LLaMA2 7 billion parameter model as the ferent random seeds. base model. ", "page_idx": 6}, {"type": "text", "text": "DROP Dataset. We begin our benchmark with the DROP dataset [50], chosen as a representative example that requires high-rank fine-tuning. In Table 2, we compare our QuanTA method with LoRA of different ranks, as well as series and parallel adapters, by fine-tuning LLaMA2 [6] with up to 70 billion parameters. ", "page_idx": 6}, {"type": "text", "text": "As shown in Table 2, LoRA consistently underperforms compared to other fine-tuning methods. While increasing the rank improves performance, LoRA still falls short, suggesting the necessity of high-rank fine-tuning for this task. In addition, QuanTA achieves performance on par with, or better than, full fine-tuning using only a a small fraction of the parameters, demonstrating the effectiveness of QuanTA\u2019s high-rank fine-tuning capability. ", "page_idx": 6}, {"type": "text", "text": "To investigate how these methods scale with the number of trainable parameters, we conducted experiments varying the number of trainable parameters on LLaMA2-7B model. The results are shown in Fig. 4. Each point in the figure represents an average of four experiments with different random seeds, and the standard deviation across these experiments is shown as error bars \u00a7. ", "page_idx": 6}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/ff12323553ce07fb4d46a7a4d75dba52867a566fca952653129f321777cf9bfa.jpg", "table_caption": [], "table_footnote": ["Table 3: Benchmark on various commonsense reasoning tasks. All results of models and PEFT methods labeled with \u201c\\*\u201d are from [54], and results with \u201c\u2020\u201d are from [20]. "], "page_idx": 7}, {"type": "text", "text": "", "page_idx": 7}, {"type": "text", "text": "As illustrated in the figure, QuanTA achieves performance comparable to or better than full fine-tuning using a small fraction of trainable parameters. Conversely, LoRA only achieves subpar performance with a small number of trainable parameters, though its performance improves with an increase in parameters. Other PEFT methods, such as series and parallel adapters, achieve results close to full fine-tuning but use significantly more parameters than QuanTA. ", "page_idx": 7}, {"type": "text", "text": "Commonsense Reasoning. We continue to evaluate our method on a collection of commonsense reasoning datasets. Following the methodology in [54], we first fine-tune the model on the COMMONSENSE170K dataset [54], a comprehensive collection of commonsense reasoning questions, and subsequently evaluate it on eight different downstream tasks. ", "page_idx": 7}, {"type": "text", "text": "In Table 3, we benchmark our QuanTA method against other fine-tuning techniques using 7- and 13-billion-parameter LLaMA and LLaMA2 models, as well as the 8-billion-parameter LLaMA3 model. Alongside prefix tuning, adapter methods, and LoRA, we also compare our approach to the recently proposed LoRA variant, the DoRA method [20]. The results clearly indicate that our QuanTA method outperforms LoRA in all cases and surpasses the DoRA method in most benchmarks, using less than one-tenth of the parameters. ", "page_idx": 7}, {"type": "text", "text": "Arithmetic Reasoning. We further test our method on arithmetic reasoning tasks by fine-tuning the model on MATH10K dataset [54] and assessing its performance on four tasks. We note that while [54] includes additional downstream tasks in the arithmetic reasoning benchmark, some test data was later found to have leaked into the training dataset. In this study, we only benchmark the four downstream tasks unaffected by this data leakage. Additionally, our evaluation procedure differs slightly from that in [54] (see Appendix E for details). ", "page_idx": 7}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/d23a84889b2d8a0e38c4c4d9ef880bcb55eaedbd4693254c6a64f632b3ba91d4.jpg", "table_caption": [], "table_footnote": ["Table 4: Benchmark on various arithmetic reasoning tasks. GPT-3.5 (labeled with \u201c\\*\u201d) results are taken from [54]. "], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "Table 4 presents the evaluation results on the four downstream tasks. Notably, all questions in the AQuA dataset are multiple-choice with mostly five options, and all models except GPT-3.5 failed to achieve accuracy higher than $20\\%$ . Therefore, we conclude that all models perform equally poorly on this task and exclude it from the average accuracy computation. This phenomenon is also consistent with previous findings [54, 20]. The results show that QuanTA significantly outperforms LoRA and even surpasses full fine-tuning with a small number of parameters. It is surprising that QuanTA exceeds full fine-tuning in these tasks, which may be due to overftiting or the challenges of optimizing hyperparameters for full fine-tuning. ", "page_idx": 8}, {"type": "text", "text": "In Appendix F, we include benchmarks with additional fine-tuning methods and on additional datasets. ", "page_idx": 8}, {"type": "text", "text": "Limitations. QuanTA currently requires applying the tensors sequentially to the hidden vectors, which may result in underutilizing the GPU when the tensors are too small. It will be helpful to develop a more efficient implementation to fully utilize GPU resources. The hyperparameters in QuanTA, such as the number of tensors applying on the same axes, have not been optimized. Choosing an optimal set of tensors could further enhance the performance of QuanTA. In the current experiments, we only consider LLaMA model series and a thorough study on different models will be beneficial if more computational resources are available. ", "page_idx": 8}, {"type": "text", "text": "8 Conclusion ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "In this paper, we introduced QuanTA, a novel, easy-to-implement, PEFT method with no inference overhead for large language models. QuanTA leverages quantum-inspired techniques to achieve highrank adaptations, addressing the limitations of existing low-rank methods. QuanTA introduces highrank fine-tuning through the universality theorem and rank representation theorem. Our extensive experiments demonstrate the efficacy of QuanTA across various tasks, including commonsense reasoning, arithmetic reasoning, and scalability. QuanTA consistently outperforms traditional finetuning methods and other PEFT approaches, achieving superior performance with a significantly smaller number of trainable parameters. This highlights the potential of quantum-informed techniques in enhancing the adaptability and efficiency of large language models. ", "page_idx": 8}, {"type": "text", "text": "QuanTA offers a scalable and efficient solution for fine-tuning large language models, advancing the state-of-the-art in natural language processing. There are several promising directions for future research and development of QuanTA. Expanding its application to a wider range of tasks and specialized domains could demonstrate its versatility and robustness. Combining QuanTA with other PEFT methods or incorporating it into ensemble models might further enhance performance, particularly for complex tasks. The parameter efficiency of QuanTA may also imply a lower chance of overfitting. Additionally, exploring advanced optimization techniques tailored specifically for QuanTA could improve convergence rates and overall efficiency. Further design based on principles from quantum computing, such as entanglement and superposition, may lead to even more efficient fine-tuning methods. Our work paves the way for further exploration of quantum-informed methods or even future quantum technologies for machine learning, making it a valuable approach for both research and practical applications with broader impacts. ", "page_idx": 8}, {"type": "text", "text": "Broader Impacts ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "The development of QuanTA represents an important advancement in the fine-tuning of LLMs, with profound societal implications. By leveraging quantum-informed methods, QuanTA reduces computational and memory demands, making advanced NLP capabilities more accessible and costeffective. This democratization of AI technology can facilitate its adoption in resource-constrained environments, bridging technological disparities. Additionally, the integration of quantum techniques could spark interdisciplinary innovations, enhancing healthcare diagnostics, financial risk assessment, and personalized education. Furthermore, QuanTA\u2019s efficiency aligns with global sustainability efforts by reducing the energy consumption associated with AI training, contributing to the reduction of AI\u2019s carbon footprint. Thus, QuanTA not only advances NLP but also promotes inclusive, sustainable, and impactful AI technologies across various sectors. However, the deployment of such powerful AI models raises concerns about data privacy, security, and the potential misuse of AI technologies. Addressing these ethical and societal challenges is crucial to ensure that the beneftis of QuanTA are realized responsibly and equitably. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgements ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "The authors acknowledge support from the National Science Foundation under Cooperative Agreement PHY-2019786 (The NSF AI Institute for Artificial Intelligence and Fundamental Interactions, http://iaifi.org/). This material is based upon work supported by the U.S. Department of Energy, Office of Science, National Quantum Information Science Research Centers, Co-design Center for Quantum Advantage (C2QA) under contract number DE-SC0012704. The research was sponsored by the United States Air Force Research Laboratory and the Department of the Air Force Artificial Intelligence Accelerator and was accomplished under Cooperative Agreement Number FA8750-19-2-1000. The computations in this paper were run on the FASRC cluster supported by the FAS Division of Science Research Computing Group at Harvard University. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. BERT: Pre-training of deep bidirectional transformers for language understanding. In Conference of the North American Chapter of the Association for Computational Linguistics, 2019.   \n[2] Alec Radford, Jeff Wu, Rewon Child, D. Luan, Dario Amodei, and Ilya Sutskever. Language models are unsupervised multitask learners, 2019.   \n[3] Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel Herbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel Ziegler, Jeffrey Wu, Clemens Winter, Chris Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray, Benjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever, and Dario Amodei. Language models are few-shot learners. In Advances in Neural Information Processing Systems, 2020.   \n[4] Albert Q. Jiang, Alexandre Sablayrolles, Antoine Roux, Arthur Mensch, Blanche Savary, Chris Bamford, Devendra Singh Chaplot, Diego de las Casas, Emma Bou Hanna, Florian Bressand, Gianna Lengyel, Guillaume Bour, Guillaume Lample, L\u00e9lio Renard Lavaud, Lucile Saulnier, Marie-Anne Lachaux, Pierre Stock, Sandeep Subramanian, Sophia Yang, Szymon Antoniak, Teven Le Scao, Th\u00e9ophile Gervet, Thibaut Lavril, Thomas Wang, Timoth\u00e9e Lacroix, and William El Sayed. Mixtral of experts, 2024.   \n[5] Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timoth\u00e9e Lacroix, Baptiste Rozi\u00e8re, Naman Goyal, Eric Hambro, Faisal Azhar, Aurelien Rodriguez, Armand Joulin, Edouard Grave, and Guillaume Lample. Llama: Open and efficient foundation language models, 2023.   \n[6] Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, Dan Bikel, Lukas Blecher, Cristian Canton Ferrer, Moya Chen, Guillem Cucurull, David Esiobu, Jude Fernandes, ", "page_idx": 9}, {"type": "text", "text": "Jeremy Fu, Wenyin Fu, Brian Fuller, Cynthia Gao, Vedanuj Goswami, Naman Goyal, Anthony Hartshorn, Saghar Hosseini, Rui Hou, Hakan Inan, Marcin Kardas, Viktor Kerkez, Madian Khabsa, Isabel Kloumann, Artem Korenev, Punit Singh Koura, Marie-Anne Lachaux, Thibaut Lavril, Jenya Lee, Diana Liskovich, Yinghai Lu, Yuning Mao, Xavier Martinet, Todor Mihaylov, Pushkar Mishra, Igor Molybog, Yixin Nie, Andrew Poulton, Jeremy Reizenstein, Rashi Rungta, Kalyan Saladi, Alan Schelten, Ruan Silva, Eric Michael Smith, Ranjan Subramanian, Xiaoqing Ellen Tan, Binh Tang, Ross Taylor, Adina Williams, Jian Xiang Kuan, Puxin Xu, Zheng Yan, Iliyan Zarov, Yuchen Zhang, Angela Fan, Melanie Kambadur, Sharan Narang, Aurelien Rodriguez, Robert Stojnic, Sergey Edunov, and Thomas Scialom. Llama 2: Open foundation and fine-tuned chat models, 2023. ", "page_idx": 10}, {"type": "text", "text": "[7] AI $@$ Meta. Llama 3 model card. 2024. ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[8] AI@Meta. Introducing Meta Llama 3: The most capable openly available LLM to date \u2014 ai.meta.com. https://ai.meta.com/blog/meta-llama-3/, 2024. [Accessed 22-05-2024]. [9] Neil Houlsby, Andrei Giurgiu, Stanislaw Jastrzebski, Bruna Morrone, Quentin De Laroussilhe, Andrea Gesmundo, Mona Attariyan, and Sylvain Gelly. Parameter-efficient transfer learning for NLP. In International Conference on Machine Learning, 2019.   \n[10] Edward J Hu, Yelong Shen, Phillip Wallis, Zeyuan Allen-Zhu, Yuanzhi Li, Shean Wang, Lu Wang, and Weizhu Chen. LoRA: Low-rank adaptation of large language models. In International Conference on Learning Representations, 2022.   \n[11] Dan Biderman, Jose Gonzalez Ortiz, Jacob Portes, Mansheej Paul, Philip Greengard, Connor Jennings, Daniel King, Sam Havens, Vitaliy Chiley, Jonathan Frankle, Cody Blakeney, and John P. Cunningham. Lora learns less and forgets less, 2024.   \n[12] Daniel Bershatsky, Daria Cherniuk, Talgat Daulbaev, Aleksandr Mikhalev, and Ivan Oseledets. Lotr: Low tensor rank weight adaptation, 2024.   \n[13] Yifan Yang, Jiajun Zhou, Ngai Wong, and Zheng Zhang. Loretta: Low-rank economic tensortrain adaptation for ultra-low-parameter fine-tuning of large language models, 2024.   \n[14] Jonas Pfeiffer, Andreas R\u00fcckl\u00e9, Clifton Poth, Aishwarya Kamath, Ivan Vulic\u00b4, Sebastian Ruder, Kyunghyun Cho, and Iryna Gurevych. AdapterHub: A framework for adapting transformers. In Conference on Empirical Methods in Natural Language Processing, 2020.   \n[15] Yaqing Wang, Sahaj Agarwal, Subhabrata Mukherjee, Xiaodong Liu, Jing Gao, Ahmed Hassan Awadallah, and Jianfeng Gao. AdaMix: Mixture-of-adaptations for parameter-efficient model tuning. In Conference on Empirical Methods in Natural Language Processing, 2022.   \n[16] Shwai He, Liang Ding, Daize Dong, Jeremy Zhang, and Dacheng Tao. SparseAdapter: An easy approach for improving the parameter-efficiency of adapters. In Findings of the Association for Computational Linguistics: EMNLP 2022, 2022.   \n[17] Junxian He, Chunting Zhou, Xuezhe Ma, Taylor Berg-Kirkpatrick, and Graham Neubig. Towards a unified view of parameter-efficient transfer learning. In International Conference on Learning Representations, 2022.   \n[18] Brian Lester, Rami Al-Rfou, and Noah Constant. The power of scale for parameter-efficient prompt tuning. In Conference on Empirical Methods in Natural Language Processing, 2021.   \n[19] Xiang Lisa Li and Percy Liang. Prefix-tuning: Optimizing continuous prompts for generation. In The 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing, 2021.   \n[20] Shih-Yang Liu, Chien-Yi Wang, Hongxu Yin, Pavlo Molchanov, Yu-Chiang Frank Wang, Kwang-Ting Cheng, and Min-Hung Chen. DoRA: Weight-decomposed low-rank adaptation. 2024.   \n[21] Dawid Jan Kopiczko, Tijmen Blankevoort, and Yuki M Asano. VeRA: Vector-based random matrix adaptation. In The Twelfth International Conference on Learning Representations, 2024.   \n[22] Nam Hyeon-Woo, Moon Ye-Bin, and Tae-Hyun Oh. Fedpara: Low-rank hadamard product for communication-efficient federated learning. In International Conference on Learning Representations, 2021.   \n[23] Ali Edalati, Marzieh Tahaei, Ivan Kobyzev, Vahid Partovi Nia, James J. Clark, and Mehdi Rezagholizadeh. Krona: Parameter efficient tuning with kronecker adapter, 2022.   \n[24] Yiming Wang, Yu Lin, Xiaodong Zeng, and Guannan Zhang. Multilora: Democratizing lora for better multi-task learning, 2023.   \n[25] Ning Ding, Xingtai Lv, Qiaosen Wang, Yulin Chen, Bowen Zhou, Zhiyuan Liu, and Maosong Sun. Sparse low-rank adaptation of pre-trained language models, 2023.   \n[26] Qingru Zhang, Minshuo Chen, Alexander Bukharin, Nikos Karampatziakis, Pengcheng He, Yu Cheng, Weizhu Chen, and Tuo Zhao. Adalora: Adaptive budget allocation for parameterefficient fine-tuning, 2023.   \n[27] Soufiane Hayou, Nikhil Ghosh, and Bin Yu. Lora+: Efficient low rank adaptation of large models, 2024.   \n[28] Peiyu Liu, Ze-Feng Gao, Wayne Xin Zhao, Zhi-Yuan Xie, Zhong-Yi Lu, and Ji-Rong Wen. Enabling lightweight fine-tuning for pre-trained language model compression based on matrix product operators. In the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing, 2021.   \n[29] Rui Pan, Xiang Liu, Shizhe Diao, Renjie Pi, Jipeng Zhang, Chi Han, and Tong Zhang. Lisa: Layerwise importance sampling for memory-efficient large language model fine-tuning, 2024.   \n[30] Zhengxuan Wu, Aryaman Arora, Zheng Wang, Atticus Geiger, Dan Jurafsky, Christopher D. Manning, and Christopher Potts. Reft: Representation finetuning for language models, 2024.   \n[31] Ting Jiang, Shaohan Huang, Shengyue Luo, Zihan Zhang, Haizhen Huang, Furu Wei, Weiwei Deng, Feng Sun, Qi Zhang, Deqing Wang, and Fuzhen Zhuang. Mora: High-rank updating for parameter-efficient fine-tuning, 2024.   \n[32] Giuseppe Carleo and Matthias Troyer. Solving the quantum many-body problem with artificial neural networks. Science, 355(6325):602\u2013606, 2017.   \n[33] Di Luo, Zhuo Chen, Kaiwen Hu, Zhizhen Zhao, Vera Mikyoung Hur, and Bryan K. Clark. Gauge-invariant and anyonic-symmetric autoregressive neural network for quantum lattice models. Phys. Rev. Res., 5:013216, Mar 2023.   \n[34] Zhuo Chen, Di Luo, Kaiwen Hu, and Bryan K. Clark. Simulating $_{2+1\\mathrm{d}}$ lattice quantum electrodynamics at finite density with neural flow wavefunctions, 2022.   \n[35] Zhuo Chen, Laker Newhouse, Eddie Chen, Di Luo, and Marin Soljacic. ANTN: Bridging autoregressive neural networks and tensor networks for quantum many-body simulation. In Advances in Neural Information Processing Systems, 2023.   \n[36] Di Luo and Bryan K Clark. Backflow transformations via neural networks for quantum manybody wave functions. Physical review letters, 122(22):226401, 2019.   \n[37] Di Luo, Giuseppe Carleo, Bryan K Clark, and James Stokes. Gauge equivariant neural networks for quantum lattice gauge theories. Physical review letters, 127(27):276402, 2021.   \n[38] Nathaniel Thomas, Tess Smidt, Steven Kearnes, Lusann Yang, Li Li, Kai Kohlhoff, and Patrick Riley. Tensor field networks: Rotation-and translation-equivariant neural networks for 3d point clouds. arXiv preprint arXiv:1802.08219, 2018.   \n[39] Maziar Raissi, Paris Perdikaris, and George E Karniadakis. Physics-informed neural networks: A deep learning framework for solving forward and inverse problems involving nonlinear partial differential equations. Journal of Computational physics, 378:686\u2013707, 2019.   \n[40] Samuel Greydanus, Misko Dzamba, and Jason Yosinski. Hamiltonian neural networks. Advances in neural information processing systems, 32, 2019.   \n[41] Miles Cranmer, Sam Greydanus, Stephan Hoyer, Peter Battaglia, David Spergel, and Shirley Ho. Lagrangian neural networks. arXiv preprint arXiv:2003.04630, 2020.   \n[42] Jascha Sohl-Dickstein, Eric Weiss, Niru Maheswaranathan, and Surya Ganguli. Deep unsupervised learning using nonequilibrium thermodynamics. In International Conference on Machine Learning, 2015.   \n[43] Jonathan Ho, Ajay Jain, and Pieter Abbeel. Denoising diffusion probabilistic models. In Advances in Neural Information Processing Systems, 2020.   \n[44] Yang Song and Stefano Ermon. Generative modeling by estimating gradients of the data distribution. In Advances in Neural Information Processing Systems, 2019.   \n[45] Yang Song, Jascha Sohl-Dickstein, Diederik P Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole. Score-based generative modeling through stochastic differential equations. In International Conference on Learning Representations, 2021.   \n[46] Jin-Guo Liu and Lei Wang. Differentiable learning of quantum circuit born machines. Physical Review A, 98(6):062324, 2018.   \n[47] Ziming Liu, Di Luo, Yilun Xu, Tommi Jaakkola, and Max Tegmark. Genphys: From physical processes to generative models. arXiv preprint arXiv:2304.02637, 2023.   \n[48] Edwin Stoudenmire and David J Schwab. Supervised learning with tensor networks. Advances in neural information processing systems, 29, 2016.   \n[49] Alex Wang, Yada Pruksachatkun, Nikita Nangia, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel Bowman. Superglue: A stickier benchmark for general-purpose language understanding systems. In Advances in Neural Information Processing Systems, 2019.   \n[50] Dheeru Dua, Yizhong Wang, Pradeep Dasigi, Gabriel Stanovsky, Sameer Singh, and Matt Gardner. DROP: A reading comprehension benchmark requiring discrete reasoning over paragraphs. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), 2019.   \n[51] A Yu Kitaev. Quantum computations: algorithms and error correction. Russian Mathematical Surveys, 52(6):1191, dec 1997.   \n[52] A. Yu. Kitaev, A. H. Shen, and M. N. Vyalyi. Classical and Quantum Computation. American Mathematical Society, USA, 2002.   \n[53] Michael A. Nielsen and Isaac L. Chuang. Quantum Computation and Quantum Information: 10th Anniversary Edition. Cambridge University Press, 2010.   \n[54] Zhiqiang Hu, Lei Wang, Yihuai Lan, Wanyu Xu, Ee-Peng Lim, Lidong Bing, Xing Xu, Soujanya Poria, and Roy Lee. LLM-adapters: An adapter family for parameter-efficient fine-tuning of large language models. In Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing, 2023.   \n[55] David P. DiVincenzo. Two-bit gates are universal for quantum computation. Physical Review A, 51(2):1015\u20131022, February 1995.   \n[56] Jean-Luc Brylinski and Ranee Brylinski. Universal quantum gates, 2001.   \n[57] Christopher Clark, Kenton Lee, Ming-Wei Chang, Tom Kwiatkowski, Michael Collins, and Kristina Toutanova. Boolq: Exploring the surprising difficulty of natural yes/no questions, 2019.   \n[58] Yonatan Bisk, Rowan Zellers, Ronan Le Bras, Jianfeng Gao, and Yejin Choi. Piqa: Reasoning about physical commonsense in natural language, 2019.   \n[59] Maarten Sap, Hannah Rashkin, Derek Chen, Ronan LeBras, and Yejin Choi. Socialiqa: Commonsense reasoning about social interactions, 2019.   \n[60] Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. Hellaswag: Can a machine really finish your sentence?, 2019.   \n[61] Keisuke Sakaguchi, Ronan Le Bras, Chandra Bhagavatula, and Yejin Choi. Winogrande: An adversarial winograd schema challenge at scale, 2019.   \n[62] Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. Think you have solved question answering? try arc, the ai2 reasoning challenge, 2018.   \n[63] Todor Mihaylov, Peter Clark, Tushar Khot, and Ashish Sabharwal. Can a suit of armor conduct electricity? a new dataset for open book question answering, 2018.   \n[64] Wang Ling, Dani Yogatama, Chris Dyer, and Phil Blunsom. Program induction by rationale generation: Learning to solve and explain algebraic word problems. ACL, 2017.   \n[65] Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. Training verifiers to solve math word problems, 2021.   \n[66] Rik Koncel-Kedziorski, Subhro Roy, Aida Amini, Nate Kushman, and Hannaneh Hajishirzi. Mawps: A math word problem repository. In North American Chapter of the Association for Computational Linguistics, 2016.   \n[67] Arkil Patel, Satwik Bhattamishra, and Navin Goyal. Are nlp models really able to solve simple math word problems?, 2021.   \n[68] Sadhika Malladi, Tianyu Gao, Eshaan Nichani, Alex Damian, Jason D Lee, Danqi Chen, and Sanjeev Arora. Fine-tuning large language models with just forward passes. 2023.   \n[69] Alex Wang, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R. Bowman. Glue: A multi-task benchmark and analysis platform for natural language understanding, 2019.   \n[70] Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. Roberta: A robustly optimized bert pretraining approach, 2019. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "Appendix ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "A Additional Details on Subspace Similarity ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "In the main paper, we use the subspace similarity to measure the \u201cintrinsic rank\u201d of fine-tuning on a specific dataset. In this section, we provide more details on it. ", "page_idx": 14}, {"type": "text", "text": "While it is tempting to compute the rank by performing singular value decomposition (SVD) on the weight matrices of fully fine-tuned models, such measurement generally overestimates the intrinsic rank due to random parameter updates during fine-tuning that are irrelevant to the performance on the downstream tasks. The authors of [10] proposes a better way to measure the intrinsic rank, which we describe as follows. ", "page_idx": 14}, {"type": "text", "text": "First, we run LoRA fine-tuning for two different ranks $r_{1}$ and $r_{2}$ and obtain the LoRA weight updates $\\Delta W^{(r_{1})}=B^{(r_{1})}A^{(r_{1})}$ and $\\bar{\\Delta W^{(r_{2})}}=B^{(r_{2})}A^{(r_{2})}$ . Then, we perform singular value decompositions on the weights to obtain $\\Delta W^{(r)}=U^{(r)}S^{(r)}V^{(r)}{}^{\\top}$ . Next, let\u2019s denote the first $i$ right singular vectors of $\\Delta W^{(r_{1}\\bar{)}}$ (first $i$ columns of $V^{(r_{1})}$ as $V^{(r_{1},i)})$ and the first $j$ right singular vectors of $\\bar{\\Delta W}^{(r_{2})}$ (first $j$ columns of $V^{(r_{2})}$ ) as denoted as $V^{(r_{2},j)}$ . The subspace similarity between these two subspace is defined as ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\phi(r_{1},r_{2},i,j)=\\frac{\\left\\|V^{(r_{1},i)}^{\\top}V^{(r_{2},j)}\\right\\|_{F}^{2}}{\\operatorname*{min}(i,j)}\\in[0,1].\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "This function equals 1 if any subspace can be contained in the other, equals 0 if the two subspaces are orthogonal, and in general measures the overlap between 0 and 1 between the two subspaces. FOr fine-tuning that has a low \u201cintrinsic rank\u201d; only the subspace spanned by the first few singular vectors (that correspond to the largest few singular vectors) should be similar, with the rest nearly perpendicular originating from random noise during fine-tuning. Thus, the subspace similarity should be close to 1 only when either $i$ or $j$ is small, and quickly decays to 0 for large $i$ and $j$ . On the other hand, when the \u201cintrinsic rank\u201d is high, all the singular vectors in one subspace can be important and therefore would appear in the other. In this case, the subspace similarity can remain high for all values of $i$ and $j$ . ", "page_idx": 14}, {"type": "text", "text": "In the main paper, we choose $r_{1}=64$ and $r_{2}=128$ , and measure the subspace similarity for both the RTE dataset [49] and the DROP dataset [50], and reported the values corresponding to the query weight matrix of the 16th layer. In this section, we include results corresponding to additional weight matrices. In Fig. A.1 and A.2, we show the subspace similarities for the value weight matrix at layer 16 and 23. We observe that the similar behaviors appear for these two weight matrices as in the main paper, where the RTE dataset exhibits a low \u201cintrinsic-rank\u201d, while the DROP dataset has a high \u201cintrinsic-rank\u201d. ", "page_idx": 14}, {"type": "image", "img_path": "EfpZNpkrm2/tmp/0b0bd154d7e373a396c22b0202992a23b4a27aa4d080ab92b25808925e9c3d2c.jpg", "img_caption": ["Figure A.1: Subspace similarities between two LoRA experiments of different ranks (64 and 128) for two datasets for the value weight matrix at layer 16. "], "img_footnote": [], "page_idx": 14}, {"type": "image", "img_path": "EfpZNpkrm2/tmp/012280c09c5fdd8a7481b70421be6e5a123e84bb3690a298fab462ddb3a83b08.jpg", "img_caption": ["Figure A.2: Subspace similarities between two LoRA experiments of different ranks (64 and 128) for two datasets for the value weight matrix at layer 23. "], "img_footnote": [], "page_idx": 15}, {"type": "text", "text": "B Constructing General QuanTA Operators ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "In the main paper, we discussed QuanTA operation when the layer weight is square $W_{0}\\in\\mathbb{R}^{d\\times d}$ and we assumed $d$ to be a composite number that can be decomposed into $d=d_{1}\\times d_{2}\\times\\cdot\\cdot\\cdot\\times d_{N}$ . Here, we will consider more general cases. ", "page_idx": 15}, {"type": "text", "text": "Let\u2019s first consider general rectangular matrices $W_{0}\\,\\in\\,\\mathbb{R}^{d\\times k}$ but still assume $d$ and $k$ to permit decompositions in the form $d=d_{1}\\times d_{2}\\times\\cdot\\cdot\\cdot\\times d_{N}$ and $k=k_{1}\\times k_{2}\\times\\cdot\\cdot\\times k_{N}$ , without loss of generality, let\u2019s assume $d\\geq k$ (transpose the matrix if $d<k$ ). In addition, assume $d$ and $k$ has a simple ratio and let $d_{1}/k_{1}=d/k$ . Note that this requirement may seem strict, but in many cases, $d$ can be as simple as a multiple of $k$ . (For example, LLaMA2-70B model contains many $1024\\times8192$ and $8192\\times1024$ weight matrices, in which case $d/k=8/1)$ ). Then, we can set $d_{n}=k_{n}$ for all $n>1$ . Among the collection of tensors, let\u2019s assume $T^{\\alpha}\\in\\dot{\\mathbb{R}}^{d_{1}d_{n}\\times k_{1}d_{n}}$ $\\left(d_{n}=k_{n}\\right)$ is a \u201crectangular\u201d tensor that applies on the first and $n$ th axes. After applying this tensor, the hidden vector changes shape from $\\hat{\\mathbb{R}}^{\\hat{d}_{1}\\times d_{2}\\times\\cdots\\times d_{N}}$ to $\\mathbb{R}^{k_{1}\\times d_{2}\\times\\cdots\\times d_{N}}$ , making the hidden vector into the correct size. Then, one just needs to make sure that all the tensors subsequent to this tensor needs to have the correct shape when applying to the first axis. A pictorial representation is shown in Fig. B.3. ", "page_idx": 15}, {"type": "image", "img_path": "EfpZNpkrm2/tmp/18bb6d5709ab029c298cb8bcdc0f32e58e5ea8ea5c26044c6fe02b8510940044.jpg", "img_caption": ["Figure B.3: Illustration of how to parameterize rectangular matrix with QuanTA "], "img_footnote": [], "page_idx": 15}, {"type": "text", "text": "In the special case where the \u201crectangular\u201d tensor is the last tensor applied to the hidden vector, this operation can be equivalently written as applying a \u201csquare\u201d tensor of shape $\\mathbb{R}^{d_{1}d_{n}\\times d_{1}d_{n}}$ , resulting in an output hidden vector of shape $\\boldsymbol{y}\\in\\dot{\\mathbb{R}}^{\\hat{d}_{1}\\times d_{2}\\searrow\\dots\\times d_{N}}\\simeq\\mathbb{R}^{d}$ and then slicing the first $k$ elements from it. In the case when $d<k$ , this operation needs to be reversed, and it can be expressed as first padding the hidden vector to appropriate size, before applying the tensor circuit. ", "page_idx": 15}, {"type": "text", "text": "More generally, it is possible to choose any set of $\\{d_{n}\\}_{n=1}^{N}$ and $\\{k_{n}\\}_{n=1}^{N}$ (where there products may or may not equal to d and k), as well as any of tensors that transforms Rd1\u00d7d2\u00d7\u00b7\u00b7\u00b7\u00d7dN \u2192Rk1\u00d7k2\u00d7\u00b7\u00b7\u00b7\u00d7kN . Then, one can always truncate or pad the input vector of size $d$ to length $\\textstyle\\prod_{n=1}^{N}d_{n}$ , and the output vector from size $\\prod_{n=1}^{N}k_{n}$ to $k$ . We note that while this method will always work, it is recommended to choose $\\{d_{n}\\}_{n=1}^{N}$ and $\\{k_{n}\\}_{n=1}^{N}$ such that there products are close to $d$ and $k$ , to achieve the best performance and avoid unnecessary cost. We furhter note that having $\\textstyle d\\neq\\prod_{n=1}^{N}d_{n}$ and $\\begin{array}{r}{k\\neq\\prod_{n=1}^{N}k_{n}}\\end{array}$ still allows the full QuanTA operator $\\tau$ to be merged into the original weight matrix, by padding and truncating the T into Rd\u00d7k. ", "page_idx": 15}, {"type": "text", "text": "C Additional Theoretical Results and Proofs ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "In the main paper, we have listed a few important theorems. In this section, we provide the proof for these theorems. We will first need the following lemma, which is fundamental to modern quantum computation. The proof of this lemma can be found in any modern quantum computation textbook such as Ref. [53] or in Ref. [55, 56]. ", "page_idx": 16}, {"type": "text", "text": "Lemma C.1 (Universality of two-qubit gates). Any $2^{M}\\times2^{M}$ unitary matrix can be written as a quantum circuit using just two-qubit gates of size $4\\times4$ . ", "page_idx": 16}, {"type": "text", "text": "This immediately gives us the following corollary. ", "page_idx": 16}, {"type": "text", "text": "Corollary C.1. Any $\\textstyle\\prod_{n}d_{n}\\times\\prod_{n}d_{n}$ unitary matrix with $d_{n}$ a power of 2 can be written as a quantum circuit using two-qudit gates of size $d_{m}d_{n}\\times d_{m}d_{n}$ . ", "page_idx": 16}, {"type": "text", "text": "Proof. It is possible to reshape the matrix into $2^{M}\\times2^{M}$ and use Lemma C.1 to obtain a two-qubit gates representation. Since two-qubit gates are a subset of two-qudit gates, this already concludes the proof. However, one can group the two-qubit gates that apply to the same qudit to reduce reduce the gate count. \u53e3 ", "page_idx": 16}, {"type": "text", "text": "We also need another lemma from quantum computation [53]. ", "page_idx": 16}, {"type": "text", "text": "Lemma C.2 (Phase Rotation). For any diagonal unitary matrix of size $2^{M}\\times2^{M}$ (whose elements are in the form of $e^{i\\theta_{k}}$ ), there exists a finite sequence of two-qubit gates with parameters $\\{\\theta_{k}\\}$ , where the structure of the sequence is fixed for all possible set of $\\{\\theta_{k}\\}$ and each two-qubit gate is an analytic function of $\\{\\theta_{k}\\}$ , that can exactly represent the diagonal matrix. ", "page_idx": 16}, {"type": "text", "text": "Similar to Corollary C.1, Lemma C.2 can also be extended to ", "page_idx": 16}, {"type": "text", "text": "Corollary C.2. For any diagonal unitary matrix of size $\\textstyle\\prod_{n}d_{n}\\times\\prod_{n}d_{n}$ with $d_{n}$ a power of 2, there always exists a finite sequence of two-qudit gates with parameters $\\{\\theta_{k}\\}$ , where the structure of the sequence is fixed for all possible set of $\\{\\theta_{k}\\}$ and each two-qudit gate is an analytic function of $\\{\\theta_{k}\\}$ , that can exactly represent the diagonal matrix. ", "page_idx": 16}, {"type": "text", "text": "We can analytically continue Corollary C.2 to nonunitary diagonal matrices. ", "page_idx": 16}, {"type": "text", "text": "Corollary C.3. For any diagonal matrix of size $\\textstyle\\prod_{n}d_{n}\\times\\prod_{n}d_{n}$ with $d_{n}$ a power of 2 with diagonal elements $\\left\\{a_{k}\\right\\}$ , there exists a finite sequence of two-qudit gates with parameters $\\left\\{a_{k}\\right\\}$ , where the structure of the sequence is fixed for all possible set of $\\{\\theta_{k}\\}$ , that can exactly represent the diagonal matrix. ", "page_idx": 16}, {"type": "text", "text": "Proof. Consider Corollary C.2, since both the full unitary matrix and the sequence of two-qudit gates are finite, and are analytic functions of $\\{\\theta_{k}\\}$ , their analytic continuation must also be equal. Therefore, setting $\\theta_{k}$ \u2019s to be imaginary numbers concludes the proof. \u53e3 ", "page_idx": 16}, {"type": "text", "text": "Now, we are finally ready to prove the universality theorem. ", "page_idx": 16}, {"type": "text", "text": "Theorem C.1 (Universality of QuanTA). Let $W$ be an arbitrary matrix of shape $2^{M}\\times2^{M}$ . For any collection of local dimensions $\\{d_{n}\\}$ such that each $d_{n}$ is a power of 2 and $\\prod_{n}{\\hat{d}}_{n}=2^{M}$ , it is always possible to decompose $W$ into a finite sequence of tensors $\\{T^{(\\alpha)}\\}$ , where each tensor applies on two axes with local dimensions $d_{m^{(\\alpha)}}$ and $d_{n(\\alpha)}$ . ", "page_idx": 16}, {"type": "text", "text": "Proof. Let $U$ , $S$ and $V$ be the singular value decomposition of $W$ . Since $U$ and $V$ are unitary matrices, it immediately follows from Corollary C.1 that they can be written as a finite sequence of tensors. In addition, since $S$ is a diagonal matrix, Corollary C.3 shows that it can also be written as a finite sequence of tensors. Combining all tensors into the same QuanTA operator by applying the sequentially, we obtain the full QuanTA decomposition of $W$ . \u53e3 ", "page_idx": 16}, {"type": "text", "text": "Theorem C.2 (Rank representation). Let $R\\,=\\,r(\\mathcal{T})$ be the rank of the full QuanTA operator, $R^{(\\alpha)}=r(T^{(\\alpha)})$ be the rank of individual tensors, $d$ be the total dimension of $\\tau$ , $d^{(\\alpha)}=d_{m^{(\\alpha)}}d_{n^{(\\alpha)}}$ be the total dimension of the individual tensor $T^{(\\alpha)}$ , and $N_{T}$ be the total number of tensors. The following inequality always holds ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\sum_{\\alpha}\\frac{d R^{(\\alpha)}}{d^{(\\alpha)}}-d(N_{T}-1)\\le R\\le\\operatorname*{min}_{\\alpha}\\frac{d R^{(\\alpha)}}{d^{(\\alpha)}}.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Proof. The rank of the product of two matrices $A$ and $B$ of shape $d\\times d$ satisfies the inequality $r(A)+r(B)-d\\leq r({\\bar{A}}B)\\leq\\operatorname*{min}\\{r(A),r(B)\\}$ . In QuanTA, each tensor can be viewed as a large matrix, where $T^{(\\alpha)}$ is applied on the $m^{(\\alpha)}\\mathrm{th}$ and $n^{(\\alpha)}$ th axes, and identity matrix is applied to the rest of the axes. In this case, the rank of this operation is the same as the rank of $T^{(\\alpha)}$ times the rank of the product of the identity matrices, which equals $\\frac{d R^{(\\alpha)}}{d^{(\\alpha)}}$ . Then, using the above inequality multiple times concludes our proof. \u53e3 ", "page_idx": 17}, {"type": "text", "text": "Theorem C.3 (Composition openness). There exists a set $\\mathbb{S}=\\{\\mathcal{M}_{k}\\}$ of matrices generated from a fixed QuanTA structure and two matrices $\\mathcal{M}_{1},\\mathcal{M}_{2}\\in\\mathbb{S}$ such that $\\bar{\\mathcal{M}_{1}}\\bar{\\mathcal{M}}_{2}\\notin\\mathbb{S}$ . ", "page_idx": 17}, {"type": "text", "text": "Proof. We consider a set of matrices $\\mathbb{S}$ generated by the QuanTA structure that consists of one layer of single-qubit rotation gates followed by a layer of two-qubit CNOT gates [53] and then one layer of single-qubit rotation gates.\u00b6 This is a set of unitary matrices with entanglement generation determined by the number of layers of CNOT gates. Consider $\\mathcal{M}_{1},\\mathcal{M}_{2}\\in\\mathbb{S}$ , according to quantum information theory, it is not possible to have $\\mathcal{M}_{1}\\mathcal{M}_{2}\\in\\mathbb{S}$ . This is because $\\mathcal{M}_{1}\\mathcal{M}_{2}$ has two layers of CNOT gates which can generate more entanglement than any element $\\mathcal{M}_{3}\\in\\mathbb{S}$ that only contains one layer of CNOT gates. \u53e3 ", "page_idx": 17}, {"type": "text", "text": "D Datasets ", "text_level": 1, "page_idx": 17}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/fa667cd13d4df8613cb32b6a860d4df660ea81f6d532328c7a5a3d35804fe5c6.jpg", "table_caption": ["Table D.1: List of datasets used in this work. "], "table_footnote": [], "page_idx": 17}, {"type": "text", "text": "In this section, we describe the datasets used in this paper. In Table D.1, the list of datasets used in this paper is listed. ", "page_idx": 17}, {"type": "text", "text": "For the DROP dataset [50], we subsample 2000 samples from the original train set as our train set, 800 samples from the train set as our validation set, and 1200 samples from the original validation set as our test set, since the original dataset does not contain a test set on Hugging Face. In addition, the $F_{1}$ -score is used to measure the closeness of the models\u2019 output compared to the ground truth since it is in general a phrase. ", "page_idx": 17}, {"type": "text", "text": "For all commonsense reasoning tasks, we first fine-tune a single model on the COMMONSENSE170K dataset collected by [54], and evaluate the same model on eight different commonsense reasoning tasks [57\u201363], which we use the version provided by [54]. The COMMONSENSE170K dataset is split into a train set of 170020 samples, and a validation set of 400 samples. All of the commonsense reasoning tasks are either Yes/No questions or multiple choice questions. In these tasks, the model is asked to choose the best answer from all the options, and accuracy is used as the evaluation metric. ", "page_idx": 17}, {"type": "text", "text": "For all arithmetic reasoning tasks, we fine-tune a single model on the MATH10K dataset [54] and evaluate the same model on four different tasks [64\u201367]. We split the MATH10K dataset into a train set of 9519 samples, and a validation set of 400 samples. Similar to the commonsense reasoning tasks, we use the version of the datasets provided by [54]. In addition, in [54], there was found some data leak issues in some of the arithmetic datasets. Here, we only consider the datasets that are unaffected. In the arithmetic reasoning tasks, although the model is asked to generate the step-by-step solution for the final answer, only the final answer is parsed to measure the accuracy. For AQuA, we parse the output text to find the last character such that it is one of the options. For the other three tasks which require numerical answers, we simply parse the last number from the output text, and consider the answer to be correct if it is the same as the ground truth for up to 4 decimal places. ", "page_idx": 17}, {"type": "text", "text": "", "page_idx": 18}, {"type": "text", "text": "E Hyperparameters and Experimental Details ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "In this section, we describe the hyperparameter choices and the experimental details. All the experiments are conducted on NVIDIA A100 GPUs with 80 GB memory. GPU count used in each experiment will be explained later. The code used to produce the experiments is released on GitHub at https://github.com/quanta-fine-tuning/quanta. Our code is implemented using [54] and [68] as references. ", "page_idx": 18}, {"type": "text", "text": "E.1 QuanTA parameterization ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Although QuanTA supports decomposing the hidden dimension into an arbitrary number of axes $N$ and a wide selection of collections of tensors $\\{T^{(\\alpha)}\\}$ as long as the tensors are compatible with the axes, in this work, we focus on $N=3$ , 4 and 5, where exactly one tensor is applied on each unique combination of axes. For example, there are 3 tensors when $N=3$ , 6 tensors when $N=4$ , and 10 tensors when $N=5$ . Note that if $N=2$ , there is only a single tensor and this approach reduces to the full fine-tuning. Since these tensors are applied sequentially, and matrix multiplications in general don\u2019t commute, the order of tensor application can also affect the result. In the case of $N=3$ , the QuanTA layer is constructed as Fig. 1 in the main paper. For $N=4$ and $N=5$ , we show the construction in Fig. E.4 ", "page_idx": 18}, {"type": "image", "img_path": "EfpZNpkrm2/tmp/4510c01b7645f409ed2dc88c516237b3b8c479289ec2f6ff965b4a0d27975658.jpg", "img_caption": ["Figure E.4: QuanTA architecture used in this work for $N=4$ and $N=5$ . "], "img_footnote": [], "page_idx": 18}, {"type": "text", "text": "E.2 Experiments on DROP dataset ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "In Table E.2, we show the hyperparameters used for the DROP experiments. Only LoRA and QuanTA are applied to the 13- and 70-billion-parameter LLaMA2 models. For the 13-billion-parameter model or smaller, only a single A100 GPU is used for fine-tuning. And for the 70-billion-parameter model, four A100 GPUs are used. For all experiments, the hyperparameters are only optimized on the 7-billion-parameter LLaMA2 model, and applied directly on larger models. In addition, all the hyperparameters are optimized on the validation set, before evaluating the model on the test set. We further note that we choose the best checkpoint obtained during fine-tuning, in terms of the $F_{1}$ -score on the validation set, as the final model to apply on the test set. Because of this, the number-of-epoch parameter does not introduce a significant effect to the final result, as long as the training converges. ", "page_idx": 18}, {"type": "text", "text": "Therefore, this hyperparameter is chosen rather arbitrarily between 3 and 6. We further note that the batch sizes reported here are the effective batch sizes, including the gradient accumulation steps. ", "page_idx": 19}, {"type": "text", "text": "E.3 Experiments on commonsense datasets ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "We explain the details of the experiments on commonsense datasets. As mentioned before, in this experiment, we first fine-tune the model on the joint COMMONSENSE170K dataset and evaluate the same fine-tuned model on all downstream tasks. Similar to the drop dataset, we optimize the hyperparameters on the validation set that we created from the COMMONSENSE170K dataset and choose the best checkpoint in terms of the validation accuracy to evaluate on the benchmarks. The hyperparameters are listed in Table E.3. ", "page_idx": 19}, {"type": "text", "text": "E.4 Experiments on arithmetic datasets ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "We further explain the details of the experiments on arithmetic datasets. Similar to previous, we first fine-tune the model on the joint MATH10K dataset and evaluate the same fine-tuned model on all downstream tasks and we optimize the hyperparameters on the validation set that we created from the MATH10K dataset and choose the best checkpoint in terms of the validation accuracy to evaluate on the benchmarks. The hyperparameters are listed in Table E.4. Notice that we choose a different set of module for LoRA to match the experimental setup of [54, 20]. ", "page_idx": 19}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/4ebe92bc0a724f29154033c0247747ad4288ce36967d879a88bbb2f057f455ae.jpg", "table_caption": [], "table_footnote": ["Table E.2: Hyperparameters used for DROP dataset for various fine-tuning methods. Curly brackets include the hyperparameter values tested during hyperparameter optimization, with the actual hyperparameter(s) underscored. Square brackets include hyperparameter values for different experiments conducted in the main paper. "], "page_idx": 20}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/5d05df684bf0aaf87fad46626c4e11b81fbe35e02f4efe1516d92314c7d0b173.jpg", "table_caption": [], "table_footnote": [], "page_idx": 21}, {"type": "text", "text": "Table E.3: Hyperparameters used for commonsense experiments. Curly brackets include the hyperparameter values tested during hyperparameter optimization, with the actual hyperparameter(s) underscored. Square brackets include hyperparameter values for different experiments conducted in the main paper. ", "page_idx": 21}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/6318af18cb5a1dba240acfccfbde2f5717945aa7590b329308491b989a7276df.jpg", "table_caption": [], "table_footnote": ["Table E.4: Hyperparameters used for arithmetic experiments. Curly brackets include the hyperparameter values tested during hyperparameter optimization, with the actual hyperparameter(s) underscored. Square brackets include hyperparameter values for different experiments conducted in the main paper. "], "page_idx": 22}, {"type": "text", "text": "F Additional Benchmarking Results ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "In this section, we include benchmarking results with additional fine-tuning methods and on additional datasets. In Table F.5 and F.6, we include additional comparisons to MoRA [31], LoRETTA [13], and KronA [23]. In Table F.7, we include additional results on five commonsense understanding tasks from the GLUE benchmark [69] using RoBERTa model [70]. ", "page_idx": 23}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/ea4b858588c0184bc410f9dc0e64298b435202f3eee4075dd0f3225f77664e4d.jpg", "table_caption": [], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "Table F.5: Benchmark of various fine-tuning methods on the DROP dataset using LLaMA2 7 billion parameter model as the base model. Fine-tuning methods in addition to the main paper are shown in italic font. In each case, we report the average of $F_{1}$ score over 4 experiments with different random seeds. For LoRA, MoRA and LoRETTA, the subscript labels the rank; for KronA the subscript labels the sizes of the matrices; and for QuanTA, the subscript labels the dimensions of axes. ", "page_idx": 23}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/0e9f0e499793457c9a35eccc31ee67076b7c9ee6c3bdaa835d0aae31a0571a11.jpg", "table_caption": [], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "Table F.6: Benchmark on various commonsense reasoning tasks using LLaMA3 8 billion parameter model as the base model. Fine-tuning methods in additional to the main paper are shown in italic font. All results of models and PEFT methods labeled with \u201c\\*\u201d are from [54], and results with \u201c\u2020\u201d are from [20]. ", "page_idx": 23}, {"type": "table", "img_path": "EfpZNpkrm2/tmp/8673f882bd5d07a63ec1e614fbf4fa031c67d19a79c825e594df457ea541a2fb.jpg", "table_caption": [], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "Table F.7: Benchmark on five natural language understanding tasks using RoBERTa model as the base model. ", "page_idx": 23}, {"type": "text", "text": "G Systematical Way to Generate einsum Expressions ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "In the main paper, we show an example of how to implement QuanTA operation easily using einsum. Here, we show how to systematically generate the einsum expression more generally. For illustrative purposes, we focus on the case where there is exactly one tensor for every combination of two axes. ", "page_idx": 24}, {"type": "text", "text": "First, we show how to generate the einsum expression for applying the QuanTA operator. ", "page_idx": 24}, {"type": "text", "text": "import itertools   \nimport opt_einsum as oe   \ndef quanta_apply_einsum_expr(N): current_symbols_inds $=$ list(range(N)) expr = \"...\" for i in current_symbols_inds: expr $+=$ oe.get_symbol(i) for (dim1, dim2) in itertools.combinations(range(-1, -N-1, -1), 2): symbol_ind1 $=$ current_symbols_inds[dim1] symbol_ind2 $=$ current_symbols_inds[dim2] symbol_ind3 $=$ symbol_ind1 $+\\texttt{N}$ symbol_ind4 $=$ symbol_ind2 $+\\texttt{N}$ expr $+=$ \",\" + \\ oe.get_symbol(symbol_ind4) + \\ oe.get_symbol(symbol_ind3) + \\ oe.get_symbol(symbol_ind2) + \\ oe.get_symbol(symbol_ind1) current_symbols_inds[dim1] $=$ symbol_ind3 current_symbols_inds[dim2] $=$ symbol_ind4 expr += \"->... for i in current_symbols_inds: expr $+=$ oe.get_symbol(i) return expr ", "page_idx": 24}, {"type": "text", "text": "Then, applying the QuanTA operator to the hidden vector is as simple as y = torch.einsum(quanta_apply_expr, x, \\*T) ", "page_idx": 24}, {"type": "text", "text": "", "page_idx": 24}, {"type": "text", "text": "Similarly, it is easy to generate the einsum expression for obtaining the full QuanTA operator as ", "page_idx": 24}, {"type": "text", "text": "import itertools   \nimport opt_einsum as oe   \ndef quanta_op_einsum_expr(N): current_symbols_inds $=$ list(range(N)) expr = \". for i in current_symbols_inds: expr $+=$ oe.get_symbol(i)   \nfor (dim1, dim2) in itertools.combinations(range(-1, -N-1, -1), 2): symbol_ind1 $=$ current_symbols_inds[dim1] symbol_ind2 $=$ current_symbols_inds[dim2] symbol_ind3 $=$ symbol_ind1 $+\\texttt{N}$ symbol_ind4 $=$ symbol_ind2 + N expr $+=$ \",\" + \\ oe.get_symbol(symbol_ind4) + \\ oe.get_symbol(symbol_ind3) + \\ oe.get_symbol(symbol_ind2) + \\ oe.get_symbol(symbol_ind1) current_symbols_inds[dim1] $=$ symbol_ind3 current_symbols_inds[dim2] $=$ symbol_ind4   \nexpr $+=$ \"->...\"   \nfor i in current_symbols_inds: expr $+=$ oe.get_symbol(i)   \nreturn expr[1:] ", "page_idx": 24}, {"type": "text", "text": "", "page_idx": 25}, {"type": "text", "text": "and obtaining the full QuanTA operator is ", "page_idx": 25}, {"type": "text", "text": "full_T = torch.einsum(quanta_op_expr, \\*T) ", "page_idx": 25}, {"type": "text", "text": "We note that the padding and truncation operators are omitted when the QuanTA operator has a different size than the original weight matrix. In addition, in our actual implementation, we use opt_einsum library to optimize the contraction order, reducing the contraction cost. ", "page_idx": 25}, {"type": "text", "text": "H Example Model Outputs ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "In this section, we provide some example output of QuanTA fine-tuned LLaMA model. ", "page_idx": 25}, {"type": "text", "text": "Task Model Output DROP Prompt: ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Passage: Hoping to rebound from their embarrassing home loss to $\\hookrightarrow$ the Lions, the Raiders flew to Invesco Field at Mile High for $\\hookrightarrow$ an AFC West duel with the Denver Broncos. In the first $\\hookrightarrow$ quarter, Oakland trailed early as Broncos QB Jay Cutler $\\hookrightarrow$ completed a 9-yard TD pass to WR Brandon Stokley for the only $\\hookrightarrow$ score of the period. In the second quarter, the Raiders got $\\hookrightarrow$ on the board with kicker Sebastian Janikowski getting a $\\hookrightarrow$ 38-yard field goal. However, Denver continued to pound away $\\hookrightarrow$ as RB Cecil Sapp got a 4-yard TD run, while kicker Jason Elam $\\hookrightarrow$ got a 23-yard field goal. In the third quarter, Oakland began $\\hookrightarrow$ to come back as QB Josh McCown (who was a gametime decision $\\hookrightarrow$ heading into the game) completed a 46-yard TD pass to WR Jerry $\\hookrightarrow$ Porter for the only score of the period. In the fourth $\\hookrightarrow$ quarter, the Raiders took the lead as DT Gerard Warren sacked $\\hookrightarrow$ Cutler in the end zone for a safety, while LB Thomas Howard $\\hookrightarrow$ returned an interception 44 yards for a touchdown (followed by $\\hookrightarrow$ a successful two-point conversion pass from McCown to WR $\\hookrightarrow$ Ronald Curry). However, the Broncos tied the game up with $\\hookrightarrow$ Elam's 20-yard field goal. In overtime, Oakland managed to $\\hookrightarrow$ make Denver go three-and-out on their first possession. A $\\hookrightarrow$ 33-yard run by RB LaMont Jordan helped set up Janikowski for a $\\hookrightarrow$ game-winning 52-yard field goal. Broncos head coach Mike $\\hookrightarrow$ Shanahan called timeout before the kick could begin. $\\hookrightarrow$ Janikowski's second try hit off the very tip of the left goal $\\hookrightarrow$ post and was no good, giving Denver a chance to win the game. $\\hookrightarrow$ The Broncos won with Elam getting a 23-yard field goal. With $\\hookrightarrow$ the loss, not only did the Raiders fall to 0-2, but they had $\\hookrightarrow$ lost 11-straight games (currently the NFL's longest losing $\\hookrightarrow$ streak) dating back to Week 9 of the 2006 season. Question: How many field goals did each kicker score in the first $\\hookrightarrow$ half? ", "page_idx": 26}, {"type": "text", "text": "Output: ", "page_idx": 26}, {"type": "text", "text": "Table H.8: Examples of QuanTA trained LLaMA2-7B Outputs for the DROP dataset. ", "page_idx": 26}, {"type": "text", "text": "Task Model Output BoolQ Prompt: ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Please answer the following question with true or false, question: $\\hookrightarrow$ is ford escape a 4 wheel drive vehicle? Answer format: $\\hookrightarrow$ true/false ", "page_idx": 27}, {"type": "text", "text": "Highest probability choice: Answer: the correct answer is true. ", "page_idx": 27}, {"type": "text", "text": "SIQA Prompt: ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Please choose the correct answer to the question: Carson took   \n$\\hookrightarrow$ Lee's risk by going skydiving with him off of the plane. What   \n$\\hookrightarrow$ will Lee want to do after? Answer1: hug Carson Answer2: buy a   \n$\\hookrightarrow$ ticket Answer3: kick Carson. Answer format:   \n$\\hookrightarrow$ answer1/answer2/answer3 ", "page_idx": 27}, {"type": "text", "text": "Highest probability choice: ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Answer: the correct answer is answer1. ", "page_idx": 27}, {"type": "text", "text": "SIQA Prompt: ", "text_level": 1, "page_idx": 27}, {"type": "image", "img_path": "EfpZNpkrm2/tmp/f4e2a185ca53060fb1a915b3b2a999040cb588076e5077ed3129b05a6e246cd1.jpg", "img_caption": [], "img_footnote": [], "page_idx": 27}, {"type": "text", "text": "Highest probability choice: ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Answer: the correct answer is ending3. ", "page_idx": 27}, {"type": "text", "text": "Task Model Output MAWPS Prompt: ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Bob will rent a car for the weekend . He can choose one of 2 $\\hookrightarrow$ payment plans . The first plan costs 57.98 for 2 days plus 13 $\\hookrightarrow$ cents per mile . The second plan costs 45.98 for 2 days plus $\\hookrightarrow$ 18 cents per mile . How many miles does Bob need to drive for $\\hookrightarrow$ the 2 plans to cost the same ? ", "page_idx": 28}, {"type": "text", "text": "Answer: ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Output: ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Let's assume that Bob drives ${\\tt x}$ miles. For the first plan, the $\\hookrightarrow$ cost would be: $57\\:.98\\;+\\;0\\.13\\mathbf{x}$ For the second plan, the cost $\\hookrightarrow$ would be: $45\\,.98~+~0\\,.18\\mathfrak{x}$ We want to find the value of x such $\\hookrightarrow$ that the two costs are equal. So, we can set up an equation: $\\hookrightarrow$ $57.98~+~0.13{\\bf x}~=~45.98~+~0.18{\\bf x}$ Simplifying this equation, we $\\hookrightarrow$ get: $0\\,.\\,05\\mathbf{x}\\ =\\ 12.00$ Dividing both sides by 0.05, we get: ${\\texttt{x}}=$ $\\hookrightarrow$ 240 Therefore, Bob needs to drive 240 miles for the two plans $\\hookrightarrow$ to cost the same. ", "page_idx": 28}, {"type": "text", "text": "Table H.10: Examples of QuanTA trained LLaMA2-7B Outputs for a selected arithmetic dataset. ", "page_idx": 28}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Justification: In the abstract and the introduction, we claimed our methods\u2019 quantum inspiration, high-rank representation, theoretical backup and strong empirical performances, and ease of implementation. All of these reflect the contributions and scope of this paper. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 29}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Justification: We discuss the limitations just before the conclusion section. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 29}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 30}, {"type": "text", "text": "Justification: All of the theoretical results presented in the main paper are backed up with proofs in the appendix. ", "page_idx": 30}, {"type": "text", "text": "Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 30}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 30}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 30}, {"type": "text", "text": "Justification: In the appendix, we include the implementation details (including part of the code), dataset processing and evaluation details, and hyperparameter choices. The code is open-sourced later on GitHub. ", "page_idx": 30}, {"type": "text", "text": "Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 30}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 31}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 31}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 31}, {"type": "text", "text": "Justification: The code is available on GitHub ", "page_idx": 31}, {"type": "text", "text": "Guidelines: ", "page_idx": 31}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 31}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 31}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 31}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 31}, {"type": "text", "text": "Justification: All the experimental details are described in the appendix. ", "page_idx": 31}, {"type": "text", "text": "Guidelines: ", "page_idx": 31}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 31}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 31}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 31}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 31}, {"type": "text", "text": "Justification: We provided the error bar in Figure 4, where the error bar refers to the sample standard deviation over four random seeds. For large scale benchmarks shown in the tables, we omit the error bar over multiple random seeds and only report the mean, because a), the baseline experiments didn\u2019t provide error bar, so it is unclear how to interpret them, and b) the experiments are very costly, and the values are reported as averages of fewer than four random seeds, making the error bar less reliable. While we don\u2019t report the error bar over multiple random seeds, it is easy to obtain the error bar from finite samples of the test set, which is given by $\\sqrt{p(1-p)/M}$ , with $p$ the final accuracy and $M$ the number of samples in the test set. ", "page_idx": 31}, {"type": "text", "text": "Guidelines: ", "page_idx": 31}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 32}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 32}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 32}, {"type": "text", "text": "Justification: We explain all the computational resources used for the experiments in the appendix. ", "page_idx": 32}, {"type": "text", "text": "Guidelines: ", "page_idx": 32}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 32}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 32}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 32}, {"type": "text", "text": "Justification: This paper conforms with NeurIPS Code of Ethics in every respect. Guidelines: ", "page_idx": 32}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 32}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 32}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 32}, {"type": "text", "text": "Justification: The broader impacts are addressed at the beginning of the appendix. ", "page_idx": 33}, {"type": "text", "text": "Guidelines: ", "page_idx": 33}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 33}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 33}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 33}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 33}, {"type": "text", "text": "Justification: Although it is not highly likely that his work poses high risks for misuse, we deploy safeguards measures as the code is open-sourced on GitHub. ", "page_idx": 33}, {"type": "text", "text": "Guidelines: ", "page_idx": 33}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 33}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 33}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 33}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 33}, {"type": "text", "text": "Justification: All the existing data and code used in this paper are open source, and are properly credited and cited. ", "page_idx": 33}, {"type": "text", "text": "Guidelines: ", "page_idx": 33}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 33}, {"type": "text", "text": "", "page_idx": 34}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 34}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 34}, {"type": "text", "text": "Justification: The code is released on GitHub with proper documentation. Besides the code, there will be no additional assets released along this paper. ", "page_idx": 34}, {"type": "text", "text": "Guidelines: ", "page_idx": 34}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 34}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 34}, {"type": "text", "text": "Answer: [NA] ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Justification: This work does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 34}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 34}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "page_idx": 34}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 34}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 34}, {"type": "text", "text": "Justification: This work does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 34}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 35}]