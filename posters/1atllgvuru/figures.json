[{"figure_path": "1ATLLgvURu/figures/figures_5_1.jpg", "caption": "Figure 1: A skip list with keys v\u2081 < ... < v\u2089 \u2208 U.", "description": "This figure shows a skip list data structure, which is a probabilistic data structure used to implement priority queues.  It consists of multiple levels of linked lists, with higher levels containing fewer elements and acting as shortcuts to lower levels.  This allows for faster search and insertion operations compared to a simple linked list.  The figure illustrates the structure with keys v1 through v9, showing how they are organized across different levels.  The HEAD and NIL nodes represent the beginning and end of the skip list, respectively.", "section": "3 Skip lists"}, {"figure_path": "1ATLLgvURu/figures/figures_8_1.jpg", "caption": "Figure 2: Sorting in the class setting", "description": "The figure shows the results of sorting experiments in the class setting for different values of n (10^4 and 10^5).  It compares the number of comparisons per element needed for sorting using several methods: LAPQ with offline and online predictions, dirty-clean sorting, Double-Hoover sort, Displacement sort, binary heap, and Fibonacci heap. The x-axis represents the number of classes relative to n, while the y-axis represents the number of comparisons per element. The plot illustrates how the different methods perform under various conditions of class separation. The performance of LAPQ, especially with offline predictions, is comparable to or surpasses traditional methods like Double-Hoover and Displacement sort, particularly as the number of classes increases.", "section": "Experiments"}, {"figure_path": "1ATLLgvURu/figures/figures_8_2.jpg", "caption": "Figure 3: Sorting in the decay setting", "description": "The figure shows the results of sorting algorithms in the decay setting for n\u2208{104,105}.  The decay setting simulates a scenario where predictions become less accurate over time.  The graph plots the number of comparisons per element (y-axis) against the number of timesteps per element (x-axis). It compares the performance of the learning-augmented priority queue (LAPQ) with offline and online predictions, the dirty-clean sort, the Double-Hoover sort, and the Displacement sort, as well as against the classical binary heap and Fibonacci heap algorithms. The results show how the performance of LAPQ is affected by the decay and compares it with the performance of other sorting algorithms.", "section": "5 Experiments"}, {"figure_path": "1ATLLgvURu/figures/figures_9_1.jpg", "caption": "Figure 8: Dijkstra's algorithm on city maps with class predictions", "description": "The figure compares the performance of Dijkstra's algorithm using different priority queue implementations on real-world city maps. It showcases the effect of class-based predictions on the number of comparisons required by the learning-augmented priority queue (LAPQ) compared to binary and Fibonacci heaps. Results are displayed for four different cities (Brussels, Paris, New York, London). The x-axis represents the number of classes (as a fraction of the total number of nodes), and the y-axis shows the average number of comparisons per node.", "section": "5 Experiments"}, {"figure_path": "1ATLLgvURu/figures/figures_9_2.jpg", "caption": "Figure 9: Dijkstra's algorithm on city maps with decay predictions", "description": "The figure shows the results of applying Dijkstra's algorithm on city maps using different priority queue implementations.  The decay setting simulates changes in shortest paths over time. It compares the performance of the learning-augmented priority queue (LAPQ) with different prediction models (node rank predictions, node dirty comparisons, key rank predictions) against standard binary and Fibonacci heaps. The x-axis represents the number of timesteps normalized by the number of nodes, and the y-axis represents the number of comparisons normalized by the number of nodes.", "section": "5 Experiments"}, {"figure_path": "1ATLLgvURu/figures/figures_27_1.jpg", "caption": "Figure 6: Sorting with rank predictions in the class setting, for n \u2208 {1000, 10000, 100000}.", "description": "The figure shows the results of sorting experiments using different algorithms in the class setting. The x-axis represents the number of classes divided by n, and the y-axis represents the number of comparisons divided by n.  Three variants of the Learning-Augmented Priority Queue (LAPQ) are compared: one using offline predictions, one with online predictions, and another using dirty comparisons.  These are compared against the Double-Hoover and Displacement sort algorithms, as well as standard Binary and Fibonacci heaps.  The results are shown for three different values of n (1000, 10000, 100000).", "section": "F.1 Sorting"}, {"figure_path": "1ATLLgvURu/figures/figures_27_2.jpg", "caption": "Figure 7: Sorting in the decay setting for n \u2208 {1000, 10000, 100000}.", "description": "The figure shows the results of sorting experiments in the decay setting for three different values of n (1000, 10000, and 100000).  The decay setting simulates a situation where the initial rank predictions are accurate, but the accuracy degrades over time. The plot shows the number of comparisons needed per element as a function of the number of timesteps divided by n, for different sorting algorithms: LAPQ with offline predictions, LAPQ with online predictions, LAPQ with dirty comparisons, Double-Hoover sort, Displacement sort, binary heap, and Fibonacci heap.  This demonstrates the performance of the proposed learning-augmented priority queue (LAPQ) compared to traditional sorting algorithms under conditions of decreasing prediction accuracy.", "section": "F.1 Sorting"}, {"figure_path": "1ATLLgvURu/figures/figures_27_3.jpg", "caption": "Figure 8: Dijkstra's algorithm on city maps with class predictions", "description": "The figure compares the performance of Dijkstra's algorithm using different priority queue implementations on four real-world city maps (Brussels, Paris, New York, London).  The algorithms use node rank predictions (offline), dirty comparison predictions, or key rank predictions. The performance is measured by the number of comparisons performed.  The figure shows how the learning-augmented priority queues (LAPQ) with various prediction models outperform the classic binary and Fibonacci heap implementations across all city maps, especially when prediction accuracy is relatively high.", "section": "5 Experiments"}, {"figure_path": "1ATLLgvURu/figures/figures_27_4.jpg", "caption": "Figure 9: Dijkstra's algorithm on city maps with decay predictions", "description": "The figure compares the performance of Dijkstra's algorithm using different priority queue implementations on four real-world city maps (Brussels, Paris, New York, London) under a decay setting.  It shows the number of comparisons made by the LAPQ (learning-augmented priority queue) with different prediction models (node rank predictions, node dirty comparisons, key rank predictions) against traditional binary heaps and Fibonacci heaps. The x-axis shows the number of timesteps relative to the number of nodes, and the y-axis shows the number of comparisons divided by the number of nodes. The decay setting simulates modifications to the shortest paths, like road construction or closure.", "section": "Experiments"}, {"figure_path": "1ATLLgvURu/figures/figures_28_1.jpg", "caption": "Figure 10: PVT with n = 100", "description": "This figure shows a visualization of a Poisson Voronoi Tessellation (PVT) with 100 nodes.  A PVT is a type of random graph model used to represent street systems or other spatial networks.  It is constructed by randomly placing points (seeds) in a 2D region, then creating cells around each seed such that each point in the region is assigned to the nearest seed.  The edges of the graph connect adjacent cells.  The figure illustrates the irregular, non-uniform structure typical of PVTs.", "section": "5 Experiments"}, {"figure_path": "1ATLLgvURu/figures/figures_28_2.jpg", "caption": "Figure 11: Dijkstra's algorithm on Poisson Voronoi Tesselation with class predictions", "description": "This figure displays the results of the Dijkstra's algorithm's performance on Poisson Voronoi Tessellations, using various priority queue implementations. The x-axis shows the ratio of the number of classes to the total number of nodes, and the y-axis represents the number of comparisons per node. The results are shown for different prediction models, including LAPQ online and dirty predictions, LAPQ key rank predictions, and standard binary and Fibonacci heaps. The error bars are presented to show the variability of the results. The plot indicates that LAPQ, using prediction models, outperforms traditional heaps, especially as the number of classes increases.", "section": "5 Experiments"}, {"figure_path": "1ATLLgvURu/figures/figures_28_3.jpg", "caption": "Figure 12: Dijkstra's algorithm on Poisson Voronoi Tesselation with decay predictions", "description": "The figure shows the results of applying Dijkstra's algorithm to Poisson Voronoi Tessellations with decay predictions.  It compares the number of comparisons performed by different priority queue implementations: LAPQ with online predictions, LAPQ with dirty comparisons, LAPQ with key rank predictions, a binary heap, and a Fibonacci heap. The x-axis represents the number of timesteps relative to n (the number of nodes), and the y-axis shows the number of comparisons per node. Three different tessellations are shown (n = 1000, 5000, and 10000).  The results illustrate that the LAPQ methods, particularly with key rank predictions, significantly reduce the number of comparisons needed compared to traditional heap-based priority queues.", "section": "Experiments"}]