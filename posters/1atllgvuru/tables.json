[{"figure_path": "1ATLLgvURu/tables/tables_2_1.jpg", "caption": "Table 1: Number of comparisons per operation used by different priority queues.", "description": "The table compares the time complexity of several priority queue implementations.  The rows represent different data structures for implementing priority queues: Binary Heap, Fibonacci Heap, Skip List, and three versions of the Learning-Augmented Priority Queue (LAPQ) using different prediction models (dirty comparisons, pointer predictions, and rank predictions). The columns indicate the time complexity of the priority queue operations: ExtractMin, Insert, and DecreaseKey.  The complexities are expressed using Big O notation and represent the average-case performance of the algorithms.", "section": "1.2 Our results"}, {"figure_path": "1ATLLgvURu/tables/tables_4_1.jpg", "caption": "Table 1: Number of comparisons per operation used by different priority queues.", "description": "The table compares the time and comparison complexities of several priority queue implementations. It shows the number of comparisons required per operation (Insert, ExtractMin, DecreaseKey) for standard priority queues such as Binary Heap, Fibonacci Heap, and Skip List, and learning-augmented priority queues (LAPQ) using three different prediction models (dirty comparisons, pointer predictions, and rank predictions).  The table highlights the improved performance of the LAPQ in terms of comparisons, especially in scenarios with accurate predictions.", "section": "1.2 Our results"}, {"figure_path": "1ATLLgvURu/tables/tables_6_1.jpg", "caption": "Table 1: Number of comparisons per operation used by different priority queues.", "description": "This table compares the time complexity of several priority queue implementations, including standard binary heap, Fibonacci heap, skip list, and the proposed learning-augmented priority queue (LAPQ) with different prediction models (dirty comparisons, pointer predictions, and rank predictions).  For each priority queue implementation and type of operation (Insert, ExtractMin, DecreaseKey), it indicates the number of comparisons needed. The table shows the advantages of using the LAPQ with different types of predictions, especially regarding the improvement in worst-case performance.", "section": "1.2 Our results"}, {"figure_path": "1ATLLgvURu/tables/tables_6_2.jpg", "caption": "Table 1: Number of comparisons per operation used by different priority queues.", "description": "This table compares the time and comparison complexities of different priority queue implementations, including standard binary heap, Fibonacci heap, skip list, and the proposed learning-augmented priority queue (LAPQ) with three different prediction models (dirty comparisons, pointer predictions, and rank predictions).  It highlights the performance improvements achieved by LAPQ, particularly in the average case, under various prediction scenarios.", "section": "1.2 Our results"}]