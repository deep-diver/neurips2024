[{"type": "text", "text": "Deep Policy Gradient Methods Without Batch Updates Target Networks, or Replay Buffers ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Gautham Vasan12 Mohamed Elsayed12 Alireza Azimi\\*12 Jiamin He\\*12 ", "page_idx": 0}, {"type": "text", "text": "Fahim Shariar12 Colin Bellinger? Martha White124 A. Rupam Mahmood124 ", "page_idx": 0}, {"type": "text", "text": "1University of Alberta 2Ami 3 National Research Council of Canada  4 CIFAR Canada AI Chair {vasan, mohamedelsayed, sazimi, jiamin12, fshahri1}@ualberta.ca colin.bellinger@nrc-cnrc.gc.ca  {whitem, armahmood}@ualberta.ca ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Modern deep policy gradient methods achieve effective performance on simulated robotic tasks, but they all require large replay buffers or expensive batch updates, or both, making them incompatible for real systems with resource-limited computers. We show that these methods fail catastrophically when limited to small replay buffers or during incremental learning, where updates only use the most recent sample without batch updates or a replay buffer. We propose a novel incremental deep policy gradient method \u2014 Action Value Gradient (AVG) and a set of normalization and scaling techniques to address the challenges of instability in incremental learning. On robotic simulation benchmarks, we show that AVG is the only incremental method that learns effectively, often achieving final performance comparable to batch policy gradient methods. This advancement enabled us to show for the first time effective deep reinforcement learning with real robots using only incremental updates, employing a robotic manipulator and a mobile robot.1 ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Real-time or online learning is essential for intelligent agents to adapt to unforeseen changes in dynamic environments. However, real-time learning faces substantial challenges in many real-world systems, such as robots, due to limited onboard computational resources and storage capacity (Hayes and Kanan 2022, Wang et al. 2023, Michieli and Ozay 2023). The system must process observations, compute and execute actions, and learn from experience, all while adhering to strict computational and time constraints (Yuan and Mahmood 2022). For example, the Mars rover faces stringent limitations on its computational capabilities and storage capacity (Verma et al. 2023), constraining the system's ability to run computationally intensive algorithms onboard. ", "page_idx": 0}, {"type": "text", "text": "Deep policy gradient methods have risen to prominence for their effectiveness in real-world control tasks, such as dexterous manipulation of a Rubik's cube (Akkaya et al. 2019), quadruped dribbling of a soccer ball (Ji et al. 2023), and magnetic control of tokamak plasmas (Degrave et al. 2022). These methods are typically used offline, such as in simulations, as they have steep resource requirements due to their use of large storage of past experience in a replay buffer, target networks and computationally intensive batch updates for learning. As a result,these methods are ill-suited for on-device learning and generally challenging to use for real-time learning. To make these methods applicable to resourcelimited computers such as edge devices, a natural approach is to reduce the replay buffer size, eliminate target networks, and use smaller batch updates that meet the resource constraints. ", "page_idx": 0}, {"type": "text", "text": "In Figure 1, we demonstrate using four MuJoCo tasks (Todorov et al. 2012) that the learning performance of batch policy gradient methods degrades substantially when the replay buffer size is reduced from their large default values. Specifically, Proximal Policy Optimization (PPO, Schulman et al., 2017), Soft Actor-Critic (SAC, Haarnoja et al., 2018), and Twin Delayed Deep Deterministic Policy Gradient (TD3, Fujimoto et al., 2018) fail catastrophically when their buffer size is reduced to 1. This case corresponds to incremental learning, where learning relies solely on the most recent sample, thus precluding the use of a replay buffer or batch updates. ", "page_idx": 0}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/9b2c816d17060a2027e5cc36674c43f1b949ee1becb1774385d0ed7c0e87da2a.jpg", "img_caption": ["Figure 1: Impact of reducing replay buffer size on SAC, PPO, and TD3: Decreasing the replay buffer size adversely affects learning. In contrast, AVG succeeds despite learning without a replay buffer, as shown by a \u201c\"buffer size\u201d of 1 in the plots. Each data point represents the mean episodic return over the final 100K steps, averaged across 30 runs. All methods were trained for 10M timesteps. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "Incremental learning methods (Vijayakumar et al. 2005, Mahmood 2017) are computationally cheap and commonly used for real-time learning with linear function approximation (Degris et al. 2012, Modayil et al. 2014, Vasan and Pilarski 2017). However, incremental policy gradient methods, such as the incremental one-step actor-critic (IAC, Sutton and Barto 2018), are rarely used in applications of deep reinforcement learning (RL), except for a few works (e.g., Young and Tian 2019) that work in limited settings. The results in Fig. 1 indicate that their absence is due to their difficulty in learning effectively when used with deep neural networks. A robust incremental method that can leverage deep neural networks for learning in real-time remains an important open challenge. ", "page_idx": 1}, {"type": "text", "text": "Incremental policy gradient methods, such as IAC, employ the likelihood ratio gradient (LG) estimator to estimate the gradient. An alternative approach to estimating the gradient, the reparameterization gradient (RG) estimator or the pathwise gradient estimator, has been observed to demonstrate lower variance in practice and can effectively handle continuous state and action spaces (Greensmith et al. 2004, Fan et al. 2015, Lan et al. 2022). RG estimators have recently gained interest in RL due to their use in deep policy gradient methods such as TD3 and SAC. However, we currently lack incremental policy gradient methods that use the RG estimator. ", "page_idx": 1}, {"type": "text", "text": "We present a novel incremental algorithm, called Action Value Gradient (AVG), which leverages deep neural networks and utilizes the RG estimator. While batch updates, replay buffers, and target networks are required to stabilize deep RL (D'Oro et al. 2022, Schwarzer et al. 2023), AVG instead incorporates normalization and scaling techniques to learn stably in the incremental setting (see Sec. 3). In Sec. 4, we demonstrate that AVG achieves strong results across a wide range of benchmarks, being the only incremental algorithm to avoid catastrophic failure and learn effectively. In Sec. 5, we highlight the key challenges of incremental learning stemming from the large and noisy gradients inherent to the process. Through an ablation study, we discuss how normalization and scaling techniques help mitigate these issues for AVG and how they may salvage the performance of other methods, including IAC and an incremental variant of SAC. We also show that target networks hinder the learning performance of AVG in the incremental setting, with only aggressive updates of the target network towards the critic achieving results comparable to AVG, while their removal reduces memory demands and simplifies our algorithm. Finally, we apply AVG to real-time robot learning tasks, showcasing the first successful demonstration of an incremental deep RL method on real robots. ", "page_idx": 1}, {"type": "text", "text": "2 Background ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "We consider the reinforcement learning setting where an agent-environment interaction is modeled as a continuous state and action space Markov Decision Process (MDP) (Sutton and Barto 2018). The state, action, and reward at timestep $t\\,\\in\\,(0,1,2,\\dots)$ is denoted by. $S_{t}~\\in{\\mathcal{S}}$ $A_{t}\\ \\in\\ A$ and $R_{t+1}\\in\\mathbb{R}$ respectively. We focus on the episodic setting where the goal of the agent is to maximize the discounted return $\\begin{array}{r}{G_{t}\\,=\\,\\sum_{k=0}^{T-t-1}\\gamma^{k}R_{t+k+1}}\\end{array}$ , where $\\gamma\\,\\in\\,[0,1]$ is a discount factor and $T$ the episode horizon. The agent selects an action $A_{t}$ according to a policy $\\pi(\\cdot|S_{t})$ where $\\pi(A|S)$ ", "page_idx": 1}, {"type": "text", "text": "gives the probability of sampling an action $A$ in state $S$ .Value functions are defined to be expected total discounted rewards from timestep $t$ ZT=t-1  Rt+b+1Sst =8 and g\u03c0(s, a) = $\\begin{array}{r}{\\mathbb{E}_{\\pi}\\left[\\sum_{k=0}^{T-t-1}\\gamma^{k}R_{t+k+1}|S_{t}=s,A_{t}=a\\right]\\!.}\\end{array}$ $\\theta$ $\\pi_{\\theta}$ such that it maximizes the expected return starting from initial states: $J(\\theta)\\doteq\\mathbb{E}_{S\\sim d_{0}}[v_{\\pi_{\\theta}}(S)]$ ", "page_idx": 2}, {"type": "text", "text": "Parameterized policies are typically learned based on the gradients of $J(\\theta)$ .Since the true gradients $\\nabla_{\\theta}J(\\theta)$ are typically not available, sample-based methods are commonly used for gradient estimation (Greensmith et al. 2004). Two existing theorems, known as policy gradient theorem and reparameterization gradient theorem provide ways of computing unbiased estimates of the gradient based on likelihood gradient (LG) estimators and reparameterization gradient (RG) estimators, respectively. ", "page_idx": 2}, {"type": "text", "text": "LG estimators use the log-derivative technique to provide an unbiased gradient estimate (Glynn 1990., Williams and Peng 1991): $\\nabla_{\\theta}\\mathbb{E}_{p_{\\theta}}[\\phi(X)]=\\mathbb{E}_{X\\sim p_{\\theta}}[\\phi(X)\\nabla_{\\theta}\\log p_{\\theta}(X)]$ , where $p_{\\theta}(x)$ is the probability density of $x$ with parameters $\\theta$ , and $\\phi(x)$ is a scalar-valued function. In the context of the policy gradient theorem (Sutton et al. 1999), the LG estimator is utilized to adjust the parameters $\\theta$ of a policy $\\pi$ , in expectation, in the direction of the gradient of the expected return: $\\mathbf{\\dot{\\nabla}}_{\\theta}J(\\theta)\\mathbf{\\theta}\\propto$ $\\mathbb{E}_{S\\sim d_{\\pi,\\gamma},A\\sim\\pi_{\\theta}}[\\nabla_{\\theta}\\log\\pi_{\\theta}(A|S)q_{\\pi_{\\theta}}(S,A)]$ , where $d_{\\pi,\\gamma}$ is the discounted stationary state distribution (Che et al. 2023). Many algorithms, including incremental ones like one-step actor-critic (IAC) and batch methods like A2C (Mnih et al. 2016), ACER (Wang et al. 2016) and PPO, are based on the policy gradient theorem and use the LG estimator. ", "page_idx": 2}, {"type": "text", "text": "RG estimators, also known as pathwise gradient estimators (Greensmith et al. 2004, Parmas and Sugiyama 2021), leverage the knowledge of the underlying density $p_{\\theta}(x)$ by introducing a simpler, equivalent sampling procedure: $\\bar{X}\\;\\sim\\;p_{\\theta}(\\cdot)\\;=\\;\\dot{f_{\\theta}(\\xi)\\dot{,}}\\,\\xi\\;\\sim\\;\\dot{g(\\cdot)}$ , where $\\xi$ is sampled from a base distribution $g(\\xi)$ independent of $\\theta$ , and $f_{\\theta}$ is a function that maps $\\xi$ to $X$ . RG estimation can be written as $\\overbar{\\nabla_{\\theta}}\\mathbb{E}_{p_{\\theta}}\\bar{[}\\phi(X)]\\,=\\,\\mathbb{E}_{\\xi\\sim g}[\\nabla_{\\theta}\\phi(f_{\\theta}(\\xi))]$ . RG estimators form the foundation of several batch RL algorithms, including Reward Policy Gradient (Lan et al. 2022), SAC and TD3. Lan et al. (2022) showed how RG estimation can be used to provide an alternative approach to unbiased estimation of the policy gradient through the reparametrization gradient theorem: $\\overset{\\cdot}{\\nabla}_{\\theta}J(\\theta)=\\mathbb{E}_{S\\sim d_{\\pi,\\gamma},A\\sim\\pi_{\\theta}}\\left[\\nabla_{\\theta}f_{\\theta}(\\xi;\\dot{S})|_{\\xi=h_{\\theta}(A;S)}^{\\texttt{\\small e-}}\\nabla_{A}q_{\\pi_{\\theta}}(\\breve{S},A)\\right]$ , where $h$ is a inverse function of $f$ ", "page_idx": 2}, {"type": "text", "text": "Deep reinforcement learning (RL) methods that use LG or RG estimators can often converge prematurely to sub-optimal policies (Mnih et al. 2016) or settle on a single output choice when multiple options could maximize the expected return (Williams and Peng 1991). This issue can be mitigated through entropy regularization, which promotes exploration and smoothens the optimization landscape under certain scenarios (Ahmed et al. 2019). This is accomplished by augmenting the reward function with an entropy term (i.e., $\\mathbb{E}[-\\log p_{\\theta}(X)])$ , encouraging the policy to maintain randomness in action selection. In this approach, the value functions are redefined as follows (Ziebart et al. 2010): $\\begin{array}{r}{v_{\\pi}^{\\mathrm{Ent}}(s)=\\mathbb{E}_{\\pi}\\left[\\sum_{k=0}^{T-t-\\hat{1}}\\gamma^{k}\\left(R_{t+k+1}+\\eta\\mathcal{H}(\\pi(\\cdot|S_{t+k}))\\right)|S_{t}=s\\right],}\\end{array}$ and $q_{\\pi}^{\\mathrm{Ent}}(s,a)=\\mathbb{E}_{\\pi}\\left[R_{t+1}+\\gamma v_{\\pi}^{\\mathrm{Ent}}(S_{t+1})|S_{t}=s,A_{t}=a\\right]$ , where $\\eta$ is the entropy coefficient and entropy $\\begin{array}{r}{\\mathcal{H}(\\pi(\\cdot|s))=-\\int_{A}\\pi(a|s)\\log\\pi(a|s)d a}\\end{array}$ ", "page_idx": 2}, {"type": "text", "text": "3  The Action Value Gradient Method ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this section, we introduce a novel algorithm called Action Value Gradient (AVG, see Alg. 1)\u00b2, outlining its key components and functionality and briefy discussing its theoretical foundations. We also discuss additional design choices that are crucial for robust and effective policy learning. AVG uses RG estimation, extended to incorporate entropy-augmented value functions: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\nabla_{\\theta}J(\\theta)=\\mathbb{E}_{S\\sim d_{\\pi,\\gamma},A\\sim\\pi_{\\theta}}\\left[\\nabla_{\\theta}f_{\\theta}(\\xi;S)|_{\\xi=h_{\\theta}(A;S)}\\nabla_{A}\\left(q_{\\pi_{\\theta}}(S,A)-\\eta\\log\\left(\\pi_{\\theta}(A|S)\\right)\\right].\\right.\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "A brief derivation of this statement is provided in Appendix A. ", "page_idx": 2}, {"type": "text", "text": "The AVG algorithm maintains a parameterized policy or actor $\\pi_{\\theta}(A|S)$ to sample actions from a continuous distribution and critic $Q_{\\phi}(S,A)$ that estimates the entropy-augmented action-value function. Both networks are parameterized using deep neural networks. AVG samples actions using the reparameterization technique (Kingma and Welling 2013), which allows the gradient to flow ", "page_idx": 2}, {"type": "text", "text": "through the sampled action $A_{\\theta}$ to the critic $Q_{\\phi}({\\bar{S_{,}}}A_{\\theta})$ , enabling the policy parameters $\\theta$ to be updated smoothly based on the critic. ", "page_idx": 3}, {"type": "text", "text": "We use the same action $A_{\\theta}$ to update both the actor and critic networks. First, the critic weights $\\phi$ are updated using the temporal difference error; $\\alpha_{Q}~>~0$ is its step size. This step also involves sampling another action $A^{\\prime}$ that is used to estimate the bootstrap target. Then, the actor updates its weights $\\theta$ based on $Q_{\\phi}(S,A_{\\theta})$ and the sample entropy $-\\log{\\left(\\pi_{\\theta}(\\dot{A}_{\\theta}|S)\\right)}$ .\uff0c $\\alpha_{\\pi}\\,>\\,0$ is the step size of the actor, and $\\eta\\geq0$ is used to weight the sample entropy term. ", "page_idx": 3}, {"type": "text", "text": "A careful reader may notice the similarity between the learning updates of SAC and AVG. However, SAC is an off-policy batch method, while AVG is an incremental onpolicy method. SAC samples actions and stores them in a replay buffer. Unlike AVG, SAC does not reuse the same action to backpropagate gradients for the actor. Additionally, AVG is simpler than SAC, as it avoids the use of double Q-learning or target $\\mathrm{Q}-$ networks (Van Hasselt et al. 2016) for stability. For comparison, we provide the pseudocode of an incremental variant of SAC, termed SAC-1 (Alg. 5). ", "page_idx": 3}, {"type": "text", "text": "We also use orthogonal initialization (Saxe et al. 2013), entropy regularization, a squashed normal policy, as is standard in off-policy actor-critic methods like DDPG, TD3, and SAC. To enforce action bounds, ", "page_idx": 3}, {"type": "text", "text": "Algorithm 1 Action Value Gradient (AVG) ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Initialize , n, Q\u03c0, QQ $\\theta$ $\\phi$ with penultimate normalization $\\begin{array}{l}{{n\\leftarrow0,\\mu\\leftarrow0,\\overline{{\\mu}}\\leftarrow0}}\\\\ {{n_{\\delta}\\leftarrow[0,0,0],\\mu_{\\delta}\\leftarrow[0,0,0],\\overline{{\\mu}}_{\\delta}\\leftarrow[0,0,0]}}\\end{array}$ for however many episodes do Initialize S (first state of the episode) $\\begin{array}{r}{\\begin{array}{l l}{S,n,\\mu,\\overline{{\\mu}},\\displaystyle-\\,\\mathrm{Normalize}(S,n,\\mu,\\overline{{\\mu}})}\\\\ {\\hfill\\qquad\\cap\\,\\hfill\\quad\\hat{\\alpha}}\\end{array}}\\end{array}$ $G\\gets0$ ", "page_idx": 3}, {"type": "text", "text": "", "page_idx": 3}, {"type": "text", "text": "while S is not terminal do $A_{\\theta}=f_{\\theta}(\\epsilon;S)$ where $\\mathbf{\\boldsymbol{\\epsilon}}\\sim\\mathcal{N}(\\mathbf{\\boldsymbol{0}},\\mathbf{\\boldsymbol{1}})$ Take action $A_{\\theta}$ ,observe $S^{\\prime},R$ $\\begin{array}{r l}&{S^{\\prime},n,\\mu,\\overline{{\\mu}},\\_{\\infty}\\leftarrow\\mathrm{{hormal\\,}i z e}(S^{\\prime},n,\\mu,\\overline{{\\mu}})}\\\\ &{\\sigma_{\\delta},n,\\mu,\\overline{{\\delta}},\\overline{{\\mu}}_{\\delta}\\leftarrow}\\\\ &{\\ S\\mathrm{cale}\\prod\\mathrm{for}\\mathrm{\\ensuremath{\\gamma}},\\emptyset,n_{\\delta},\\mu_{\\delta},\\overline{{\\mu}}_{\\delta})}\\\\ &{G\\leftarrow G+R}\\\\ &{A^{\\prime}\\sim\\pi\\theta(\\cdot|S^{\\prime})}\\\\ &{\\delta\\leftarrow R+\\gamma(Q_{\\phi}(S^{\\prime},A^{\\prime})-\\eta\\log\\pi_{\\theta}(A^{\\prime}|S^{\\prime}))}\\\\ &{\\quad-Q_{\\phi}(S,A_{\\theta})}\\\\ &{\\delta\\leftarrow\\delta/\\sigma_{\\delta}}\\\\ &{\\phi\\leftarrow\\phi-\\alpha_{Q}\\delta\\nabla_{\\phi}\\left(Q_{\\phi}(S,a)\\right|_{\\alpha=A_{\\theta}}}\\\\ &{\\theta\\leftarrow\\theta+\\alpha_{\\pi}\\nabla_{\\theta}(Q_{\\phi}(S,A_{\\theta})-\\eta\\log\\pi_{\\theta}(A_{\\theta}|S))}\\\\ &{S\\leftarrow S^{\\prime}}\\end{array}$ end while $\\begin{array}{r l}&{\\sigma_{\\delta},n_{\\delta},\\mu_{\\delta},\\overline{{\\mu}}_{\\delta}\\gets}\\\\ &{\\qquad\\mathrm{ScaleTDError}(R,0,G,n_{\\delta},\\mu_{\\delta},\\overline{{\\mu}}_{\\delta})}\\end{array}$ ", "page_idx": 3}, {"type": "text", "text": "", "page_idx": 3}, {"type": "text", "text": "end for ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "a squashed normal policy passes the sampled action from a normal distribution through the tanh function to obtain actions in the range $[-1,1]$ ${\\cal A}_{\\theta}\\,=\\,f_{\\theta}(\\xi;S)\\,=\\,\\mathtt{t a n h}(\\mu_{\\theta}(S)+\\xi\\sigma_{\\theta}(S))$ where $\\xi\\sim\\mathcal{N}(0,1)$ . This parameterization is particularly useful for entropy-regularized RL objectives. In an unbounded normal policy, the standard deviation $\\sigma$ has a monotonic relationship with entropy, such that maximizing the entropy often drives $\\sigma$ to large values, approximating a uniform random policy. Conversely, for a squashed univariate normal distribution, entropy increases with $\\sigma$ only up to a certain threshold, beyond which it begins to decrease (see Fig. 2). ", "page_idx": 3}, {"type": "text", "text": "Incremental methods can be particularly prone to issues stemming from large and noisy gradients. While off-policy batch methods such as SAC and TD3 benefit from many compute-intensive gradient updates, which effectively smooth out noisy gradients, incremental methods require alternative strategies to manage large gradient updates. Hence, we focus on additional incremental normalization and scaling methods that help stabilize the learning process. These techniques can be seamlessly incorporated into our algorithm with minimal computational overhead. Sec. 5 provides an in-depth discussion that motivates and comprehensively analyzes the impact of the normalization and scaling techniques used in our proposed algorithm. ", "page_idx": 3}, {"type": "text", "text": "Stable learning in AVG is achieved by normalizing inputs and hidden unit activations, as well as scaling the temporal difference error. ", "page_idx": 3}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/bf6e413e26eb187b0afdaf3fc42bc6623bf17fa150174975989665eca921add4.jpg", "img_caption": ["Figure 2: Effect of $\\sigma$ on entropy of normal and squashed normal distribution "], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "Below, we outline three normalization and scaling techniques used in AVG (more details in Sec. 5). ", "page_idx": 3}, {"type": "text", "text": "Observation normalization We normalize the observation, which is a commonly used technique in on-policy RL algorithms such as PPO to attain good learning performance. We use an online algorithm to estimate the sample mean and variance (Welford 1962, See Alg. 2). Sample running mean and variance are effective for stationary and transient distributions, enabling continuous updates that adapt to timevarying characteristics efficiently. In contrast, weighted means emphasize recent observations, making them ideal when recent data points hold greater importance. We use the sample running mean since standard continuous control benchmarks exhibit transient distributions for policies. ", "page_idx": 3}, {"type": "text", "text": "", "page_idx": 4}, {"type": "text", "text": "Penultimate Normalization Bjorck et al. (2022) suggest normalizing features $(\\psi_{\\boldsymbol\\theta}(S))$ of the penultimate layer of a neural network. These features are normalized into a unitvector $\\hat{\\psi}_{\\boldsymbol\\theta}({\\boldsymbol{S}})\\,=\\,\\psi_{\\boldsymbol\\theta}({\\boldsymbol{S}})/\\|\\psi_{\\boldsymbol\\theta}({\\boldsymbol{S}})\\|_{2}$ , with_gradients computed through the feature normalization. Unlike layer normalization (Ba et al. 2016), no mean subtraction is performed. ", "page_idx": 4}, {"type": "table", "img_path": "DX5GUwMFFb/tmp/385093e99fe709644185298fa5ec6c6d56d4ebb300db6694031854714efb146b.jpg", "table_caption": [], "table_footnote": [], "page_idx": 4}, {"type": "text", "text": "", "page_idx": 4}, {"type": "text", "text": "Scaling Temporal Difference Errors Schaul et al. (2021) proposed replacing raw temporal difference (TD) errors $\\delta_{t}$ by a scaled version: $\\smash{\\bar{\\delta}_{t_{\\alpha}}:=\\,\\delta_{t}/\\sigma_{\\delta}}$ where $\\bar{\\sigma_{\\delta}^{2}}:=\\mathbb{V}[R]+\\mathbb{V}[\\gamma]\\mathbb{E}[G^{2}]$ . This technique can handle varying episodic return scales across domains, tasks, and stages of learning. It is also algorithm-agnostic and does not require access to the internal states of an agent. In batch RL methods with a replay buffer, $\\sigma_{\\delta}$ can be computed offline by aggregating the discounted return from each state across stored episodes. However, in the incremental setting, where past data cannot be reused, this approach is infeasible. Consequently, we only use the cumulative return starting from the episode's initial state (See Alg. 3). We also use sample mean and variance of $R,\\gamma$ and $G^{2}$ to calculate $\\sigma_{\\delta}$ ", "page_idx": 4}, {"type": "table", "img_path": "DX5GUwMFFb/tmp/9fbb4adb99b7c28b2227b688afc8a5b24922bd301a911d7467a9f003a0825ef2.jpg", "table_caption": [], "table_footnote": [], "page_idx": 4}, {"type": "text", "text": "we provide a convergence analysis for the reparameterization gradient estimator, which the AVG estimator (1) builds upon. The analysis fixes errors in the convergence result for deterministic policies from Xiong et al. (2022) and extends it to the general case of reparameterized policies. To the best of our knowledge, this is the first convergence result for model-free methods that use the reparameterization gradient estimator. Furthermore, a detailed discussion of related theoretical results is also included in Appendix A. ", "page_idx": 4}, {"type": "text", "text": "4  AVG on Simulated Benchmark Tasks ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "In this section, we demonstrate the superior performance of AVG compared to existing incremental learning methods. Specifically, we compare AVG against an existing incremental method \u2014 IAC, which has demonstrated strong performance with linear function approximation in real-time learning across both simulated and real-world robot tasks (Degris et al. 2012, Vasan 2017). The implementation details can be found in Appendix E. Additionally, we evaluate AVG against incremental adaptations of SAC and TD3, both of which, like AVG, use RG estimation. ", "page_idx": 4}, {"type": "text", "text": "SAC and TD3 rely on large replay buffers to store and replay past experiences, a crucial feature for tackling challenging benchmark tasks. To adapt these batch-based methods to an incremental setting, we set the minibatch and replay buffer size to 1, allowing them to process each experience as it is encountered. We refer to these incremental variants as SAC-1 and TD3-1, respectively. We use off-the-shelf implementations of TD3 and SAC provided by CleanRL (Huang et al. 2022b). The choice of hyper-parameters and full learning curves can be found in the Appendix F. ", "page_idx": 4}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/30967525f637c5d27b06bda00f6aa3b8ba862b7b4d8735eb187d2f7c6bde343c.jpg", "img_caption": ["Figure 3: AVG on Gymnasium and DeepMind Control Suite tasks. Each solid learning curve is an average of 30 independent runs. The shaded regions represent a $95\\%$ confidence interval of the bootstrap distribution. Note that $S A C$ refers to SAC with a replay buffer size of $1M$ .The corresponding dashed line represents the mean performance over the final 10K steps of training. "], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "In Figure 3, we present the learning performance of AVG in comparison to IAC, SAC-1, and TD3-1. For reference, we also include the final performance of SAC with large replay buffers and default parameters, trained for $1M$ timesteps, indicated by the gray dashed line (referred to as $S A C$ ).Notably, AVG is the only incremental algorithm that learns effectively, achieving performance comparable to SAC in Gymnasium (Towers et al. 2023) environments and surpassing it in the Dog benchmarks from DeepMind Control Suite (Tassa et al. 2018). Nauman et al. (2024) suggests that non-default regularization, such as layer normalization is essential for SAC to perform well in the Dog domain. ", "page_idx": 5}, {"type": "text", "text": "To optimize the hyperparameters for each method\u2014AVG, IAC, SAC-1, and TD3-1, we conducted a random search, which is more efficient for high-dimensional search spaces than grid search (Bergstra and Bengio 2012). We evaluated 300 different hyperparameter configurations, each trained with 10 random seeds for $2M$ timesteps on five challenging continuous control environments: Ant- $\\cdot\\nu4$ Hopper-v4,HalfCheetah- $\\nu4$ Humanoid- $\\cdot\\nu4$ and Walker2d-v4. Each configuration was ranked based on its average undiscounted return per run, with the top-performing configuration selected for each environment. Using the best configuration, we then conducted longer training runs of 10 million timesteps with 30 random seeds. ", "page_idx": 5}, {"type": "text", "text": "Sparse reward environments can present additional challenges, often increasing both the difficulty and the time required for learning (Vasan et al. 2024). Hence, we also evaluate our algorithms on sparse reward environments from the DeepMind Control Suite. We use one unique hyper-parameter configuration per algorithm across four environments: finger_spin, dog_stand, dog_walk, dog_trot (see Fig. 3). Further details are provided in Appendix F.4. ", "page_idx": 5}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/6e2b89c3ac79c039c3b0d1502b27c59531c872e00488fddbd7ecf6b43960ff18.jpg", "img_caption": [], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "Learning From Pixels We use the visual reacher task to ensure that Figure 4: AVG and IAC on the AVG can be used with visual RL. In this task, the agent uses vision  Visual Reacher task and proprioception to reach a goal. As shown in Fig. 4, AVG consistently outperforms IAC, which exhibits high variance and struggles to learn. Task details are provided in Appendix B.3. ", "page_idx": 5}, {"type": "text", "text": "5 Stabilizing Incremental Policy Gradient Methods ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "In this section, we first highlight some issues with incremental policy gradient methods, which arise from the large and noisy gradients inherent to the setting. We perform a comprehensive ablation study to assess the effects of observation normalization, penultimate normalization, and TD error scaling individually and in combination\u2014on the performance of AVG. Additionally, we demonstrate how other incremental methods, such as IAC and SAC-1, may also benefit from normalization and scaling. ", "page_idx": 6}, {"type": "text", "text": "5.1  Instability  Without Normalization ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Deep RL can suffer from instability, often manifesting as high variance (Bjorck et al. 2022), reduced expressivity of neural networks over time (Nikishin et al. 2022, Sokar et al. 2023), or even a gradual drop in performance (Dohare et al. 2023, Elsayed and Mahmood 2024, Elsayed et al. 2024a), primarily due to the non-stationarity of data streams. Recently, Lyle et al. (2024) identified another common challenge that may induce difficulty in learning: the large regression target scale. For instance, in the Humanoid-v4 task, bootstrapped targets can range from $-20$ to 8000 during training. Consequently, the critic faces the difficult task of accurately representing values that fluctuate widely across different stages of training. This can lead to excessively large TD errors, destabilizing the learning process. ", "page_idx": 6}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/622abfd4f4c778562ac798f4c965e4c870511de06b917430183cd4d7adee6ef7.jpg", "img_caption": ["Figure 5: The gradient norm of the critic and actor networks for AVG and SAC, along with their average episodic returns. $A V G^{-}$ denotes AVG without any normalization or scaling applied. The solid lines represent the average, whereas the light lines represent the values for the individual runs. Note that the y-axis in the plots for actor and critic gradient norms is displayed on a logarithmic scale. "], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "Figure 5 illustrates a failure condition that can arise due to large regression target scale, high variance, and reduced expressivity \u2014- challenges that are particularly problematic for incremental methods. Here, we compare a successful SAC training run to a failed AVG run without normalization or scaling techniques (termed $A V G^{-}$ 0. While batch RL methods like SAC manage large, noisy gradients by smoothing them out through batch updates and improving stability with target Q-networks, incremental methods like AVG are more susceptible to numerically unstable updates, which can lead to failure or divergence in learning. $\\mathrm{AVG^{-}}$ exemplifies this issue by demonstrating excessively large gradient norms, particularly in the critic network, resulting in erratic gradients that hinder learning. ", "page_idx": 6}, {"type": "text", "text": "Building on these insights, we hypothesize that stable learning in AVG can be achieved by balancing update magnitudes across time steps and episodes, reducing the infuence of outlier experiences. This can be partly accomplished by centering and scaling the inputs, normalizing the hidden unit activations, and scaling the TD errors. Andrychowicz et al. (2021) show that appropriately scaling the observations can help improve performance, likely since it helps improve learning dynamics (Sutton 1988, Schraudolph 2002, LeCun et al. 2002). Scaling both the targets (e.g., by scaling the rewards, Engstrom et al. 2019) and the observations (e.g., normalization, Andrychowicz et al. 2021) is a well-established strategy that has shown success and is incorporated into widely used algorithms such as PPO (Schulman et al. 2017), helping improve its performance and stability (Rao et al. 2020, Huang et al. 2022a). ", "page_idx": 6}, {"type": "text", "text": "5.2  Disentangling the Effects of Normalization and Scaling ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "A combination of three techniques consistently achieves good performance for AVG: 1) TD error scaling (Schaul et al. 2021) to resolve the issue of large bootstrapped target scale (termed scaled_td, 2) observation normalization to maintain good learning dynamics (termed norm_obs, and 3) penultimate ", "page_idx": 6}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/3e28fdfc0ddca957730ceee1b08bbe5a19a5332988106ab7b59f869039af3d9c.jpg", "img_caption": [], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "Figure 6: Ablation study of normalization and scaling techniques used with AVG. We plot the learning curves of the best hyperparameter configurations for each task variant. Each solid learning curve is an average of 30 independent runs. The shaded regions represent a $95\\%$ confidence interval. ", "page_idx": 7}, {"type": "text", "text": "normalization to reduce instability and improve plasticity (termed pnorm, Bjorck et al. 2022), similar to layer normalization (Lyle et al. 2023). We selected Welford's online algorithm for normalizing observations due to its unbiased nature and its ability to maintain statistics across the entire data stream. In preliminary experiments, weighted methods that favored more recent samples did not perform well. Schaul et al. (2021) illustrate the risks associated with clipping or normalizing rewards, which led us to adopt their straightforward approach of scaling the temporal difference error with a multiplicative factor. Additionally, we favored pnorm over layer normalization since it performed better empirically in our experiments (see Fig. 13, App. B.2). It is worth noting that alternative normalization techniques could potentially achieve similar, if not superior, outcomes. Our focus here is to emphasize the importance of normalization and scaling issues and propose easy-to-use solutions. ", "page_idx": 7}, {"type": "text", "text": "We conduct an ablation study to evaluate the impact of the three techniques\u2014-norm_obs, pnorm and scaled_td\u2014on the performance of AVG. We assess these techniques both individually and in combination, resulting in a total of 8 variants. The learning curves for the best seed obtained via our random search procedure (detailed in App. F.4) for each variant are shown in Fig. 6. The combination of all three techniques achieves the best overall performance. ", "page_idx": 7}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/a3aea5fb6c60f9a1ea3558b64599a3eaa79f1e63f3734e22248bfc1091ab6795.jpg", "img_caption": ["Figure 7: Impact of normalization and scaling on IAC, SAC-1 and TD3-1. Suffix $\"+\"$ denotes each algorithm plus normalization and scaling. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "In Fig. 7, we assess the impact of our proposed normalization and scaling techniques on IAC, SAC-1 and TD3-1. While $\\mathrm{LAC^{+}}$ performs in a mostly comparable manner to AvG, $S\\mathrm{AC}{-1^{+}}$ showsinconsistent performance, performing well in only two tasks but failing or even diverging in environments such as Hopper-v4 and Walker2d-v4. TD3- $1^{+}$ fails to learn in all environments. ", "page_idx": 8}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/4788655f395da2c04ccdcf701ac3a9cc9d6f5415688a7ef8ca4912ffe037f3ca.jpg", "img_caption": ["5.3 AVG with Target Q-Networks ", "Figure 8: Impact of target Q network on AVG for different values of $\\tau$ , which represents the Polyak averaging coefficient. Here, $\\tau=0$ corresponds to a fixed target network, and $\\tau=1$ indicates that the current Q-network and the target network are identical, that is, not using a target network. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "Target networks are commonly used in off-policy batch methods to stabilize learning (Mnih et al. 2015). By using a separate network that is updated less frequently, target networks introduce a delay in the propagation of value estimates. This delay can be advantageous in batch methods with large replay buffers, as it helps maintain a more stable target (Lillicrap et al. 2015, Fujimoto et al. 2018). However, this delayed update can slow down learning in online RL (Kim et al. 2019). ", "page_idx": 8}, {"type": "text", "text": "In Figure 8, we evaluate the impact of using target Q-networks with AVG. Similar to SAC, we use Polyak averaging to update the target Q-network: $\\phi_{\\mathrm{target}}=(1-\\tau)\\cdot\\phi_{\\mathrm{target}}+\\tau\\cdot\\phi$ We run an experiment varying $\\tau$ between $[0,1]$ , where $\\tau=0$ denotes a fixed target network and $\\tau=1$ implies the target network is identical to the current Q-network. We detail the pseudocode in Appendix C (see Alg. 4). The results show no benefit to using target networks, with only large values of $\\tau$ performing comparably to AVG. Additionally, removing target networks reduces memory usage and simplifies the implementation of our algorithm. ", "page_idx": 8}, {"type": "text", "text": "6  AVG with Resource-Constrained Robot Learning ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "On-device  learning enables mobile robots to continuously improve, adapt to new data, and handle unforeseen situations, which is crucial for tasks like autonomous navigation and object recognition. Commercial robots, such as the iRobot Roomba, often use onboard devices with limited memory, ranging from microcontrollers with kilobytes of memory to more powerful edge devices like the Jetson Nano 4GB. Leveraging these onboard edge devices can reduce the need for constant server communication, enhancing reliability in areas with limited ", "page_idx": 8}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/ff60370da5802e4f6ba894586034029b1238d5bdabb4134e64eaa1628611be10.jpg", "img_caption": [], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "connectivity. Storing large replay buffers on these devices is infeasible, necessitating computationally efficient, incremental algorithms. ", "page_idx": 8}, {"type": "text", "text": "To demonstrate the effectiveness of our proposed AVG algorithm for on-device incremental deep RL, we utilize the UR-Reacher-2 and Create-Mover tasks, as developed by Mahmood et al. (2018). We use two robots: UR5 robotic arm and iRobot Create 2, a hobbyist version of Roomba. In the UR-Reacher-2 task, the agent aims to reach arbitrary target positions on a 2D plane (Fig. 9a). This task is a real-world adaptation of the Mujoco Reacher task. In the Create-Mover task, the agent's goal is to move the robot forward as fast as possible within an enclosed arena. A representative image of the desired behavior is shown in Fig. 9b. Each run requires slightly over two hours of robot experience time on both robots. In our learning curves (see Fig. 10), the dark lines represent the average over five runs for AVG, whereas the light lines represent the values for the individual runs. Details of the setup can be found in Appendix H. ", "page_idx": 8}, {"type": "text", "text": "", "page_idx": 9}, {"type": "text", "text": "The performance of AVG and resource-constrained SAC on URReacher-2 is shown in Fig. 10 (top). We term the resourceconstrained variants of SAC as SAC-1 and SAC-1oO, where the suffix indicates both the replay buffer capacity and mini-batch size used during training. Note that SAC-1 is incremental, but SAC-100 is still a batch method with limited memory resources. In these experiments, both SAC-100 and SAC-1 struggle significantly, failing to learn under the imposed memory limitations. In contrast, AVG demonstrates robust performance, efficiently utilizing limited memory to achieve fast and superior learning. ", "page_idx": 9}, {"type": "text", "text": "On the mobile robot task Create-Mover, the learning system is limited to onboard computation using a Jetson Nano 4GB. This introduces additional compute constraints in terms of action sampling time and learning update time. Our implementation requires $5m s$ to sample an action for both AVG and SAC-1. On the other hand, for learning updates, AVG requires only about $37m s$ per update, compared to SAC-1's $67m s$ A batch update for SAC would exceed the action cycle time $(150m s)$ forCreateMover. Hence, we compare AVG only against SAC-1. The learning curves on the Create-Mover task in Fig. 10 (bottom) clearly show AVG's superior performance, while SAC-1 fails to learn any meaningful policy. This highlights AVG's efficiency and suitability for real-time learning in resource-constrained environments. Our work demonstrates for the first time effective real-robot learning with incremental deep reinforcement learning methods3. ", "page_idx": 9}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/99f10e914d89e88d422d74a0071c4ebaa08038ae6636df85ca619857c4bdc2bb.jpg", "img_caption": ["Figure 10: Learning curves on Real Robot Tasks "], "img_footnote": [], "page_idx": 9}, {"type": "text", "text": "", "page_idx": 9}, {"type": "text", "text": "7 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "This work revives incremental policy gradient methods for deep RL and offers significant computational advantages over standard batch methods for onboard robotic applications. We introduced a novel incremental algorithm called Action Value Gradient (AVG) and demonstrated its ability to consistently outperform other incremental and resource-constrained batch methods across a range of benchmark tasks. Crucially, we showed how normalization and scaling techniques enable AVG to achieve robust learning performance even on challenging high-dimensional control problems. Finally, we presented the first successful application of an incremental deep RL method learning control policies from scratch directly on physical robots\u2014a robotic manipulator and a mobile robot. Overall, our proposed AVG algorithm opens up new possibilities for deploying deep RL with limited onboard computational resources of robots, enabling lifelong learning and adaptation in the real world. ", "page_idx": 9}, {"type": "text", "text": "Limitations and Future Work The main limitation of our approach is low sample efficiency compared to batch methods. Developing AVG with eligibility traces (Singh and Sutton 1996, van Hasselt et al. 2021) is a natural future direction to generalize our one-step AVG and possibly improve its sample efficiency. We also find that AVG can be sensitive to the choice of hyper-parameters. A valuable extension would be stabilizing the algorithm to perform well across environments using the same hyper-parameters. Our work is limited to continuous action space, but it can also be extended to discrete action spaces following Jang et al. (2017), which we leave to future work. Additionally, AVG omits discounting in the state distribution, which is common and further biases the update but can be addressed with the correction proposed by Che et al. (2023). Finally, we acknowledge a concurrent work by Elsayed et al. (2024b), which stabilizes existing incremental methods like $\\bar{\\bf A}\\bar{\\bf C}(\\lambda)$ and $\\boldsymbol{\\mathrm{Q}}(\\lambda)$ except for reparameterization policy gradient methods. The robustness of AVG may potentially improve by replacing Adam with an optimizer for adaptive step sizes proposed in that work. ", "page_idx": 9}, {"type": "text", "text": "Societal Impact Our paper presents academic findings, but the proposed algorithm offers new opportunities for deploying deep reinforcement learning on robots with limited computational resources. This enables lifelong learning and real-world adaptation, advancing the development of more capable autonomous agents. While our contributions themselves do not cause negative societal effects, we advise the community to reflect on possible consequences as they expand upon our research. ", "page_idx": 10}, {"type": "text", "text": "Acknowledgements We thank all reviewers for their insightful comments and suggested experiments, which strengthened both the content and presentation of our paper. We would also like to thank Shibhansh Dohare, Kris De Asis, Homayoon Farrahi, Varshini Prakash, and Shivam Garg for their helpful discussions. We are also appreciative of the computing resources provided by the Digital Research Alliance of Canada and the financial support from the CCAI Chairs program, the RLAI laboratory, Amii, and NSERC of Canada. ", "page_idx": 10}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "Ahmed, Z., Le Roux, N., Norouzi, M., and Schuurmans, D. (2019). Understanding the impact of entropy on policy optimization. In International conference on machine learning, pages 151-160. PMLR. ", "page_idx": 10}, {"type": "text", "text": "Akkaya, I., Andrychowicz, M., Chociej, M., Litwin, M., McGrew, B., Petron, A., Paino, A., Plappert, M., Powell, G., Ribas, R., et al. (2019). Solving rubik's cube with a robot hand. arXiv preprint arXiv:1910.07113.   \nAndrychowicz, M., Raichuk, A., Stanczyk, P., Orsini, M., Girgin, S., Marinier, R., Hussenot, L., Geist, M., Pietquin, O., Michalski, M., et al. (2021). What matters in on-policy reinforcement learning? a large-scale empirical study. In International Conference on Learning Representations.   \nBa, J. L., Kiros, J. R., and Hinton, G. E. (2016). Layer normalization. arXiv preprint arXiv: 1607.06450.   \nBergstra, J. and Bengio, Y. (2012). Random search for hyper-parameter optimization. Journal of machine learning research, 13(2).   \nBhandari, J., Russo, D., and Singal, R. (2018). A finite time analysis of temporal difference learning with linear function approximation. In Conference on Learning Theory (COLT).   \nBhatnagar, S., Ghavamzadeh, M., Lee, M., and Sutton, R. S. (2007). Incremental natural actor-critic algorithms. Advances in neural information processing systems, 20.   \nBjorck, J., Gomes, C. P., and Weinberger, K. Q. (2022). Is high variance unavoidable in rl? a case study in continuous control. International Conference on Learning Representations.   \nCen, S., Cheng, C., Chen, Y, Wei, Y., and Chi, Y. (2022). Fast global convergence of natural policy gradient methods with entropy regularization. Operations Research, 70(4):2563-2578.   \nChe, F., Vasan, G., and Mahmood, A. R. (2023). Correcting discount-factor mismatch in on-policy policy gradient methods. In International Conference on Machine Learning, pages 4218-4240. PMLR.   \nDegrave, J., Felici, F, Buchli, J., Neunert, M., Tracey, B., Carpanese, F., Ewalds, T., Hafner, R., Abdolmaleki, A., de Las Casas, D., et al. (2022). Magnetic control of tokamak plasmas through deep reinforcement learning. Nature, 602(7897):414 419.   \nDegris, T., Pilarski, P. M., and Sutton, R. S. (2012). Model-free reinforcement learning with continuous action in practice. In 2012 American control conference (ACC), pages 2177-2182. IEEE.   \nDing, Y., Zhang, J., and Lavaei, J. (2021). Beyond exact gradients: Convergence of stochastic soft-max policy gradient methods with entropy regularization. arXiv preprint arXiv:2110.10117.   \nDohare, S., Lan, Q., and Mahmood, A. R. (2023). Overcoming policy collapse in deep reinforcement learning. In Sixteenth European Workshop on Reinforcement Learning.   \nD'Oro, P., Schwarzer, M., Nikishin, E., Bacon, P-L., Bellemare, M. G., and Courville, A. (2022). Sample-eficient reinforcement learning by breaking the replay ratio barrier. In Deep Reinforcement Learning Workshop NeurIPS 2022.   \nElsayed, M., Lan, Q., Lyle, C., and Mahmood, A. R. (2024a). Weight clipping for deep continual and reinforcement learning. Reinforcement Learning Journal, 5:2198-2217.   \nElsayed, M. and Mahmood, A. R. (2024). Addressing loss of plasticity and catastrophic forgetting in continual learning. In International Conference on Learning Representations.   \nElsayed, M., Vasan, G., and Mahmood, A.R. (2024b). Streaming deep reinforcement learning fnally works. arXiv preprint arXiv:2410.14606.   \nEngstrom, L., Ilyas, A., Santurkar, S., Tsipras, D., Janoos, F., Rudolph, L., and Madry, A. (2019). Implementation matters in deep rl: A case study on ppo and trpo. In International conference on learning representations.   \nFan, K., Wang, Z., Beck, J., Kwok, J., and Heller, K. A. (2015). Fast second order stochastic backpropagation for variational inference. Advances in Neural Information Processing Systems, 28.   \nFujimoto, S., Hoof, H., and Meger, D. (2018). Addressing function approximation error in actor-critic methods. In International conference on machine learning, pages 1587-1596. PMLR.   \nGlynn, P. W. (1990). Likelihood ratio gradient estimation for stochastic systems. Communications of the ACM, 33(10):75-84.   \nGreensmith, E., Bartlett, P. L., and Baxter, J. (2004). Variance reduction techniques for gradient estimates in reinforcement learning. Journal of Machine Learning Research, 5(9).   \nHaarnoja, T., Zhou, A., Abbeel, P., and Levine, S. (2018). Soft actor-critic: Off-policy maximum entropy deep reinforcement learning with a stochastic actor. In International conference on machine learning, pages 1861-1870. PMLR.   \nHayes, T L. and Kanan, C. (2022). Online continual learning for embedded devices. In Conference on Lifelong Learning Agents, pages 744-766. PMLR.   \nHuang, S., Dossa, R. F. J., Raffin, A., Kanervisto, A., and Wang, W. (2022a). The 37 implementation details of proximal policy optimization. The ICLR Blog Track 2023.   \nHuang, S., Dossa, R.F. J., Ye, C., Braga, J., Chakraborty, D., Mehta, K., and AraAsjo, J. G. (2022b). Cleanrl: High-quality single-file implementations of deep reinforcement learning algorithms. Journal of Machine Learning Research, 23(274):1-18.   \nJang, E., Gu, S., and Poole, B. (2017). Categorical reparameterization with gumbel-softmax. In International Conference on Learning Representations.   \nJi, Y, Margolis, G. B., and Agrawal, P. (2023). Dribblebot: Dynamic legged manipulation in the wild. In2023 IEEE International Conference on Robotics and Automation (ICRA), pages 5155-5162. IEEE.   \nKim, S., Asadi, K., Litman, M., and Konidaris, G. (2019). Deepmellow: removing the need for a target network in deep q-learning. In Proceedings of the twenty eighth international joint conference on artificial intelligence.   \nKingma, D. P and Welling, M. (2013). Auto-encoding variational bayes. arXiv preprint arXiv: 1312.6114.   \nLan, Q., Tosatto, S., Farrahi, H., and Mahmood, A. R. (2022). Model-free policy learning with reward gradients. Proceedings of The 25th International Conference on Artificial Intelligence and Statistics (AISTATS).   \nLeCun, Y.,Bottou, L., Orr, G. B., and Muiller, K.-R. (2002). Efficient backprop. In Neural networks: Tricks of the trade, pages 9-50. Springer.   \nLevine, S., Finn, C., Darrell, T., and Abbeel, P. (2016). End-to-end training of deep visuomotor policies. Journal of Machine Learning Research, 17(39):1-40.   \nLillicrap, T. P., Hunt, J. J., Pritzel, A., Heess, N., Erez, T., Tassa, Y., Silver, D., and Wierstra, D. (2015). Continuous control with deep reinforcement learning. arXiv preprint arXiv:1509.02971.   \nLyle, C., Zheng, Z., Khetarpal, K., van Hasselt, H., Pascanu, R., Martens, J., and Dabney, W. (2024). Disentangling the causes of plasticity loss in neural networks. arXiv preprint arXiv:2402.18762.   \nLyle, C., Zheng, Z., Nikishin, E., Pires, B. A., Pascanu, R., and Dabney, W. (2023). Understanding plasticity in neural networks. In International Conference on Machine Learning, pages 23190 23211. PMLR.   \nMahmood, A. (2017). Incremental Of-policy Reinforcement Learning Algorithms. PhD thesis, University of Alberta.   \nMahmood, A. R., Korenkevych, D., Vasan, G., Ma, W., and Bergstra, J. (2018). Benchmarking reinforcement learning algorithms on real-world robots. In Conference on robot learning, pages 561-591. PMLR.   \nMei, J., Xiao, C., Szepesvari, C., and Schuurmans, D. (2020). On the global convergence rates of softmax policy gradient methods. In International conference on machine learning, pages 6820-6829. PMLR.   \nMichieli, U. and Ozay, M. (2023). Online continual learning for robust indoor object recognition. In 2023 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), pages 3849-3856.IEEE.   \nMitrophanov, AY. (2005). Sensitivity and convergence of uniformly erodic Markv chains. Joual of Applied Probability, 42(4):1003-1014.   \nMnih, V., Badia, A. P, Mirza, M., Graves, A., Lillicrap, T., Harley, T., Silver, D., and Kavukcuoglu, K. (2016). Asynchronous methods for deep reinforcement learning. In International conference on machine learning, pages 1928-1937. PMLR.   \nMnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., Graves, A., Riedmiller, M, Fidjeland, A. K., Ostrovski, G., et al. (2015). Human-level control through dep reinforcement learning. nature, 518(7540):529-533.   \nModayil J,Whit, A, and Suton,R.S. 2014). Multi-tmescale nexting a reforment lang robot. Adaptive Behavior, 22(2):146-160.   \nNauman, M., Bortkiewicz, M., Ostaszewski, M., Milos, P., Trzcinski, T., and Cygan, M. (2024). Overestmaton, overiting, and plasticity in actor-cric: the bitterlessnof renforcment laing. arXiv preprint arXiv:2403.00514.   \nNikishin, E., Schwarzer, M., D'Oro, P., Bacon, P-L., and Courville, A. (2022). The primacy bias in deep reinforcement learning. In International conference on machine learning, pages 16828-16847. PMLR.   \nNota, C. and Thomas, P. S. (2019). Is the policy gradient a gradient? arXiv preprint arXiv:1906.07073.   \nParmas, P. and Sugiyama, M. (2021). A unified view of likelihood ratio and reparameterization gradients. In International Conference on Artifcial Inteligence and Statistics, pages 4078-4086. PMLR.   \nRao, N., Aljalbout, E., Sauer, A., and Haddadin, S. (2020). How to make deep rl work in practice. arXiv preprint arXiv:2010.13083.   \nSaxe, A. M., McClelland, J. L., and Ganguli, S. (2013). Exact solutions to the nonlinear dynamics of learning in deep linear neural networks. arXiv preprint arXiv:1312.6120.   \nSchaul, T., Ostrovski, G., Kemaev, I., and Borsa, D. (2021). Return-based scaling: Yet another normalisation trick for deep rl. arXiv preprint arXiv:2105.05347.   \nSchraudolph, N. N. (2002). Centering neural network gradient factors. In Neural Networks: Tricks of the Trade, pages 207-226. Springer.   \nSchulman, J, Wolski, F, Dhariwal, P, Radford, A7, and Klimov, O. (2017). Proximal policy optimization algorithms. arXiv preprint arXiv: 1707.06347.   \nSchwarzer, M, Ceron, J. S. O., Courville, A., Bellemare, M. G, Agarwal, R., and Castro, P S. (2023). Bigger, better, faster: Human-level atari with human-level effciency. In Intenational Conference on Machine Learning, pages 30365-30380. PMLR.   \nSeyde, T., Gilitschenski, I., Schwarting, W., Stellato, B., Riedmiller, M., Wulfmeier, M., and Rus, D. (2021). Is bang-bang control all you need? solving continuous control with bernoulli policies. Advances in Neural Information Processing Systems, 34:27209-27221.   \nSilver, D., Lever, G., Heess, N., Degris, T., Wierstra, D., and Riedmiller, M. (2014). Deterministic policy gradient algorithms. In International conference on machine learning, pages 387-395. Pmlr.   \nSingh, S. P. and Sutton, R. S. (1996). Reinforcement learning with replacing eligibility traces. Machine learning, 22(1):123-158.   \nSokar, G., Agarwal, R., Castro, P. S., and Evci, U. (2023). The dormant neuron phenomenon in deep reinforcement learning. In International Conference on Machine Learning, pages 32145-32168. PMLR.   \nSutton, R. (1988). Nadaline: A normalized adaptive linear element that learns effciently. GTE TR88-509.4), GTE Laboratories Incorporated.   \nSutton, R. S. and Barto, A. G. (2018). Reinforcement learning: An introduction. MIT press.   \nSutton, R. S., McAllester, D., Singh, S., and Mansour, Y. (1999). Policy gradient methods for reinforcement learning with function approximation. Advances in neural information processing systems, 12.   \nTassa, Y, Doron, Y., Muldal, A., Erez, T., Li, Y, Casas, D. d. L., Budden, D., Abdolmaleki, A., Merel, J., Lefrancq, A., et al. (2018). Deepmind control suite. arXiv preprint arXiv: 1801.00690.   \nTodorov, E., Erez, T, and Tassa, Y. (2012). Mujoco: A physics engine for model-based control. In2012 IEEE/RSJ international conference on inteligent robots and systems, pages 5026-5033. IEEE.   \nTowers, M., Terry, J. K., Kwiatkowski, A., Balis, J. U., Cola, G. d., Deleu, T., Goulao, M., Kallinteris, A., KG, A., Krimmel, M., Perez-Vicente, R., Pierr\u00e9, A., Schulhoff, S., Tai, J. J., Shen, A. T. J., and Younis, O. G. (2023). Gymnasium.   \nTsitsiklis, J. N. and Van Roy, B. (1997). An analysis of temporal-difference learning with function approximation. IEEE Transactions on Automatic Control, 42(5):674 - 690.   \nTu, S. and Recht, B. (2019). The gap between model-based and model-free methods on the linear quadratic regulator: An asymptotic viewpoint. In Conference on Learning Theory (COLT), pages 3036-3083.   \nVan Hasselt, H., Guez, A., and Silver, D. (2016). Deep reinforcment learning with double q-learing. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 30. AAAI Press.   \nvan Hasselt, H., Madjiheurem, S., Hessel, M, Silver, D., Barreto, A., and Borsa, D. (2021). Expected eligibility traces. In Proceedings of the AAAl Conference on Artificial Intelligence, volume 35, pages 9997-10005.   \nVasan, G. (2017). Teaching a powered prosthetic arm with an intact arm using reinforcement learning. MSc Thesis, University of Alberta.   \nVasan, G. and Pilarski, P M. (2017). Learning from demonstration: Teaching a myoelectric prosthesis with an intact limb via reinforcement learning. In 2017 International Conference on Rehabilitation Robotics (ICORR), pages 1457-1464. IEEE.   \nVasan, G., Wang, Y, Shahriar, F., Bergstra, J., Jagersand, M., and Mahmood, A. R. (2024). Revisiting sparse rewards for goal-reaching reinforcement learning. Reinforcement Learning Journal, 4:1841- 1854.   \nVerma, V., Maimone, M. W., Gaines, D. M., Francis, R., Estlin, T. A., Kuhn, S. R., Rabideau, G. R., Chien, S. A., McHenry, M. M., Graser, E. J., et al. (2023). Autonomous robotics is driving Perseverance rover's progress on Mars. Science Robotics, 8(80):eadi3099.   \nVijayakumar, S., D'souza, A., and Schaal, S. (2005). Incremental online learning in high dimensions. Neural computation, 17(12):2602-2634.   \nWang, Y., Vasan, G., and Mahmood, A. R. (2023). Real-time reinforcement learning for vision-based robotics utilizing local and remote computers. In 2023 IEEE International Conference on Robotics and Automation (ICRA), pages 9435-9441. IEEE.   \nWang, Z., Bapst, V., Heess, N., Mnih, V., Munos, R., Kavukcuoglu, K., and De Freitas, N. (2016). Sample efficient actor-critic with experience replay. arXiv preprint arXiv: 1611.01224.   \nWelford, B. (1962). Note on a method for calculating corrected sums of squares and products. Technometrics, 4(3):419-420.   \nWilliams, R. J. and Peng, J. (1991). Function optimization using connectionist reinforcement learning algorithms. Connection Science, 3(3):241-268.   \nXiong, H., Xu, T., Liang, Y., and Zhang, W. (2020). Non-asymptotic convergence of adam-type reinforcement learning algorithms under markovian sampling. arXiv preprint arXiv:2002.06286.   \nXiong, H., Xu, T., Zhao, L., Liang, Y., and Zhang, W. (2022). Deterministic policy gradient: Convergence analysis. In Uncertainty in Artificial Intelligence, pages 2159-2169. PMLR.   \nYoung, K. and Tian, T. (2019). Minatar: An atari-inspired testbed for thorough and reproducible reinforcement learning experiments. arXiv preprint arXiv: 1903.03176.   \nYuan, Y. and Mahmood, A. R. (2022). Asynchronous reinforcement learning for real-time control of physical robots. In 2022 International Conference on Robotics and Automation (ICRA), pages 5546-5552.IEEE.   \nZhang, B. and Sennrich, R. (2019). Root mean square layer normalization. Advances in Neural Information Processing Systems, 32.   \nZiebart, B. D., Bagnell, J. A., and Dey, A. K. (2010). Modeling interaction via the principle of maximum causal entropy. In International conference on machine learning. PMLR. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "", "page_idx": 14}, {"type": "text", "text": "A Theoretical Foundations ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "A.1  Reparameterization Policy Gradient Theorem ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Please refer to the Theorems and Proofs section of Lan et al. (2022) for detailed proofs. We only provide a short proof sketch for reference. ", "page_idx": 15}, {"type": "text", "text": "Theorem 1 (Reparameterization Policy Gradient Theorem). Given an MDP and a policy objective $\\begin{array}{r}{J(\\theta)\\doteq\\int d_{0}(s)\\bar{v}_{\\pi_{\\theta}}(s)d s}\\end{array}$ The reparameterization policy gradient is given as ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\nabla_{\\theta}J(\\theta)=\\mathbb{E}_{S\\sim d_{\\pi,\\gamma},A\\sim\\pi_{\\theta}}\\left[\\nabla_{\\theta}f_{\\theta}(\\xi;S)\\vert_{\\xi=h_{\\theta}(A;S)}\\nabla_{A}q_{\\pi_{\\theta}}(S,A)\\right].\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Proof. ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\nabla_{\\theta}J(\\theta)=\\nabla_{\\theta}\\int d_{0}(\\theta)v_{\\theta_{\\theta_{\\theta}}}(s)d s}\\\\ &{\\quad=\\nabla_{\\theta}\\int d_{0}(s)\\left(\\int_{d\\tau_{*}(s)}\\pi_{\\theta}(a)|\\partial_{\\pi_{*}}(s,a)d a\\,d s\\right)d s}\\\\ &{\\quad=\\nabla_{\\theta}\\int d_{0}(s)\\left(\\int\\mathcal{A}_{\\pi_{*}(s)}(s)p(\\xi)q_{\\theta_{\\theta}}(s,f_{\\theta}(\\xi_{*}))d\\xi\\,d s\\right)d s}\\\\ &{\\quad=\\int d_{0}(s)\\left(\\int d_{\\pi_{*}(s)}(y)\\xi(y)q_{\\theta_{\\theta}}(s,f_{\\theta}(\\xi_{*}))d\\xi\\,d s\\right)d s}\\\\ &{\\quad=\\int d_{0}(s)\\left(\\int d_{\\pi_{*}(s)}(y)\\xi(y)f_{\\theta}(\\xi_{*})\\nabla_{\\theta}(a,(s,0)[\\partial_{\\pi_{*}}(s,a)]_{a=\\pi_{*}(s)}d\\xi\\,d s\\right)d s}\\\\ &{\\quad\\propto\\int d_{\\pi_{*}(s)}(s)p(\\xi)\\nabla_{\\theta}f_{\\theta}(\\xi_{*})\\nabla_{\\theta}q_{\\theta_{*}}(s,a)|_{a=\\pi_{*}(s)}d s\\,d s}\\\\ &{\\quad=\\int d_{\\pi_{*}(s)}(s)\\pi_{\\theta}(a)\\nabla_{\\theta}f_{\\theta}(\\xi_{*})|_{a=\\pi_{*}(s)}\\nabla_{\\theta}q_{\\theta_{*}}(s,a)|_{a=\\pi_{*}(s)}d s}\\\\ &{\\quad=\\mathbb{E}_{s\\sim d_{\\pi_{*}(s)}\\sim\\pi_{*}(\\nabla_{\\theta}f_{\\theta}(\\xi_{*}))\\mid c=b\\in\\pi_{*}(s)}\\nabla_{\\theta}q_{\\theta_{*}}(s,a)|_{a=\\pi_{*}(s)}d s}\\\\ &{\\quad=\\mathbb{E}_{s\\sim d_{\\pi_{*}(s)}\\sim\\pi_{*}(\\nabla_{\\theta}f_{\\theta}(\\xi_{*}))\\mid c=b\\in\\pi_{*}(s)}\\nabla_{\\theta}q_{\\theta_{*}}(s,a)|_{a=\\pi_{*}(s)}\\}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "A.2 Action Value Gradient Theorem ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Theorem 2 (Action Value Gradient Theorem). Given an MDP and a policy objective $\\begin{array}{r}{J(\\theta)\\doteq\\int d_{0}(s)v_{\\pi_{\\theta}}^{E n t}(s)d s}\\end{array}$ . The action value gradient is given as ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\nabla_{\\theta}J(\\theta)=\\mathbb{E}_{S\\sim d_{\\pi,\\gamma},A\\sim\\pi_{\\theta}}\\left[\\nabla_{\\theta}f_{\\theta}(\\xi;S)|_{\\xi=h_{\\theta}(A;S)}\\nabla_{A}(q_{\\pi_{\\theta}}(S,A)-\\eta\\log\\pi_{\\theta}(A|S))\\right].\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Proof. ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\gamma_{\\theta}\\mathcal{I}(\\theta)=\\nabla_{\\theta}\\int d_{0}(s)\\nu\\frac{\\mathbb{E}\\mathbb{H}(s)}{\\pi_{\\theta}}\\omega\\big|\\,d s}\\\\ &{\\quad\\quad=\\nabla_{\\theta}\\int d_{0}(s)\\left(\\int\\mathcal{A}_{\\pi_{\\theta}}(s)\\pi_{\\theta}(a(s))(q_{\\pi_{\\theta}}(s,a)-\\eta\\mathcal{H}(\\cdot|s))d a\\,d s\\right)\\,d s}\\\\ &{\\quad\\quad=\\nabla_{\\theta}\\int d_{0}(s)\\left(\\int\\mathcal{A}_{\\pi_{\\theta}}(s)\\pi_{\\theta}(a(s))(q_{\\pi_{\\theta}}(s,a)-\\eta\\log\\pi(a(s)))d a\\,d s\\right)\\,d s}\\\\ &{\\quad\\quad=\\nabla_{\\theta}\\int d_{0}(s)\\left(\\int\\mathcal{A}_{\\pi_{\\theta}}(s)p(\\xi)(q_{\\pi_{\\theta}}(s,\\rho(\\xi;s))-\\eta\\log\\pi(\\rho(\\xi;s)|s))d s\\right)\\,d s}\\\\ &{\\quad\\quad=\\int d_{0}(s)\\left(\\int d_{\\pi_{\\theta}}(s)p(\\xi)\\nabla_{\\theta}(q_{\\pi_{\\theta}}(s,\\rho_{\\theta}(\\xi;s))-\\eta\\log\\pi(\\rho(\\xi;s)|s))\\right)d\\xi\\,d s}\\\\ &{\\quad\\quad=\\int d_{0}(s)\\left(\\int d_{\\pi_{\\theta}}(s)p(\\xi)\\nabla_{\\theta}p(\\xi;s)\\nabla_{a}(q_{\\pi_{\\theta}}(s,a)-\\eta\\log\\pi(\\rho(\\xi;s)|s))\\right)d s\\,d s}\\\\ &{\\quad\\quad=\\int d_{0}(s)\\left(\\int d_{\\pi_{\\theta}}(s)p(\\xi)\\nabla_{a}p(\\xi;s)\\nabla_{a}(q_{\\pi_{\\theta}}(s,a)-\\eta\\log\\pi(\\rho(\\xi;s)|s))\\right)_{\\alpha}}\\\\ &{\\quad\\quad\\propto\\int d_{\\pi_{\\theta}}(s)p(\\xi)\\nabla_{\\theta}\\int d_{0}(\\xi;s)\\nabla_{a}q_{\\pi}(s,a)-\\eta\\log\\pi(\\rho(\\xi;s)|s))\\|_{\\alpha}-\\mu_{\\theta}(s)d\\xi\\,d s\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\lefteqn{=\\int d_{\\pi,\\gamma}(s)\\pi_{\\theta}(a|s)(\\nabla_{\\theta}f_{\\theta}(\\xi;s)|_{\\xi=h_{\\theta}(a;s)}\\nabla_{a}(q_{\\pi_{\\theta}}(s,a)-\\eta\\log\\pi(a|s))d a\\,d s}}\\\\ &{=\\mathbb{E}_{S\\sim d_{\\pi,\\gamma},A\\sim\\pi_{\\theta}}\\left[\\nabla_{\\theta}f_{\\theta}(\\xi;S)|_{\\xi=h_{\\theta}(A;S)}\\nabla_{A}(q_{\\pi_{\\theta}}(S,A)-\\eta\\log\\pi(A|S))\\right].}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "We get the third line since $\\forall s$ , the term $\\log\\pi(A|s)$ is unbiased estimate of $\\mathcal{H}(\\cdot|s)$ so we can write $\\mathcal{H}(\\cdot|s)=\\mathbb{E}[\\log\\pi(A|s)],\\forall s$ ", "page_idx": 16}, {"type": "text", "text": "A.3Related Theoretical Works ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "We review relevant theoretical works on the convergence of actor-critic algorithms. To the best of our knowledge, there is no existing proof for the exact action value gradient (AVG) algorithm used in our paper. However, there are studies of algorithms similar to ours that provide some theoretical justification. ", "page_idx": 16}, {"type": "text", "text": "We begin by considering the case without entropy regularization. Xiong et al. (2022) examine the convergence of deterministic policy gradient (DPG; Silver et al. 2014) algorithms. Their online version of DPG employs i.i.d. samples of states from the stationary distribution, which differs from the single stream of experience examined in our study. In addition, DPG uses a deterministic policy with a fixed exploration noise distribution, whereas AVG also learns the exploration parameter. Nevertheless, this work is one of the closest to ours, as it uses the reparameterized gradient estimator in the update. Besides, Bhatnagar et al. (2007) provide convergence guarantees for incremental actor-critic algorithms. However, their results are based on the likelihood-ratio estimator, and thus applicable to incremental actor critic but not AVG. ", "page_idx": 16}, {"type": "text", "text": "When considering the entropy-regularized objective, most studies assume the presence of the true gradient (Mei et al. 2020, Cen et al. 2022), with the exception of Ding et al. (2021), which provides an asymptotic convergence guarantee to stationary points for entropy-regularized actor-critic algorithms. However, their algorithm differs from AVG in two aspects: First, the samples used in their update are from the discounted stationary distribution; second, they also use the likelihood-ratio estimator. Nonetheless, their work offers valuable insights into the theoretical underpinnings of the entropyregularized objective. ", "page_idx": 16}, {"type": "text", "text": "Despite these differences, it is reasonable to hypothesize that our algorithm converges, given the convergence guarantees for algorithms closely related to ours. The techniques from these works may be useful for demonstrating the convergence of our algorithm. For example, we can extend the convergence analysis for deterministic policies in Xiong et al. (2022) to the general case of reparameterized policies, as shown in Appendix I. ", "page_idx": 16}, {"type": "text", "text": "B AVG Design Choices ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Orthogonal Initialization helps improve the training stability and convergence speed of neural networks by ensuring that the weight matrix has orthogonal properties, thereby preserving the variance of the input through the layers (Saxe et al. 2013). ", "page_idx": 17}, {"type": "text", "text": "Squashed Normal Policy SAC utilizes a squashed Normal, where the unbounded samples from a Normal distribution are passed through the tanh function to obtain bounded actions in the range $[-1,1]:A_{\\theta}=f_{\\theta}(\\epsilon;S)\\stackrel{.}{=}\\mathbf{tanh}(\\mu_{\\theta}(\\bar{S})+\\sigma_{\\theta}(S)\\epsilon)$ where $\\mathbf{\\boldsymbol{\\epsilon}}\\sim\\mathcal{N}(\\mathbf{\\boldsymbol{0}},\\mathbf{\\boldsymbol{1}})$ . This parameterization is useful for entropy-regularized RL objectives, which maximizes the return based on the maximumentropy formulation. With an unbounded Normal policy, the standard deviation $\\sigma$ has a linear relationship with entropy. Hence, learning to maximize entropy can often result in very large values Of $\\sigma$ , potentially leading to behavior resembling a uniform random policy. In contrast, for a univariate squashed Normal with zero mean, increasing $\\sigma$ does not continuously maximize the entropy; it decreases after a certain threshold. ", "page_idx": 17}, {"type": "text", "text": "Entropy Regularization Given that batch methods such as SAC benefit from entropy regularization, we consider variants of AVG with and without entropy regularization. There are two types of entropy terms that can be added to the actor, and critic updates: 1) distribution entropy: $\\mathcal{H}(\\pi(\\cdot|S))$ , and 2) sample entropy: $-\\log(\\pi(A|S))$ .We use sample entropy as our final choice in Algorithm 1, which utilizes sample entropy for the regularization of both the actor and $\\mathrm{Q}$ -network. ", "page_idx": 17}, {"type": "text", "text": "Simply increasing $\\sigma$ does not maximize the entropy of a univariate squashed Normal with zero mean (see Fig. 2). Increasing $\\sigma$ results in the probability density function (PDF) of a squashed Normal concentrating at the edges (Fig. 11), resembling bang-bang control (Seyde et al. 2021). ", "page_idx": 17}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/c758edb82b238c6cf02197a78f35de0a440f3ce8cd48dae96446e297c3fed959.jpg", "img_caption": ["Figure 11: Squashed Normal Distribution PDF "], "img_footnote": [], "page_idx": 17}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/20ddc5bf8f95eb05ec00341306e64230efb278076d5f1049a3667cea3a55a08d.jpg", "img_caption": ["B.1   Relative Performance of Different Hyperparameter Configurations in Random Search ", "Figure 12: Hyperparameter Evaluation via Random Search. Scatter plot of the performance of the best 25 out of 300 unique hyper-parameter configurations. Note that the y-axis represents the area under the curve for 2M timesteps, not an evaluation of the final policy for 10M timesteps. "], "img_footnote": [], "page_idx": 17}, {"type": "text", "text": "We conduct an ablation study to evaluate the impact of these techniques on the performance of AVG. We assess these techniques both individually and in combination, resulting in a total of 8 variants. AVG, without any normalization or scaling techniques, serves as the baseline. We test 300 unique hyper-parameter configurations for each variant, trained for $2M$ timesteps with 10 random seeds on the Ant-v4, Hopper-v4 and Humanoid-v4 environments. We then calculate the average undiscounted return for each run (i.e., the area under the curve [AUC]) and average the AUC across all 10 seeds. We plot the top 30 hyper-parameter configurations in Fig. 12 as a scatter plot, ranked in descending order from highest to lowest mean AUC. Each plot point represents the mean AUC, and the thin lines denote the standard error. Note that a point for a hyper-parameter configuration is plotted only if the configuration runs without diverging on all 10 random seeds. These plots can be indicative of which variant would obtain the highest average episodic return when trained for longer and the robustness of the variants to the choice of hyper-parameters. ", "page_idx": 17}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/e3517dcf09c13875c956628266b94b601c9eaebd2231e31a56dff1c671104a8f.jpg", "img_caption": ["Figure 13: Comparing different neural network feature normalizations \u2014\u2014 penultimate normalization (pnorm) against layer normalization (layer norm) and RMS normalization (RMS norm) "], "img_footnote": [], "page_idx": 18}, {"type": "text", "text": "When comparing different neural network feature normalizations, penultimate normalization (pnorm), layer normalization (layer norm), and RMS normalization (RMS norm) each offer unique advantages depending on the architecture and task. Layer normalization (Ba et al. 2016) is widely used for stabilizing hidden layer pre-activations by normalizing across features within each layer, which helps models converge consistently across a variety of tasks. Root mean square layer normalization, on the other hand, normalizes based on the root mean square of pre-activations, providing stability without fully normalizing the mean, which can be beneficial in reducing variance across diverse input patterns (Zhang and Sennrich 2019). Penultimate normlazation focuses on the penultimate layer activations, normalizing just before the final layer, which allows it to maintain high-quality feature representations critical for downstream performance (Bjorck et al. 2022). ", "page_idx": 18}, {"type": "text", "text": "Figure 13 indicates that AVG, which uses penultimate normalization, consistently outperform those with other normalizations. We use the random search procedure described earlier to identify the hyperparameter configuration for each variant. ", "page_idx": 18}, {"type": "text", "text": "B.3 Vision-Based Learning using AVG ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "This task involves moving a two-degree-of-freedom (DoF) planar arm's fingertip to a random spherical target on a 2D plane. It includes two sub-tasks (easy, hard), that vary in target and fingertip sizes. It is an adaptation of the dm_control reacher Tassa et al. (2018). ", "page_idx": 18}, {"type": "text", "text": "For the non-visual task, observations include the fingertip's position, speed, and the fingertip-to-target vector. For the visual task, the fingertip-to-target vector is removed, and the agent receives three consecutive stacked images of size $84\\times84\\times3$ ", "page_idx": 18}, {"type": "text", "text": "The action space consists of torques applied to the two joints, scaled from $[-1,-1]$ to $[1,1]$ .The reward function is modified to give $-1$ per step, encouraging shorter episodes. After each timeout, the fingertip is reset to a random location while the target remains unchanged. Episodes terminate when the fingertip reaches the target within its size, and upon termination, the agent is reset and a new target is randomly generated for the next episode. ", "page_idx": 18}, {"type": "text", "text": "Convolutional Neural Network Architecture Our convolutional neural network (CNN) architecture comprises four convolutional layers, followed by a combination of a Spatial Softmax layer and proprioception information. The convolutional layers have 32 output channels and $3\\mathrm{x}3$ kernels, with stride of two for the first three layers and one for the last layer. After these convolutional layers, we use spatial-softmax (Levine et al. 2016) to convert the encoding vector into soft coordinates to track the target more precisely. Additionally, proprioception information is concatenated with the spatial softmax features. The exact number of parameters depends on the input data size and task-specific requirements. The two MLP layers have 512 hidden units each. All the layers except the final output layer use ReLU activation. ", "page_idx": 18}, {"type": "text", "text": "C AVG with Target Q Networks ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Algorithm 4 Action Value Gradient With Target Q-Networks ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Initialize $\\gamma,\\eta,\\alpha_{\\pi},\\alpha_{Q},\\tau$   \n$\\theta,\\phi$ with penultimate normalization   \n$\\begin{array}{l}{{n\\leftarrow0,\\mu\\leftarrow0,\\overline{{\\mu}}\\leftarrow0}}\\\\ {{n_{\\delta}\\leftarrow[0,0,0],\\mu_{\\delta}\\leftarrow[0,0,0],\\overline{{\\mu}}_{\\delta}\\leftarrow[0,0,0]}}\\end{array}$   \n$\\bar{\\phi}\\leftarrow\\phi$ (target Q-network)   \nfor however many episodes do Initialize S (first state of the episode) $S,n,\\mu,\\overline{{{\\mu}}},\\_\\leftarrow\\leftarrow\\mathtt{N o r m a l i z e}(S,n,\\mu,\\overline{{{\\mu}}})$ $G\\gets0$ while S is not terminal do $A_{\\theta}=f_{\\theta}(\\epsilon;S)$ where $\\mathbf{\\boldsymbol{\\epsilon}}\\sim\\mathcal{N}(\\mathbf{\\boldsymbol{0}},\\mathbf{\\boldsymbol{1}})$ Take action $A_{\\theta}$ , observe $S^{\\prime},R$ $S^{\\prime},n,\\mu,\\overline{{\\mu}},\\_\\leftarrow\\leftarrow\\mathtt{N o r m a l i z e}(S^{\\prime},n,\\mu,\\overline{{\\mu}})$ $\\begin{array}{r l}&{\\sigma_{\\delta},n_{\\delta},\\mu_{\\delta},\\mu_{\\delta}\\gets\\mathrm{scaLe1DError}(R,\\gamma,\\psi,n_{\\delta},\\mu_{\\delta},\\mu_{\\delta})}\\\\ &{G\\gets G+R}\\\\ &{A^{\\prime}\\sim\\pi_{\\theta}(\\cdot|S^{\\prime})}\\\\ &{\\delta\\gets R+\\gamma(Q_{\\bar{\\phi}}(S^{\\prime},A^{\\prime})-\\eta\\log\\pi_{\\theta}(A^{\\prime}|S^{\\prime}))-Q_{\\phi}(S,A_{\\theta})}\\\\ &{\\delta\\gets\\delta/\\sigma_{\\delta}}\\\\ &{\\phi\\gets\\phi-\\alpha_{Q\\delta}\\,\\nabla_{\\phi}\\,Q_{\\phi}(S,a)|_{a=A_{\\theta}}}\\\\ &{\\theta\\gets\\theta+\\alpha_{\\pi}\\nabla_{\\theta}(Q_{\\phi}(S,A_{\\theta})-\\eta\\log\\pi_{\\theta}(A_{\\theta}|S))}\\\\ &{\\bar{\\phi}\\gets(1-\\tau)\\bar{\\phi}+\\tau\\phi}\\\\ &{S\\gets S^{\\prime}}\\end{array}$ endwhile $\\sigma_{\\delta},n_{\\delta},\\mu_{\\delta},\\overline{{{\\mu}}}_{\\delta}\\gets\\mathtt{S c a l e T D E r r o r}(R,0,G,n_{\\delta},\\mu_{\\delta},\\overline{{{\\mu}}}_{\\delta})$   \nendfor ", "page_idx": 19}, {"type": "text", "text": "D Incremental Soft Actor Critic (SAC-1) ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Algorithm 5 Incremental SAC (SAC-1)   \n1: Initialize policy parameters $\\theta$ , Q-function parameters $\\phi_{1}$ \uff0c $\\phi_{2}$ , discount factor $\\gamma$ , polyak averaging   \ncoefficient $\\rho$ and learnable entropy coefficient $\\alpha_{\\eta}$   \n2: Initialize target Q-network parameters $\\bar{\\phi}_{1}\\leftarrow\\phi_{1},\\bar{\\phi}_{2}\\leftarrow\\phi_{2}$   \n3: for however many episodes do   \n4: Initialize S (frst state of the episode)   \n5: while S is not terminal do   \n6: Sample action $A\\sim\\pi_{\\theta}(\\cdot|S)$   \n7: Execute action $A$ in the environment   \n8: Observe next state $S^{\\prime}$ , reward $R$   \n9: $A^{\\prime}\\sim\\pi_{\\theta}(\\cdot|S^{\\prime})$   \n10: for $i\\in\\{1,2\\}$ do   \n11: $\\begin{array}{r l}&{\\delta\\leftarrow R+\\gamma(Q_{\\bar{\\phi}_{i}}(S^{\\prime},A^{\\prime})-\\eta\\log\\pi_{\\theta}(A^{\\prime}|S^{\\prime}))-Q_{\\phi_{i}}(S,A)}\\\\ &{\\phi\\leftarrow\\phi-\\alpha_{Q}\\delta\\ \\nabla_{\\phi}\\ Q_{\\phi}(S,A)}\\end{array}$   \n12: Critic update   \n13: end for   \n14: 15: X \\~ fe(s; S) where $\\begin{array}{r l}&{\\mathbf{\\mathcal{A}}_{\\theta}\\sim J{\\boldsymbol{\\theta}}\\left\\{\\zeta;{\\boldsymbol{\\mathcal{S}}}\\right\\}\\,\\mathrm{wnere}\\ s\\sim\\mathcal{N}\\left(\\mathbf{\\mathcal{V}},\\mathbf{\\mathcal{X}}\\right)}\\\\ &{\\theta\\leftarrow\\theta+\\nabla_{\\theta}\\left(\\operatorname*{min}_{i=1,2}Q_{\\phi_{i}}(S,X_{\\theta})-\\alpha\\log\\pi_{\\theta}(X_{\\theta}|S)\\right)\\vert_{\\alpha=\\alpha_{\\eta}}}\\\\ &{\\eta\\leftarrow\\eta-\\nabla_{\\eta}\\alpha_{\\eta}(-\\log\\pi_{\\theta}(X|S)-t a r g e t_{-}e n t r o p y)\\vert_{X=X_{\\theta}}}\\end{array}$ $\\xi\\sim\\mathcal{N}(0,1)$ Actor update   \n16:   \n17: for $i\\in\\{1,2\\}$ do   \n18: $\\bar{\\phi}_{i}\\leftarrow\\rho\\phi_{i}+(1-\\rho)\\bar{\\phi}_{i}$ \u2265 Update target networks   \n19: end for   \n20: $S\\gets S^{\\prime}$   \n21: end while   \n22: end for ", "page_idx": 20}, {"type": "text", "text": "We outline the components of AVG and SAC for clarity: ", "page_idx": 20}, {"type": "table", "img_path": "DX5GUwMFFb/tmp/4eff5565849bf766275ee9891af94e7f6a4ad5ba918611d684597b74f37cdaf2.jpg", "table_caption": ["Table 1: Comparison of SAC and AVG algorithms "], "table_footnote": [], "page_idx": 20}, {"type": "text", "text": "In addition, SAC is off-policy, whereas AVG is on-policy. SAC samples an action and stores it in the buffer. Unlike AVG, SAC's action is not reused to update the actor. ", "page_idx": 20}, {"type": "text", "text": "We consider the one-step actor-critic by Sutton and Barto (2018), where the actor (i.e., policy) and critic (i.e., value function) are updated incrementally, as new transitions are observed, rather than waiting for complete episodes or batches of data. We also drop the discount correction term in actor updates since it often leads to poor performance empirically (Nota and Thomas 2019). ", "page_idx": 21}, {"type": "text", "text": "We also consider an entropy regularization term in the actor and critic objectives to encourage exploration and discourage premature convergence to a deterministic policy (Williams and Peng 1991, Mnih et al. 2016). In the following subsection, we examine both distribution entropy and sample entropy, finding that distribution entropy performs better empirically. The ", "page_idx": 21}, {"type": "text", "text": "Algorithm 6 Incremental Actor Critic (IAC) Initialize $\\theta,\\phi,\\gamma,\\eta,\\alpha_{\\pi},\\alpha_{V}$ for however many episodes do Initialize S (first state of the episode) while S is not terminal do $A\\sim\\pi_{\\theta}(\\cdot|S)$ Takeaction $A$ ,observe $S^{\\prime},R$ $\\begin{array}{r l}&{\\delta\\leftarrow R+\\gamma V_{\\phi}(S^{\\prime})-V_{\\phi}(S)}\\\\ &{\\phi\\leftarrow\\phi+\\alpha_{V}\\delta\\ \\nabla_{\\phi}V_{\\phi}(S)}\\\\ &{\\theta\\leftarrow\\theta+\\alpha_{\\pi}\\nabla_{\\theta}(\\log\\left(\\pi_{\\theta}(A|S)\\right)\\delta+\\eta\\mathcal{H}(\\pi_{\\theta}(\\cdot|S))}\\\\ &{S\\leftarrow S^{\\prime}}\\end{array}$ end while end for ", "page_idx": 21}, {"type": "text", "text": "pseudocode for our implementation of IAC is detailed in Alg. 6. ", "page_idx": 21}, {"type": "text", "text": "E.1 Ablation Study of IAC: Distribution against Sample Entropy ", "text_level": 1, "page_idx": 21}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/2d6c33113a9a2986801b58dbc58b89fb9a1e88a6c9bb31f962f3230923972aeb.jpg", "img_caption": [], "img_footnote": [], "page_idx": 21}, {"type": "text", "text": "Figure 14: Performance of IAC Variants. Learning curves of the best hyper-parameter configurations found via random search for each task variant. Each solid curve is averaged over 30 independent runs. The shaded regions represent a $95\\%$ confidence interval. ", "page_idx": 21}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/e5b463b5ed6dacba6b0e1dd6c02f4e024f40a5f00212d9bca8206b5729b0b419.jpg", "img_caption": ["Figure 15: Performance of Incremental Actor Critic (IAC) Variants. Each solid learning curve is an average of 30 independent runs. The shaded regions represent a $95\\%$ confidence interval. "], "img_footnote": [], "page_idx": 21}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/ea8ddb0d48e2ee282ebb6dbf7c33378fc1a19d16113614a2f86c0a1160aa6831.jpg", "img_caption": ["E.2 Impact of Normalization & Scaling on IAC ", "Figure 16: Ablation study of normalization and scaling techniques used with IAC (Algo. 6). We plot the learning curves of the best hyper-parameter configurations for each task variant. Each solid learning curve is an average of 3 independent runs. The shaded regions represent a $95\\%$ confidence interval. "], "img_footnote": [], "page_idx": 22}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/fb2e0bab9708ee467032d4137493b78a1a28b7d5a362aea44c538a9b4e821b2f.jpg", "img_caption": ["Figure 17: Hyperparameter Evaluation via Random Search. Scatter plot of the performance of the best 30 out of 300 unique hyper-parameter configurations. Note that the y-axis represents the area under the curve, not an evaluation of the final policy. "], "img_footnote": [], "page_idx": 22}, {"type": "text", "text": "Our results show that IAC also benefits from normalization and scaling techniques used in AVG (see Fig. 16). The hyperparameter evaluation via random search (Fig. 17) highlights the top 30 configurations out of 300, with the y-axis representing area under the curve rather than final policy performance. ", "page_idx": 22}, {"type": "text", "text": "F   Hyper-parameter Settings in Simulation ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "F.1 Choice of Hyper-parameters for PPO ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Proximal Policy Optimization (PPO) Schulman et al. (2017) introduced PPO, an on-policy policy gradient method. It incorporates proximal optimization ideas to prevent large policy updates, improving stability through its carefully designed surrogate objective. ", "page_idx": 23}, {"type": "text", "text": "We use an off-the-shelf implementation of PPO from CleanRL that can be found here: https : //github.com/vwxyzjn/cleanrl/blob/8cbca61360ef98660f149e3d76762350ce613323/ cleanrl/ppo_continuous_action.py ", "page_idx": 23}, {"type": "table", "img_path": "DX5GUwMFFb/tmp/545a64be93d97b790d3c828572b247f0fb7774dc2564d49fcacf13a0799b782f.jpg", "table_caption": ["Table 2: Default parameters for CleanRL PPO implementation. "], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "F.2  Choice of Hyper-parameters for TD3 ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Twin Delayed Deep Deterministic Policy Gradient (TD3) Fujimoto et al. (2018) introduced an offpolicy algorithm that builds upon DDPG (Lillicrap et al. 2015) known as TD3. Both DDPG and TD3 utilize the reparameterization gradient, albeit for deterministic policies. They made three key modifications that resulted in better performance: (1) using two deep Q-networks to address overestimation bias, (2) delaying updates of the actor-network to reduce per-update error accumulation, and (3) adding noise to the target action used for computing the critic target values. ", "page_idx": 23}, {"type": "text", "text": "We use an off-the-shelf implementation of TD3 from CleanRL that can be found here: https : //github.com/vwxyzjn/cleanrl/blob/8cbca61360ef98660f149e3d76762350ce613323/ cleanrl/td3_continuous_action.py ", "page_idx": 23}, {"type": "table", "img_path": "DX5GUwMFFb/tmp/ad9467761af1f68bd56c3d6fa7418c3304c3b09f5bb5ff64d15bcb77c4c9ab31.jpg", "table_caption": ["Table 3: Default parameters for CleanRL TD3 implementation. "], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "F.3  Choice of Hyper-parameters for SAC ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Soft Actor-Critic (SAC) SAC is an off-policy algorithm which uses the reparametrization gradient along with entropy-augmented rewards (Haarnoja et al. 2018). While TD3 learns a deterministic policy, SAC learns a stochastic policy. TD3 adds noise to the target policy for exploration, whereas SAC's stochastic policy inherently explores by sampling actions from a distribution. We use an adaptation of Vasan et al. (2024) as our baseline SAC implementation. ", "page_idx": 24}, {"type": "table", "img_path": "DX5GUwMFFb/tmp/782a3cae695330a043a8e118b29fcebb1522d602d82d66c674757180063faf0f.jpg", "table_caption": ["Table 4: Default parameters for SAC implementation. "], "table_footnote": [], "page_idx": 24}, {"type": "text", "text": "F.4 Hyper-Parameter Optimization Using Random Search ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Our random search procedure for hyper-parameter optimization first involves initializing a random number generator (RNG) using unique seed values to ensure reproducibility. Then we use the RNG to sample learning rates for the actor and critic networks, parameters for the Adam optimizer, entropy coefficient, discount factor $(\\gamma)$ and polyak averaging constant (if applicable). The ranges of hyper-parameter values we use in this experiment are listed in Table 5. ", "page_idx": 24}, {"type": "table", "img_path": "DX5GUwMFFb/tmp/27aaf59a771f41cccaadb6cd5e6ac7bfc67c0688da560cecee8671b49a5e0735.jpg", "table_caption": ["Table 5: Random Search Procedure for Hyperparameters "], "table_footnote": [], "page_idx": 24}, {"type": "text", "text": "G Additional Results ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "G.1 Impact of Replay Buffer Size on Learning Performance ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "The following figures show the impact of reducing replay buffer size of three state-of-the art deep RL algorithms \u2014 SAC, PPO and TD3; Reducing the size of the replay buffer has detrimental impact on learning performance. Each solid learning curve is an average of 30 independent runs. The shaded regions represent a $95\\%$ confidence interval. These learning curves were also used to generate Fig. 1. ", "page_idx": 25}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/22915a3a14ab740a37ae1dd219ea69e446fb3c7a751a590b092b7ada8b2bae8c.jpg", "img_caption": ["Figure 20: TD3 "], "img_footnote": [], "page_idx": 25}, {"type": "text", "text": "H  Real-Robot Experiment Description ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "UR-Reacher-2D We utilize the UR-Reacher-2 task, as developed by Mahmood et al. (2018), which involves the Reacher task using a UR5 robot. The agent aims to reach arbitrary target positions on a 2D plane. We control the second and third joints from the base by sending angular speeds within the range of $[-0.3,+0.3]r a d/s$ . The observation vector includes joint angles, joint velocities, the previous action, and the vector difference between the target and the fingertip coordinates. The workstation for UR5-VisualReacher has an AMD Ryzen Threadripper 2950 processor, an NVidia 2080Ti GPU, and 128G memory. ", "page_idx": 26}, {"type": "text", "text": "Create-Mover We utilize the Create-Mover task, as developed by Mahmood et al. (2018), where the agent needs to move the robot forward as fast as possible within an enclosed arena. Compared to the original paper, we have a $3.92f t\\times4.33f t$ arena. The action space is $[-150m m/s,150\\dot{m}m/s]^{2}$ for actuating the two wheels with speed control. The observation vector is composed of 6 wallsensors values and the previous action. For the wall sensors, we always take the latest values received within the action cycle and use Equation 1 by (Benet et al. 2002) to convert the incoming signals to approximate distances. The reward function is the summation of the directed distance values over $10\\;\\mathrm{most}$ recent sensory packets. An episode is 90 seconds long but ends earlier if the agent triggers one of its bump sensors. When an episode terminates, the position of the robot is reset by moving backward to avoid bumping into the wall immediately. ", "page_idx": 26}, {"type": "table", "img_path": "DX5GUwMFFb/tmp/06a2fcbfafefa2cf7c6e26a06b8fa1a495b036a8a90fe16e68b1fcb003ef12ab.jpg", "table_caption": [], "table_footnote": [], "page_idx": 26}, {"type": "image", "img_path": "DX5GUwMFFb/tmp/a2a565813a367439a283cd22e815a70f623090a7a42aa71e194e69430ef908ba.jpg", "img_caption": ["Table 6: Default parameters for Robot Tasks. ", "Figure 21: Learning curves on Robots. Comparison of AVG with full PPO & SAC. Note that running SAC and SAC-100 onboard for the Create-Mover task is computationally infeasible. "], "img_footnote": [], "page_idx": 26}, {"type": "text", "text": "1  Convergence Analysis for Reparameterization Gradient ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "In this section, we present a convergence analysis for reparameterization policy gradient (RPG) in (2), which is one of the main components in our proposed AVG. We analyze a slightly different variant of AVG, that we call RPG-TD, shown in Algorithm 7. We extend the convergence result from Xiong et al. (2022) for deterministic policies to the general case of reparameterized policies. ", "page_idx": 27}, {"type": "text", "text": "Like AVG, RPG-TD uses the reparameterization gradient and updates one sample at a time, but it differs in that it does not have entropy regularization and normalizations. We also make a few typical theoretical assumptions, like i.i.d. sampling of transition tuples, that do not perfectly match the real setting for AVG. Following Xiong et al. (2022) and for analytical convenience, we use the stationary state distribution $\\begin{array}{r}{d_{\\theta}(s)=\\operatorname*{lim}_{T\\rightarrow\\infty}\\int_{s_{0}}\\frac{1}{T}\\sum_{t=0}^{T}d_{0}(s_{0})p(s_{0}\\rightarrow s,t,f_{\\theta})\\,d s_{0}}\\end{array}$ for the critic update, and the discounted state visitation $\\begin{array}{r}{\\nu_{\\theta}(s)=\\int_{s_{0}}\\sum_{t=0}^{\\infty}\\gamma^{t}d_{0}(s_{0})p(s_{0}\\to s,t,f_{\\theta})\\,d s_{0}}\\end{array}$ for the actor update. Here, $f_{\\theta}(s,\\epsilon)$ denotes the reparameterized policy, and $p(s_{0}\\to s,t,f_{\\theta})$ represents the density of state $s$ after $t$ steps from state $s_{0}$ following policy $f_{\\theta}$ . Note that we follow the notations and language from Xiong et al. (2022) while avoiding changes as much as possible for easy comparison with the original result. ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\begin{array}{r l r}{\\lefteqn{\\nabla J(\\theta)=\\int_{s}\\int_{\\epsilon}\\nu_{\\theta}(s)p(\\epsilon)\\nabla_{\\theta}f_{\\theta}(s,\\epsilon)\\nabla_{a}Q^{f_{\\theta}}(s,a)|_{a=f_{\\theta}(s,\\epsilon)}\\,d\\epsilon d s}}\\\\ &{}&{=\\mathbb{E}_{\\nu_{\\theta},p}\\left[\\nabla_{\\theta}f_{\\theta}(s,\\epsilon)\\nabla_{a}Q^{f_{\\theta}}(s,a)|_{a=f_{\\theta}(s,\\epsilon)}\\right].\\quad\\quad\\quad}\\end{array}\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "We will present the assumptions and the convergence result for RPG-TD in Appendix I.1. The proofs of the convergence result and the intermediate results are provided in Appendix I.2. To highlight the differences between our extended analysis and that of Xiong et al. (2022), we use blue to indicate modifications specific to reparameterized policies. These modifications include replacing the deterministic policy $\\bar{\\mu_{\\theta}(s)}$ with the reparameterized policy $f_{\\theta}(s,\\epsilon)$ and properly handling of the expectation over the prior random variable $\\epsilon\\sim p$ . In addition, we fixed a few errors in the original analysis and result, which are shown in red. ", "page_idx": 27}, {"type": "table", "img_path": "DX5GUwMFFb/tmp/f234188840dd84ada1c9944eb1a2c536fcd4a4c122ad700a3aac2f8262c068b7.jpg", "table_caption": [], "table_footnote": [], "page_idx": 27}, {"type": "text", "text": "1.1  Convergence Result ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "We present the full set of assumptions below and refer interested reader to Xiong et al. (2022) for detailed discussions about these assumptions. ", "page_idx": 27}, {"type": "text", "text": "Assumption 3. For any $\\theta_{1},\\theta_{2},\\theta\\,\\in\\,\\mathbb{R}^{d}$ , there exist positive constants $L_{f},L_{\\phi}$ and $\\lambda_{\\Phi}$ , such that (1) $\\bigl\\|f_{\\theta_{1}}(s,\\epsilon)-f_{\\theta_{2}}(s,\\epsilon)\\bigr\\|\\,\\le\\,L_{f}\\,\\bigl\\|\\theta_{1}-\\theta_{2}\\bigr\\|\\,,\\forall s\\,\\in\\,S,\\epsilon\\in\\mathbb{R}$ (2) $\\left\\|\\nabla_{\\theta}f_{\\theta_{1}}(s,\\epsilon)-\\nabla_{\\theta}f_{\\theta_{2}}(s,\\epsilon)\\right\\|\\ \\leq$ $L_{\\psi}\\left\\|\\theta_{1}-\\theta_{2}\\right\\|,\\forall s\\in\\mathcal{S},\\epsilon\\in\\mathbb{R}$ ; (3 he marix $\\Psi_{\\theta}:=\\mathbb{E}_{\\nu_{\\theta},p}\\left[\\nabla_{\\theta}f_{\\theta}(s,\\epsilon)\\nabla_{\\theta}f_{\\theta}(s,\\epsilon)^{T}\\right]$ is n-singular with the minimal eigenvalue uniformly lower-bounded as $\\bar{\\sigma}_{\\operatorname*{min}}(\\Psi_{\\theta})\\geq\\lambda_{\\Psi}$ ", "page_idx": 27}, {"type": "text", "text": "Assumption 4. For any $a_{1},a_{2}\\in{\\mathcal{A}}$ there exist positive constants $L_{P},L_{r}$ , such that (1) the transition kernel satisfies $\\left|P(s^{\\prime}|s,a_{1})-P(s^{\\prime}|s,a_{2})\\right|\\,\\leq\\,L_{P}\\left\\|a_{1}-a_{2}\\right\\|,\\forall s,s^{\\prime}\\in S;$ (2) the reward function satisfies $\\left|r(s,a_{1})-r(s,a_{2})\\right|\\leq L_{r}\\left\\|a_{1}-a_{2}\\right\\|,\\forall s,s^{\\prime}\\in S.$ ", "page_idx": 28}, {"type": "text", "text": "Assumption 5. For any $a_{1},a_{2}\\quad\\in\\quad{\\mathcal{A}}$ , there exists a positive constant $L_{Q}$ \uff0c such that $\\begin{array}{r}{\\left\\|\\nabla_{a}Q^{f_{\\theta}}(s,a_{1})\\!-\\!\\nabla_{a}Q^{f_{\\theta}}(s,a_{2})\\right\\|\\le L_{Q}\\left\\|a_{1}-a_{2}\\right\\|,\\forall\\theta\\in\\mathbb{R}^{d},s\\in\\mathcal{S}}\\end{array}$ ", "page_idx": 28}, {"type": "text", "text": "Assumption 6. The feature function $\\phi:S\\times A\\rightarrow\\mathbb{R}^{d}$ is uniformly bounded, i.e., $\\|\\phi(\\cdot,\\cdot)\\|\\leq C_{\\phi}$ for some positive constant $C_{\\phi}$ . In addition, we define $A\\;=\\;\\mathbb{E}_{d_{\\theta}}\\left[\\phi(x)(\\gamma\\phi(x^{\\prime})-\\phi(x))^{T}\\right]$ and $D\\,=\\,\\mathbb{E}_{d_{\\theta}}\\,\\left[\\phi(x)\\phi(x)^{T}\\right]$ , and assume that $A$ and $D$ are non-singular. We further assume that the absolute value of the eigenvalues of $A$ are uniformly lower bounded, i.e., $|\\sigma(A)|\\geq\\lambda_{A}$ for some positive constant $\\lambda_{A}$ ", "page_idx": 28}, {"type": "text", "text": "Proposition 7 (Compatible function approximation). $A$ function estimator $Q^{w}(s,a)$ iscompatible with a reparameterized policy $f_{\\theta}$ i.e, $\\nabla J(\\theta)\\;=\\;\\mathbb{E}_{\\nu_{\\theta},p}\\left[\\nabla_{\\theta}f_{\\theta}(s,\\epsilon)\\nabla_{a}Q^{w}(s,a)|_{a=f_{\\theta}(s,\\epsilon)}\\right]$ \uff0cfit satisfies the following two conditions: ", "page_idx": 28}, {"type": "text", "text": "$\\boldsymbol{I}.\\;\\;\\nabla_{a}{Q}^{w}(s,a)|_{a=f_{\\theta}(s,\\epsilon)}=\\nabla_{\\theta}f_{\\theta}(s,\\epsilon)^{T}\\boldsymbol{w};$   \n2. $w\\ =\\ w_{\\xi_{\\theta}}^{*}$ minimizes the mean square error $\\mathbb{E}_{\\nu_{\\theta},p}\\left[\\xi(s,\\epsilon;\\theta,w)^{T}\\xi(s,\\epsilon;\\theta,w)\\right]$ \uff0cwhere $\\xi(s,\\epsilon;\\theta,\\stackrel{\\cdot}{w})\\!=\\!\\nabla_{a}Q^{w}(s,a)|_{a=f_{\\theta}(s,\\epsilon)}-\\nabla_{a}Q^{f_{\\theta}}(s,a)|_{a=f_{\\theta}(s,\\epsilon)}$ ", "page_idx": 28}, {"type": "text", "text": "Given the above assumption, one can show that the reparameterization gradient is smooth (Lemma 8), and that Algorithm 7 converges (Theorem 9), the proofs of which are presented in Appendix 1.2. ", "page_idx": 28}, {"type": "text", "text": "Lemma 8. Suppose Assumptions 3-5 hold. Then the reparameterization gradient $\\nabla J(\\theta)$ defined in (2) is Lipschitz.continuous with the parameter $L_{J}$ ,i.e., $\\forall\\theta_{1},\\theta_{2}\\in\\mathbb{R}^{d}$ ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\begin{array}{c}{\\|\\nabla J(\\theta_{1})-\\nabla J(\\theta_{2})\\|\\le L_{J}\\,\\|\\theta_{1}-\\theta_{2}\\|\\,,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(3)}\\\\ {L_{J}=\\bigg(\\frac{1}{2}L_{P}L_{f}^{2}L_{\\nu}C_{\\nu}+\\frac{L_{\\psi}}{1\\!-\\!\\gamma}\\bigg)\\,\\bigg(L_{r}+\\frac{\\gamma R_{\\mathrm{max}}L_{P}}{1-\\gamma}\\bigg)\\!+\\!\\frac{L_{f}}{1-\\gamma}\\,\\bigg(L_{Q}L_{f}\\!+\\!\\frac{\\gamma}{2}L_{P}^{2}R_{\\mathrm{max}}L_{f}C_{\\nu}\\!+\\!\\frac{\\gamma L_{P}L_{r}L_{f}}{1-\\gamma}\\bigg).}\\end{array}}\\end{array}\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Theorem 9. Suppose that Assumptions 3-6 hold. Let $\\begin{array}{c c l}{{\\alpha_{w}}}&{{\\leq}}&{{\\frac{\\lambda}{2C_{A}^{2}};M}}&{{\\geq}}&{{\\frac{48\\alpha_{w}C_{A}^{2}}{\\lambda};\\alpha_{\\theta}}}&{{\\leq}}\\end{array}$ $\\begin{array}{r}{\\operatorname*{min}\\left\\{\\frac{1}{4L_{J}},\\frac{\\lambda\\alpha_{w}}{24\\sqrt{6}L_{h}L_{w}}\\right\\}}\\end{array}$ Then the output of RPG-TD in Algorithm 7 satisfies ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{c}{\\displaystyle\\operatorname*{min}_{t\\in[T]}\\mathbb{E}\\left\\|\\nabla J(\\theta_{t})\\right\\|^{2}\\leq\\frac{c_{1}}{T}+\\frac{c_{2}}{M}+c_{3}\\kappa^{2},\\qquad\\qquad\\qquad\\qquad}\\\\ {\\displaystyle1=\\frac{8R_{\\mathrm{max}}}{\\alpha_{\\theta}(1-\\gamma)}+\\frac{144L_{h}^{2}}{\\lambda\\alpha_{w}}\\left\\|w_{0}-w_{\\theta_{0}}^{*}\\right\\|^{2},c_{2}=\\left[48\\alpha_{w}^{2}(C_{A}^{2}C_{w}^{2}+C_{b}^{2})+\\frac{96L_{w}^{2}L_{f}^{4}C_{w_{\\xi}}^{2}\\alpha_{\\theta}^{2}}{\\lambda\\alpha_{w}}\\right]\\cdot\\frac{144L_{h}^{2}}{\\lambda\\alpha_{w}}+}\\\\ {\\displaystyle_{w_{\\xi}}^{2},c_{3}~=~18L_{h}^{2}+\\left[\\frac{24L_{w}^{2}L_{h}^{2}\\alpha_{\\theta}^{2}}{\\lambda\\alpha_{w}}+\\frac{24}{\\lambda\\alpha_{w}}\\right]\\cdot\\frac{144L_{h}^{2}}{\\lambda\\alpha_{w}}~w i t h~C_{A}~=~2C_{\\phi}^{2},C_{b}~=~R_{\\mathrm{max}}C_{\\phi},C_{w}~=~\\alpha_{f}~}\\\\ {,C_{w_{\\xi}}=\\frac{L_{f}C_{Q}}{\\lambda_{\\Psi}(1-\\gamma)},L_{w}~=~\\frac{L_{J}}{\\lambda_{\\Psi}}+\\frac{L_{f}C_{Q}}{\\lambda_{\\Psi}^{2}(1-\\gamma)}\\left(L_{f}^{2}L_{\\nu}+\\frac{2L_{f}L_{\\psi}}{1-\\gamma}\\right),L_{h}~=~L_{f}^{2},C_{Q}~=~L_{r}+L_{P}~.}\\end{array}\n$$wher 72L,C RmaxC \u5165A $\\begin{array}{r}{\\frac{\\gamma R_{\\operatorname*{max}}}{1-\\gamma},L_{\\nu}=\\frac{1}{2}C_{\\nu}L_{P}L_{f}}\\end{array}$ and $L_{J}$ defned in Lemma 8, and we defne ", "text_format": "latex", "page_idx": 28}, {"type": "equation", "text": "$$\n\\kappa:=\\operatorname*{max}_{\\theta}\\left\\|w_{\\theta}^{\\ast}-w_{\\xi_{\\theta}}^{\\ast}\\right\\|.\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Comparison with Theorem 9 and Theorem 1 of Xiong et al. (2022). The differences between the reparameterization gradient and the deterministic policy gradient results are minimal. Aside from correcting the errors (highlighted in red; see Appendix I.2 for details), the most notable distinction is the replacement of $L_{\\mu}$ in Xiong et al. (2022) with $L_{f}$ , which may be different. Additionally, constants related to the critic, such as $L_{Q}$ and $\\kappa$ , may also differ, as they are now defined for a more general policy class. While this theoretical comparison shows little divergence, practical performance could vary significantly. ", "page_idx": 28}, {"type": "text", "text": "1.2Proofs ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "1.2.1 Supporting Lemmas for Proving Lemma 8 ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Lemma 10. Suppose Assumptions 3 and 4 hold. We define the total variation norm between two state visitation distributions respectively corresponding to two policies $f_{\\theta_{1}},f_{\\theta_{2}}$ as $\\|\\nu_{\\theta_{1}}(\\cdot)-\\nu_{\\theta_{2}}(\\cdot)\\|_{T V}=$ $\\begin{array}{r}{\\int_{s}|\\nu_{\\theta_{1}}(d s)-\\nu_{\\theta_{2}}(d s)|}\\end{array}$ .Thenthereexistssomeconstant $L_{\\nu}>0$ suchthat ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\|\\nu_{\\theta_{1}}(\\cdot)-\\nu_{\\theta_{2}}(\\cdot)\\|_{T V}\\leq L_{\\nu}\\,\\|\\theta_{1}-\\theta_{2}\\|\\,.}\\end{array}\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Proof. Since we consider ergodic Markov chains, Theorem 3.1 of Mitrophanov (2005) shows that there exists some constant $C_{\\nu}>1$ ,suchthat ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\|\\nu_{\\theta_{1}}(\\cdot)-\\nu_{\\theta_{2}}(\\cdot)\\|_{T V}\\leq C_{\\nu}\\,\\|P_{\\theta_{1}}-P_{\\theta_{2}}\\|_{\\mathrm{op}}\\,,}\\end{array}\n$$", "text_format": "latex", "page_idx": 29}, {"type": "text", "text": "where $P_{\\theta}$ denotes the state transition kernel corresponding to a policy $f_{\\theta}$ , and the operator norm $\\lVert\\cdot\\rVert_{\\mathrm{op}}$ is given by $\\begin{array}{r}{\\|P\\|_{\\mathrm{op}}=\\operatorname*{sup}_{\\|q\\|_{T V}=1}\\|q P\\|_{T V}}\\end{array}$ Then we have ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\|P_{0_{1}}-P_{\\theta_{0}}\\|_{\\mathrm{q}\\rightarrow}}&{\\underset{[\\imath]\\rightarrow\\mathrm{q}}{\\operatorname*{sup}}\\left\\|\\int_{\\gamma_{0}}(P_{0_{1}}-P_{\\theta_{0}})(s,\\cdot)q(d s)\\right\\|_{\\mathrm{T}\\mathcal{V}}}\\\\ &{\\qquad=\\frac{1}{2}\\underset{[\\imath]\\rightarrow\\mathrm{T}^{*}\\cap\\mathrm{T}}{\\operatorname*{sup}}\\int_{\\gamma_{0}}\\bigg|\\int_{s}\\big(P_{0_{1}}(s,d s^{\\prime})-P_{0_{2}}(s,d s^{\\prime})\\big)q(d s)\\bigg|}\\\\ &{\\qquad\\overset{\\mathrm{c}}{\\leq}\\frac{1}{2}\\underset{[\\imath]\\rightarrow\\mathrm{T}^{*}\\in\\mathrm{T}^{*}}{\\operatorname*{sup}}\\int_{s_{\\varepsilon}}\\int_{s_{\\varepsilon}}|P_{0_{1}}(s,d s^{\\prime})-P_{0_{2}}(s,d s^{\\prime})|\\,q(d s)}\\\\ &{\\qquad=\\frac{1}{2}\\underset{[\\imath]\\rightarrow\\mathrm{T}^{*}\\in\\mathrm{T}^{*}}{\\operatorname*{sup}}\\int_{s_{\\varepsilon}}\\int_{s_{\\varepsilon}}\\bigg|\\int_{s}\\big(P(d s^{\\prime}|s,f_{\\eta_{1}}(s,\\cdot))-P(d s^{\\prime}|s,f_{\\eta_{1}}(s,\\cdot))\\big)\\,p(d s)\\bigg|\\,q(d s)}\\\\ &{\\qquad\\leq\\frac{1}{2}\\underset{[\\imath]\\rightarrow\\mathrm{T}^{*}\\in\\mathrm{T}^{*}}{\\operatorname*{sup}}\\int_{s_{\\varepsilon}}\\int_{s_{\\varepsilon}}\\int_{s_{\\varepsilon}}|P(d s^{\\prime}|s,f_{\\eta_{1}}(s,\\cdot))-P(d s^{\\prime}|s,f_{\\eta_{1}}(s,\\cdot))|\\,p(d s)|\\,q(d s)}\\\\ &{\\qquad\\overset{\\mathrm{Q}}{\\leq}\\frac{1}{2}\\underset{[\\imath]\\rightarrow\\mathrm{T}^{*}\\in\\mathrm{T}^{*}}{\\operatorname*{sup}}\\int_{s_{\\varepsilon}}\\int_{s_{\\varepsilon}}\\int_{t}|f_{\\eta_{1}}(s,\\varepsilon)-f_{\\eta_{2}}(s,\\cdot)|\\,p(d s)|\\,q(d s)}\\\\ &{\\qquad\\overset{\\mathrm{Q}}{\\leq}\\frac{1 \n$$", "text_format": "latex", "page_idx": 29}, {"type": "text", "text": "where (i) follows form Assumption 4, and (i) follows from Assumption 3. Then, combining the above bound together with (5) completes the proof. \u53e3 ", "page_idx": 29}, {"type": "text", "text": "Lemma 11. Suppose Assumptions 3 and 4 hold. The value function is Lipschitz continuous w.rt. the policies.That is,for any $\\bar{\\theta_{1}(\\theta_{2}\\in\\mathbb{R}^{d},s\\in S}$ wehave ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\left\\|V^{f_{\\theta_{1}}}(s)-V^{f_{\\theta_{2}}}(s)\\right\\|\\leq L_{V}\\left\\|\\theta_{1}-\\theta_{2}\\right\\|,\n$$", "text_format": "latex", "page_idx": 29}, {"type": "text", "text": "where $\\begin{array}{r}{L_{V}=R_{\\mathrm{max}}L_{\\nu}+\\frac{L_{r}L_{f}}{1-\\gamma}}\\end{array}$ ", "page_idx": 29}, {"type": "text", "text": "Proof. By definition, we have $\\begin{array}{r}{V^{f_{\\theta}}(s_{0})\\;=\\;\\int_{s}\\int_{\\epsilon}r(s,f_{\\theta}(s,\\epsilon))p(d\\epsilon)\\nu_{f_{\\theta}}^{s_{0}}(d s)}\\end{array}$ where $\\nu_{f_{\\theta}}^{s_{0}}(\\cdot)$ is the discounted state visitation measure given the initial state, i.e., $\\begin{array}{r}{\\nu_{f_{\\theta}}^{s_{0}}(s)=\\sum_{t=0}^{\\infty}\\gamma^{t}p(s_{0}\\,\\to\\,s,t,f_{\\theta})}\\end{array}$ We then derive ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{V^{\\mu}(x_{0})-V^{\\mu}(z_{0})\\Big|}\\\\ &{\\quad=\\left|\\int_{\\mathbb{Z}}\\int_{\\mathbb{Z}}\\Big[e^{i\\left(z_{0},f_{\\eta}\\left(z_{0}\\right)\\right)p}(d z)e_{\\eta,\\eta}^{\\mu*}\\left(d\\delta)-\\int_{\\mathcal{Z}}\\int_{\\mathbb{Z}}r(s,f_{\\eta}(s,\\epsilon))p(d z)b_{\\eta,\\eta}^{\\nu*}\\left(d\\delta\\right)\\Big|}\\\\ &{\\quad\\le\\int_{\\mathbb{Z}}\\Big|\\int_{\\mathbb{Z}}r(s,f_{\\eta}(s,\\epsilon))\\nu_{\\rho_{1}}^{\\mu*}\\left(d\\delta\\right)-\\int_{\\mathbb{Z}}r(s,f_{\\eta}(s,\\epsilon))\\nu_{\\rho_{2}}^{\\mu*}\\left(d\\delta\\right)\\Big|p(d z)}\\\\ &{\\quad\\le\\int_{\\mathbb{Z}}\\Big|\\int_{\\mathbb{Z}}r(s,f_{\\eta}(s,\\epsilon))\\nu_{\\rho_{1}}^{\\mu*}\\left(d\\delta\\right)-\\int_{\\mathbb{Z}}r(s,f_{\\eta}(s,\\epsilon))\\nu_{\\rho_{2}}^{\\eta*}\\left(d\\delta\\right)\\Big|p(d z)}\\\\ &{\\quad\\quad+\\int_{\\mathbb{Z}}\\Big|\\int_{\\mathbb{Z}}r(s,f_{\\eta}(s,\\epsilon))\\nu_{\\rho_{2}}^{\\mu*}\\left(d\\delta\\right)-\\int_{\\mathbb{Z}}\\nu(s,f_{\\eta}(s,\\epsilon))\\nu_{\\rho_{2}}^{\\eta*}\\left(d\\delta\\right)\\Big|p(d z)}\\\\ &{\\quad\\le\\int\\int_{\\mathbb{Z}}\\Big|r(s,f_{\\eta}(s,\\epsilon))\\left|\\cdot\\left|p_{\\eta}^{\\mu*}\\left(d\\delta\\right)-\\nu_{\\rho_{1}}^{\\mu*}\\left(d\\delta\\right)\\right|p(d z)}\\\\ &{\\qquad+\\int_{\\mathbb{Z}}\\int_{\\mathbb{Z}}\\Big|r(s,f_{\\eta}(s,\\epsilon))-r(s,f_{\\eta}(s,\\epsilon))\\nu_{\\rho_{2}}^{\\eta*}\\left(d\\delta\\right)\\Big|p(d z)}\\\\ &{\\quad\\quad+\\int_{\\mathbb{Z}}\\int_{\\mathbb{Z}}\\Big|r(s,f_{\\eta}(s,\\epsilon))-r(s,f_{\\eta}(s,\\epsilon))\\Big|\\nu_{\\rho_{2}}^{\\eta*}\\left(d\\delta\\right)\\rho(d z)}\\\\ &{\\quad\\le R\n$$", "text_format": "latex", "page_idx": 29}, {"type": "equation", "text": "$$\n\\begin{array}{l}{\\displaystyle\\stackrel{\\mathrm{(ii)}}{\\leq}R_{\\operatorname*{max}}L_{\\nu}\\left\\|\\theta_{1}-\\theta_{2}\\right\\|+L_{r}L_{f}\\left\\|\\theta_{1}-\\theta_{2}\\right\\|\\int_{\\epsilon}\\int_{s}\\nu_{f_{\\theta_{2}}}^{s_{0}}(d s)p(d\\epsilon)}\\\\ {\\displaystyle=\\left(R_{\\operatorname*{max}}L_{\\nu}+\\frac{L_{r}L_{f}}{1-\\gamma}\\right)\\left\\|\\theta_{1}-\\theta_{2}\\right\\|,}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "where (i) follows from Assumption 4, and (i) follows from Lemma 10 and Assumption 3. ", "page_idx": 30}, {"type": "text", "text": "Lemma 12. Suppose Assumptions 3-5 hold. The gradient of $Q$ -function w.r.t. action is uniformly bounded. That is, for any $(s,\\bar{a})\\in\\mathcal{S}\\times\\mathcal{A},\\theta\\in\\mathbb{R}^{d}$ ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\left\\|\\nabla_{a}Q^{f_{\\theta}}(s,a)\\right\\|\\leq C_{Q},\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "where $\\begin{array}{r}{C_{Q}=L_{r}+L_{P}\\cdot\\frac{\\gamma R_{\\operatorname*{max}}}{1-\\gamma}}\\end{array}$ .Furthermore, $\\nabla_{a}Q^{f_{\\theta}}(s,a_{\\theta})$ is Lipschit continuous w.t. $\\theta$ thatis, for any $\\theta_{1},\\theta_{2}\\in\\mathbb{R}^{d}$ , we have ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left\\|\\nabla_{a}Q^{f_{\\theta_{1}}}(s,f_{\\theta_{1}}(s,\\epsilon))-\\nabla_{a}Q^{f_{\\theta_{2}}}(s,f_{\\theta_{2}}(s,\\epsilon))\\right\\|\\le L_{Q}^{\\prime}\\left\\|\\theta_{1}-\\theta_{2}\\right\\|,}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "where $L_{Q}^{\\prime}=L_{Q}L_{f}+\\gamma L_{P}L_{V}$ ", "page_idx": 30}, {"type": "text", "text": "Proof. For the boundedness property, we have ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\left\\Vert\\nabla_{a}Q^{f_{\\theta}}(s,a)\\right\\Vert=\\left\\Vert\\nabla_{a}\\int_{s}\\left(r(s,a)+\\gamma P(s^{\\prime}|s,a)V^{f_{\\theta}}(s^{\\prime})\\right)d s^{\\prime}\\right\\Vert}\\\\ &{\\qquad\\qquad\\leq\\left\\Vert\\nabla_{a}r(s,a)\\right\\Vert+\\gamma\\displaystyle\\int_{s}\\left\\Vert\\nabla_{a}P(s^{\\prime}|s,a)\\right\\Vert\\cdot\\left\\vert V^{f_{\\theta}}(s^{\\prime})\\right\\vert d s^{\\prime}}\\\\ &{\\qquad\\qquad\\leq L_{r}+L_{P}\\cdot\\displaystyle\\frac{\\gamma R_{\\operatorname*{max}}}{1-\\gamma},}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "where the last inequality follows from Assumptions 3, 4 and the fact that $\\begin{array}{r}{\\left|V^{f_{\\theta}}(s^{\\prime})\\right|\\le\\frac{R_{\\operatorname*{max}}}{1-\\gamma}}\\end{array}$ ", "page_idx": 30}, {"type": "text", "text": "We next show the Lipschitz property as follows. ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\Big\\|\\nabla_{a}Q^{f_{\\theta_{1}}}(s,f_{\\theta_{1}}(s,\\epsilon))-\\nabla_{a}Q^{f_{\\theta_{2}}}(s,f_{\\theta_{2}}(s,\\epsilon))\\Big\\|}\\\\ &{\\quad\\le\\Big\\|\\nabla_{a}Q^{f_{\\theta_{1}}}(s,f_{\\theta_{1}}(s,\\epsilon))-\\nabla_{a}Q^{f_{\\theta_{1}}}(s,f_{\\theta_{2}}(s,\\epsilon))\\Big\\|}\\\\ &{\\quad\\quad+\\Big\\|\\nabla_{a}Q^{f_{\\theta_{1}}}(s,f_{\\theta_{2}}(s,\\epsilon))-\\nabla_{a}Q^{f_{\\theta_{2}}}(s,f_{\\theta_{2}}(s,\\epsilon))\\Big\\|}\\\\ &{\\quad\\quad\\overset{(i)}{\\le}L_{Q}\\left\\|f_{\\theta_{1}}(s,\\epsilon)-f_{\\theta_{2}}(s,\\epsilon)\\right\\|+\\Big\\|\\nabla_{a}Q^{f_{\\theta_{1}}}(s,f_{\\theta_{2}}(s,\\epsilon))-\\nabla_{a}Q^{f_{\\theta_{2}}}(s,f_{\\theta_{2}}(s,\\epsilon))\\Big\\|}\\\\ &{\\quad\\overset{(i i)}{\\le}L_{Q}L_{f}\\left\\|\\theta_{1}-\\theta_{2}\\right\\|+\\left\\|\\int_{s}\\gamma_{a}P(s^{\\prime}|s,a)\\left(V^{f_{\\theta_{1}}}(s^{\\prime})-V^{f_{\\theta_{2}}}(s^{\\prime})\\right)d s^{\\prime}\\right\\|}\\\\ &{\\quad\\le L_{Q}L_{f}\\left\\|\\theta_{1}-\\theta_{2}\\right\\|+\\gamma\\int_{s}\\left\\|\\nabla_{a}P(s^{\\prime}|s,a)\\right\\|\\cdot\\left|V^{f_{\\theta_{1}}}(s^{\\prime})-V^{f_{\\theta_{2}}}(s^{\\prime})\\right|d s^{\\prime}}\\\\ &{\\quad\\quad\\overset{(i i i i)}{\\le}(L_{Q}L_{f}+\\gamma L_{P}L_{V})\\left\\|\\theta_{1}-\\theta_{2}\\right\\|,}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "where (i) follows from Assumption 5, (i) follows from Assumption 3 and (i) follows from Assumption 4 and Lemma 11. ", "page_idx": 30}, {"type": "text", "text": "1.2.2 Proof of Lemma 8 ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "To simplify the notation, we define $\\psi_{\\boldsymbol\\theta}(s,\\boldsymbol\\epsilon)\\,:=\\,\\nabla_{\\boldsymbol\\theta}f_{\\boldsymbol\\theta}(s,\\boldsymbol\\epsilon)$ $a_{\\theta}\\,=\\,f_{\\theta}(s,\\epsilon)$ and $\\nabla_{a}Q^{f_{\\theta}}(s,a_{\\theta})\\,=$ $\\nabla_{a}Q^{f_{\\theta}}(s,a)|_{a=f_{\\theta}(s,\\epsilon)}$ in the following proof. ", "page_idx": 30}, {"type": "text", "text": "We start from the form of the off-policy deterministic policy gradient given in (2), and have ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{l}{\\displaystyle\\|\\nabla J(\\theta_{1})-\\nabla J(\\theta_{2})\\|}\\\\ {\\displaystyle\\quad=\\left\\|\\int_{s}\\int_{\\epsilon}\\psi_{\\theta_{1}}(s,\\epsilon)\\nabla_{a}Q^{f_{\\theta_{1}}}(s,a_{\\theta_{1}})p(d\\epsilon)\\nu_{\\theta_{1}}(d s)-\\int_{s}\\int_{\\epsilon}\\psi_{\\theta_{2}}(s,\\epsilon)\\nabla_{a}Q^{f_{\\theta_{2}}}(s,a_{\\theta_{2}})p(d\\epsilon)\\nu_{\\theta_{2}}(d s)\\right\\|_{s}}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "equation", "text": "$$\n\\leq\\int_{\\epsilon}\\left\\|\\int_{s}\\psi_{\\theta_{1}}(s,\\epsilon)\\nabla_{a}Q^{f_{\\theta_{1}}}(s,a_{\\theta_{1}})\\nu_{\\theta_{1}}(d s)-\\int_{s}\\psi_{\\theta_{2}}(s,\\epsilon)\\nabla_{a}Q^{f_{\\theta_{2}}}(s,a_{\\theta_{2}})\\nu_{\\theta_{2}}(d s)\\right\\|p(d\\epsilon).\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "Now, ", "page_idx": 31}, {"type": "text", "text": "$\\begin{array}{r l}&{\\quad\\displaystyle\\int_{{\\cal B}_{\\varepsilon}}\\int_{\\varepsilon_{0}}^{\\varepsilon}\\mathrm{e}(s_{n+1})\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+2})\\sin_{\\theta_{0}}(\\theta_{0})-\\int_{\\varepsilon_{\\theta}}\\int_{\\varepsilon_{\\theta}}(s_{n})\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+3\\theta_{0}})\\sin_{\\theta_{0}}(\\theta_{0})\\,\\Biggr|}\\\\ &{\\quad+\\displaystyle\\int_{\\{\\cal B}_{\\varepsilon}}\\int_{\\varepsilon_{0}}^{\\varepsilon}\\mathrm{e}(s_{n+1})\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+3\\theta_{0}})\\sin_{\\theta_{0}}(\\theta_{0})-\\int_{\\varepsilon_{\\theta}}(s_{n})\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+3\\theta_{0}})\\sin_{\\theta_{0}}(\\theta_{0})\\,\\Biggr|}\\\\ &{\\quad+\\displaystyle\\int_{\\{\\cal B}_{\\varepsilon}}\\int_{\\varepsilon_{0}}^{\\varepsilon}\\mathrm{e}(s_{n+1})\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+3\\theta_{0}})\\sin_{\\theta_{0}}(\\theta_{0})-\\int_{\\varepsilon_{\\theta}}\\mathrm{e}(s_{n})\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+3\\theta_{0}})\\sin_{\\theta_{0}}(\\theta_{0})\\,\\Biggr|}\\\\ &{\\quad\\le\\displaystyle\\int_{\\varepsilon_{\\theta}}\\mathrm{e}(s_{n+1})\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+3\\theta_{0}})\\sin_{\\theta_{0}}(\\theta_{0})\\,\\sinh\\{\\mathrm{e}\\}}\\\\ &{\\quad+\\displaystyle\\int_{\\{\\cal B}_{\\varepsilon}}\\left(s_{n+1})\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+3\\theta_{0}})-\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+3\\theta_{0}})\\right)\\ln\\{\\mathrm{e}\\}}\\\\ &{\\quad+\\displaystyle\\int_{\\varepsilon_{\\theta}}\\mathrm{e}(s_{n+1})\\nabla_{\\theta}\\alpha^{\\prime}\\mathrm{e}(s_{n+3\\theta_{0}})\\sin_{\\theta_{0}}(\\theta_{0}$ := L,J I101 - 02ll , (7 ", "page_idx": 31}, {"type": "text", "text": "where (i)follows because $\\|\\psi_{\\theta}(s,\\epsilon)\\|\\le L_{f}$ as indicated by Assumption 3 and $\\left\\|\\nabla_{a}Q^{f_{\\theta}}(s,a)\\right\\|\\leq C_{Q}$ by Lemma 12, i fllows fom Assmption 3 and Lemma 12 i folows because $\\begin{array}{r}{\\int_{s}\\nu_{\\theta}(d s)=\\frac{1}{1-\\gamma}}\\end{array}$ and (iv) follows from Lemma 10. Plugging (7) to (6), we finish the proof. ", "page_idx": 31}, {"type": "text", "text": "1.2.3 Supporting Lemmas for Proving Theorem 9 ", "text_level": 1, "page_idx": 31}, {"type": "text", "text": "Lemma 13. The following two properties hold. ", "text_level": 1, "page_idx": 31}, {"type": "text", "text": "1. Let $\\hat{Y},\\bar{Y}\\in\\mathbb{R}^{d_{1}\\times d_{2}}$ be matrice satisfying $\\left\\|\\hat{Y}\\right\\|_{F}\\leq C_{Y},\\left\\|\\bar{Y}\\right\\|_{F}\\leq C_{Y}$ $\\hat{Y}$ is an unbased estimator of $\\bar{Y}$ and $\\{\\hat{Y}_{j}\\}_{j}$ are i.i.d. estimators, then we have ", "page_idx": 31}, {"type": "equation", "text": "$$\n\\mathbb{E}\\left\\Vert\\frac{1}{M}\\sum_{j=0}^{M-1}\\hat{Y}_{j}-\\bar{Y}\\right\\Vert_{F}^{2}\\leq\\frac{4C_{Y}^{2}}{M}.\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "2. Let $\\hat{y}$ $\\bar{y}\\in\\mathbb{R}^{d}$ be vectors satisfying $\\|\\hat{y}\\|\\leq C_{y},\\|\\bar{y}\\|\\leq C_{y}$ f $\\hat{y}$ is an unbiased estimator of $\\bar{y}$ and $\\{y_{j}\\}_{j}$ are i.i.d. estimators, then we have ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\mathbb{E}\\left\\|\\frac{1}{M}\\sum_{j=0}^{M-1}\\hat{y}_{j}-\\bar{y}\\right\\|^{2}\\leq\\frac{4C_{y}^{2}}{M}.\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "Proof. See the proof of Lemma 4 of Xiong et al. (2022)) ", "page_idx": 32}, {"type": "text", "text": "Lemma 14. Let $w_{\\xi_{\\theta}}^{*}$ be defined in Proposition 7. Suppose Assumptions 3-5 hold. Then we have ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\|w_{\\xi_{\\theta}}^{*}\\|\\leq C_{w_{\\xi}},\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "where Cwe = $\\begin{array}{r}{C_{w_{\\xi}}=\\frac{L_{f}C_{Q}}{\\lambda_{\\Psi}\\left(1-\\gamma\\right)}}\\end{array}$ (). Furthermore, for any 01, 02, we have ", "page_idx": 32}, {"type": "text", "text": "where L = + () ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left\\|w_{\\xi_{\\theta_{1}}}^{*}-w_{\\xi_{\\theta_{2}}}^{*}\\right\\|\\leq L_{w}\\left\\|\\theta_{1}-\\theta_{2}\\right\\|,}\\\\ {\\frac{L_{J}}{\\lambda_{\\Psi}}+\\frac{L_{f}C_{Q}}{\\lambda_{\\Psi}^{2}\\left(1-\\gamma\\right)}\\left(L_{f}^{2}L_{\\nu}+\\frac{2L_{f}L_{\\psi}}{1-\\gamma}\\right)\\!.}\\end{array}\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "Proof. We first show the boundedness of $\\|\\nabla J(\\theta)\\|$ ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\lefteqn{\\|\\nabla J(\\theta)\\|=\\left\\|\\int_{s}\\int_{\\epsilon}\\nabla_{\\theta}f_{\\theta}(s,\\epsilon)\\nabla_{a}Q^{f_{\\theta}}(s,a)\\vert_{a=f_{\\theta}(s,\\epsilon)}p(d\\epsilon)\\nu_{\\theta}(d s)\\right\\|}}\\\\ &{\\le\\int_{s}\\int_{\\epsilon}\\|\\nabla_{\\theta}f_{\\theta}(s,\\epsilon)\\|\\,\\left\\|\\nabla_{a}Q^{f_{\\theta}}(s,a)\\vert_{a=f_{\\theta}(s,\\epsilon)}\\right\\|p(d\\epsilon)\\nu_{\\theta}(d s)}\\\\ &{\\overset{(i)}{\\le}L_{f}C_{Q}\\int_{s}\\int_{\\epsilon}\\nu_{\\theta}(d s)p(d\\epsilon)=\\frac{L_{f}C_{Q}}{(1-\\gamma)},}\\end{array}\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "where (i) follows from Assumption 3 and Lemma 12. ", "page_idx": 32}, {"type": "text", "text": "Recall we define $\\boldsymbol{\\Psi}_{\\theta}\\:=\\:\\mathbb{E}_{\\boldsymbol{\\nu}_{f_{\\theta}}}\\left[\\boldsymbol{\\nabla}_{\\boldsymbol{\\theta}}f_{\\boldsymbol{\\theta}}(s,\\boldsymbol{\\epsilon})\\boldsymbol{\\nabla}_{\\boldsymbol{\\theta}}f_{\\boldsymbol{\\theta}}(s,\\boldsymbol{\\epsilon})^{T}\\right]$ .Assumption 3 implies that $\\Psi_{\\theta}$ is nonsingular. Then by definition, we have ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\left\\|w_{\\xi_{\\theta}}^{*}\\right\\|=\\left\\|\\Psi_{\\theta}^{-1}\\nabla J(\\theta)\\right\\|\\leq\\frac{1}{\\lambda_{\\Psi}}\\left\\|\\nabla J(\\theta)\\right\\|\\leq\\frac{L_{f}C_{Q}}{\\lambda_{\\Psi}(1-\\gamma)}.\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "Next, we show the Lipschitz continuity property. ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\left|v_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*}-v_{\\hat{v}_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}}^{*}\\right|}\\\\ &{=\\left\\lVert\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*}\\nabla J(\\theta_{1})-\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*}\\nabla J(\\theta_{2})\\right\\rVert}\\\\ &{=\\left\\lVert\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*}\\nabla J(\\theta_{1})-\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*}\\nabla J(\\theta_{2})+\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*1}\\nabla J(\\theta_{2})-\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*1}\\nabla J(\\theta_{2})\\right\\rVert}\\\\ &{\\le\\left\\lVert\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*1}(\\nabla J(\\theta_{1})-\\nabla J(\\theta_{2}))\\right\\rVert+\\left\\lVert\\left(\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*1}-\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*1}\\right)\\nabla J(\\theta_{2})\\right\\rVert}\\\\ &{\\stackrel{(a)}{\\le}\\frac{L}{\\omega_{\\eta}}\\left\\lVert\\theta_{1}-\\theta_{2}\\right\\rVert+\\left\\lVert\\left(\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*1}-\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*2}\\right)\\nabla J(\\theta_{2})\\right\\rVert}\\\\ &{=\\frac{L}{\\lambda_{\\mathcal{V}_{\\hat{v}}}}\\left\\lVert\\theta_{1}-\\theta_{2}\\right\\rVert+\\left\\lVert\\left(\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*1}\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*2}-\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*1}\\Psi_{\\hat{v}_{\\hat{v}_{\\hat{v}}}}^{*1}\\right)\\nabla J(\\theta_{2})\\right\\rVert}\\\\ &{=\\frac{L}{\\lambda_{\\mathcal{V}_{\\hat{v}}}} \n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "where (i) follows from Lemma 8 and Assumption 3. ", "page_idx": 32}, {"type": "text", "text": "Observe that ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\|\\Psi_{\\theta_{2}}-\\Psi_{\\theta_{1}}\\|}\\\\ &{=\\left\\|\\displaystyle\\int_{s}\\int_{\\epsilon}\\nabla_{\\theta}f_{\\theta_{2}}(s,\\epsilon)\\nabla_{\\theta}f_{\\theta_{2}}(s,\\epsilon)^{T}p(d\\epsilon)\\nu_{\\theta_{2}}(d s)-\\displaystyle\\int_{s}\\int_{\\epsilon}\\nabla_{\\theta}f_{\\theta_{1}}(s,\\epsilon)\\nabla_{\\theta}f_{\\theta_{1}}(s,\\epsilon)^{T}p(d\\epsilon)\\nu_{\\theta_{1}}(d s)\\right\\|}\\\\ &{=\\left\\|\\displaystyle\\int_{\\epsilon}\\left(\\int_{s}\\nabla_{\\theta}f_{\\theta_{2}}(s,\\epsilon)\\nabla_{\\theta}f_{\\theta_{2}}(s,\\epsilon)^{T}\\nu_{\\theta_{2}}(d s)-\\displaystyle\\int_{s}\\nabla_{\\theta}f_{\\theta_{1}}(s,\\epsilon)\\nabla_{\\theta}f_{\\theta_{1}}(s,\\epsilon)^{T}\\nu_{\\theta_{1}}(d s)\\right)p(d\\epsilon)\\right\\|}\\\\ &{\\le\\displaystyle\\int_{\\epsilon}\\left\\|\\displaystyle\\int_{s}\\nabla_{\\theta}f_{\\theta_{2}}(s,\\epsilon)\\nabla_{\\theta}f_{\\theta_{2}}(s,\\epsilon)^{T}\\nu_{\\theta_{2}}(d s)-\\displaystyle\\int_{s}\\nabla_{\\theta}f_{\\theta_{1}}(s,\\epsilon)\\nabla_{\\theta}f_{\\theta_{1}}(s,\\epsilon)^{T}\\nu_{\\theta_{1}}(d s)\\right\\|p(d\\epsilon).\\qquad\\mathrm{~(9)~}}\\end{array}\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "Now, ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\lefteqn{\\left\\|\\int_{s}\\nabla\\rho f_{\\sigma_{2}}(s,e)\\nabla\\rho f_{\\sigma_{2}}(s,e)^{T}\\nu_{\\theta_{2}}(d s)-\\int_{s}\\nabla\\rho f_{\\sigma_{1}}(s,e)\\nabla\\rho f_{\\sigma_{1}}(s,e)^{T}\\nu_{\\theta_{1}}(d s)\\right\\|}}\\\\ &{\\leq\\left\\|\\int_{s}\\nabla\\rho f_{\\sigma_{2}}(s,e)\\nabla\\theta_{2}(s,e)^{T}\\nu_{\\theta_{2}}(d s)-\\int_{s}\\nabla\\rho f_{\\sigma_{2}}(s,e)\\nabla\\varphi f_{\\sigma_{2}}(s,e)^{T}\\nu_{\\theta_{1}}(d s)\\right\\|}\\\\ &{\\quad+\\left\\|\\int_{s}\\nabla\\rho f_{\\sigma_{2}}(s,e)\\nabla\\varphi f_{\\sigma_{2}}(s,e)^{T}\\nu_{\\theta_{1}}(d s)-\\int_{s}\\nabla\\rho f_{\\sigma_{2}}(s,e)\\nabla\\varphi f_{\\sigma_{1}}(s,e)^{T}\\nu_{\\theta_{1}}(d s)\\right\\|}\\\\ &{\\quad+\\left\\|\\int_{s}\\nabla\\rho f_{\\sigma_{2}}(s,e)\\nabla\\varphi f_{\\sigma_{1}}(s,e)^{T}\\nu_{\\theta_{1}}(d s)-\\int_{s}\\nabla\\rho f_{\\sigma_{1}}(s,e)\\nabla\\varphi f_{\\sigma_{1}}(s,e)^{T}\\nu_{\\theta_{1}}(d s)\\right\\|}\\\\ &{\\stackrel{(a)}{\\leq}L_{f}^{2}|\\nu_{\\theta_{1}}(\\cdot)-\\nu_{\\theta_{2}}(\\cdot)|_{T^{\\mathcal{N}}}+2L_{f}\\int_{s}\\|\\nabla\\varphi f_{\\sigma_{2}}(s,e)-\\nabla\\varphi f_{\\sigma_{1}}(s,e)\\|\\nu_{\\theta_{1}}(d s)}\\\\ &{\\stackrel{(b)}{\\leq}L_{f}^{2}|\\nu_{\\theta_{1}}(\\cdot)-\\nu_{\\theta_{2}}(\\cdot)|_{T^{\\mathcal{N}}}+\\frac{2L_{f}L_{e}}{1-\\gamma}\\|\\nu_{\\theta_{1}}-\\theta_{2}\\|}\\\\ &{\\stackrel{(a)}{\\leq}\\left(L_{f}^{2}L_{e}+\\frac{2L_{f}L_{e}}{1-\\gamma}\\right)\\|\\theta_{1}-\\theta_{2}\\|,}\\end{\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "where both (i) and (ii) follow from Assumption 3, and (i) follows from Lemma 10. Plugging (9) to (10), we get ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\left\\|\\Psi_{\\theta_{2}}-\\Psi_{\\theta_{1}}\\right\\|\\leq\\left(L_{f}^{2}L_{\\nu}+\\frac{2L_{f}L_{\\psi}}{1-\\gamma}\\right)\\left\\|\\theta_{1}-\\theta_{2}\\right\\|.\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "Thus, we have ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\left|\\left|w_{\\xi_{\\theta_{1}}}^{*}-w_{\\xi_{\\theta_{2}}}^{*}\\right|\\right|}\\\\ &{\\quad\\le\\displaystyle\\frac{L_{J}}{\\lambda_{\\Psi}}\\left||\\theta_{1}-\\theta_{2}|\\right|+\\frac{L_{f}C_{Q}}{\\lambda_{\\Psi}^{2}(1-\\gamma)}\\left|\\left|\\Psi_{\\theta_{2}}-\\Psi_{\\theta_{1}}\\right|\\right|}\\\\ &{\\quad\\le\\left[\\frac{L_{J}}{\\lambda_{\\Psi}}+\\frac{L_{f}C_{Q}}{\\lambda_{\\Psi}^{2}(1-\\gamma)}\\left(L_{f}^{2}L_{\\nu}+\\frac{2L_{f}L_{\\psi}}{1-\\gamma}\\right)\\right]\\left|\\theta_{1}-\\theta_{2}\\right|.}\\end{array}\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "For the clarity of the presentation, we will use the following notation for the gradient estimate for $J(\\theta_{t})$ ", "page_idx": 33}, {"type": "equation", "text": "$$\nh_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})=\\frac{1}{M}\\sum_{j=0}^{M-1}\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})^{T}w_{t}.\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "Lemma 15. Suppose Assumptions 3-5. Then we have ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})-\\nabla J(\\theta_{t})\\right\\|^{2}\\leq3L_{h}^{2}\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+3L_{h}^{2}\\kappa^{2}+\\frac{12L_{f}^{4}C_{w_{\\xi}}^{2}}{M},\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "where $L_{h}=L_{f}^{2}$ and $\\kappa$ is defined in (4). ", "page_idx": 33}, {"type": "text", "text": "Proof. By definition, we have ", "page_idx": 34}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{t},B_{t})-\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad=\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{t},B_{t})-h_{\\theta_{t}}(w_{\\theta_{t}}^{*},B_{t})+h_{\\theta_{t}}(w_{\\theta_{t}}^{*},B_{t})-h_{\\theta_{t}}(w_{\\theta_{t}}^{*},B_{t})+h_{\\theta_{t}}(w_{\\xi_{\\theta_{t}}}^{*},B_{t})-\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad\\le3\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{t},B_{t})-h_{\\theta_{t}}(w_{\\theta_{t}}^{*},B_{t})\\right\\|^{2}+3\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{\\theta_{t}}^{*},B_{t})-h_{\\theta_{t}}(w_{\\xi_{\\theta_{t}}}^{*},B_{t})\\right\\|^{2}}\\\\ &{\\quad\\quad+3\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{\\xi_{\\theta_{t}}}^{*},B_{t})-\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad\\stackrel{(i)}{\\le}\\lambda L_{j}^{2}\\mathbb{E}\\left\\|{\\psi_{t}}-w_{\\theta_{t}}^{*}\\right\\|^{2}+3L_{h}^{2}\\mathbb{E}\\left\\|w_{\\theta_{t}}^{*}-w_{\\xi_{\\theta_{t}}}^{*}\\right\\|^{2}+3\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{\\xi_{\\theta_{t}}}^{*},B_{t})-\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad\\stackrel{(i i)}{\\le}3L_{h}^{2}\\mathbb{E}\\left\\|{\\psi_{t}}-w_{\\theta_{t}}^{*}\\right\\|^{2}+3L_{h}^{2}\\kappa^{2}+3\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{\\xi_{\\theta_{t}}}^{*},B_{t})-\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad\\stackrel{(i i i)}{\\le}3L_{h}^{2}\\mathbb{E}\\left\\|{\\psi_{t \n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "where (i) follows because for any $w_{1},w_{2},\\theta\\in\\mathbb{R}^{d}$ ,we have ", "page_idx": 34}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\begin{array}{l}{\\|h_{\\theta}(w_{1},\\mathcal{B}_{t})-h_{\\theta}(w_{2},\\mathcal{B}_{t})\\|=\\left\\|\\displaystyle\\frac{1}{M}\\sum_{j=0}^{M-1}\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})^{T}(w_{1}-w_{2})\\right\\|}\\\\ {\\le L_{f}^{2}\\left\\|w_{1}-w_{2}\\right\\|:=L_{h}\\left\\|w_{1}-w_{2}\\right\\|,}\\end{array}}\\end{array}\n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "(ii) follows from (4), and (ii) holds due to the fact that ", "page_idx": 34}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{\\xi_{t}}^{*},B_{t})-\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad=\\mathbb{E}\\left\\|\\frac{1}{M}\\frac{M-1}{\\int_{\\gamma_{0}}^{\\gamma}}\\nabla\\theta f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})\\nabla\\phi f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})^{T}w_{\\xi_{t}}^{*}-\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad=\\frac{1}{M^{2}}\\displaystyle\\sum_{i=0}^{M-1}\\sum_{j=0}^{M-1}\\mathbb{E}\\langle\\nabla f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,i}^{\\prime})\\nabla\\phi f_{\\theta_{t}}(s_{t,i}^{\\prime},\\epsilon_{t,i}^{\\prime})^{T}w_{\\xi_{t}}^{*}-\\nabla J(\\theta_{t}),}\\\\ &{\\quad\\quad\\nabla\\phi f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})\\nabla f_{\\theta_{t}}(s_{t,i}^{\\prime},\\epsilon_{t,j}^{\\prime})^{T}w_{\\xi_{t}}^{*}-\\nabla J(\\theta_{t})\\rangle}\\\\ &{\\quad=\\frac{1}{M^{2}}\\displaystyle\\sum_{j=0}^{M-1}\\mathbb{E}\\left\\|\\nabla\\phi f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})\\nabla\\phi f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})^{T}w_{\\xi_{t}}^{*}-\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad\\stackrel{(a)}{\\le}\\frac{1}{M^{2}}\\displaystyle\\sum_{j=0}^{M-1}4L_{j}^{4}c_{\\epsilon_{t}}^{2}=\\frac{4L_{j}^{2}C_{w_{t}}^{2}}{M},}\\end{array}\n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "where (i) follows from Assumption 3, Lemma 13 and Lemma 14.4 Here, to apply Lemma 13, we need to upper-bound the norms of both the unbiased estimators and their expectation. For the former, wehave ", "page_idx": 34}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left\\|\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})^{T}w_{\\xi_{\\theta_{t}}}^{*}\\right\\|\\leq L_{f}^{2}C_{w_{\\xi}},}\\end{array}\n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "while for the latter, we have ", "page_idx": 34}, {"type": "equation", "text": "$$\n\\|\\nabla J(\\theta_{t})\\|\\le\\frac{L_{f}C_{Q}}{(1-\\gamma)}=\\lambda_{\\Psi}C_{w_{\\xi}}\\le L_{f}^{2}C_{w_{\\xi}},\n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "where we use the bound of $\\nabla J(\\theta_{t})$ derived in (8), the definition of $C_{w_{\\xi}}$ in Lemma 14, and that ", "page_idx": 34}, {"type": "equation", "text": "$$\n\\lambda_{\\Psi}\\leq\\frac{1}{n}\\mathrm{trace}(\\Psi)=\\left\\|\\mathbb{E}_{\\nu_{\\theta},p}\\left[\\nabla_{\\theta}f_{\\theta_{t}}(s,\\epsilon)\\nabla_{\\theta}f_{\\theta_{t}}(s,\\epsilon)^{T}\\right]\\right\\|^{2}\\leq L_{f}^{2}.\n$$", "text_format": "latex", "page_idx": 34}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbb{E}\\left\\|\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})^{T}w_{\\xi_{\\theta_{t}}}^{*}-\\nabla J(\\theta_{t})\\right\\|^{2}\\leq4L_{f}^{4}C_{w_{\\xi}}^{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 35}, {"type": "text", "text": "1.2.4 Proof of Theorem 9 ", "text_level": 1, "page_idx": 35}, {"type": "text", "text": "We use the following notations for the clarity of the presentation: ", "page_idx": 35}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{g_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})=\\displaystyle\\frac{1}{M}\\sum_{j=0}^{M-1}\\delta_{t,j}\\phi(x_{t,j})=\\displaystyle\\frac{1}{M}\\sum_{j=0}^{M-1}\\big(A_{t,j}w_{t}+b_{t,j}\\big):=\\hat{A}_{t}w_{t}+\\hat{b}_{t};}\\\\ &{\\quad\\bar{g}_{\\theta_{t}}(w_{t})=\\mathbb{E}_{d_{\\theta_{t}}}\\left[\\delta_{t}\\phi(x_{t})\\right]=\\bar{A}_{t}w_{t}+\\bar{b}_{t};}\\\\ &{\\quad\\bar{g}_{\\theta_{t}}(w_{\\theta_{t}}^{*})=\\bar{A}_{t}w_{\\theta_{t}}^{*}+\\bar{b}_{t}=0.}\\end{array}\n$$", "text_format": "latex", "page_idx": 35}, {"type": "text", "text": "Step I: Characterizing dynamics of critic's error via coupling with actor. ", "text_level": 1, "page_idx": 35}, {"type": "text", "text": "In the first step, we characterize the propagation of the dynamics of critic's dynamic tracking error based on its coupling with actor's updates. That is, we develop the relationship between $\\left\\|w_{t+1}-w_{\\theta_{t+1}}^{*}\\right\\|^{2}$ and $\\left\\lVert\\boldsymbol{w}_{t}-\\boldsymbol{w}_{\\boldsymbol{\\theta}_{t}}^{*}\\right\\rVert^{2}$ by their coupling with actor's updates. ", "page_idx": 35}, {"type": "text", "text": "We first use the dynamics of the critic to obtain ", "page_idx": 35}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{u}_{1+1}:=-u_{1,1}^{\\top}}\\\\ &{:=\\lVert u_{1+1}-u_{1,2}^{\\top}\\rVert}\\\\ &{:=\\lVert u_{1+1}-u_{1,3}^{\\top}\\rVert}\\\\ &{:=\\lVert u_{1+1}-u_{1,4}^{\\top}\\rVert}\\\\ &{:=\\lVert u_{1}-u_{1,4}^{\\top}\\rVert+2\\alpha_{2,1}(u_{1}-u_{1,2}^{\\top})^{2}+2\\alpha_{3}(u_{1}(u_{1},B_{1}))^{2}}\\\\ &{:=\\lVert u_{1}-u_{1,4}^{\\top}\\rVert+2\\alpha_{3}(u_{1}-u_{1,3}^{\\top}\\rVert)(\\alpha_{3}+u_{2,1}^{\\top}-u_{1,4}^{\\top})\\rVert}\\\\ &{\\quad+\\alpha_{4}^{2}\\lVert u_{1}(u_{1},B_{1})^{2}}\\\\ &{:=-\\lVert u_{1,5}^{\\top}-u_{1,6}^{\\top}\\rVert}\\\\ &{:=-\\lVert u_{1,6}^{\\top}-u_{1,7}^{\\top}+2\\alpha_{3}(u_{1}-u_{1,4}^{\\top})^{2}L(u_{1}-u_{1,5}^{\\top})+2\\alpha_{4}(u_{1}-u_{1,6}^{\\top}-u_{1,8}^{\\top})(u_{1},B_{1})^{2}-\\beta_{4}(u_{1})}\\\\ &{\\quad+\\alpha_{5}^{2}\\lVert u_{1}(u_{1},B_{1})^{2}}\\\\ &{:=-\\lVert u_{1,6}^{\\top}-u_{1,8}^{\\top}\\rVert}\\\\ &{\\stackrel{(a)}{\\leq}\\lVert u_{1}-u_{1,1}^{\\top}\\rVert}\\\\ &{:=\\lVert u_{1,7}^{\\top}-u_{1,8}^{\\top}-u_{1,7}^{\\top}+2\\alpha_{3}(u_{1}-u_{1,8}^{\\top})(u_{1},B_{1})^{2}-\\beta_{4}(u_{1},B_{1})^{2}}\\\\ &{\\quad+2\\alpha_{5}\\lVert u_{1,1}^{\\top}-u_{1,6}^{\\top}\\rVert}\\\\ &{:=-\\lVert u_{\n$$", "text_format": "latex", "page_idx": 35}, {"type": "text", "text": "where (i) follows from the property $(w_{t}\\,-\\,w_{\\theta_{t}}^{*})^{T}\\bar{A}_{t}(w_{t}\\,-\\,w_{\\theta_{t}}^{*})\\,\\leq\\,-{\\lambda}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}$ withsome constant $\\lambda>0$ for any policy, which has been proved in Tsitsiklis and Van Roy (1997), Bhandari et al. (2018), Tu and Recht (2019), Xiong et al. (2020), and (i) follows because $\\left\\|A\\right\\|^{2}\\leq2(1+\\gamma^{2})C_{\\phi}^{4}\\leq$ $4C_{\\phi}^{4}:=C_{A}^{2}$ ", "page_idx": 35}, {"type": "text", "text": "Taking the expectation over the actor and the critic parameters on both sides yields ", "page_idx": 36}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbb{E}\\left\\|w_{t+1}-w_{\\theta_{t}}^{*}\\right\\|^{2}}\\\\ &{\\leq(1-2\\alpha_{w}\\lambda+2\\alpha_{w}^{2}C_{A}^{2})\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+2\\alpha_{w}\\mathbb{E}\\langle w_{t}-w_{\\theta_{t}}^{*},g_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})-\\bar{g}_{\\theta_{t}}(w_{t})\\rangle}\\\\ &{\\quad+\\,2\\alpha_{w}^{2}\\mathbb{E}\\left\\|g_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})-\\bar{g}_{\\theta_{t}}(w_{t})\\right\\|^{2}}\\\\ &{=(1-2\\alpha_{w}\\lambda+2\\alpha_{w}^{2}C_{A}^{2})\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+2\\alpha_{w}^{2}\\mathbb{E}\\left\\|g_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})-\\bar{g}_{\\theta_{t}}(w_{t})\\right\\|^{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 36}, {"type": "text", "text": "Observe that ", "page_idx": 36}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbb{E}\\left\\|g_{\\theta_{t}}(w_{t},B_{t})-\\bar{g}_{\\theta_{t}}(w_{t})\\right\\|^{2}}\\\\ &{\\quad=\\mathbb{E}\\left\\|\\bar{A}_{t}w_{t}+\\bar{b}_{t}-\\bar{A}_{t}w_{t}-\\bar{b}_{t}\\right\\|^{2}}\\\\ &{\\quad\\overset{\\mathrm{(i)}}{\\le}3\\mathbb{E}\\left\\|\\left(\\bar{A}_{t}-\\bar{A}_{t}\\right)(w_{t}-w_{\\theta_{t}}^{*})\\right\\|^{2}+3\\mathbb{E}\\left\\|\\left(\\bar{A}_{t}-\\bar{A}_{t}\\right)w_{\\theta_{t}}^{*}\\right\\|^{2}+3\\mathbb{E}\\left\\|\\hat{b}_{t}-\\bar{b}_{t}\\right\\|^{2}}\\\\ &{\\quad\\le3\\mathbb{E}\\left\\|\\bar{A}_{t}-\\bar{A}_{t}\\right\\|_{F}^{2}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+3\\mathbb{E}\\left\\|\\bar{A}_{t}-\\bar{A}_{t}\\right\\|_{F}^{2}\\left\\|w_{\\theta_{t}}^{*}\\right\\|^{2}+3\\mathbb{E}\\left\\|\\hat{b}_{t}-\\bar{b}_{t}\\right\\|^{2}}\\\\ &{\\quad\\overset{\\mathrm{(ii)}}{\\le}\\frac{12C_{4}^{2}}{M}\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+\\frac{12\\left(C_{4}^{2}\\mathbb{E}\\left\\|w_{\\theta_{t}}^{*}\\right\\|^{2}+C_{\\theta_{t}}^{2}\\right)}{M}}\\\\ &{\\quad\\overset{\\mathrm{(iii)}}{\\le}\\frac{12C_{4}^{2}}{M}\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+\\frac{12\\left(C_{4}^{2}C_{4}^{2}C_{\\theta_{t}}^{2}+C_{\\theta_{t}}^{2}\\right)}{M},}\\end{array}\n$$", "text_format": "latex", "page_idx": 36}, {"type": "text", "text": "where (i) followsbecause $(x+y+z)^{2}\\leq3x^{2}+3y^{2}+3z^{2}$ , (i) follows from Lemma 13 and $C_{b}:=$ $R_{\\mathrm{max}}C_{\\phi}\\geq\\|b\\|$ and (i)follows because $\\left\\|w_{\\theta_{t}}^{*}\\right\\|^{2}=\\left\\|{\\bar{A}}_{t}^{-1}{\\bar{b}}_{t}\\right\\|^{2}\\leq C_{b}/\\lambda_{A}=R_{\\operatorname*{max}}C_{\\phi}/\\lambda_{A}:=C_{w}$ by Assumption 6. ", "page_idx": 36}, {"type": "text", "text": "Substituting the above bound into (11), we have ", "page_idx": 36}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbb{E}\\left\\|w_{t+1}-w_{\\theta_{t}}^{*}\\right\\|^{2}}\\\\ &{\\quad\\leq(1-2\\alpha_{w}\\lambda+2\\alpha_{w}^{2}C_{A}^{2})\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+2\\alpha_{w}^{2}\\mathbb{E}\\left\\|g_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})-\\bar{g}_{\\theta_{t}}(w_{t})\\right\\|^{2}}\\\\ &{\\quad\\leq\\bigg(1-2\\alpha_{w}\\lambda+2\\alpha_{w}^{2}C_{A}^{2}+\\frac{24\\alpha_{w}^{2}C_{A}^{2}}{M}\\bigg)\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+\\frac{24\\alpha_{w}^{2}(C_{A}^{2}C_{w}^{2}+C_{b}^{2})}{M}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 36}, {"type": "text", "text": "Since $\\begin{array}{r}{\\alpha_{w}\\leq\\frac{\\lambda}{2C_{A}^{2}};M\\geq\\frac{48\\alpha_{w}C_{A}^{2}}{\\lambda}}\\end{array}$ , we frther obtain ", "page_idx": 36}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbb{E}\\left\\|w_{t+1}-w_{\\theta_{t}}^{*}\\right\\|^{2}}\\\\ &{\\quad\\leq\\left(1-2\\alpha_{w}\\lambda+2\\alpha_{w}^{2}C_{A}^{2}+\\frac{24\\alpha_{w}^{2}C_{A}^{2}}{M}\\right)\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+\\frac{24\\alpha_{w}^{2}\\left(C_{A}^{2}C_{w}^{2}+C_{b}^{2}\\right)}{M}}\\\\ &{\\quad\\leq\\left(1-\\frac{\\alpha_{w}\\lambda}{2}\\right)\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+\\frac{24\\alpha_{w}^{2}\\left(C_{A}^{2}C_{w}^{2}+C_{b}^{2}\\right)}{M}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 36}, {"type": "text", "text": "Next, we use Young's inequality, and obtain ", "page_idx": 36}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbb{E}\\left\\|w_{t+1}-w_{\\theta_{t+1}}^{*}\\right\\|^{2}}\\\\ &{\\leq\\left(1+\\displaystyle\\frac{1}{2(2/\\lambda\\alpha_{w}-1)}\\right)\\mathbb{E}\\left\\|w_{t+1}-w_{\\theta_{t}}^{*}\\right\\|^{2}+\\left(1+2(2/\\lambda\\alpha_{w}-1)\\right)\\mathbb{E}\\left\\|w_{\\theta_{t}}^{*}-w_{\\theta_{t+1}}^{*}\\right\\|^{2}}\\\\ &{\\overset{\\mathrm{i}}{\\leq}\\left(1-\\displaystyle\\frac{\\lambda\\alpha_{w}}{4}\\right)\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+\\displaystyle\\frac{4-\\lambda\\alpha_{w}}{4-2\\lambda\\alpha_{w}}\\cdot\\frac{24\\alpha_{w}^{2}(C_{A}^{2}C_{w}^{2}+C_{b}^{2})}{M}+\\displaystyle\\frac{4}{\\lambda\\alpha_{w}}\\mathbb{E}\\left\\|w_{\\theta_{t}}^{*}-w_{\\theta_{t+1}}^{*}\\right\\|^{2}}\\\\ &{\\overset{\\mathrm{i}}{\\leq}\\left(1-\\displaystyle\\frac{\\lambda\\alpha_{w}}{4}\\right)\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}+\\displaystyle\\frac{4-\\lambda\\alpha_{w}}{4-2\\lambda\\alpha_{w}}\\cdot\\frac{24\\alpha_{w}^{2}(C_{A}^{2}C_{w}^{2}+C_{b}^{2})}{M}+\\frac{12L_{w}^{2}}{\\lambda\\alpha_{w}}\\mathbb{E}\\left\\|\\theta_{t+1}-\\theta_{t}\\right\\|^{2}+\\displaystyle\\frac{24\\kappa^{2}}{\\lambda\\alpha_{w}},}\\end{array}\n$$", "text_format": "latex", "page_idx": 36}, {"type": "text", "text": "where (i) follows from the bound derived in (12), and (i) holds due to the fact that? ", "page_idx": 37}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbb{E}\\left\\|w_{\\theta_{t}}^{*}-w_{\\theta_{t+1}}^{*}\\right\\|^{2}}\\\\ &{\\quad\\leq3\\mathbb{E}\\left\\|w_{\\theta_{t}}^{*}-w_{\\xi_{\\theta_{t}}}^{*}\\right\\|^{2}+3\\mathbb{E}\\left\\|w_{\\xi_{\\theta_{t}}}^{*}-w_{\\xi_{\\theta_{t+1}}}^{*}\\right\\|^{2}+3\\mathbb{E}\\left\\|w_{\\xi_{\\theta_{t+1}}}^{*}-w_{\\theta_{t+1}}^{*}\\right\\|^{2}}\\\\ &{\\quad\\overset{\\mathrm{(i)}}{\\leq}3\\kappa^{2}+3\\mathbb{E}\\left\\|w_{\\xi_{\\theta_{t}}}^{*}-w_{\\xi_{\\theta_{t+1}}}^{*}\\right\\|^{2}+3\\kappa^{2}}\\\\ &{\\quad\\overset{\\mathrm{(ii)}}{\\leq}6\\kappa^{2}+3L_{w}^{2}\\mathbb{E}\\left\\|\\theta_{t+1}-\\theta_{t}\\right\\|^{2},}\\end{array}\n$$", "text_format": "latex", "page_idx": 37}, {"type": "text", "text": "where (i) follows from the definition of $\\kappa$ in (4), and (ii) follows from Lemma 14. ", "page_idx": 37}, {"type": "text", "text": "Step II: Bounding cumulative tracking error via compatibility theorem for DPG. ", "page_idx": 37}, {"type": "text", "text": "In this step, we bound the cumulative tracking error based on the dynamics of the tracking error from the last step. To this end, we need to first bound the difference between two consecutive actor parameters. ", "page_idx": 37}, {"type": "text", "text": "Observ that $\\begin{array}{r}{\\theta_{t+1}-\\theta_{t}=\\frac{\\alpha_{\\theta}}{M}\\sum_{j=0}^{M-1}\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})\\nabla_{\\theta}f_{\\theta_{t}}(s_{t,j}^{\\prime},\\epsilon_{t,j}^{\\prime})^{T}w_{t}=\\alpha_{\\theta}h_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})}\\end{array}$ and $\\begin{array}{r}{\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})\\right\\|^{2}\\leq2\\mathbb{E}\\left\\|\\nabla J(\\theta_{t})\\right\\|^{2}+2\\mathbb{E}\\left\\|h_{\\theta_{t}}(w_{t},\\mathcal{B}_{t})-\\nabla J(\\theta_{t})\\right\\|^{2}.}\\end{array}$ We proceed to bound (13) as follows ", "page_idx": 37}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbb{E}\\left\\|\\mathbf{v}_{t+1}-\\mathbf{w}_{t+\\frac{1}{2}}\\right\\|^{2}}\\\\ &{\\leq\\left(1-\\frac{\\Delta u_{t}}{\\Delta u_{t}}\\right)\\mathbb{E}\\left\\|\\mathbf{r}_{t}-\\mathbf{w}_{\\hat{w}_{\\hat{w}_{\\hat{w}}}^{*}}\\right\\|^{2}+\\frac{4-\\lambda_{0}}{4-2\\Delta_{t}}\\mathbf{,~}\\frac{24\\Delta_{t}^{2}\\left(C_{\\hat{w}}^{2}C_{\\hat{w}}^{2}+C_{\\hat{w}}^{2}\\right)}{M}+\\frac{12L_{w}^{2}}{\\lambda_{0}\\omega_{0}}\\mathbb{E}\\|\\mathbf{\\hat{p}}_{t+1}-\\mathbf{\\hat{e}}_{\\hat{w}_{\\hat{w}}}\\|^{2}+\\frac{2^{2}}{\\lambda_{1}}}\\\\ &{\\leq\\left(1-\\frac{\\Delta u_{t}}{\\Delta u_{t}}\\right)\\mathbb{E}\\left\\|\\mathbf{r}_{t}-\\mathbf{w}_{\\hat{w}_{\\hat{w}_{\\hat{w}}}^{*}}\\right\\|^{2}+\\frac{48\\alpha_{t}^{2}\\left(C_{\\hat{w}}^{2}C_{\\hat{w}}^{2}+C_{\\hat{w}}^{2}\\right)}{\\lambda_{0}\\omega_{0}}+\\frac{2L L_{w}^{2}\\alpha_{t}^{2}\\mathbb{E}\\left\\|\\mathbf{V}_{t}\\right\\|^{2}}{\\lambda_{0}\\omega_{0}}}\\\\ &{\\quad+\\frac{24L_{w}^{2}\\alpha_{t}^{2}}{\\lambda_{0}\\omega_{0}}\\mathbb{E}\\|\\mathbf{\\hat{p}}_{t}(\\mathbf{w}_{t},\\mathbf{B}_{t})-\\mathbf{\\hat{V}}(J(\\theta))\\|^{2}-\\frac{24\\lambda_{t}}{\\lambda_{0}\\omega_{0}}}\\\\ &{\\overset{(b)}{\\leq}\\left(1-\\frac{\\Delta u_{t}}{\\Delta u_{t}}+\\frac{72L_{w}^{2}L_{w}^{2}\\alpha_{t}^{2}}{\\lambda_{0}\\omega_{0}}\\right)\\mathbb{E}\\left\\|\\mathbf{r}_{t}-\\mathbf{w}_{\\hat{w}_{\\hat{w}_{\\hat{w}}}^{*}}\\right\\|^{2}+\\frac{48\\alpha_{t}^\n$$", "text_format": "latex", "page_idx": 37}, {"type": "text", "text": "where (i) follows from Lemma 15, and (ii) follows because $\\begin{array}{r}{\\alpha_{\\theta}\\le\\frac{\\lambda\\alpha_{w}}{24L_{h}L_{w}}}\\end{array}$ ", "page_idx": 37}, {"type": "text", "text": "We further take the summation over all iterations on both sides of (14) and have ", "page_idx": 37}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\displaystyle\\sum_{t=0}^{T-1}\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}}\\\\ &{\\le\\displaystyle\\sum_{t=0}^{T-1}\\left(1-\\frac{\\lambda\\alpha_{w}}{8}\\right)^{t}\\left\\|w_{0}-w_{\\theta_{0}}^{*}\\right\\|^{2}+\\frac{24L_{w}^{2}\\alpha_{\\theta}^{2}}{\\lambda\\alpha_{w}}\\sum_{t=0}^{T-1}\\sum_{i=0}^{t-1}\\left(1-\\frac{\\lambda\\alpha_{w}}{8}\\right)^{t-1-i}\\mathbb{E}\\left\\|\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad+\\left[\\frac{48\\alpha_{w}^{2}(C_{A}^{2}C_{w}^{2}+C_{b}^{2})}{M}+\\frac{24L_{w}^{2}\\alpha_{\\theta}^{2}}{\\lambda\\alpha_{w}}\\left(3L_{h}^{2}\\kappa^{2}+\\frac{12L_{f}^{4}C_{w_{\\xi}}^{2}}{M}\\right)+\\frac{24\\kappa^{2}}{\\lambda\\alpha_{w}}\\right]\\sum_{t=0}^{T-1}\\sum_{i=0}^{t-1}\\left(1-\\frac{\\lambda\\alpha_{w}}{8}\\right)^{t-1-i}}\\end{array}\n$$", "text_format": "latex", "page_idx": 37}, {"type": "text", "text": "SIn Xiong et al 2022),they directly use $\\mathbb{E}\\left\\|w_{\\theta_{t}}^{*}-w_{\\theta_{t+1}}^{*}\\right\\|^{2}\\leq L_{w}\\mathbb{E}\\left\\|\\theta_{t+1}-\\theta_{t}\\right\\|^{2}$ which is not proven and is different from the inequality from Lemma $14\\!\\!:\\mathbb{E}\\left\\|w_{\\xi_{\\theta_{t}}}^{*}-w_{\\xi_{\\theta_{t+1}}}^{*}\\right\\|^{2}\\leq L_{w}\\mathbb{E}\\left\\|\\theta_{t+1}-\\theta_{t}\\right\\|^{2}$ . Here, we use the triangle inequality to give abound for $\\mathbb{E}\\left\\|w_{\\theta_{t}}^{*}-w_{\\theta_{t+1}}^{*}\\right\\|^{2}$ ", "page_idx": 37}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\leq\\displaystyle\\frac{8\\left\\Vert w_{0}-w_{\\theta_{0}}^{*}\\right\\Vert^{2}}{\\lambda\\alpha_{w}}+\\left[\\frac{48\\alpha_{w}^{2}(C_{A}^{2}C_{w}^{2}+C_{b}^{2})}{M}+\\frac{24L_{w}^{2}\\alpha_{\\theta}^{2}}{\\lambda\\alpha_{w}}\\left(3L_{h}^{2}\\kappa^{2}+\\frac{12L_{f}^{4}C_{w_{\\xi}}^{2}}{M}\\right)+\\frac{24\\kappa^{2}}{\\lambda\\alpha_{w}}\\right]\\cdot\\frac{8T}{\\lambda\\alpha_{w}}}\\\\ &{\\quad+\\displaystyle\\frac{192L_{w}^{2}\\alpha_{\\theta}^{2}}{\\lambda^{2}\\alpha_{w}^{2}}\\sum_{t=0}^{T-1}\\mathbb{E}\\left\\Vert\\nabla J(\\theta_{t})\\right\\Vert^{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 38}, {"type": "text", "text": "Step IMl: Overall convergence by canceling tracking error via actor's positive progress. ", "text_level": 1, "page_idx": 38}, {"type": "text", "text": "In this step, we establish the overall convergence to a stationary policy by novel cancellation of the above cumulative tracking error via actor's update progress. ", "page_idx": 38}, {"type": "text", "text": "Based on Lemma 8, we have ", "page_idx": 38}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\left|\\hat{\\mathcal{Z}}(\\theta_{+1})-\\mathbb{E}\\hat{\\mathcal{Z}}(\\mu_{+})\\right|}\\\\ &{\\geq\\mathbb{E}\\{\\mathcal{Z}(\\mu_{+}),\\theta_{+1}-\\theta_{i}\\}-\\frac{L_{2}}{2}\\mathbb{E}\\{\\left|\\theta_{+1}-\\theta_{i}\\right|^{2}\\}}\\\\ &{=\\alpha_{+}\\mathbb{E}\\{\\mathcal{Y}(J_{+}),h_{a_{}}(w_{+},B_{1})\\}-\\frac{L_{2}\\mu_{+}2}{2}\\mathbb{E}\\left|h_{a_{}}(w_{+},B_{1})\\right|^{2}}\\\\ &{=\\alpha_{+}\\mathbb{E}\\{\\mathcal{Y}(\\mu_{+})\\}^{2}+\\alpha_{+}\\mathbb{E}\\{\\mathcal{Y}(J_{+}),h_{a_{}}(w_{+},B_{1})-\\mathbb{V}(J_{+})\\}-\\frac{L_{2}\\mu_{+}^{2}}{2}\\mathbb{E}\\{h_{a_{}}(w_{+},B_{1})\\}^{2}}\\\\ &{\\overset{\\mathrm{(a)0}}{\\geq}\\frac{\\alpha_{+}}{2}\\mathbb{E}\\{\\mathcal{Y}(\\mu_{+})\\}^{2}-\\frac{\\alpha_{+}}{4}\\mathbb{E}\\{h_{a}(w_{+},B_{1})-\\mathbb{V}(J_{+})\\}^{2}}\\\\ &{\\quad-\\frac{L_{2}\\mu_{+}^{2}}{2}\\mathbb{E}\\{h_{a_{}}(w_{+},B_{1})-\\mathbb{V}(J_{+})+\\mathbb{V}(J_{+})\\}^{2}}\\\\ &{\\geq\\left(\\frac{\\alpha_{+}}{2}-L_{2}\\alpha_{+}^{2}\\right)\\mathbb{E}\\{\\left|\\mathcal{Y}(\\mu_{+})\\right|^{2}-\\left(\\frac{\\alpha_{+}}{2}+L_{2}\\alpha_{+}^{2}\\right)\\mathbb{E}\\left|h_{a_{}}(w_{+},B_{1})-\\mathbb{V}(J_{+})\\right|^{2}}\\\\ &{\\overset{\\mathrm{(a)0}}{\\geq}\\left(\\frac{\\alpha_{-}}{2}-L_{2}\\alpha_{+}^{2}\\right)\\mathbb{E}\\{\\mathcal{Y}(\\mu_{+})\\}^{2}-\\left(\\frac{\\alpha_{+}}{ \n$$", "text_format": "latex", "page_idx": 38}, {"type": "text", "text": "where (i) follows because $x^{T}y\\geq-{\\textstyle{\\frac{1}{2}}}x^{2}-{\\textstyle{\\frac{1}{2}}}y^{2}$ , (i) follows from Lemma 15, and (i) follows from the condition \u03b1e \u2264 4t., ", "page_idx": 38}, {"type": "text", "text": "We next take the summation over all iterations on both sides of the above bound and obtain ", "page_idx": 38}, {"type": "equation", "text": "T-1 $$\n\\begin{array}{r l}&{\\frac{\\alpha_{\\theta}}{4}\\displaystyle\\sum_{t=0}^{T-1}\\mathbb{E}\\left\\|\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad\\le\\mathbb{E}[J(\\theta_{T+1})]-\\mathbb{E}[J(\\theta_{0})]+\\frac{3\\alpha_{\\theta}}{4}\\left(3L_{h}^{2}\\kappa^{2}+\\frac{12L_{f}^{4}C_{w_{\\xi}}^{2}}{M}\\right)\\cdot T+\\frac{9\\alpha_{\\theta}L_{h}^{2}}{4}\\displaystyle\\sum_{t=0}^{T-1}\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}}\\\\ &{\\quad\\le\\displaystyle\\frac{R_{\\operatorname*{max}}}{1-\\gamma}+\\frac{3\\alpha_{\\theta}}{4}\\left(3L_{h}^{2}\\kappa^{2}+\\frac{12L_{f}^{4}C_{w_{\\xi}}^{2}}{M}\\right)\\cdot T+\\frac{9\\alpha_{\\theta}L_{h}^{2}}{4}\\displaystyle\\sum_{t=0}^{T-1}\\mathbb{E}\\left\\|w_{t}-w_{\\theta_{t}}^{*}\\right\\|^{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 38}, {"type": "text", "text": "Substituting the cumulative tracking error bound derived in (15) into (17) yields ", "page_idx": 38}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\frac{\\alpha_{\\theta}}{8}\\displaystyle\\sum_{t=0}^{T-1}\\mathbb{E}\\left\\|\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad\\overset{\\mathrm{(i)}}{\\leq}\\left(\\frac{\\alpha_{\\theta}}{4}-\\frac{432L_{h}^{2}L_{w}^{2}\\alpha_{\\theta}^{3}}{\\lambda^{2}\\alpha_{w}^{2}}\\right)\\displaystyle\\sum_{t=0}^{T-1}\\mathbb{E}\\left\\|\\nabla J(\\theta_{t})\\right\\|^{2}}\\\\ &{\\quad\\leq\\displaystyle\\frac{R_{\\operatorname*{max}}}{1-\\gamma}+\\frac{3\\alpha_{\\theta}}{4}\\left(3L_{h}^{2}\\kappa^{2}+\\frac{12L_{f}^{4}C_{w_{\\xi}}^{2}}{M}\\right)\\cdot T+\\frac{18\\alpha_{\\theta}L_{h}^{2}}{\\lambda\\alpha_{w}}\\left\\|w_{0}-w_{\\theta_{0}}^{*}\\right\\|^{2}}\\end{array}\n$$", "text_format": "latex", "page_idx": 38}, {"type": "text", "text": "\u00b0Here, we highlight this condition on $\\alpha\\theta$ , which is missing from Theorem 1 of Xiong et al. (2022). ", "page_idx": 38}, {"type": "equation", "text": "$$\n+\\left[\\frac{48\\alpha_{w}^{2}(C_{A}^{2}C_{w}^{2}+C_{b}^{2})}{M}+\\frac{8L_{w}^{2}\\alpha_{\\theta}^{2}}{\\lambda\\alpha_{w}}\\left(3L_{h}^{2}\\kappa^{2}+\\frac{12L_{f}^{4}C_{w_{\\xi}}^{2}}{M}\\right)+\\frac{24\\kappa^{2}}{\\lambda\\alpha_{w}}\\right]\\cdot\\frac{18\\alpha_{\\theta}L_{h}^{2}T}{\\lambda\\alpha_{w}},\n$$", "text_format": "latex", "page_idx": 39}, {"type": "text", "text": "where (i) follows from the condition $\\begin{array}{r}{\\alpha_{\\theta}\\leq\\frac{\\lambda\\alpha_{w}}{24\\sqrt{6}L_{h}L_{w}}}\\end{array}$ ", "page_idx": 39}, {"type": "text", "text": "Finally, we have ", "page_idx": 39}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\underset{\\in[T]}{\\operatorname*{sin}}\\mathbb{E}\\left\\Vert\\nabla J(\\theta_{t})\\right\\Vert^{2}\\leq\\cfrac{1}{T}\\underset{t=0}{\\overset{T-1}{\\sum}}\\mathbb{E}\\left\\Vert\\nabla J(\\theta_{t})\\right\\Vert^{2}}\\\\ &{\\leq\\left(\\frac{8R_{\\operatorname*{max}}}{\\alpha\\theta(1-\\gamma)}+\\frac{144L_{h}^{2}}{\\lambda\\alpha_{w}}\\left\\Vert w_{0}-w_{\\theta_{0}}^{*}\\right\\Vert^{2}\\right)\\cdot\\cfrac{1}{T}+6\\left(3L_{h}^{2}\\kappa^{2}+\\frac{12L_{f}^{4}C_{w_{\\varepsilon}}^{2}}{M}\\right)}\\\\ &{\\quad\\quad+\\left[\\frac{48\\alpha_{w}^{2}(C_{A}^{2}C_{w}^{2}+C_{b}^{2})}{M}+\\frac{8L_{w}^{2}\\alpha_{\\theta}^{2}}{\\lambda\\alpha_{w}}\\left(3L_{h}^{2}\\kappa^{2}+\\frac{12L_{f}^{4}C_{w_{\\varepsilon}}^{2}}{M}\\right)+\\frac{24\\kappa^{2}}{\\lambda\\alpha_{w}}\\right]\\cdot\\frac{144L_{h}^{2}}{\\lambda\\alpha_{w}}}\\\\ &{=\\frac{c_{1}}{T}+\\frac{c_{2}}{M}+c_{3}\\kappa^{2},}\\end{array}\n$$", "text_format": "latex", "page_idx": 39}, {"type": "text", "text": "where7 ", "page_idx": 39}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{c_{1}=\\cfrac{8R_{\\mathrm{max}}}{\\alpha_{\\theta}\\left(1-\\gamma\\right)}+\\cfrac{144L_{h}^{2}}{\\lambda\\alpha_{w}}\\left\\Vert w_{0}-w_{\\theta_{0}}^{*}\\right\\Vert^{2},}\\\\ &{c_{2}=72L_{f}^{4}C_{w_{\\xi}}^{2}+\\left[48\\alpha_{w}^{2}(C_{A}^{2}C_{w}^{2}+C_{b}^{2})+\\cfrac{96L_{w}^{2}L_{f}^{4}C_{w_{\\xi}}^{2}\\alpha_{\\theta}^{2}}{\\lambda\\alpha_{w}}\\right]\\cdot\\cfrac{144L_{h}^{2}}{\\lambda\\alpha_{w}},}\\\\ &{c_{3}=18L_{h}^{2}+\\left[\\cfrac{24L_{w}^{2}L_{h}^{2}\\alpha_{\\theta}^{2}}{\\lambda\\alpha_{w}}+\\cfrac{24}{\\lambda\\alpha_{w}}\\right]\\cdot\\cfrac{144L_{h}^{2}}{\\lambda\\alpha_{w}}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 39}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 40}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 40}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately refect the paper's contributions and scope? ", "page_idx": 40}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 40}, {"type": "text", "text": "Justification: All our claims are verified by extensive experimental results and ablation studies in simulation and also tested on robots. ", "page_idx": 40}, {"type": "text", "text": "Guidelines: ", "page_idx": 40}, {"type": "text", "text": "\u00b7 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u00b7 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u00b7 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u00b7 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 40}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 40}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 40}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 40}, {"type": "text", "text": "Justification: We discuss the limitations of our work in the main paper. ", "page_idx": 40}, {"type": "text", "text": "Guidelines: ", "page_idx": 40}, {"type": "text", "text": "\u00b7 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u00b7 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u00b7 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should refect on how these assumptions might be violated in practice and what the implications would be.   \n\u00b7 The authors should refect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u00b7 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u00b7 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u00b7 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u00b7 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren't acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 40}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 40}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 40}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 40}, {"type": "text", "text": "Justification: We discuss the relevant theory and convergence proofs of the reparametrization gradient estimator in Appendix A and Appendix I respectively. ", "page_idx": 41}, {"type": "text", "text": "Guidelines: ", "page_idx": 41}, {"type": "text", "text": "\u00b7 The answer NA means that the paper does not include theoretical results.   \n\u00b7 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u00b7 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u00b7 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u00b7 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u00b7 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 41}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 41}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 41}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 41}, {"type": "text", "text": "Justification: We propose a novel incremental policy gradient algorithm. We provide pseudocode and implementation details which are easy to follow and reproduce. Our code is also available publicly on GitHub and Google Colab. ", "page_idx": 41}, {"type": "text", "text": "Guidelines: ", "page_idx": 41}, {"type": "text", "text": "\u00b7 The answer NA means that the paper does not include experiments.   \n\u00b7 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u00b7 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u00b7 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u00b7 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 41}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 41}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 42}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 42}, {"type": "text", "text": "Justification: We share the relevant code. All data can be generated during training. ", "page_idx": 42}, {"type": "text", "text": "Guidelines: ", "page_idx": 42}, {"type": "text", "text": "\u00b7 The answer NA means that paper does not include experiments requiring code.   \n\u00b7 Please see the NeurIPS code and data submission guidelines (https: //nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u00b7 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\" is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u00b7 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https : //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u00b7 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u00b7 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u00b7 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u00b7 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 42}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 42}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 42}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 42}, {"type": "text", "text": "Justification: We provide descriptions of our experimental setup in the main paper. We also list important hyper-parameters, neural network architectures, and other training details in the appendix. ", "page_idx": 42}, {"type": "text", "text": "Guidelines: ", "page_idx": 42}, {"type": "text", "text": "\u00b7 The answer NA means that the paper does not include experiments. \u00b7 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u00b7 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 42}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 42}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 42}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 42}, {"type": "text", "text": "Justification: We assume normally distributed errors. All results are averaged over 30 runs and reportedwith $95\\%$ confidence interval. ", "page_idx": 42}, {"type": "text", "text": "Guidelines: ", "page_idx": 42}, {"type": "text", "text": "\u00b7 The answer NA means that the paper does not include experiments. \u00b7 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 42}, {"type": "text", "text": "\u00b7 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u00b7 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u00b7 The assumptions made should be given (e.g., Normally distributed errors).   \n\u00b7 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u00b7 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u00b7 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u00b7 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 43}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 43}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 43}, {"type": "text", "text": "Justification: It is listed in the appendix ", "page_idx": 43}, {"type": "text", "text": "Guidelines: ", "page_idx": 43}, {"type": "text", "text": "\u00b7 The answer NA means that the paper does not include experiments.   \n\u00b7 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u00b7 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u00b7 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn't make it into the paper). ", "page_idx": 43}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https: //neurips.cc/public/EthicsGuidelines? ", "page_idx": 43}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "Justification: Our paper conforms to the NeurIPS Code of Ethics Guidelines: ", "page_idx": 43}, {"type": "text", "text": "\u00b7 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u00b7 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u00b7 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 43}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 43}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 43}, {"type": "text", "text": "Justification: We discuss this in the main paper under the paragraph tile Societal Impact. Guidelines: ", "page_idx": 43}, {"type": "text", "text": "\u00b7 The answer NA means that there is no societal impact of the work performed. \u00b7 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. ", "page_idx": 43}, {"type": "text", "text": "\u00b7 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u00b7 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u00b7 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u00b7 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 44}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 44}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 44}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 44}, {"type": "text", "text": "Justification: This paper does not pose such risks ", "page_idx": 44}, {"type": "text", "text": "Guidelines: ", "page_idx": 44}, {"type": "text", "text": "\u00b7 The answer NA means that the paper poses no such risks.   \n\u00b7 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u00b7 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u00b7 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 44}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 44}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 44}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 44}, {"type": "text", "text": "Justification: We implemented most of our algorithms from scratch and use popular benchmarks and cite them as and when necessary. All our results are generated during training. ", "page_idx": 44}, {"type": "text", "text": "Guidelines: ", "page_idx": 44}, {"type": "text", "text": "\u00b7 The answer NA means that the paper does not use existing assets.   \n\u00b7 The authors should cite the original paper that produced the code package or dataset.   \n\u00b7 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u00b7 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u00b7 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u00b7 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode . com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u00b7 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u00b7 If this information is not available online, the authors are encouraged to reach out to the asset's creators. ", "page_idx": 44}, {"type": "text", "text": "", "page_idx": 45}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 45}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 45}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 45}, {"type": "text", "text": "Justification: We provide our code and a Readme file to run experiments ", "page_idx": 45}, {"type": "text", "text": "Guidelines: ", "page_idx": 45}, {"type": "text", "text": "\u00b7 The answer NA means that the paper does not release new assets.   \n\u00b7 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u00b7 The paper should discuss whether and how consent was obtained from people whose assetisused.   \n\u00b7 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 45}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 45}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 45}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 45}, {"type": "text", "text": "Justification: his paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 45}, {"type": "text", "text": "\u00b7 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u00b7 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u00b7 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 45}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 45}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution)were obtained? ", "page_idx": 45}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 45}, {"type": "text", "text": "Justification: This paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 45}, {"type": "text", "text": "\u00b7 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u00b7 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u00b7 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPs Code of Ethics and the guidelines for their institution.   \n\u00b7 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 45}, {"type": "text", "text": "", "page_idx": 46}]