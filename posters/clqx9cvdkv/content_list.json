[{"type": "text", "text": "UniIF: Unified Molecule Inverse Folding ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Zhangyang Gao 1,2, \u2020, Jue Wang 1,2, \u2020, Cheng Tan 1,2, \u2020, Lirong Wu 2, Yufei Huang 2, Siyuan Li 2, Zhirui Ye 2, Stan Z. Li 2, \u2217 1 Zhejiang University 2 Westlake University ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Molecule inverse folding has been a long-standing challenge in chemistry and biology, with the potential to revolutionize drug discovery and material science. Despite specified models have been proposed for different small- or macro-molecules, few have attempted to unify the learning process, resulting in redundant efforts. Complementary to recent advancements in molecular structure prediction, such as RoseTTAFold All-Atom and AlphaFold3, we propose the unified model UniIF for the inverse folding of all molecules. We do such unification in two levels: 1) DataLevel: We propose a unified block graph data form for all molecules, including the local frame building and geometric feature initialization. 2) Model-Level: We introduce a geometric block attention network, comprising a geometric interaction, interactive attention and virtual long-term dependency modules, to capture the 3D interactions of all molecules. Through comprehensive evaluations across various tasks such as protein design, RNA design, and material design, we demonstrate that our proposed method surpasses state-of-the-art methods on all tasks. UniIF offers a versatile and effective solution for general molecule inverse folding. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Molecule inverse folding plays a pivotal role in drug and material design, enabling scientists to synthesize novel molecules with the desired structure. Previously, many studies focus on either macromolecules [19, 33, 21, 9, 17, 4, 10, 17, 8, 34] or small molecules [6, 26, 16, 28, 14, 31] separately, leaving the challenge of inverse folding general molecules. For example, the advanced small molecule model [6, 31] take atoms as basic units; the macromolecule models [8, 10] consider predefined microstructures (such as amino acids and nucleotides) as the basic units. Additionally, even for the same molecule, different models employ varying strategies to extract geometric features. Complementary to the great success of RoseTTAFold All-Atom [25] and AlphaFold3 [1] in molecular structure prediction, we propose a unified model, UniIF, for the inverse folding of all molecules. ", "page_idx": 0}, {"type": "text", "text": "By comparing small- and macro-molecules, we identify three challenges toward the unified model: (1) Unit Discrepancy: The macromolecules takes predefined microstructures (amino acids and nucleotides) as the basic units, while small molecules takes atoms as basic units. (2) Geometric Featurizer: Different studies employ various strategies for extracting geometric features from structures, such as distance, angles and tensor product; there are lack of unified featurization strategy. (3) System Size: The small-molecules allow the full attention transformer to learn long-term dependencies, but the quadratic computing cost limits the mechanism scalling up to macro-molecular systems. Alternatively, previous research use sparse ", "page_idx": 0}, {"type": "image", "img_path": "clqX9cVDKV/tmp/8a1bced1c082206a72e0a7201c117e3cfa28a98b47a341984acdbb23cc0aa4cc.jpg", "img_caption": ["Figure 1: Unified molecule inverse folding. "], "img_footnote": [], "page_idx": 0}, {"type": "text", "text": "GNN, which suffers from the limited local receptive field that causes over-smoothing and oversquashing [29]. In addition, developing a unified model working well for all molecules is challenging. ", "page_idx": 0}, {"type": "text", "text": "The unit discrepancy makes it challenge to adapt methods across small- and macro-molecules, which explains the divergence between these two research lines. As a solution, we propose a frame-based block to unify the representation of amino acids, nucleotides, and atoms: a group of atoms with varying size is treated as a block with fixed size. Each block includes decoupled equivariant basis and invariant features, generalizing the representation of AlphaFold2 and other small-molecule methods. ", "page_idx": 1}, {"type": "text", "text": "The geometric featurizer is necessary to capture the geometric interactions between blocks. We initialize the equivariant block basis using predefined rules or a learnable GNN layer, and then constructing invariant block features based on these basis. The key operation is to use local coordinates and dot product to capture the geometric interactions between virtual atoms. We reuse the featurizer in each model layer to interactively learn updated geometric features, where the concept of directed virtual atom is introduced to enhance the pairwise interactions. We show that the unified featurizer works well across protein design, RNA design, and material design. ", "page_idx": 1}, {"type": "text", "text": "We use sparse GNN to address the system size issue, while maintaining the ability to capture longterm dependencies. The transformer-style protein models like AlphaFold and RosettaFold require a substantial amount of GPU memory. Sparse GNNs, on the other hand, are criticized for their tendency to over-smooth and over-squash due to their limited local receptive field. To be efficient while preserving the ability to capture long-term dependencies, we introduce global virtual blocks. Each virtual block is connected to all real blocks, serving as an information exchange agent. ", "page_idx": 1}, {"type": "text", "text": "We conducted comprehensive experiments across various tasks, including protein design, RNA design, and material design, to demonstrate the effectiveness of UniIF. The results show that UniIF achieves state-of-the-art performance on all the tasks, which is non-trivial and may benefit the machine learning, drug discovery, and material science communities. ", "page_idx": 1}, {"type": "text", "text": "2 Related work ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Unification. Unified molecular learning has attracted increasing attention in recent years. RoseTTAFold All-Atom (RFAA) [25] and AlphaFold3 [1] are two representative models that have achieved remarkable success in protein structure prediction. RoseTTAFold All-Atom uses an atombond graph for small molecules and a frame graph for macromolecules. AlphaFold3 uses a bi-level representations, i.e., atom representation and token representation, for all molecules. The token concept is requivalent to the block concept in this paper, which means a group of atoms, such as a amino acid or a nucleotide. GET [24] and EPT [20] are two recent models that use a block representation for both small and macromolecules and introduce a new equivariant transformer backbone. Unlike RFAA [25], which specifies a atom-bond graph for small molecules, our model employs a unified block graph for all molecule types and do not require the atom-bond graph. Our model also differs from AlphaFold3 [1], GET [24] and EPT [20] in the that we introduce the vector basis for each block. ", "page_idx": 1}, {"type": "text", "text": "Protein Inverse Folding. Recent research use $k$ -NN graph to represent the 3D structure and employ graph neural networks for protein inverse folding. GraphTrans [19] uses the graph attention encoder and autoregressive decoder for protein design. GVP [21] proposes geometric vector perceptrons to learn from both scalar and vector features. GCA [33] introduces global graph attention for learning contextual features. In addition, ProteinSolver [32] is developed for scenarios where partial sequences are known while not reporting results on standard benchmarks. Recently, AlphaDesign [9], ProteinMPNN [4], ESMIF [17], LMDesign [40], KWDesign [8], VFN [27] achieves dramatic improvements. A benchmark [11] is proposed to comprehensively evaluate protein design models. ", "page_idx": 1}, {"type": "text", "text": "RNA Inverse Folding. RNA inverse folding is a challenging task due to the complex secondary structure and tertiary structure. Traditional methods [3] include colony optimization and constraint programming, in addition to adaptive walk, simulated annealing and Boltzmann sampling. Recent deep learning method RDesign [34] has achieved promising results and build a benchmark for AI researchers to follow-up. RiboDiffusion [18] use diffusion decoder to generate RNA sequences conditioned on the backbone structure embeddings. ", "page_idx": 1}, {"type": "text", "text": "Material Design. Deciding which chemical compositions are likely to form compounds is a critical task in material design [28, 26, 14]. An important application is to substitute lattice-site elements or ionic species within existing compounds that exhibit similar chemical behaviors. Wang et al. [36] successfully employed the elemental substitution method to discover 18,479 stable compounds out of a pool of 189,981 potential candidates. Recently, Jensen et al. [6] introduced a open dataset for material design and established a benchmark for evaluating deep learning models in this domain. ", "page_idx": 1}, {"type": "text", "text": "3 Method ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "3.1 Overall Framework ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "As shown in Fig. 2, we propose the unified model for general molecule inverse folding. The key insights include: (1) transforming all molecules into block graphs, where each block represents an amino acid, nucleotide, or atom; (2) proposing a geometric featurizer to initialize geometric node and edge features; and (3) introducing a new GNN layer with long-term dependencies to learn expressive block representations. Our unified model achieves competitive results across diverse tasks, including protein design, RNA design, and material design. ", "page_idx": 2}, {"type": "image", "img_path": "clqX9cVDKV/tmp/b6996d0cb77223e10192112c34fda441cb323b4a83271ef84399aa1f8bdb2b8f.jpg", "img_caption": ["Figure 2: The Overall framework. (1) The model treat all types of molecules as block graphs. For macromolecules, we use predefined frames based on amino acids and nucleotides; for small molecules, we learn the local frame of each block by one-layer GNN. (2) A geometric featurizer is used to initialize the geometric node feature and edge features. (3) We propose the block graph attention layer, based on which we build the block graph neural network to learn expressive block representations. (4) Finally, we show that the UniIF can achieve competitive results on diverse tasks, ranging from protein design, RNA design and material design. "], "img_footnote": [], "page_idx": 2}, {"type": "text", "text": "3.2 Block Graph ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "We introduce the block graph to represent all types of molecules, where the key insight is to transform irregular set of atoms (varying size) as regular block representation (fixed size). ", "page_idx": 2}, {"type": "image", "img_path": "clqX9cVDKV/tmp/7a602ff5591beea3803ac218b5fd20aac7ca8accc0c8b2871d881ace1bb82a0d.jpg", "img_caption": ["Figure 3: Blocks of different molecules. The basic building blocks include amino acids, nucleotides and atoms. "], "img_footnote": [], "page_idx": 2}, {"type": "text", "text": "Atom-based Block Representation. A block $\\pmb{{\\cal B}}~=~\\{(x_{i},z_{i})\\}_{i=1}^{|\\mathcal{B}|}$ contains a set of atoms $\\{\\pmb{x}_{i},\\pmb{z}_{i}\\}_{i=1}^{|\\mathcal{B}|}$ , where $\\pmb{x}_{i}~\\in~\\mathbb{R}^{3}$ and $z_{i}~\\in~\\mathbb{R}^{d}$ represent the equivariant coordinate and invariant features, such as the atom type. The common block types include amino acids, nucleotides, and atoms, which are represented as $B^{f o l d},\\,B^{r n a}$ , and $\\bar{\\beta}^{s m o l}$ , respectively. Formally, we write $\\mathcal{B}^{f o l d}\\;=\\;\\{({\\pmb x}_{i},{\\pmb z}_{i})\\}_{i\\in\\mathcal{V}^{f o l d}}$ and $\\beta^{r n a}\\;=\\;\\{(x_{i},z_{i})\\}_{i\\in\\mathcal{V}^{n a}}$ , where $\\mathcal{V}^{f o l d}\\;\\stackrel{\\cdot}{=}\\;\\{{\\bf N},{\\bf C}1,\\dot{\\bf C}2,{\\bf O}\\}$ and $\\mathcal{V}^{r n a}\\;=\\;\\{\\mathrm{P},\\mathrm{C5},\\mathrm{C4},\\bar{\\mathrm{C3}},\\mathrm{C2},\\mathrm{C1},\\mathrm{O5},\\mathrm{O4},\\mathrm{O3},\\mathrm{O2}\\}$ are the sets of atoms for amino acids and nucleotides, respectively. For small molecules, each atom $a$ represents a block $B^{s m o l}=\\{({\\pmb x}_{a},{\\pmb z}_{a})\\}$ , where $1\\leq a\\leq118$ . As the block size $|\\beta|$ varies for different types of blocks, the atom-based blocks representation could not directly be applied for unified modeling. ", "page_idx": 2}, {"type": "text", "text": "Frame-based Block Representation. We introduce frame-based block representation to unify the modeling of all molecules. A block $\\boldsymbol{B}\\,=\\,(\\boldsymbol{F},\\dot{\\boldsymbol{f}})$ contains the equivariant frame $F$ and invariant feature vector $\\pmb{f}\\in\\dot{\\mathbb{R}}^{d}$ . The local frame $F(R,t)$ contains the axis matrix $\\boldsymbol{R}\\,=\\,[e_{1},e_{2},e_{3},\\cdot\\cdot\\cdot\\,,e_{u}]$ and translation vector $\\pmb{t}$ . We set $\\pmb{t}$ as the coordinate of the representative atom, i.e., $C1$ of macromolecules and the atom itself of small molecules. Following AlphaFold2, we consider the special case that $R\\in\\mathbb{R}^{\\breve{3},3}$ is orthogonal. However, additional experiments show that the model can also work well with non-orthogonal axis matrix. For macromolecules, the axis matrix $R$ is predefined based on amino acids and nucleotides, while for small molecules, we learn the axis matrix $R$ as it does not have prior common structure patterns. The frame-based block representation decouples geometric information: (1) the local frame basis describe the equivariant pose; (2) the invariant feature vector could embed the atom type and invariant local structure patterns for different tasks. More importantly, the dimension of the frame-based block representation is fixed, which is beneficial for the unified modeling; we build block features in Sec. 3.3. ", "page_idx": 3}, {"type": "image", "img_path": "clqX9cVDKV/tmp/e29464acddc27a42e4f131b1bd6344985f9f749892c78d3c3a44f84f05562d36.jpg", "img_caption": ["Used for Unified Modeling ", "Atom-based Block (varying size) Figure 4: Unified molecule inverse folding. "], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "", "page_idx": 3}, {"type": "text", "text": "Frame-based Block Graph. Given a molecule $\\mathcal{M}=\\{B_{s}\\}_{s=1}^{n}$ containing $n$ blocks, we build the block graph $\\mathcal{G}(\\{B_{s}\\}_{s=1}^{n},\\mathcal{E})$ using kNN algorithm. In the block graph, the $s$ -th node is represented as $\\boldsymbol{B}_{s}=\\left(F_{s},f_{s}\\right)$ , and the edge between $(s,t)$ is represented as $\\boldsymbol{B_{s t}}=\\left(F_{s t},f_{s t}\\right)$ . The relative frame is defined as $\\tilde{F_{s t}}=F_{s}^{-1}\\circ\\tilde{F_{t}}$ . Inspired by [22, 10, 27], we modify PiFold featurizer to initialize the geometric node feature $f_{s}$ and edge feature $\\pmb{f}_{s,t}$ ; refer to Sec. 3.3. ", "page_idx": 3}, {"type": "text", "text": "Relation to Other Methods. The frame-based block is a generalized data form of AlphaFold2 and other methods. If $R$ is required to be a rotation matrix, the frame-based block is equivalent to AlphaFold2\u2019s local frame; otherwise, it is equivalent to represent the atom as invariant feature $^h$ and equivalent vector $\\textbf{\\em x}$ , similar to GVP [21] and DimeNet [12]. ", "page_idx": 3}, {"type": "text", "text": "3.3 Block Graph Featurizer ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Learning Local Frame. For small molecules, there is no predefined local frame, and we need to learn the local frame for each atom. Given the the molecule $\\pmb{\\mathcal{M}}=\\{(\\pmb{x}_{s},\\pmb{z}_{s})\\}_{s=1}^{|\\mathcal{M}|}$ , we use a 1-layer of GNN to initialize the atom representation $\\{z_{s}\\}_{s=1}^{|\\mathcal{M}|}\\gets\\mathtt{B l o c k G A T}(\\{x_{s},z_{s}\\}_{s=1}^{|\\mathcal{M}|})$ , where the inital local frames are . The rotation vector $\\pmb{r}_{s}$ of the $s$ -th atom is constructed by message passing: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\pmb{r}_{s}=(r_{x},r_{y},r_{z})=\\sum_{k\\in\\cal{N}_{s}}\\frac{e^{\\mathtt{M L P}(z_{s},z_{t})}}{\\sum_{k\\in\\cal{N}_{s}}e^{\\mathtt{M L P}(z_{s},z_{k})}}\\frac{\\pmb{x}_{k}-\\pmb{x}_{s}}{||\\pmb{x}_{k}-\\pmb{x}_{s}||}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "$\\mathcal{N}_{s}$ is the $s$ -th atom\u2019s neighbor system. Let the direction $\\begin{array}{r}{(r_{x},r_{y},r_{z})=\\frac{r_{s}}{||r_{s}||}}\\end{array}$ and magnitude $\\theta=||\\pmb{r}_{s}||$ represent the rotation axis and angle, we compute the quanternion $\\mathbf{\\mathit{q}}_{s}$ and rotation matrix $R_{s}$ : ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left\\{q_{s}=[w,x,y,z]=[\\cos{\\frac{\\theta}{2}},r_{x}\\sin{\\frac{\\theta}{2}},r_{y}\\sin{\\frac{\\theta}{2}},r_{z}\\sin{\\frac{\\theta}{2}}]\\right.\\ \\ \\ \\ }\\\\ {\\left.R_{s}=[e_{x},e_{y},e_{z}]=\\left[\\begin{array}{l l l}{1-2y^{2}-2z^{2}}&{2x y-2z w}&{2x z+2y w}\\\\ {2x y+2z w}&{1-2x^{2}-2z^{2}}&{2y z-2x w}\\\\ {2x z-2y w}&{2y z+2x w}&{1-2x^{2}-2y^{2}}\\end{array}\\right]}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Finally, the local frame of the $s$ -th atom is $T_{s}(R_{s},t_{s})$ , where $\\pmb{t}_{s}$ is the atom coordinate. Experiments show that learning rotation vectors consistently outperforms learning Schmidt-orthogonalized axises. ", "page_idx": 3}, {"type": "text", "text": "Node Geometric Feature. The invariant block feature captures the atom type and the local structure: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\left\\{\\begin{array}{l l}{\\displaystyle z_{i}^{p o s}=R_{s}^{T}(\\pmb{x}_{i}-t_{s})=F_{s}^{-1}\\circ\\pmb{x}_{i}}&{\\mathrm{Equivalent~to~invariant~features,local~structure}}\\\\ {\\displaystyle f_{s}=\\frac{1}{\\lvert\\mathcal{B}_{s}\\rvert}\\sum_{i\\in\\mathcal{B}_{s}}\\mathbb{M}\\mathbb{P}(z_{i},z_{i}^{p o s})}&{\\mathrm{Pooling~atom~features~as~block~features,embed~atom~type}}\\end{array}\\right.\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "The inverse frame operation $T_{s}^{-1}$ project the equivalent global coordinates to the invariant local coordinate, i.e., $\\pmb{x}^{l o c a l}=F_{s}^{-1}\\stackrel{\\circ}{\\circ}\\pmb{x}^{g l o b a l}=R_{s}^{T}(\\pmb{x}^{g l o b a l}-\\pmb{t}_{s})$ . We use MLP to embed atom type and local coordinates. All atom features in the same block are pooled to get the block feature $\\pmb{f}_{s}$ . ", "page_idx": 4}, {"type": "text", "text": "Edge Geometric Feature. We initialize pairwise features following the principle that ", "page_idx": 4}, {"type": "text", "text": "Edge features capture the directed $3D$ interactions. ", "page_idx": 4}, {"type": "text", "text": "Instead of using mutually constructed distance and angle features, we concatenate the local coordinates of two blocks to fully describe their 3D positions. Given $\\boldsymbol{{\\beta}}_{s}$ and $B_{t}$ with global coordinate matrices as $X_{s}\\in\\mathbb{R}^{|v_{s}|,3}$ and $\\mathbf{\\dot{\\boldsymbol{X}}}_{t}\\in\\mathbb{R}^{|v_{t}|,3}$ , the invariant edge features following $s\\gets t$ direction is ", "page_idx": 4}, {"type": "equation", "text": "$$\nf_{s,t}=T_{s}^{-1}\\circ([X_{s}\\Vert X_{t}])\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $T_{s}^{-1}=(R_{s}^{T},-R_{s}^{T}\\pmb{t}_{s})$ projects equivariant global coordinates to invariant local coordinates. ", "page_idx": 4}, {"type": "text", "text": "3.4 Block Graph Attention Module ", "text_level": 1, "page_idx": 4}, {"type": "image", "img_path": "clqX9cVDKV/tmp/13a05c8f36fb29bb54208ddf599b03cd31a3595b1fa5e9a6451cc1392994a212.jpg", "img_caption": [], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "Figure 5: Block Graph Attention Module. (a) Virtual Block for Long-term Dependencies. (b) Geometric Interaction Extractor for learning pairwise features. (c) Gated Edge Attention for updating node features. ", "page_idx": 4}, {"type": "text", "text": "Frame-based SE-(3) Module Design. Given the geometric transformation ${\\pmb y}=W{\\pmb x}$ , we decompose $W=R_{t}\\Sigma R_{s}^{T}$ using SVD and explain $\\pmb{y}=R_{t}\\bar{\\Sigma}R_{s}^{T}\\pmb{x}$ as: ", "page_idx": 4}, {"type": "text", "text": "1. Projecting $\\textbf{\\em x}$ as the local coordinate $\\pmb{x}^{l o c a l}$ using the frame $F_{s}(R_{s},\\mathbf{0})$ , i.e., $\\pmb{x}^{l o c a l}=R_{s}^{T}\\pmb{x}$ .   \n2. Updating local coordinates via gated attention, i.e., $\\pmb{x}^{l o c a l}\\leftarrow\\pmb{\\Sigma}\\pmb{x}^{l o c a l}$ .   \n3. Translating $\\pmb{x}^{l o c a l}$ as the global coordinate using frame $T_{t}(R_{t},\\mathbf{0})$ , i.e., ${\\pmb y}=R_{t}{\\pmb x}^{l o c a l}$ . ", "page_idx": 4}, {"type": "text", "text": "If we parameterize $\\Sigma\\pmb{y}$ as $f_{\\theta}({\\pmb y})$ , and considers the effects of translation, i.e., $T_{s}(R_{s},t_{s}),T_{t}(R_{t},t_{t})$ , the general principle of designing SE-(3) networks could be: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left\\{\\begin{array}{l l}{\\hat{z}=R_{s}^{-1}(\\pmb{x}-t_{s})=T_{s}^{-1}\\circ\\pmb{x}\\quad\\mathrm{Equivalent~to~invariant}}\\\\ {\\hat{z}\\leftarrow f_{\\theta}(\\hat{z})\\quad\\mathrm{Invariant~update,one~can~use~GNN~or~Transformer}}\\\\ {\\hat{x}=R_{t}\\hat{y}+t_{t}=T_{t}\\circ\\hat{z}\\quad\\mathrm{Invariant~to~equivalent}}\\end{array}\\right.}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "The well-known AlphaFold actually follows such a design, where they parameterize $f_{\\theta}$ as the IPA module. In this work, we replace $f_{\\theta}$ with an enhanced graph neural network: ", "page_idx": 4}, {"type": "equation", "text": "$$\nf_{s}^{(l+1)},f_{s t}^{(l+1)}\\gets f_{\\theta}(f_{s}^{(l)},f_{s t}^{(l)}|T_{s},T_{s t},\\mathcal{E})\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\pmb{f}_{s}^{(l)}$ and $\\pmb{f}_{s t}^{(l)}$ represent the input node and edge features of the $l$ -th layer. In Fig. 5, we show the design of the Block Graph Attention Module, consisting of three components: (1) geometric interaction extractor, (2) virtual block for long-term dependencies, and (3) the edge attention mechanism. We show the detailed design of the Block Graph Attention Module in the following sections. ", "page_idx": 4}, {"type": "text", "text": "Long-term Dependency via Virtual Blocks. The GNN is criticized by local receptive field, yielding the problem of over-smoothing and over-squashing [2, 5, 29, 13]. Transformers overcome these problems using direct paths between distant nodes, while suffering from the ${\\mathcal{O}}(n^{2})$ computing cbloostc.k  dWiree ictnltyr ocdouncnee $n^{\\prime}$ s  tvoir taulla lt hbel orecakls $\\{B_{i}\\}_{i=n}^{n+n^{\\prime}}$ sualst iinngf ionr natds dfitoiro na alg rdaipreh.ct eEda ecdh gveisr.t uAasl $(2\\cdot n\\cdot\\bar{n^{\\prime}})$ $n^{\\prime}\\ll n$ , we claim that the computing cost is close to original GNN. All the virtual blocks, i.e., $T_{n+1}(R^{\\prime},t^{\\prime}),T_{n+2}(R^{\\prime},t^{\\prime}),\\cdot\\cdot\\cdot\\cdot,\\bar{T}_{n+n^{\\prime}}\\!(R^{\\prime},t^{\\prime})$ , share the same rotation $R^{\\prime}$ and translation $t^{\\prime}$ : ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left\\{\\begin{array}{l l}{\\mathbf{X}=[x_{1},x_{2},\\cdot\\cdot\\cdot]\\quad\\mathrm{All~the~coordinates~of~the~molecule}}\\\\ {\\mathbf{X}^{T}\\mathbf{X}=U\\Lambda V^{T}\\quad\\mathrm{SVD}}\\\\ {R^{\\prime}=U V^{T}=[e_{x},e_{y},e_{z}]}\\\\ {t^{\\prime}=\\frac{\\sum_{i=1}^{N}x_{i}}{N}\\quad\\mathrm{Center~of~Mass}}\\end{array}\\right.}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "The invariant features of virtual blocks are different, as we hope they learn diverse interactions. We encode the index to initialize block features $\\pmb{f}_{i}^{\\prime}=\\mathtt{E m b e d d i n g}(i)$ for $i\\in\\{1,2,\\cdots\\,,n^{\\prime}\\}$ . ", "page_idx": 5}, {"type": "text", "text": "Geometric Interaction Extractor. We enhance edge features with geometric interactions using the local coordinates of virtual inter-atoms and dot products of virtual intra-atoms. Previous works, such as PiFold [10], introduced virtual atoms in the featurizer to capture informative side-chain geometry beyond protein backbones, resulting in performance gains. VFN [27] extended this idea by allowing GNN layers to update the virtual atoms. However, these efforts are limited to learning virtual intra-atoms conditioned on node features. Instead, we propose virtual inter-atoms conditioned ", "page_idx": 5}, {"type": "image", "img_path": "clqX9cVDKV/tmp/4ce8cb0916ea040c2f5f96ed8a36f7c257aa4531b2d53da50f1667f71f605c33.jpg", "img_caption": ["Figure 6: Geometric Interactions. "], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "on edge features, allowing the same node to exhibit different virtual states specified by edges. Additionally, inspired by small molecule modeling, we use the dot product of virtual intra-atoms to capture angle information. We show the geometric interactions in Fig. 6, and formulate it as: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left\\{\\pmb{h}_{s t}^{(l)},\\pmb{h}_{t}^{(l)}=\\mathbb{M}\\mathbb{L}\\mathbb{P}(\\pmb{f}_{s t}^{(l)}),\\mathbb{M}\\mathbb{L}\\mathbb{P}(\\pmb{f}_{t}^{(l)})\\in\\mathbb{R}^{m,3}\\quad\\mathrm{Edge~feature}\\right.}\\\\ {\\hat{z}_{s t}^{(l)}=(T_{s t}\\circ h_{s t}^{(l)})\\|h_{s t}^{(l)}\\quad\\mathrm{Local~coordinates~of~virtual~inter\\-atoms}}\\\\ {a_{s t}=h_{s}^{T}R_{s}^{T}R_{t}h_{t}\\quad\\mathrm{Geometric~dot~product~of~virtual~intra\\-atoms}}\\\\ {g_{s t}^{(l)}=\\mathbb{M}\\mathbb{L}\\mathbb{P}(\\hat{z}_{s t}^{(l)},q_{s t},r_{s t},a_{s t})}\\\\ {f_{s t}^{(l)}\\gets\\mathbb{M}\\mathbb{L}\\mathbb{P}(\\pmb{f}_{s t}^{(l)},\\pmb{g}_{s t}^{(l)})}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $T_{s t}=T_{s}^{-1}\\circ T_{t}=\\left(R_{s}^{-1}R_{t},R_{s}^{-1}({t_{t}}-{t_{s}})\\right)$ , $q_{s t}=\\mathrm{vec}(R_{s t})\\in\\mathbb{R}^{9}$ is the flatten rotation matrix of $T_{s t}$ , and $r_{s t}=||\\pmb{t}_{s}-\\pmb{t}_{t}||$ indicates the pairwise distance. All $q_{s t}$ , $r_{s t}$ an $\\mathbf{\\delta}a_{s t}$ are invariant features. We highlight the difference to previous researches in color. ", "page_idx": 5}, {"type": "text", "text": "Gated Edge Attention. We modify PiFold\u2019s GNN to capture the geometric interactions when updating node features. For molecular design tasks, we find that aggregating edge features only leads to consistent performance gains. We understand this phenomenon as the model can pay more attention on learning 3D interactions under such a model design. In addition, we use a gated mechanism to control how the edge features are injected to node features. The gated edge attention module is: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\left\\{w_{s t}=\\mathtt{A t t M L P}\\big(f_{s}^{(l)}||f_{s t}^{(l)}||f_{t}^{(l)}\\big)|\\right.}\\\\ &{a_{s t}=\\frac{\\exp w_{s t}}{\\sum_{k\\in\\mathcal{N}_{s}}\\exp w_{s k}}}\\\\ &{h_{t}^{(l)}=\\mathtt{E d g e l l L P}\\big(f_{s t}^{(l)}\\big)\\quad\\mathrm{Only~conditiond~on~edge}}\\\\ &{\\left.\\Delta f_{s}^{(l)}=\\sum_{t\\in\\mathcal{N}_{s}}a_{s t}h_{t}^{(l)}\\right.}\\\\ &{f_{s}^{(l+1)}=f_{s}^{(l)}+\\sigma(\\mathrm{MLP}(\\Delta f_{s}^{(l)}))\\odot\\Delta f_{s}^{(l)}\\quad\\mathrm{Update~node~feature~via~forget~gate}}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\odot$ is element-wise product operation, and $\\sigma(\\cdot)$ is the sigmoid function. We highlight the difference between PiGNN and the proposed module in color. ", "page_idx": 5}, {"type": "text", "text": "FFN & Edge Updating. Analogous to the transformer model, the FFN is a MLP. The edge updating layer remains the same as PiFold: ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\pmb{f}_{s t}=\\mathtt{E d g e M L P}(\\pmb{f}_{s}||\\pmb{f}_{s t}||\\pmb{f}_{t})\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "The proposed module could be equivalently implemented as a transformer module using matrix multplication. However, we find that padding proteins to the maximum length would grealy increase the computing cost in both GPU occupancy and runtime; We suggest using GNN without padding. ", "page_idx": 6}, {"type": "text", "text": "Regularization. We find that the proposed model fit training data better than PiFold and more likely to suffer from overftiting. To address this issue, we randomly drop out the nodes/edges with a probability of $p$ to prevent overftiting. We find that controlling the dropout rate could result in models with different fitting abilities. The best performance is achieved when $p=0.05$ . ", "page_idx": 6}, {"type": "text", "text": "4 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We show the effectiveness of UniIF via multiple inverse folding tasks and ablation studies. We briefly introduce molecular design tasks as follows: ", "page_idx": 6}, {"type": "text", "text": "\u2022 Protein Design (T1): Designing protein sequences folding into the target structure.   \n\u2022 RNA Design (T2): Designing RNA sequences folding into the target structure.   \n\u2022 Material Design (T3): Discoverying stable composition from a known material structure. ", "page_idx": 6}, {"type": "text", "text": "4.1 Protein Design (T1) ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Task Description Protein design aims to design protein sequences that fold into target structures. Given a protein backbone structure $\\mathcal{X}=\\{X_{i}\\mathrm{~\\bar{\\in}~\\bar{R}^{m,3}~}\\colon1\\leq\\,i\\,\\leq\\,n\\}$ , where $m$ is the maximum number of points belonging to the $i$ -th residue, $n$ is the number of residues and the natural proteins are composed by 20 types of amino acids, the goal is to learn a function ${\\mathcal{F}}_{\\theta}$ : ", "page_idx": 6}, {"type": "equation", "text": "$$\n{\\mathcal{F}}_{\\theta}:{\\mathcal{X}}\\mapsto{\\hat{S}}.\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "The parameters $\\theta$ are learned by minimizing the cross-entropy loss, i.e., $\\mathcal{L}(\\mathcal{F}_{\\theta}(\\mathcal{X}),\\mathcal{S})~=$ $\\begin{array}{r}{-\\sum_{i=1}^{\\hat{n}}\\log s_{i}p(\\hat{s}_{i}|\\mathcal{X},\\theta)}\\end{array}$ . The task is challenging due to the combinatorial search space of amino acids and the complex relationship between sequence and structure. ", "page_idx": 6}, {"type": "text", "text": "Settings We evaluate of UniIF on the CATH4.3 dataset [30] following prior works [11, 8]. The dataset is split by the CATH topology classification code, yielding 16,631 training, 1,516 validation, and 1,864 testing samples. To assess generalization, we adopt a time-split strategy, considering the use of pretrained ESM2 models by some baselines, which risk data leakage. The time-split evaluation assigns data before a specific date to the training set and data after that date to the test set. For structural time-split evaluation, we use the CASP15 dataset [11], containing novel crystal structures not seen during training. For sequence time-split evaluation, we use the NovelPro dataset [8], which includes 76 protein sequences released within 30 days before November 23, 2023, with structures predicted by AlphaFold2. UniIF consists of 10 layers of BlockGAT with a hidden dimension of 128. It is trained using the Adam optimizer with a learning rate of 1e-3 and a batch size of 8 for 50 epochs. ", "page_idx": 6}, {"type": "text", "text": "Metrics & Baselines We report the median recovery rate of the top-1 predicted sequences, representing the percentage of correctly predicted residues. The ESM2-free baselines include StructGNN [19], GraphTrans [19], GCA [33], GVP [21], AlphaDesign [9], ProteinMPNN [4], and PiFold [10]. The ESM2-based baselines include LMDesign [17] and KWDesign [8]. While we prefer open-source baselines, we also re-implement VFN [27] for a comprehensive comparison. ", "page_idx": 6}, {"type": "text", "text": "Conclusion We provide results under different settings (with and without ESM2) and across diverse datasets (CATH4.3, CASP, NovelPro). Using a pure inverse folding model without ESM2, UniIF achieves the best performance on all datasets, demonstrating its effectiveness. Notably, UniIF outperforms the strong baseline PiFold with fewer learnable parameters. In time-split evaluations, UniIF surpasses all baselines, including ESM2-based methods, by a significant margin. On NovelPro, which features novel sequences, UniIF outperforms LMDesign and KWDesign that use ESM2 for sequence refinement. This indicates UniIF\u2019s superior generalizability, crucial for real-world applications. Ablation studies show that the proposed geometric featurizer, gated edge attention, and global virtual frame enhance performance. On CATH4.3, the overall improvement is slight due to strong baselines, but time-split evaluation highlights UniIF\u2019s superiority in generalization. ", "page_idx": 6}, {"type": "table", "img_path": "clqX9cVDKV/tmp/5774d1bbef0e8bc534ba68cfaad03636aecdbce227467452ce02d381a3a6f82c.jpg", "table_caption": [], "table_footnote": ["Table 1: Protein Design results. The best and suboptimal results are labeled with bold and underlined. \"VFN\" means that we replace the geometric interaction operation with VFN\u2019s operation [27]. \"-GDP\" means that we remove the geometric dot product features. \"-EAttn\" means that we replace the gated edge attention with PiGNN\u2019s attention module [10]. \"-VFrame\" means that we remove the global virtual frames. "], "page_idx": 7}, {"type": "text", "text": "", "page_idx": 7}, {"type": "text", "text": "4.2 RNA Design (T2) ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "Task Description Similar to protein design, RNA design aims to design RNA sequences that fold into target structures. Specially, previous work [34] use the RNA secondary structure as additional input to guide the design process, since the tertiary structure is limited. In this work, we only use the tertiary structures as input for the reason of unification, which is more challenging than the baselines. ", "page_idx": 7}, {"type": "text", "text": "Datasets & Baselines We conduct experiments RNA on the dataset collected by RDesign [34], consisting of 2218 RNA tertiary structures, which are divided into training (1774 structures), testing (223 structures), and validation (221 structures) sets based on their structural similarity. Following RDesign\u2019s benchmark, baseline methods include SeqRNN, SeqLSTM, StructMLP, StructGNN, and StructGNN, GraphTrans [19], PiFold [10] and RDesign [34]. Given the small number of data samples, we report the median recovery and its standard deviation for theree independent runs. ", "page_idx": 7}, {"type": "table", "img_path": "clqX9cVDKV/tmp/01515f7a9199e364136fbe0fcb0531eb6baa7ebf8f5ab5c519fab6c962731d66.jpg", "table_caption": ["Table 2: The recovery of RNA design. The best and suboptimal results are labeled with bold and underlined. "], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "Conclusion As shown in Table 2, UniIF achieves the best performance in all cases. The improvement is significant, as previous strong baselines like PiFold only excelled in protein design. To our knowledge, UniIF is the first model to achieve state-of-the-art performance in both protein and RNA design tasks, demonstrating its versatility and effectiveness. Compared to RDesign, which uses additional secondary structure features, UniIF relies solely on tertiary structure input and still performs better. UniIF successfully unifies the protein and RNA design processes, paving the way for a unified inverse folding model for protein-RNA complexes in future developments. ", "page_idx": 7}, {"type": "text", "text": "4.3 Material Design (T3) ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "Task Description Discovering stable atom compositions from known material structures is crucial for new material discovery [28, 26, 14]. This task is challenging due to the large composition space and the lack of large-scale data. Thanks to recent benchmark efforts [6], we can evaluate the performance of UniIF on this novel task. ", "page_idx": 8}, {"type": "text", "text": "Datasets $\\&$ Baselines We evaluated UniIF on the CHILI-3K dataset [6], which consists of nanomaterial graphs derived from mono-metal oxides. The dataset includes 53 metallic elements and one non-metallic element (oxygen), comprising 3,180 graphs, 6,959,085 nodes, and 49,624,440 edges. Following the official benchmark, the dataset is randomly split into training $(80\\%)$ , validation $(10\\%)$ , and testing $(10\\%)$ sets. Baselines include GCN [23], PMLP [39], GraphSAGE [15], GAT [35], GraphUNet [7], GIN [38], and EdgeCNN [37]. Experiments are repeated three times with different seeds, using early stopping with a patience of 50 epochs, and trained up to 1000 epochs. ", "page_idx": 8}, {"type": "table", "img_path": "clqX9cVDKV/tmp/d894cc1c8da376792a896b6d9f606ddd669e17218a70958334d7e251a4b29798.jpg", "table_caption": ["Table 3: CHILI-3K Results. "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "Conclusion In Table 3, UniIF outperforms all baselines by a large margin. Ablation studies demonstrate the crucial role of the learned local frame in enhancing interaction feature extraction. In addition, how to learn the local frame is also important. In the \"- quat\" ablation, we try to learn the x, y, and z axes with Householder orthogonalization directly, but found it less effective, with the recovery rate dropping from $75.3\\%$ to $65.2\\%$ . This highlights the value of the proposed local frame learning mechanism. ", "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "4.4 Case Study ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "In Fig. 7, we show the designed protein and RNA sequences.In addition, we use AlphaFold3 [1] to re-fold the designed sequences into structures. The ground truth (gray), PiFold (green), and UniIF (pink) structures are alinged and compared. We observe that UniIF improves both the recovery and RMSD of the designed protein and RNA, demonstrating its effectiveness in inverse folding tasks. ", "page_idx": 8}, {"type": "image", "img_path": "clqX9cVDKV/tmp/2d264da223be0cac08c1aa88a7db28a041037a4f074e9d83d09ca71d9874b39c.jpg", "img_caption": ["Figure 7: Designed examples. The ground truth (gray), PiFold (green), and UniIF (pink) structures are alinged. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "5 Conclusion ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We propose the first unified model, dubbled UniIF, for general molecule inverse folding. The key points include unifying the data representation, the featurizer and the model architecture without a drop in performance. Extensive experiments show that UniIF surpasses baseline methods on all tasks. Ablation studies reveal that the geometric interaction extractor, gated edge attention, and virtual long-term dependency modules contribute to performance gains. We believe that the proposed model can benefit multiple domains, such as machine learning, drug design, and material design. ", "page_idx": 8}, {"type": "text", "text": "Acknowledgements ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "This work was supported by National Science and Technology Major Project (No. 2022ZD0115101), National Natural Science Foundation of China Project (No. U21A20427), Project (No. WU2022A009) from the Center of Synthetic Biology and Integrated Bioengineering of Westlake University and Integrated Bioengineering of Westlake University and Project (No. WU2023C019) from the Westlake University Industries of the Future Research Funding. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Josh Abramson, Jonas Adler, Jack Dunger, Richard Evans, Tim Green, Alexander Pritzel, Olaf Ronneberger, Lindsay Willmore, Andrew J Ballard, Joshua Bambrick, et al. Accurate structure prediction of biomolecular interactions with alphafold 3. Nature, pages 1\u20133, 2024. [2] Uri Alon and Eran Yahav. On the bottleneck of graph neural networks and its practical implications. In International Conference on Learning Representations, 2020. [3] Alexander Churkin, Matan Drory Retwitzer, Vladimir Reinharz, Yann Ponty, J\u00e9r\u00f4me Waldisp\u00fchl, and Danny Barash. Design of rnas: comparing programs for inverse rna folding. Briefings in bioinformatics, 19(2):350\u2013358, 2018.   \n[4] Justas Dauparas, Ivan Anishchenko, Nathaniel Bennett, Hua Bai, Robert J Ragotte, Lukas F Milles, Basile IM Wicky, Alexis Courbet, Rob J de Haas, Neville Bethel, et al. Robust deep learning based protein sequence design using proteinmpnn. bioRxiv, 2022.   \n[5] Francesco Di Giovanni, Lorenzo Giusti, Federico Barbero, Giulia Luise, Pietro Lio, and Michael M Bronstein. On over-squashing in message passing neural networks: The impact of width, depth, and topology. In International Conference on Machine Learning, pages 7865\u2013 7885. PMLR, 2023.   \n[6] Ulrik Friis-Jensen, Frederik L Johansen, Andy S Anker, Erik B Dam, Kirsten M\u00d8 Jensen, and Raghavendra Selvan. Chili: Chemically-informed large-scale inorganic nanomaterials dataset for advancing graph machine learning. arXiv preprint arXiv:2402.13221, 2024.   \n[7] Hongyang Gao and Shuiwang Ji. Graph u-nets. In international conference on machine learning, pages 2083\u20132092. PMLR, 2019.   \n[8] Zhangyang Gao, Cheng Tan, Xingran Chen, Yijie Zhang, Jun Xia, Siyuan Li, and Stan Z Li. Kw-design: Pushing the limit of protein deign via knowledge refinement. In The Twelfth International Conference on Learning Representations, 2023.   \n[9] Zhangyang Gao, Cheng Tan, Stan Li, et al. Alphadesign: A graph protein design method and benchmark on alphafolddb. arXiv preprint arXiv:2202.01079, 2022.   \n[10] Zhangyang Gao, Cheng Tan, and Stan Z. Li. Pifold: Toward effective and efficient protein inverse folding. In International Conference on Learning Representations, 2023.   \n[11] Zhangyang Gao, Cheng Tan, Yijie Zhang, Xingran Chen, Lirong Wu, and Stan Z Li. Proteininvbench: Benchmarking protein inverse folding on diverse tasks, models, and metrics. Advances in Neural Information Processing Systems, 36, 2024.   \n[12] Johannes Gasteiger, Janek Gro\u00df, and Stephan G\u00fcnnemann. Directional message passing for molecular graphs. arXiv preprint arXiv:2003.03123, 2020.   \n[13] Jhony H Giraldo, Konstantinos Skianis, Thierry Bouwmans, and Fragkiskos D Malliaros. On the trade-off between over-smoothing and over-squashing in deep graph neural networks. In Proceedings of the 32nd ACM International Conference on Information and Knowledge Management, pages 566\u2013576, 2023.   \n[14] Sean D Griesemer, Yi Xia, and Chris Wolverton. Accelerating the prediction of stable materials with machine learning. Nature Computational Science, 3(11):934\u2013945, 2023.   \n[15] Will Hamilton, Zhitao Ying, and Jure Leskovec. Inductive representation learning on large graphs. Advances in neural information processing systems, 30, 2017.   \n[16] Geoffroy Hautier, Christopher C Fischer, Anubhav Jain, Tim Mueller, and Gerbrand Ceder. Finding nature\u2019s missing ternary oxide compounds using machine learning and density functional theory. Chemistry of Materials, 22(12):3762\u20133767, 2010.   \n[17] Chloe Hsu, Robert Verkuil, Jason Liu, Zeming Lin, Brian Hie, Tom Sercu, Adam Lerer, and Alexander Rives. Learning inverse folding from millions of predicted structures. bioRxiv, 2022.   \n[18] Han Huang, Ziqian Lin, Dongchen He, Liang Hong, and Yu Li. Ribodiffusion: Tertiary structure-based rna inverse folding with generative diffusion models. bioRxiv, pages 2024\u201304, 2024.   \n[19] John Ingraham, Vikas K Garg, Regina Barzilay, and Tommi Jaakkola. Generative models for graph-based protein design. 2019.   \n[20] Rui Jiao, Xiangzhe Kong, Ziyang Yu, Wenbing Huang, and Yang Liu. Equivariant pretrained transformer for unified geometric learning on multi-domain 3d molecules. arXiv preprint arXiv:2402.12714, 2024.   \n[21] Bowen Jing, Stephan Eismann, Patricia Suriana, Raphael JL Townshend, and Ron Dror. Learning from protein structure with geometric vector perceptrons. arXiv preprint arXiv:2009.01411, 2020.   \n[22] John Jumper, Richard Evans, Alexander Pritzel, Tim Green, Michael Figurnov, Olaf Ronneberger, Kathryn Tunyasuvunakool, Russ Bates, Augustin \u017d\u00eddek, Anna Potapenko, et al. Highly accurate protein structure prediction with alphafold. Nature, 596(7873):583\u2013589, 2021.   \n[23] Thomas N Kipf and Max Welling. Semi-supervised classification with graph convolutional networks. arXiv preprint arXiv:1609.02907, 2016.   \n[24] Xiangzhe Kong, Wenbing Huang, and Yang Liu. Generalist equivariant transformer towards 3d molecular interaction learning. arXiv preprint arXiv:2306.01474, 2023.   \n[25] Rohith Krishna, Jue Wang, Woody Ahern, Pascal Sturmfels, Preetham Venkatesh, Indrek Kalvet, Gyu Rie Lee, Felix S Morey-Burrows, Ivan Anishchenko, Ian R Humphreys, et al. Generalized biomolecular modeling and design with rosettafold all-atom. Science, 384(6693):eadl2528, 2024.   \n[26] Yue Liu, Tianlu Zhao, Wangwei Ju, and Siqi Shi. Materials discovery and design using machine learning. Journal of Materiomics, 3(3):159\u2013177, 2017.   \n[27] Weian Mao, Muzhi Zhu, Zheng Sun, Shuaike Shen, Lin Yuanbo Wu, Hao Chen, and Chunhua Shen. De novo protein design using geometric vector field networks. arXiv preprint arXiv:2310.11802, 2023.   \n[28] Bryce Meredig, Ankit Agrawal, Scott Kirklin, James E Saal, Jeff W Doak, Alan Thompson, Kunpeng Zhang, Alok Choudhary, and Christopher Wolverton. Combinatorial screening for new materials in unconstrained composition space with machine learning. Physical Review B, 89(9):094104, 2014.   \n[29] Khang Nguyen, Nong Minh Hieu, Vinh Duc Nguyen, Nhat Ho, Stanley Osher, and Tan Minh Nguyen. Revisiting over-smoothing and over-squashing using ollivier-ricci curvature. In International Conference on Machine Learning, pages 25956\u201325979. PMLR, 2023.   \n[30] Christine A Orengo, Alex D Michie, Susan Jones, David T Jones, Mark B Swindells, and Janet M Thornton. Cath\u2013a hierarchic classification of protein domain structures. Structure, 5(8):1093\u20131109, 1997.   \n[31] Rafael Sarmiento-Perez, Tiago FT Cerqueira, Sabine Korbel, Silvana Botti, and Miguel AL Marques. Prediction of stable nitride perovskites. Chemistry of Materials, 27(17):5957\u20135963, 2015.   \n[32] Alexey Strokach, David Becerra, Carles Corbi-Verge, Albert Perez-Riba, and Philip M Kim. Fast and flexible protein design using deep graph neural networks. Cell Systems, 11(4):402\u2013411, 2020.   \n[33] Cheng Tan, Zhangyang Gao, Jun Xia, and Stan Z Li. Generative de novo protein design with global context. arXiv preprint arXiv:2204.10673, 2022.   \n[34] Cheng Tan, Yijie Zhang, Zhangyang Gao, Bozhen Hu, Siyuan Li, Zicheng Liu, and Stan Z Li. Hierarchical data-efficient representation learning for tertiary structure-based rna design. In The Twelfth International Conference on Learning Representations, 2023.   \n[35] Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, Yoshua Bengio, et al. Graph attention networks. stat, 1050(20):10\u201348550, 2017.   \n[36] Hai-Chen Wang, Silvana Botti, and Miguel AL Marques. Predicting stable crystalline compounds using chemical similarity. npj Computational Materials, 7(1):12, 2021.   \n[37] Yue Wang, Yongbin Sun, Ziwei Liu, Sanjay E Sarma, Michael M Bronstein, and Justin M Solomon. Dynamic graph cnn for learning on point clouds. ACM Transactions on Graphics (tog), 38(5):1\u201312, 2019.   \n[38] Keyulu Xu, Weihua Hu, Jure Leskovec, and Stefanie Jegelka. How powerful are graph neural networks? arXiv preprint arXiv:1810.00826, 2018.   \n[39] Chenxiao Yang, Qitian Wu, Jiahua Wang, and Junchi Yan. Graph neural networks are inherently good generalizers: Insights by bridging gnns and mlps. arXiv preprint arXiv:2212.09034, 2022.   \n[40] Zaixiang Zheng, Yifan Deng, Dongyu Xue, Yi Zhou, Fei Ye, and Quanquan Gu. Structureinformed language models are protein designers. bioRxiv, pages 2023\u201302, 2023. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 12}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "Justification: Our experimental results support the claims. ", "page_idx": 12}, {"type": "text", "text": "Guidelines: ", "page_idx": 12}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 12}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [No] ", "page_idx": 12}, {"type": "text", "text": "Justification: The limitation is that we do not do wet-experiments. But we think this is out of scope for the AI paper. ", "page_idx": 12}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 12}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 12}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 12}, {"type": "text", "text": "Justification: Not applicable as the paper does not include theoretical results. Guidelines: ", "page_idx": 13}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 13}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 13}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 13}, {"type": "text", "text": "Justification: We provided the model and training details in Section 3.1. ", "page_idx": 13}, {"type": "text", "text": "Guidelines: ", "page_idx": 13}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 13}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 13}, {"type": "text", "text": "Answer: [No] ", "page_idx": 14}, {"type": "text", "text": "Justification: The code will be released upon acceptance. Guidelines: ", "page_idx": 14}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 14}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 14}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 14}, {"type": "text", "text": "Justification: We have provided such information in the experimental section. Guidelines: ", "page_idx": 14}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 14}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 14}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 14}, {"type": "text", "text": "Justification: We provided the standard deviation in the RNA design and material design tasks. ", "page_idx": 14}, {"type": "text", "text": "Guidelines: ", "page_idx": 14}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 14}, {"type": "text", "text": "", "page_idx": 15}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 15}, {"type": "text", "text": "Answer: [No] ", "page_idx": 15}, {"type": "text", "text": "Justification: All experiments are conducted on an NVIDIA A100 with 80G memory. The longest training time is about 1 day. ", "page_idx": 15}, {"type": "text", "text": "Guidelines: ", "page_idx": 15}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 15}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 15}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 15}, {"type": "text", "text": "Justification: ", "page_idx": 15}, {"type": "text", "text": "Guidelines: ", "page_idx": 15}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 15}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 15}, {"type": "text", "text": "Answer: [No] ", "page_idx": 15}, {"type": "text", "text": "Justification: This is a computational technical paper and does not have conducted realistic biological application. ", "page_idx": 15}, {"type": "text", "text": "Guidelines: ", "page_idx": 15}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 15}, {"type": "text", "text": "", "page_idx": 16}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 16}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 16}, {"type": "text", "text": "Justification: ", "page_idx": 16}, {"type": "text", "text": "Guidelines: ", "page_idx": 16}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks. ", "page_idx": 16}, {"type": "text", "text": "\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 16}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 16}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 16}, {"type": "text", "text": "Justification: ", "page_idx": 16}, {"type": "text", "text": "Guidelines: ", "page_idx": 16}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets. ", "page_idx": 16}, {"type": "text", "text": "\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided. ", "page_idx": 16}, {"type": "text", "text": "\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 17}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 17}, {"type": "text", "text": "Answer: [NA]   \nJustification: No new datasets are introduced in the paper. Guidelines:   \n\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 17}, {"type": "text", "text": "", "page_idx": 17}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 17}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 17}, {"type": "text", "text": "Justification: ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 17}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 17}, {"type": "text", "text": "Answer: [No] ", "page_idx": 17}, {"type": "text", "text": "Justification: ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 17}]