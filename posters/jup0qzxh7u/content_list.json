[{"type": "text", "text": "Adaptive Layer Sparsity for Large Language Models via Activation Correlation Assessment ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Wei $\\mathbf{Li}^{1}$ , Lujun $\\mathbf{L}\\mathbf{i}^{2\\dagger}$ , Mark Lee1\u2217, Shengjie Sun3 ", "page_idx": 0}, {"type": "text", "text": "1University of Birmingham 2Hong Kong University of Science and Technology, 3AISpeech Co., Ltd. WXL885@student.bham.ac.uk, lilujunai@gmail.com, M.G.Lee@bham.ac.uk shengjie.sun@aispeech.com ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Large Language Models (LLMs) have revolutionized the field of natural language processing with their impressive capabilities. However, their enormous size presents challenges for deploying them in real-world applications. Traditional compression techniques, like pruning, often lead to suboptimal performance due to their uniform pruning ratios and lack of consideration for the varying importance of features across different layers. To address these limitations, we present a novel Adaptive Layer Sparsity (ALS) approach to optimize LLMs. Our approach consists of two key steps. Firstly, we estimate the correlation matrix between intermediate layers by leveraging the concept of information orthogonality. This novel perspective allows for a precise measurement of the importance of each layer across the model. Secondly, we employ a linear optimization algorithm to develop an adaptive sparse allocation strategy based on evaluating the correlation matrix. This strategy enables us to selectively prune features in intermediate layers, achieving fine-grained optimization of the LLM model. Considering the varying importance across different layers, we can significantly reduce the model size without sacrificing performance. We conduct extensive experiments on publicly available language processing datasets, including the LLaMA-V1|V2|V3 family and OPT, covering various benchmarks. Our experimental results validate the effectiveness of our ALS method, showcasing its superiority over previous approaches. The performance gains demonstrate its potential for enhancing LLMs\u2019 efficiency and resource utilization. Notably, our approach surpasses the state-of-the-art models Wanda and SparseGPT, showcasing its ability to excel even under high sparsity levels. Codes at: https://github.com/lliai/ALS. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Large language models (LLMs) [62, 49, 3] have demonstrated remarkable performance in various natural language processing (NLP) [55, 54, 4] tasks. However, their size and computational requirements pose significant challenges for widespread adoption and deployment. To address these practical constraints, model compression techniques, such as weight pruning and quantization, can potentially reduce the size and computational requirements of LLMs. ", "page_idx": 0}, {"type": "text", "text": "The emergence of LLMs has revolutionized the field of NLP. However, despite their revolutionary impact, the massive scale and complexity of LLMs presents significant challenges for model compression. Conventional pruning methods [27, 19, 38, 19, 15, 59], which often require one or more iterations of fine-tuning or retraining to preserve performance, have become impractical for LLMs due to the substantial computational cost and time required. ", "page_idx": 0}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/cf7083cdc1eb3a9dfb1a0e4c2f3d8de4cd0f7f83a258b424ddcfba816c22f2b7.jpg", "img_caption": ["Figure 1: Overview of our framework. We first compute the sum of Redundancy Metric between layer $i$ -th and other layers to construct objective function. Then, we solve a linear programming problem to optimize total sparsity ratios $\\bar{S}^{(q_{i})}$ ( $\\mathit{\\check{g}}_{i}$ is pre-layer sparsity) under constraints. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "Due to the failure to the Magnitude approach to pruning [28] and other previous methods on LLMs, recent efforts such as SparseGPT [17], Wanda [46], DSOT [65], Pruning Large Language Models with BESA [57], and OWL [58] aim to address this challenge by reconstructing the layerwise outputs of LLMs. Specifically, SparseGPT introduces a technique for pruning less significant weights and reconstructing layerwise outputs based on an importance metric derived from the Hessian matrix. To reduce the computational overhead of SparseGPT, Wanda proposes a simplified strategy that relies solely on the product of weight and activation magnitudes for pruning. DSOT computes the reconstruction error incrementally for each layer, optimizing the intra-layer sparse configuration through further weight pruning or growth, which forms the basis for subsequent weight recovery and additional pruning operations. These methods adopt a training-free approach. In contrast, BESA [57] proposes learning the optimal pruning ratio within each layer through training, finding that considering the overall sparsity configuration within a layer enhances the performance of sparse models. However, this method primarily focuses on intra-layer sparsity configuration. It requires substantial training time, typically taking at least 5 hours on an A100-80G GPU, which is considerably slower than other training-free techniques [17, 46, 65]. Another notable method is OWL [58], which proposes a non-uniform layerwise sparsity technique that assigns different sparsity ratios based on the outlier ratio within each layer, leveraging the unique characteristic of LLMs where some features exhibit significantly larger magnitudes by tuning hyperparameters such as the outlier threshold and sparsity upper/lower bounds to obtain optimal parameter setting. Nevertheless, unlike the aforementioned methods, OWL relies heavily on empirical analysis without providing a solid theoretical foundation for its effectiveness. ", "page_idx": 1}, {"type": "text", "text": "However, existing methods have several significant drawbacks. First, for BESA, DSOT, and some traditional techniques, minimizing the layer-by-layer pruning error does not effectively mitigate the impact of pruning on model performance, as the pruning error accumulates across layers due to its inherent greedy nature [24] and may also become trapped in local optima [13, 22]. Second, LLM pruning methods such as Wanda, SparseGPT, and Magnitude apply uniform sparsity ratio to each layer, despite the significant variations in each layer\u2019s contribution to the final model performance [57, 65]. To achieve better performance for different layers, the sparsity needs to be manually adjusted for all layers. Third, for the newly proposed OWL method, more theoretical analysis is needed on why its outlier-based non-uniform sparsity outperforms uniform sparsity. Moreover, the choice of hyperparameters in OWL, such as the outlier threshold and sparsity upper/lower bounds, is sensitive to model performance, but their optimal ranges are not theoretically explained, and the effective ranges and thresholds are derived through manual tuning. Furthermore, the transferability of these hyperparameters across different datasets has yet to be systematically studied. Therefore, when applying OWL to new models, complex adjustments by hand must be performed to determine the potentially optimal parameter combination. ", "page_idx": 1}, {"type": "text", "text": "To address the multiple challenges of getting trapped in local optima, manually setting sparsity for all layers, and relying on empirical manual experiments to derive optimal sparsity ratios, we propose a simple, effective, and efficient method called Adaptive Layer Sparsity (ALS) for allocating sparsity ratios. The overall pipeline of our proposed method is illustrated in Fig. 1. This technique optimizes the pruning rate across different layers. To the best of our knowledge, this is the first attempt to reformulate the sparsity allocation problem in LLMs as a linear programming problem. We tackle these challenges by constructing an objective function and constraints. The constraint of the linear programming problem is that the total number of parameters should be less than the target model size. We then compute the independence matrix [25] at both the layer level and intra-layer component level based on the output or input features. According to our experiments, the independence between layers is positively correlated with model performance, as shown in Fig. 2 (c). Therefore, maximizing the independence between each layer of the model is considered our objective function. Unlike existing black-box optimization methods, we formulate this problem as a linear one that can be solved by any linear problem solver. This approach enables efficient global sparsity ratio allocation for LLMs ranging from 7B to 70B parameters on a single A100-80GB GPU. If the model scale is too large, reaching 160B, we can also perform multi-threaded computation on a CPU. For a 70B model, the global sparsity configuration can be obtained in just 20 minutes on an A100-80G GPU. ", "page_idx": 1}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "To rigorously assess the efficacy of ALS, we conducted extensive experiments on diverse LLMs, including LLaMA-V1 [49], LLaMA-V2 [50], LLaMA-V3 [1], and OPT [62] model families, with parameter counts ranging from 6.7 billion to 70 billion. In the main experiments, we evaluated the WikiText-2 perplexity and average accuracy on 7 zero-shot datasets at various sparsity ratios $20\\%$ to $70\\%$ ) for LLaMA-V2 7B/13B (Table 1) and at $50\\%$ sparsity for all model families (Tables 2 and 3). Detailed results for each zero-shot dataset on LLaMA-V2 family models at $50\\%$ sparsity are presented in Table 4. The analysis experiments consist of 6 sets, examining the impact of calibration data, sparsity bounds setting, and model redundancy on performance (Fig. 2), as well as the influence of feature selection, standardization, and comparisons with Wanda and LoRA fine-tuning. Additional experiments including detailed of main experiments, analyses of granularity, decreasing functions, visualizations of layer redundancy, sparsity ratio allocation and comparison with OWL method are provided in the Appendix C and D. These experimental results unequivocally demonstrate that ALS consistently yields substantial performance improvements for sparse LLMs across various LLMs and downstream tasks. ", "page_idx": 2}, {"type": "text", "text": "2 Related Work ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Model Compression method try to design efficient models and reduce the memory and computational requirements of LLMs. These methods can be categorized into quantization [42, 12, 35, 33], sparsification [17, 46, 10, 9] and distillation [56, 29, 30, 31, 32, 11, 53]. Quantization converts high bit-width weights and activations into compact, low bit-width representations, while sparsification increases the proportion of zero-valued elements in model weights. Our method optimizes LLM sparsification by strategically allocating sparsity across the model\u2019s layers to maximize performance and minimize computational overhead. In contrast to optimization-based compression techniques (e.g., OMPQ [35]) for CNN models in vision tasks, our approach focuses on different LLM models and NLP tasks and devises various functions and strategies accordingly. ", "page_idx": 2}, {"type": "text", "text": "Sparsity in LLMs has garnered significant attention as a means to accelerate inference speed and reduce memory consumption by applying sparsity in the model weights or activations. sparsity techniques can be categorized into two main approaches: structured pruning [34, 23] and unstructured pruning [16, 64, 46, 63]. While the primary focus of these works lies in determining the pruning criteria, such as weight importance and pruning ratio, the enormous parameter scale of LLMs presents an additional challenge in terms of pruning efficiency. Conventional pruning methods [15, 59, 63, 23, 27, 19, 38, 19], dating back to the early work of Hassibi [20] in the 1990s, which successfully reduced model size and improved efficiency in deep learning architectures by removing redundant weights to create sparse and lightweight models, heavily rely on extensive retraining and are often infeasible for LLMs due to prohibitively high computational overhead and prolonged training times. To address this issue, researchers have developed LLM-specific pruning techniques that prioritize train-free and time efficiency. In the context of structured pruning, LLMpruner [34] explores the application of structured pruning to LLMs and employs LoRA to recover the performance of the pruned model. For unstructured pruning, SparseGPT [17] stands out as a notable method that draws inspiration from the Optimal Brain Surgeon (OBS) [20] approach, taking into account the impact of removing individual weights on the network reconstruction loss. SparseGPT introduces an efficient technique for estimating the Hessian matrix, enabling the application of the traditional OBS method to largescale models. Another prominent unstructured pruning method, Wanda [46], employs a simple yet effective strategy based on the product of weight and activation values to identify and eliminate less important weights, further enhancing the pruning speed. Despite these advancements, most existing methods adopt a uniform pruning rate across all layers, which may lead to suboptimal performance. In contrast, our approach introduces a novel layer adaptive pruning strategy that dynamically allocates sparsity based on the importance of each layer, effectively minimizing performance degradation while achieving high compression ratios. ", "page_idx": 2}, {"type": "text", "text": "", "page_idx": 3}, {"type": "text", "text": "Sparsity Allocation in Network Pruning. Conventional methods for achieving adaptive layerwise sparsity in neural networks [14, 5, 26] often rely on a layer-by-layer pruning approach, where the objective is to minimize the sum of errors introduced in each layer. However, this greedy strategy [24] leads to the accumulation of errors across layers, resulting in suboptimal performance when directly adapted to LLMs. The extensive retraining required on vast datasets further amplifies the challenges of applying these techniques to LLMs. Recent efforts, such as BESA [57] and DSOT [65], have shifted focus to intra-block sparsity allocation, employing various strategies to optimize the sparsity distribution within individual blocks. Despite operating at a finer granularity, these methods fundamentally adhere to a layer-wise pruning paradigm, neglecting the importance of global sparsity allocation. Consequently, the resulting allocation may be locally optimal [13, 22] within each layer but globally suboptimal, potentially leading to solutions stuck in local optima. Recently, a new approach called OWL [58] attempts to address this issue by introducing a non-uniform layer-wise sparsity technique. This technique primarily relies on manually tuning the outlier threshold and sparsity upper/lower bounds (which are very small values and sensitive to performance) through extensive experimentation to obtain potentially optimal parameter configurations. Although OWL demonstrates the potential for improved sparsity allocation, it heavily depends on empirical analysis and fails to provide a solid theoretical foundation for its effectiveness, limiting its generalizability and robustness across different LLMs architectures and datasets. ", "page_idx": 3}, {"type": "text", "text": "3 Methodology ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "3.1 Preliminary ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Pruning LLMs is a method that aims to obtain a sparse representation of the model by eliminating a predetermined fraction of the pre-trained weights. The primary objective is to minimize the divergence between the outputs generated by the sparse and dense models [21]. However, directly tackling this problem can be challenging due to the massive scale of LLMs. We discover that the mutual information entropy in Eq. 1 can effectively quantify the degree of discrepancy between different layers of the model. ", "page_idx": 3}, {"type": "equation", "text": "$$\nI\\left(x_{i};x_{j}\\right)=H\\left(x_{i}\\right)+H\\left(x_{j}\\right)-H\\left(x_{i},x_{j}\\right)\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Neural networks can be decomposed into a sequence of layers. In the decomposed form, we represent the neural network as $F\\,=\\,{\\bar{\\{}f_{1},f_{2},\\dots,f_{L}\\}}$ , For a given random sample $\\boldsymbol{x}_{0}\\,\\in\\,\\mathbb{R}^{d_{0}}$ , let $x_{i}=$ $f_{i}\\left(f_{i-1}\\left(\\ldots f_{1}\\left(x_{0}\\right)\\right)\\right)\\in\\mathbb{R}^{d_{i}}$ represents the output of the random sample at the $i$ -th layer. ", "page_idx": 3}, {"type": "text", "text": "Based on the previous definitions of the marginal entropies and joint entropy, the mutual information between $x_{i}$ and $x_{j}$ can be derived from Eq. 1 and formally defined as Eq. 2 [8]. ", "page_idx": 3}, {"type": "equation", "text": "$$\nI\\left(x_{i};x_{j}\\right)=\\int p\\left(x_{i},x_{j}\\right)\\log\\frac{p\\left(x_{i},x_{j}\\right)}{p\\left(x_{i}\\right)p\\left(x_{j}\\right)}d x_{i}d x_{j}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "High mutual information between layers indicates redundancy, while low mutual information suggests that these layers have learned complementary representations [43]. When two variables $x_{i}$ and $x_{j}$ are independent, their mutual information is zero, i.e., $I(x_{i};x_{j})=0$ . According to information theory [41] and the Information Bottleneck (IB) theory [48], minimizing the mutual information between layers can reduce redundancy, remove irrelevant information, and enhance the overall representational capacity of the network. This \"compression\" of the representation enables the network to extract higher-level and more compact features, thereby reducing the reconstruction error. In summary, by sparsifying layers with higher mutual information and minimizing the mutual information throughout the entire network, the reconstruction error can be minimized. ", "page_idx": 3}, {"type": "text", "text": "To approximate the mutual information between layers, we propose employing Monte Carlo sampling, thereby circumventing the need for intractable integrals. Specifically, we randomly select $N$ samples $x_{0}^{(1)},\\dot{x_{0}^{(2)}},\\dots,x_{0}^{(N)}$ from the training dataset, which follow a probability density function (PDF) $P(x)$ . For each sample $\\boldsymbol{x}_{0}^{(n)}$ , the outputs at the $i$ -th and $j$ -th layers are denoted as $\\boldsymbol{x}_{i}^{(n)}$ and $\\v{x}_{j}^{(n)}$ , respectively. We can estimate the integral using the sample average: I\u02c6 (xi; xj) \u2248 N1  nN=1 logp pxi(xni) ,px jx(jn) . ${\\hat{I}}\\left(x_{i};x_{j}\\right)$ is the estimated mutual information, $p\\left(x_{i}^{(n)},x_{j}^{(n)}\\right)$ is the joint PDF, and $p\\left(x_{i}^{(n)}\\right)$ and $p\\left(x_{j}^{(n)}\\right)$ are the marginal PDFs. We aim to approximate these probability densities using kernel density estimation. ", "page_idx": 4}, {"type": "text", "text": "Computing marginal and joint probability densities: Based on the kernel density estimation [44], we can utilize it to estimate the probability density functions. This allows us to approximate the probability density functions using the features of the samples. Kernel density estimation is a non-parametric method for estimating the probability density function of a random variable. For instance, given a set of samples $\\bar{Y}\\;\\stackrel{!}{=}\\;\\bar{\\{y_{1},y_{2},\\ldots,\\dot{y}_{N}\\}}$ , The kernel density estimate is defined as: p\u02c6(y) = N1h iN=1 K y\u2212hyi , where K(\u00b7) is a kernel function, commonly used kernels include Gaussian, Epanechnikov, etc., and $h$ is the bandwidth parameter. ", "page_idx": 4}, {"type": "text", "text": "We apply kernel density estimation to compute the marginal and joint probability density functions of the samples\u2019 outputs at the $i$ -th and $j$ -th layers. The choice of the bandwidth parameter $h$ can be determined through cross-validation or other methods. However, to simplify our derivation, we can consider that in high-dimensional spaces, the influence of the kernel function $K$ is relatively insignificant. We are mainly focused on the ratio of relative densities [40, 60]. Therefore, the bandwidth parameter $h$ can be cancelled out. We can calculate the marginal and joint probability density functions of the samples\u2019 outputs at the $i$ -th and $j$ -th layers using kernel density estimation, which can be found in the Appendix. ", "page_idx": 4}, {"type": "text", "text": "Monte Carlo Approximation of Mutual Information. Substituting the kernel density estimates into the Monte Carlo approximation formula for mutual information and simplifying the expression using the feature matrix inner product approximation for the kernel function, as mentioned by Tschannen [51], we obtain: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\hat{I}\\left(x_{i};x_{j}\\right)\\approx\\frac{1}{N}\\sum_{n=1}^{N}\\log\\frac{\\left\\lVert x_{i}^{(n)T}x_{j}^{(n)}\\right\\rVert_{F}}{\\left\\lVert x_{i}^{(n)T}x_{i}^{(n)}\\right\\rVert_{F}\\left\\lVert x_{j}^{(n)T}x_{j}^{(n)}\\right\\rVert_{F}}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\Vert\\cdot\\Vert_{F}$ denotes the Frobenius norm. In this approximation, we employ the feature matrix inner product to approximate the kernel function, $K\\left(\\left(x_{i}^{(n)},x_{j}^{(n)}\\right),\\left(x_{i}^{(k)},x_{j}^{(k)}\\right)\\right)\\approx\\left\\|x_{i}^{(n)T}x_{j}^{(n)}\\right\\|_{F}$ Similarly, for the marginal kernel functions is $K\\left(x_{i}^{(n)},x_{i}^{(k)}\\right)\\approx\\left\\|x_{i}^{(n)T}x_{i}^{(n)}\\right\\|_{F}$ ", "page_idx": 4}, {"type": "text", "text": "Decreasing function: Since mutual information has no general upper bound, its upper limit depends on the entropy of either $x_{i}$ or $x_{j}$ . To address this, we can use decreasing functions to transform the range of mutual information, ensuring a bounded and more interpretable metric. For instance, using $\\bar{e}^{\\bar{I}(x_{i};x_{j})}$ or a Gaussian function, we can redefine the measure as follows. Considering that a batch of data is fed into the model simultaneously and each layer output concurrently, we can omit the $\\textstyle\\sum_{n=1}^{N}$ and $\\textstyle{\\frac{1}{N}}$ . Instead, we can use $X_{i}$ and $X_{j}$ to represent the calculations for the entire batch input. Applying $\\left\\Vert{X_{i}^{T}X_{j}}\\right\\Vert e^{\\hat{I}(X_{i};X_{j})}$ as a decreasing function to Eq. 3. Therefore, we can derive the Redundancy Metric (RM) formula, where $R M(\\cdot)\\in[0,1]$ according to the Cauchy-Schwarz inequality: ", "page_idx": 4}, {"type": "equation", "text": "$$\nR M\\left({{X}_{i}},{{X}_{j}}\\right)=\\frac{{{\\left\\|{{X}_{i}^{T}}{{X}_{j}}\\right\\|}^{2}}}{{{\\left\\|{{X}_{i}^{T}}{{X}_{i}}\\right\\|}\\left\\|{{X}_{j}^{T}}{{X}_{j}}\\right\\|}}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "The decreasing function transforms the range of the RM formula such that a value of 0 indicates complete independence between layers, while 1 represents complete redundancy. This formulation ", "page_idx": 4}, {"type": "text", "text": "can serve as the objective function for maximization. The complete derivation process for this section, including the details of Eq. 4, is presented in Appendix B. ", "page_idx": 5}, {"type": "text", "text": "3.3 Linear Optimization ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Our Redundancy Metric reveals the redundancy among layers in a neural network, guiding sparsity ratio allocation. Experiments on LLaMA2-13B with various sparsity configurations show a negative correlation between model redundancy and WikiText-2 perplexity (PPL). Model redundancy is defined as the sum of each layer\u2019s RM for the remaining layers, as depicted in Fig. 2 (c). Consequently, redundancy minimization is adopted as the objective function, incorporating model size constraints to formulate a linear programming problem that yields the optimal sparsity configuration. ", "page_idx": 5}, {"type": "text", "text": "Intra-layer Sparsity Allocation. For a given neural network, we construct a redundancy matrix $\\Psi$ , where $\\psi_{i j}\\,=\\,R M(x_{i},x_{j})$ . The sum of non-diagonal elements for each row of the matrix is computed as $\\begin{array}{r}{\\rho_{i}=\\sum_{j=1}^{L}\\psi_{i j}-1}\\end{array}$ . A smaller $\\rho_{i}$ indicates stronger independence between $x_{i}$ and the outputs of other layers. We model this relationship using the monotonically decreasing function: $\\omega_{i}=e^{-\\frac{1}{\\mu}\\rho_{i}}$ , where $\\mu$ is a dynamic hyperparameter controlling the difference in sparsity ratios across layers, defined as $\\textstyle{\\frac{1}{n}}\\sum_{j=1}^{n}{\\dot{\\psi}}_{i j}$ , which smooths the descent speed (Fig. 8). The importance factor for the first $i$ layers is represented by $\\omega_{i}$ . With these components, we formulate the linear programming problem as follows: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\displaystyle\\mathrm{Objective:~}\\operatorname*{max}_{\\mathbf{q}}\\sum_{i=1}^{L}\\left(\\frac{q_{i}}{L-i+1}\\sum_{j=i}^{L}\\omega_{j}\\right),}\\\\ &{\\displaystyle\\mathrm{Constraints:~}\\sum_{i}^{L}S^{(q_{i})}\\leq\\mathcal{B}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $S^{(q_{i})}$ denotes the model size of the $i$ -th layer under sparsity $q_{i}$ , and $\\boldsymbol{\\mathrm{\\Delta}}\\boldsymbol{\\mathrm{\\Omega}}^{\\beta}$ represents the target model size. The optimal sparsity configuration is given by $\\mathbf{q}$ . To maximize the model\u2019s representative capacity, our method try to assign smaller sparsity configurations to more independent layers by maximizing an objective function. For a more fine-grained sparsity allocation, we extend our approach to include intra-layer component-level sparsity allocation. After determining the sparsity ratios for each layer, we treat the remaining parameters in this layer as the target size and construct objective functions for its individual components. By applying ALS at this granular level, we obtain a secondary sparsity allocation, resulting in unique sparsity ratios for every layer and component. This hierarchical approach enables a highly customized and adaptable sparsity distribution throughout the entire network architecture, potentially leading to enhanced efficiency and performance gains. ", "page_idx": 5}, {"type": "text", "text": "4 Experimental Results ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Setup. For pruning, we follow the settings of Wanda, SparseGPT, and Magnitude. Regarding the calibration data used in the linear optimization process, we follow the configurations of SparseGPT and Wanda, selecting data from the C4 dataset and ensuring that all test data are zero-shot. We use a calibration data size of 16 for linear optimization hyperparameters. The granularity, explained in Appendix. E.1 for linear optimization results is set to $0.5\\%$ . For the values of $x_{i}$ , we use the input, although output and intermediate gates can also be used. Hyperparameter analysis is primarily conducted in the analysis section. Details about the experimental environment are provided in Appendix E.1. ", "page_idx": 5}, {"type": "text", "text": "Evaluation and Metrics. We measure the performance of pruned models through zero-shot tasks and language modeling. For zero-shot evaluation, we utilize seven tasks from the EleutherAI LM Harness [47]: Winogrande [39], PIQA [2], OpenBookQA [37], HellaSwag [61], BoolQ [6], ARC (Easy and Challenge) [7], and RTE (Recognizing Textual Entailment) [52]. We also include WikiText2 [36]. For the first seven datasets, we use the accuracy metric provided in the EleutherAI LM Harness. For WikiText2, we use the word_perplexity (PPL) metric. During evaluation, we ensure using the same database version, GPU model, and random seed. ", "page_idx": 5}, {"type": "text", "text": "Models. We evaluate the performance of ALS on LLMs, including LLaMA-V1 7B/13B/30B/65B [49], LLaMA-V2 7B/13B/70B [50], LLaMA-V3 8B [1], OPT 6.7B/13B [62]. ", "page_idx": 5}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/cff01d7d6d925d348a38de0081fb69d8f4f6ec3cdb660ad0339ed613e2d7bf3a.jpg", "table_caption": ["Table 1: WikiText-2 perplexity performance of ALS at varying sparsity rates for sparse LLaMA-V2-7B/13B pruned by the Magnitude, SparseGPT, Wanda metric. "], "table_footnote": [], "page_idx": 6}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/95feb2ed2b23f224db9bde2d4e15409c833fe2812e8b95e081144f4c9f098ffa.jpg", "table_caption": ["Table 2: WikiText-2 perplexity performance of ALS at $50\\%$ sparsity rates for sparse LLaMA-V1-7B/13B/30B/65B, LLaMA-V2-7B/13B/70B, LLaMA-V3 8B/70B and OPT-6.7B/13B pruned by the Magnitude, SparseGPT, Wanda metric. "], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "Baselines. We run ALS on LLMs with various methods, including Wanda [45], Magnitude-based pruning [18] and SparseGPT [16]. ", "page_idx": 6}, {"type": "text", "text": "4.1 Language Modeling ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Quantitative Evaluation. In Table 2, we compare the wikitext2 (PPL) performance of different pruning methods under $50\\%$ sparsity on the LLaMA-V1, LLaMA-V2, LLaMA-V3, and OPT models, including Dense (unpruned), Magnitude pruning [28], SparseGPT pruning [17], Wanda pruning [46], and the results of these pruning methods enhanced by ALS. The results show that the ALS generally improves the performance of various pruning methods. ", "page_idx": 6}, {"type": "text", "text": "For LLaMA-V1 models, Magnitude pruning shows high perplexity, e.g., 42.26 for the 7B model, reduced to 16.80 with ALS. SparseGPT performs better, with 18.35 for the 13B model, reduced to 11.87 with ALS. Wanda achieves the best results, with 13.30 for the 13B model, reduced to 12.47 with ALS. ", "page_idx": 6}, {"type": "text", "text": "For LLaMA-V2 and LLaMA-V3 models, ALS also reduces perplexity significantly. For instance, the Magnitude pruning in 13B LLaMA-V2 model drops from 15.19 to 10.78, and Wanda pruning in the 8B LLaMA-V3 model from 15.01 to 12.30 with ALS. ", "page_idx": 6}, {"type": "text", "text": "On the OPT model, perplexity significantly increases after pruning. For instance, the 13B model of OPT has a perplexity as high as $4.09{\\mathrm{e}}4$ after Magnitude pruning, which remarkably reduces to 3.96e3 with ALS, demonstrating the effect of ALS in handling LLM pruning. However, there is an example where performance does not significantly improve with ALS. For instance, the 13B model of LLaMA-V1 has 9.90 perplexity after SparseGPT pruning, which slightly increases with ALS. ", "page_idx": 6}, {"type": "text", "text": "In summary, ALS significantly enhances model performance across various pruning methods by effectively mitigating performance loss. ", "page_idx": 6}, {"type": "text", "text": "Varying Sparsity Rates. Table 1 presents the perplexity scores of sparse LLaMA-V2 7B and 13B models pruned by Magnitude, SparseGPT, and Wanda methods, with and without ALS, at varying sparsity levels $20\\%$ to $70\\%$ ). The results show that as sparsity increases, perplexity scores generally deteriorate, indicating a decline in language modeling performance. However, as the sparsity level increases, the performance gap between ALS and non-ALS methods widens, with ALS exhibiting better performance at most sparsity levels. This suggests that ALS can help mitigate the performance degradation caused by higher sparsity, becoming increasingly effective at maintaining LLMs performance as the sparsity level grows. ", "page_idx": 6}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/1bc65cfebe0ffe3ef2f3996ee7a641707e626c63264182696da7ca4b23bccdcf.jpg", "table_caption": ["Table 3: Averaged accuracies $(\\%)$ for zero-shot tasks at $50\\%$ sparsity rate for sparse LLaMA-V1 7B/13B/30B/65B, LLaMA-V2 7B/13B/70B, LLaMA-V3 8B and OPT-6.7B/13B . "], "table_footnote": [], "page_idx": 7}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/e18c394afb039e768d3595084086740f9ecc8eb889be0a434f07dee1c1d9c6f9.jpg", "table_caption": ["Table 4: Accuracies $(\\%)$ for zero-shot tasks with $50\\%$ sparsity using LLaMA-V2 family. "], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "4.2 Zero-shot Tasks ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "In Table 3, we present the averaged accuracy performance of pruned LLaMA-V1, LLaMA-V2, LLaMA-V3, and OPT models on seven downstream zero-shot tasks at a $50\\%$ sparsity ratio. For detailed performance on specific tasks, please refer to Table 4, which shows improvements in most tasks. The average accuracy across the majority of tasks demonstrates the effectiveness of ALS in enhancing sparse large language models of any scale. Remarkably, for LLaMA3-8B, the incorporation of ALS leads to an improvement of $14.14\\%$ and $9.87\\%$ compared to the Magnitude and SparseGPT baselines, respectively. Similarly, for LLaMA1-13B, the addition of ALS results in an improvement of $5.95\\%$ compared to the baselines. ", "page_idx": 7}, {"type": "text", "text": "The significant performance improvement of LLaMA-V3 8B may be attributed to the fact that the new model is not well-suited for uniform pruning methods. we further use the LLaMA-V3 8B model as an example to intuitively present the improvements brought by ALS from the perspective of the heat map (Fig. 3 in the Appendix D). The heat map reveals that, at $50\\%$ sparsity, the redundancy between layers of the LLaMA-V3 8B model exhibits a distinct pattern compared to other models. The green distribution on both sides indicates that there is small redundancy between the shallow layers and other layers. This suggests that the information captured by the middle and deep layers has more overlap and similarity with other layers. The ALS method takes advantage of this inter-layer redundancy pattern and apply high sparsity ratio into the layers with higher redundancy. It maximally preserves the key information and reduces the impact of sparsification on model performance. From the heat maps of different models in the Appendix D, it can also be observed that each model requires a different sparsity ratio because the redundancy between its layers varies. ", "page_idx": 7}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/e46d6921cdf057157a7f3ef5e40fcb023e992704d08647f7ae1926dcc1152d3e.jpg", "table_caption": ["Table 5: WikiText-2 perplexity of Wanda with Table 6: Zero-shot accuracy $(\\%)$ of Wanda with ALS at $50\\%$ sparsity on LLaMA-family models.ALS at $50\\%$ sparsity on LLaMA-family models. "], "table_footnote": [], "page_idx": 8}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/cdd0e8ff14aefb00cac0c233df6ca1cb5734952c0cd6309f6d18cd0ee5b7d9c8.jpg", "table_caption": ["Table 7: Results of feature choice from varyingTable 8: Impact of normalizing features and component output of each layer on WikiText2 per-layer weights for distance function on and zero-shot tasks. WikiText2 and zero-shot tasks . "], "table_footnote": [], "page_idx": 8}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/46e42361cc2dfda7e317ff5956ed697ff2b4234a2ed979d3b51b06f3055759d7.jpg", "table_caption": [], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "4.3 Ablation Study ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "In this part, we examine the impact of various components within the ALS framework and compare it with LoRA Fine-tuning, specifically focusing on its bound setting, standardization on weight or feature, granularity choice, which can be found in Appendix. E.1, feature choice and robustness to calibration samples. All experimental setups are based on the LLaMA2-13B model with Wanda pruning and ALS. ", "page_idx": 8}, {"type": "text", "text": "Comparison with LoRA Fine-tuning. Our experiments in Table 5 and Table 6 demonstrate the substantial benefits of combining Wanda $^{+}$ ALS with LoRA fine-tuning across the LLaMA model family. The improvements are most striking in the LLaMA-V1 7B model, which showed a dramatic reduction in perplexity by 4.82 alongside a $10.17\\%$ increase in accuracy. Larger V1 models also benefited, with the 30B and 13B variants showing perplexity reductions of 1.43 and 1.15, coupled with accuracy gains of $2.09\\%$ and $1.89\\%$ respectively. The LLaMA-V2 models exhibited similar positive trends, with both 7B and 13B versions showing perplexity improvements and accuracy increases. These impressive results were achieved using just $2000\\,{\\mathrm{C}}4$ samples for LoRA fine-tuning in a zero-shot setting, highlighting the method\u2019s efficiency and effectiveness even with limited training data unrelated to the evaluation tasks. ", "page_idx": 8}, {"type": "text", "text": "Feature Selection and Normalization. Table 7 (a) compares the performance of input, output, and gate features in capturing layer independence, with output features achieving slightly lower perplexity. Table 8 (b) demonstrates the significant impact of jointly normalizing features and per-layer weights. Applying this normalization strategy yields a substantial improvement in accuracy, increasing from $66.40\\%$ to $68.11\\%$ , while also reducing perplexity from 10.078 to 10.070. ", "page_idx": 8}, {"type": "text", "text": "Comparison with OWL. We compared the performance of our proposed method with the OWL method on a set of benchmark datasets. The results are summarized in Table 9. We adopted the optimal parameter settings described in the OWL paper. Across all tested configurations, our method consistently achieved lower values compared to OWL, demonstrating its superior performance. Specifically, in the unstructured $50\\%$ setting, Wanda with ALS outperformed OWL by a margin of 0.25 units. Furthermore, in the structured pruning settings of 2:4 and 4:8, the advantage of Wanda with ALS increased to 0.95 and 0.44, respectively. ", "page_idx": 8}, {"type": "text", "text": "N:M Results. We also investigated the performance of our method in the N:M setting, where $N$ features are selected from $M$ available features. The results are shown in Table 9. Similarly, for OWL, we used the optimal parameter combination reported in their paper. Across all N:M configurations, ALS consistently achieved lower values compared to OWL. As the number of selected features $N$ increased, both methods exhibited performance improvements, but the advantage of ALS became more pronounced. For instance, in the 2:4 case, ALS outperformed OWL by a margin of 0.95 units, and this gap further widened to 1.82 in the 4:8 case. Overall, OWL is a method that is highly sensitive to parameter settings, and obtaining the optimal parameters may require dozens of experiments to determine the best combination. Moreover, there is no clear theoretical analysis explaining why such a combination should be used. ", "page_idx": 8}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/1c4a4a2c815c3bb459338b7940907b199ee921601f7f1fd7e850632a40013653.jpg", "img_caption": ["Figure 2: (a) Calibration data experiment: PPL decreases slightly with more data. (b) Pruning bounds: Model performance remains relatively stable between $30\\%$ and $70\\%$ bounds. (c) Model redundancy: Higher RM metric, lower performance. "], "img_footnote": [], "page_idx": 9}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/144ac1e467421a772e6f9d13a15108180aa9739709ca2d542006e2dccc320c5b.jpg", "table_caption": ["Table 9: WikiText-2 perplexity performance onTable 10: Pruning speed of various methods LLaMA-V2-13B at $50\\%$ sparsity rates. with ALS on LLaMA-V2-7B. "], "table_footnote": [], "page_idx": 9}, {"type": "text", "text": "Calibration Data. In Fig. 2 (a), we present the performance of pruning methods with different numbers of calibration samples. We use the size of 2, 4, 8, 16, 32, 64, 128, 256. Although this experiment reveals that the model\u2019s performance improves with an increase in the size of the calibration data, the improvement is quite limited. Even when comparing the scales of 2 and 256 in calibration samples, the perplexity decreases by only 0.11. These results further highlight the robustness of ALS. ", "page_idx": 9}, {"type": "text", "text": "Boundes. In Fig. 2 (b) demonstrates the effect of pruning bounds on the performance of the LLaMAV2 13B model. When the pruning bounds are set too high (e.g., 0.0-1.0), the model\u2019s performance significantly deteriorates from $10^{\\bar{1}}t o10^{3}$ compared with 0.3-0.7, indicating that aggressive pruning may impair the model\u2019s representational capacity. However, when the pruning bounds are set between $30\\%$ and $70\\%$ , the model\u2019s performance remains nearly unaffected. ", "page_idx": 9}, {"type": "text", "text": "Computation efficiency. As shown in Table 10, our ALS involves two computational phases: the Redundancy Metric (RM) calculation, which consistently takes approximately 90 seconds across all methods, and the Linear Programming (LP) solution, requiring roughly 160-170 milliseconds. The total processing time varies notably depending on the base pruning method employed: Magnitude pruning, requiring just 1.62 seconds for its base operation, achieves the fastest total completion time of 1.51 minutes when combined with ALS. Wanda, with its base pruning time of 199 seconds, completes the entire process in 4.81 minutes, while SparseGPT, requiring 1058 seconds for its base operation, takes 19.16 minutes in total. Compared to BESA [57] with 4.5 hours for sparsity allocation and pruning, our approach is notably faster, completing the process in minutes rather than hours. ", "page_idx": 9}, {"type": "text", "text": "5 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In this work, we present Adaptive Layer Sparsity (ALS), a novel approach for optimizing LLMs through the efficient allocation of sparsity across layers. By minimizing inter-layer redundancy, ALS achieves significant model compression while maintaining performance, as demonstrated through extensive experiments on diverse LLMs and tasks. We hope ALS offers valuable insights and practical tools for deploying LLMs under limited computational resources, and that our work may shed light on the role of sparsity in LLMs and its potential for model optimization. Future research will explore the relationship between sparsity allocation and individual weight importance, and investigate the integration of dynamic sparsity allocation with pruning metrics. By pushing the boundaries of model compression and efficiency, we aim to enhance the development of more capable and accessible LLMs for diverse applications. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[1] AI@Meta. Llama 3 model card. 2024. 3, 6 ", "page_idx": 10}, {"type": "text", "text": "[2] Yonatan Bisk, Rowan Zellers, Jianfeng Gao, Yejin Choi, et al. Piqa: Reasoning about physical commonsense in natural language. In Proceedings of the AAAI conference on artificial intelligence (AAAI), volume 34, pages 7432\u20137439, 2020. 6   \n[3] Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language models are few-shot learners. Advances in neural information processing systems (NeurIPs), 33:1877\u20131901, 2020. 1   \n[4] S\u00e9bastien Bubeck, Varun Chandrasekaran, Ronen Eldan, Johannes Gehrke, Eric Horvitz, Ece Kamar, Peter Lee, Yin Tat Lee, Yuanzhi Li, Scott Lundberg, et al. Sparks of artificial general intelligence: Early experiments with gpt-4. arXiv preprint arXiv:2303.12712, 2023. 1   \n[5] Yanqi Chen, Zhengyu Ma, Wei Fang, Xiawu Zheng, Zhaofei Yu, and Yonghong Tian. A unified framework for soft threshold pruning. In The Eleventh International Conference on Learning Representations, 2023. 4   \n[6] Christopher Clark, Kenton Lee, Ming-Wei Chang, Tom Kwiatkowski, Michael Collins, and Kristina Toutanova. Boolq: Exploring the surprising difficulty of natural yes/no questions. arXiv preprint arXiv:1905.10044, 2019. 6   \n[7] Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. Think you have solved question answering? try arc, the ai2 reasoning challenge. ArXiv, abs/1803.05457, 2018. 6   \n[8] Thomas M. Cover and Joy A. Thomas. Elements of Information Theory (Wiley Series in Telecommunications and Signal Processing). Wiley-Interscience, USA, 2006. 4   \n[9] Peijie Dong, Lujun Li, Xiang Liu, Zhenheng Tang, Xuebo Liu, Qiang Wang, and Xiaowen Chu. Lpzero: Language model zero-cost proxy search from zero. arXiv preprint arXiv:2410.04808, 2024. 3   \n[10] Peijie Dong, Lujun Li, Zhenheng Tang, Xiang Liu, Xinglin Pan, Qiang Wang, and Xiaowen Chu. Pruner-zero: Evolving symbolic pruning metric from scratch for large language models. In ICML, 2024. 3   \n[11] Peijie Dong, Lujun Li, and Zimian Wei. Diswot: Student architecture search for distillation without training. In CVPR, 2023. 3   \n[12] Peijie Dong, Lujun Li, Zimian Wei, Xin Niu, Zhiliang Tian, and Hengyue Pan. Emq: Evolving training-free proxies for automated mixed precision quantization. In ICCV, 2023. 3   \n[13] Xin Dong, Shangyu Chen, and Sinno Jialin Pan. Learning to prune deep neural networks via layer-wise optimal brain surgeon. In Proceedings of the 31st International Conference on Neural Information Processing Systems, NIPS\u201917, page 4860\u20134874, Red Hook, NY, USA, 2017. Curran Associates Inc. 2, 4   \n[14] Utku Evci, Trevor Gale, Jacob Menick, Pablo Samuel Castro, and Erich Elsen. Rigging the lottery: Making all tickets winners. In International Conference on Machine Learning (ICML), pages 2943\u20132952, 2020. 4   \n[15] Jonathan Frankle and Michael Carbin. The lottery ticket hypothesis: Finding sparse, trainable neural networks. In International Conference on Learning Representations, 2019. 1, 3   \n[16] Elias Frantar and Dan Alistarh. Massive language models can be accurately pruned in one-shot. In International Conference on Machine Learning (ICML), 2023. 3, 7   \n[17] Elias Frantar and Dan Alistarh. Sparsegpt: massive language models can be accurately pruned in one-shot. In Proceedings of the 40th International Conference on Machine Learning, ICML\u201923. JMLR.org, 2023. 2, 3, 7   \n[18] Song Han, Jeff Pool, John Tran, and William Dally. Learning both weights and connections for efficient neural network. In Advances in Neural Information Processing Systems (NeurIPS), pages 1135\u20131143, 2015. 7   \n[19] Song Han, Jeff Pool, John Tran, and William J. Dally. Learning both weights and connections for efficient neural networks. In Proceedings of the 28th International Conference on Neural Information Processing Systems - Volume 1, NIPS\u201915, page 1135\u20131143, Cambridge, MA, USA, 2015. MIT Press. 1, 3   \n[20] B. Hassibi, D.G. Stork, and G.J. Wolff. Optimal brain surgeon and general network pruning. In IEEE International Conference on Neural Networks, pages 293\u2013299 vol.1, 1993. 3   \n[21] Babak Hassibi, David G Stork, and Gregory J Wolff. Optimal brain surgeon and general network pruning. In IEEE international conference on neural networks, pages 293\u2013299. IEEE, 1993. 4   \n[22] Yang He, Guoliang Kang, Xuanyi Dong, Yanwei Fu, and Yi Yang. Soft filter pruning for accelerating deep convolutional neural networks. In Proceedings of the 27th International Joint Conference on Artificial Intelligence, IJCAI\u201918, page 2234\u20132240. AAAI Press, 2018. 2, 4   \n[23] Zhongzhan Huang, Xinjiang Wang, and Ping Luo. Convolution-weight-distribution assumption: Rethinking the criteria of channel pruning. CoRR, abs/2004.11627, 2020. 3   \n[24] Chunhui Jiang, Guiying Li, Chao Qian, and Ke Tang. Efficient dnn neuron pruning by minimizing layer-wise nonlinear reconstruction error. In Proceedings of the 27th International Joint Conference on Artificial Intelligence, IJCAI\u201918, page 2298\u20132304. AAAI Press, 2018. 2, 4   \n[25] Simon Kornblith, Mohammad Norouzi, Honglak Lee, and Geoffrey Hinton. Similarity of neural network representations revisited. In Kamalika Chaudhuri and Ruslan Salakhutdinov, editors, Proceedings of the 36th International Conference on Machine Learning, volume 97 of Proceedings of Machine Learning Research, pages 3519\u20133529. PMLR, 09\u201315 Jun 2019. 3   \n[26] Aditya Kusupati, Vivek Ramanujan, Raghav Somani, Mitchell Wortsman, Prateek Jain, Sham Kakade, and Ali Farhadi. Soft threshold weight reparameterization for learnable sparsity. In International Conference on Machine Learning (ICML), pages 5544\u20135555, 2020. 4   \n[27] Yann LeCun, John Denker, and Sara Solla. Optimal brain damage. In D. Touretzky, editor, Advances in Neural Information Processing Systems, volume 2. Morgan-Kaufmann, 1989. 1, 3   \n[28] Jaeho Lee, Sejun Park, Sangwoo Mo, Sungsoo Ahn, and Jinwoo Shin. Layer-adaptive sparsity for the magnitude-based pruning. In International Conference on Learning Representations (ICLR), 2020. 2, 7   \n[29] Lujun Li, Yufan Bao, Peijie Dong, Chuanguang Yang, Anggeng Li, Wenhan Luo, Qifeng Liu, Wei Xue, and Yike Guo. Detkds: Knowledge distillation search for object detectors. In ICML, 2024. 3   \n[30] Lujun Li, Peijie Dong, Anggeng Li, Zimian Wei, and Ya Yang. Kd-zero: Evolving knowledge distiller for any teacher-student pairs. NeuIPS, 2024. 3   \n[31] Lujun Li, Peijie Dong, Zimian Wei, and Ya Yang. Automated knowledge distillation via monte carlo tree search. In ICCV, 2023. 3   \n[32] Lujun Li and Zhe Jin. Shadow knowledge distillation: Bridging offline and online knowledge transfer. In NeuIPS, 2022. 3   \n[33] Ji Lin, Jiaming Tang, Haotian Tang, Shang Yang, Xingyu Dang, and Song Han. Awq: Activation-aware weight quantization for llm compression and acceleration. arXiv preprint arXiv:2306.00978, 2023. 3   \n[34] Xinyin Ma, Gongfan Fang, and Xinchao Wang. LLM-pruner: On the structural pruning of large language models. In Thirty-seventh Conference on Neural Information Processing Systems, 2023. 3   \n[35] Yuexiao Ma, Taisong Jin, Xiawu Zheng, Yan Wang, Huixia Li, Yongjian Wu, Guannan Jiang, Wei Zhang, and Rongrong Ji. Ompq: Orthogonal mixed precision quantization. In Proceedings of the AAAI conference on artificial intelligence, volume 37, pages 9029\u20139037, 2023. 3   \n[36] Stephen Merity, Caiming Xiong, James Bradbury, and Richard Socher. Pointer sentinel mixture models. In International Conference on Learning Representations, 2017. 6   \n[37] Todor Mihaylov, Peter Clark, Tushar Khot, and Ashish Sabharwal. Can a suit of armor conduct electricity? a new dataset for open book question answering. In EMNLP, 2018. 6   \n[38] Pavlo Molchanov, Stephen Tyree, Tero Karras, Timo Aila, and Jan Kautz. Pruning convolutional neural networks for resource efficient inference. In International Conference on Learning Representations, 2017. 1, 3   \n[39] Keisuke Sakaguchi, Ronan Le Bras, Chandra Bhagavatula, and Yejin Choi. Winogrande: An adversarial winograd schema challenge at scale. Communications of the ACM, 64(9):99\u2013106, 2021. 6   \n[40] David W. Scott. Multivariate density estimation and visualization. Papers 2004,16, Berlin, 2004. 5   \n[41] C. E. Shannon. A mathematical theory of communication. Bell System Technical Journal, 27(3):379\u2013423, 1948. 4   \n[42] Wenqi Shao, Mengzhao Chen, Zhaoyang Zhang, Peng Xu, Lirui Zhao, Zhiqian Li, Kaipeng Zhang, Peng Gao, Yu Qiao, and Ping Luo. Omniquant: Omnidirectionally calibrated quantization for large language models. In The Twelfth International Conference on Learning Representations, 2024. 3   \n[43] Ravid Shwartz-Ziv and Naftali Tishby. Opening the black box of deep neural networks via information. arXiv preprint arXiv:1703.00810, 2017. 4   \n[44] Bernard W Silverman. Density estimation for statistics and data analysis. Routledge, 2018. 5   \n[45] Mingjie Sun, Zhuang Liu, Anna Bair, and J Zico Kolter. A simple and effective pruning approach for large language models. arXiv preprint arXiv:2306.11695, 2023. 7   \n[46] Mingjie Sun, Zhuang Liu, Anna Bair, and J Zico Kolter. A simple and effective pruning approach for large language models. In The Twelfth International Conference on Learning Representations, 2024. 2, 3, 7   \n[47] Sutawika, Schoelkopf, Gao, Abbasi, Biderman, Tow, fattori, Lovering, farzanehnakhaee, Phang, Thite, Fazz, Wang, Muennighoff, Aflah, sdtblck, nopperl, gakada, tttyuntian, researcher, Chris, Etxaniz, Lee, Kasner, Khalid, Hsu, Kanekar, Ammanamanchi, Boykis, and AndyZwei. EleutherAI/lm-evaluation-harness: v0.4.2, March 2024. 6, 24   \n[48] Naftali Tishby and Noga Zaslavsky. Deep learning and the information bottleneck principle. In 2015 ieee information theory workshop (itw), pages 1\u20135. IEEE, 2015. 4   \n[49] Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timoth\u00e9e Lacroix, Baptiste Rozi\u00e8re, Naman Goyal, Eric Hambro, Faisal Azhar, et al. Llama: Open and efficient foundation language models. arXiv preprint arXiv:2302.13971, 2023. 1, 3, 6   \n[50] Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288, 2023. 3, 6   \n[51] Michael Tschannen, Josip Djolonga, Paul K Rubenstein, Sylvain Gelly, and Mario Lucic. On mutual information maximization for representation learning. arXiv preprint arXiv:1907.13625, 2019. 5   \n[52] Alex Wang, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel Bowman. GLUE: A multi-task benchmark and analysis platform for natural language understanding. In Tal Linzen, Grzegorz Chrupa\u0142a, and Afra Alishahi, editors, Proceedings of the 2018 EMNLP Workshop BlackboxNLP: Analyzing and Interpreting Neural Networks for NLP, pages 353\u2013355, Brussels, Belgium, November 2018. Association for Computational Linguistics. 6   \n[53] Qiufeng Wang, Xu Yang, Shuxia Lin, and Xin Geng. Learngene: Inheriting condensed knowledge from the ancestry model to descendant models. ArXiv, abs/2305.02279, 2023. 3   \n[54] Jason Wei, Yi Tay, Rishi Bommasani, Colin Raffel, Barret Zoph, Sebastian Borgeaud, Dani Yogatama, Maarten Bosma, Denny Zhou, Donald Metzler, et al. Emergent abilities of large language models. Transactions on Machine Learning Research, 2022. 1   \n[55] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Fei Xia, Ed Chi, Quoc V Le, Denny Zhou, et al. Chain-of-thought prompting elicits reasoning in large language models. Advances in Neural Information Processing Systems (NeurIPs), 35:24824\u201324837, 2022. 1   \n[56] Liu Xiaolong, Li Lujun, Li Chao, and Anbang Yao. Norm: Knowledge distillation via n-to-one representation matching. In ICLR, 2023. 3   \n[57] Peng Xu, Wenqi Shao, Mengzhao Chen, Shitao Tang, Kaipeng Zhang, Peng Gao, Fengwei An, Yu Qiao, and Ping Luo. BESA: Pruning large language models with blockwise parameter-efficient sparsity allocation. In The Twelfth International Conference on Learning Representations, 2024. 2, 4, 10   \n[58] Lu Yin, You Wu, Zhenyu Zhang, Cheng-Yu Hsieh, Yaqing Wang, Yiling Jia, Mykola Pechenizkiy, Yi Liang, Zhangyang Wang, and Shiwei Liu. Outlier weighed layerwise sparsity (owl): A missing secret sauce for pruning llms to high sparsity. arXiv preprint arXiv:2310.05175, 2023. 2, 4   \n[59] Miao Yin, Burak Uzkent, Yilin Shen, Hongxia Jin, and Bo Yuan. Gohsp: a unified framework of graph and optimization-based heterogeneous structured pruning for vision transformer. In Proceedings of the Thirty-Seventh AAAI Conference on Artificial Intelligence and Thirty-Fifth Conference on Innovative Applications of Artificial Intelligence and Thirteenth Symposium on Educational Advances in Artificial Intelligence, AAAI\u201923/IAAI\u201923/EAAI\u201923. AAAI Press, 2023. 1, 3   \n[60] Adriano Z Zambom and Ronaldo Dias. A review of kernel density estimation with applications to econometrics. International Econometric Review, 5(1):20\u201342, 2013. 5   \n[61] Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. Hellaswag: Can a machine really finish your sentence? arXiv preprint arXiv:1905.07830, 2019. 6   \n[62] Susan Zhang, Stephen Roller, Naman Goyal, Mikel Artetxe, Moya Chen, Shuohui Chen, Christopher Dewan, Mona Diab, Xian Li, Xi Victoria Lin, et al. Opt: Open pre-trained transformer language models. arXiv preprint arXiv:2205.01068, 2022. 1, 3, 6   \n[63] Yuxin Zhang, Mingbao Lin, Fei Chao, Yan Wang, Ke Li, Yunhang Shen, Yongjian Wu, and Rongrong Ji. Lottery jackpots exist in pre-trained models. IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI), 2023. 3   \n[64] Yuxin Zhang, Mingbao Lin, Zhihang Lin, Yiting Luo, Ke Li, Fei Chao, Yongjian Wu, and Rongrong Ji. Learning best combination for efficient n: M sparsity. In Advances in Neural Information Processing Systems (NeurIPS), 2022. 3   \n[65] Yuxin Zhang, Lirui Zhao, Mingbao Lin, Sun Yunyun, Yiwu Yao, Xingjia Han, Jared Tanner, Shiwei Liu, and Rongrong Ji. Dynamic sparse no training: Training-free fine-tuning for sparse LLMs. In The Twelfth International Conference on Learning Representations, 2024. 2, 4 ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "Appendix ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "A Limitation: Computational Complexity of Intra-Layer Component Independence Calculation ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "In the ALS method, a key step is computing the independence matrix between layers. While calculating the matrix at the layer level for a 70 billion parameter model with 80 layers requires only an $80\\times80$ RM matrix, including intra-layer components increases the matrix size to $7\\times80\\times7\\times80$ , leading to 49 times more computational time and resources. ", "page_idx": 14}, {"type": "text", "text": "\u2022 High Computational Complexity: The increased matrix size results in exponential growth in computation and resource consumption.   \n\u2022 Excessive Memory Usage: High-dimensional matrix computations require substantial memory, potentially exceeding hardware capacities. ", "page_idx": 14}, {"type": "text", "text": "Solutions ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "\u2022 Hybrid Solution with $\\mathbf{C++}$ : Store intermediate data locally and use $C++$ to handle calculations and solve the linear programming problem. This approach can be up to 50 times faster than using Python alone.   \n\u2022 Alternatively, calculate sparsity ratios for each layer, determine the parameters to retain, and use these as the target size for further linear programming. This approach requires only an $80\\times80$ RM matrix and 7 additional $7\\times7$ matrices, without significantly increasing computation time. ", "page_idx": 14}, {"type": "text", "text": "Hybrid Solution with $C++$ is a preferred solution because it will keep most of independent components to maintain the model performance after pruning. ", "page_idx": 14}, {"type": "text", "text": "B Detailed Formulae Derivation ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "This section provides a detailed derivation of the key mathematical formulae used in the paper. ", "page_idx": 14}, {"type": "text", "text": "B.1 Detailed Derivation of the Mutual Information Approximation ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "The objective of LLMs is to minimize the reconstruction error between the outputs of the sparse and dense models. We start by defining the mutual information between the outputs of different layers to quantify the redundancy within the model. Mutual information $I(X;Y)$ measures the amount of information obtained about one random variable $X$ through observing the other random variable $Y$ . It quantifies the reduction in uncertainty of $X$ due to the knowledge of $Y$ . This measure helps identify layers with high redundancy, which can be pruned to achieve a more efficient representation. ", "page_idx": 14}, {"type": "text", "text": "The mutual information $I\\left(X_{i};X_{j}\\right)$ between two layers $i$ and $j$ is given by: ", "page_idx": 14}, {"type": "equation", "text": "$$\nI\\left(X_{i};X_{j}\\right)=H\\left(X_{i}\\right)+H\\left(X_{j}\\right)-H\\left(X_{i},X_{j}\\right)\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "where $H\\left(X_{i}\\right)$ and $H\\left(X_{j}\\right)$ are the marginal entropies, and $H\\left(X_{i},X_{j}\\right)$ is the joint entropy. The entropy $H(X)$ measures the average amount of information or uncertainty in a random variable $X$ . These entropies are defined as: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\begin{array}{l}{H\\left(X_{i}\\right)=-\\int p\\left(x_{i}\\right)\\log p\\left(x_{i}\\right)\\mathrm{d}x_{i}}\\\\ {H\\left(X_{j}\\right)=-\\int p\\left(x_{j}\\right)\\log p\\left(x_{j}\\right)\\mathrm{d}x_{j}}\\\\ {H\\left(X_{i},X_{j}\\right)=-\\int p\\left(x_{i},x_{j}\\right)\\log p\\left(x_{i},x_{j}\\right)\\mathrm{d}x_{i}\\mathrm{~d}x_{j}}\\end{array}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "The mutual information can also be expressed in terms of the probability density functions as: ", "page_idx": 14}, {"type": "equation", "text": "$$\nI\\left(X_{i};X_{j}\\right)=\\int p\\left(x_{i},x_{j}\\right)\\log\\frac{p\\left(x_{i},x_{j}\\right)}{p\\left(x_{i}\\right)p\\left(x_{j}\\right)}\\mathrm{d}x_{i}\\mathrm{~d}x_{j}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "To approximate these values, we use Monte Carlo sampling. Given $N$ i.i.d. samples $\\mathbf{x}^{(1)},\\mathbf{\\hat{x}}^{(2)},\\ldots,\\mathbf{x}^{(N)}$ drawn from the joint distribution $p(x_{i},x_{j})$ , the mutual information can be approximated as: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\hat{I}\\left(X_{i};X_{j}\\right)\\approx\\frac{1}{N}\\sum_{n=1}^{N}\\log\\frac{p\\left(x_{i}^{(n)},x_{j}^{(n)}\\right)}{p\\left(x_{i}^{(n)}\\right)p\\left(x_{j}^{(n)}\\right)}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Using kernel density estimation to approximate the probability densities. For instance: ", "page_idx": 15}, {"type": "equation", "text": "$$\n{\\hat{p}}(\\mathbf{y})={\\frac{1}{N h^{d}}}\\sum_{i=1}^{N}K\\left({\\frac{\\mathbf{y}-\\mathbf{y}_{i}}{h}}\\right)\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Here, $K(\\cdot)$ is the kernel function, $h$ is the bandwidth parameter, and $d$ is the dimension of y. Kernel density estimation is a non-parametric method for estimating the probability density function $p(\\mathbf{y})$ of a random vector $\\mathbf{y}$ , given a set of i.i.d. samples $\\mathbf{Y}=\\{\\mathbf{y}_{1},\\mathbf{y}_{2},\\hdots,\\mathbf{y}_{N}\\}$ drawn from $p(\\mathbf{y})$ . Commonly used kernels include the Gaussian and Epanechnikov kernels. ", "page_idx": 15}, {"type": "text", "text": "To compute the marginal and joint probability density functions of the samples\u2019 outputs at the $i$ -th and $j$ -th layers, we apply kernel density estimation: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\hat{p}\\left(\\mathbf{x}_{i}\\right)=\\frac{1}{N h_{i}^{d_{i}}}\\displaystyle\\sum_{n=1}^{N}K\\left(\\frac{\\mathbf{x}_{i}-\\mathbf{x}_{i}^{(n)}}{h_{i}}\\right)}\\\\ &{\\hat{p}\\left(\\mathbf{x}_{j}\\right)=\\frac{1}{N h_{j}^{d_{j}}}\\displaystyle\\sum_{n=1}^{N}K\\left(\\frac{\\mathbf{x}_{j}-\\mathbf{x}_{j}^{(n)}}{h_{j}}\\right)}\\\\ &{\\hat{p}\\left(\\mathbf{x}_{i},\\mathbf{x}_{j}\\right)=\\frac{1}{N h_{i}^{d_{i}}h_{j}^{d_{j}}}\\displaystyle\\sum_{n=1}^{N}K\\left(\\frac{\\mathbf{x}_{i}-\\mathbf{x}_{i}^{(n)}}{h_{i}}\\right)K\\left(\\frac{\\mathbf{x}_{j}-\\mathbf{x}_{j}^{(n)}}{h_{j}}\\right)}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "where $d_{i}$ and $d_{j}$ are the dimensions of $\\mathbf{x}_{i}$ and $\\mathbf{x}_{j}$ , respectively. ", "page_idx": 15}, {"type": "text", "text": "To derive the mutual information approximation, let\u2019s start with the Monte Carlo approximation of mutual information (Equation 7). Substituting the kernel density estimates (Equations 9-11) into Equation 7, we get: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\hat{I}\\left(X_{i};X_{j}\\right)\\approx\\frac{1}{N}\\sum_{n=1}^{N}\\log\\frac{\\sum_{k=1}^{N}K\\left(\\frac{\\mathbf{x}_{i}^{\\left(n\\right)}-\\mathbf{x}_{i}^{\\left(k\\right)}}{h_{i}}\\right)K\\left(\\frac{\\mathbf{x}_{j}^{\\left(n\\right)}-\\mathbf{x}_{j}^{\\left(k\\right)}}{h_{j}}\\right)}{\\left(\\sum_{k=1}^{N}K\\left(\\frac{\\mathbf{x}_{i}^{\\left(n\\right)}-\\mathbf{x}_{i}^{\\left(k\\right)}}{h_{i}}\\right)\\right)\\left(\\sum_{k=1}^{N}K\\left(\\frac{\\mathbf{x}_{j}^{\\left(n\\right)}-\\mathbf{x}_{j}^{\\left(k\\right)}}{h_{j}}\\right)\\right)}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Now, consider the feature matrix inner product approximation for the kernel function. Let: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{l}{\\displaystyle K\\left(\\frac{\\mathbf{x}_{i}^{\\left(n\\right)}-\\mathbf{x}_{i}^{\\left(k\\right)}}{h_{i}}\\right)\\approx\\left\\|\\mathbf{x}_{i}^{\\left(n\\right)T}\\mathbf{x}_{i}^{\\left(k\\right)}\\right\\|_{F}}\\\\ {\\displaystyle K\\left(\\frac{\\mathbf{x}_{j}^{\\left(n\\right)}-\\mathbf{x}_{j}^{\\left(k\\right)}}{h_{j}}\\right)\\approx\\left\\|\\mathbf{x}_{j}^{\\left(n\\right)T}\\mathbf{x}_{j}^{\\left(k\\right)}\\right\\|_{F}}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "where $\\|\\cdot\\|_{F}$ denotes the Frobenius norm. ", "page_idx": 15}, {"type": "text", "text": "Therefore, the joint kernel function can be approximated by: ", "page_idx": 15}, {"type": "equation", "text": "$$\nK\\left(\\left(\\mathbf{x}_{i}^{(n)},\\mathbf{x}_{j}^{(n)}\\right),\\left(\\mathbf{x}_{i}^{(k)},\\mathbf{x}_{j}^{(k)}\\right)\\right)\\approx\\left\\|\\mathbf{x}_{i}^{(n)T}\\mathbf{x}_{j}^{(n)}\\right\\|_{F}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Substituting these approximations (Equations 13-15) back into the mutual information formula (Equation 12), we get: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\hat{I}\\left(X_{i};X_{j}\\right)\\approx\\frac{1}{N}\\sum_{n=1}^{N}\\log\\frac{\\left\\lVert\\mathbf{x}_{i}^{(n)T}\\mathbf{x}_{j}^{(n)}\\right\\rVert_{F}}{\\left\\lVert\\mathbf{x}_{i}^{(n)T}\\mathbf{x}_{i}^{(n)}\\right\\rVert_{F}\\left\\lVert\\mathbf{x}_{j}^{(n)T}\\mathbf{x}_{j}^{(n)}\\right\\rVert_{F}}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "This leads to the final expression for the mutual information approximation using Monte Carlo sampling and kernel density estimation with the feature matrix inner product approximation. ", "page_idx": 15}, {"type": "text", "text": "B.2 Redundancy Metric Derivation ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Since mutual information has no general upper bound, its upper limit depends on the entropy of either $X_{i}$ or $X_{j}$ , which represent the $i$ -th and $j$ -th layer output of a batch input. To address this, we can use functions to transform the range of mutual information, ensuring a bounded and more interpretable metric. For instance, using $e^{\\hat{I}(X_{i};X_{j})}$ or a Gaussian function, we can redefine the measure as follows. Considering $\\left\\|\\mathbf{x}_{i}^{T}\\mathbf{x}_{j}\\right\\|_{F}e^{\\hat{I}(X_{i};X_{j})}$ for a batch of inputs, we can remove the sum and $\\textstyle{\\frac{1}{N}}$ , then obtain: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\left\\|\\mathbf{X}_{i}^{T}\\mathbf{X}_{j}\\right\\|_{F}\\cdot e^{\\hat{I}(X_{i};X_{j})}=\\frac{\\left\\|\\mathbf{X}_{i}^{T}\\mathbf{X}_{j}\\right\\|_{F}^{2}}{\\left\\|\\mathbf{X}_{i}^{T}\\mathbf{X}_{i}\\right\\|_{F}\\left\\|\\mathbf{X}_{j}^{T}\\mathbf{X}_{j}\\right\\|_{F}}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "To derive the Redundancy Metric (RM) formula, we consider that a batch is a set of samples processed simultaneously by the neural network. Because a batch is input simultaneously, we remove the summation and division by $N$ , obtaining the following formula: ", "page_idx": 16}, {"type": "equation", "text": "$$\nR M\\left({{\\bf{X}}_{i}},{{\\bf{X}}_{j}}\\right)=\\frac{{\\left\\|{{\\bf{X}}_{i}^{T}{\\bf{X}}_{j}}\\right\\|_{F}^{2}}}{{\\left\\|{{\\bf{X}}_{i}^{T}{\\bf{X}}_{i}}\\right\\|_{F}\\left\\|{{\\bf{X}}_{j}^{T}{\\bf{X}}_{j}}\\right\\|_{F}}}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "In this formula, $R M(\\cdot)\\in[0,1]$ , where a value close to 0 indicates high independence between the layers (low redundancy), and a value close to 1 indicates high redundancy (low independence). ", "page_idx": 16}, {"type": "text", "text": "B.3 Constraints and Objective Functions ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Our redundancy metric is used to guide the allocation of sparsity ratios across layers. We construct a redundancy matrix $\\Psi\\in\\mathbb{R}^{L\\times L}$ where each element $\\psi_{i j}$ represents the redundancy between layers $i$ and $j$ , computed using Equation 18. The overall redundancy of each layer is: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\rho_{i}=\\sum_{j=1}^{L}\\psi_{i j}-1\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "A lower $\\rho_{i}$ indicates higher independence. Using a monotonically decreasing function, we define the importance factor $\\omega_{i}$ as: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\omega_{i}=e^{-\\frac{1}{\\mu}\\rho_{i}}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where $\\mu$ is a hyperparameter controlling the decay rate. ", "page_idx": 16}, {"type": "text", "text": "Our objective is to maximize the sum of the weighted sparsity ratios across all layers, subject to a model size constraint $\\boldsymbol{\\mathrm{\\Delta}}\\boldsymbol{\\mathrm{\\Omega}}^{\\beta}$ . The sparsity ratio $q_{i}\\in[0,1]$ represents the fraction of weights to be pruned in the $i$ -th layer. The optimization problem can be formulated as: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\mathrm{maximize}_{\\mathbf{q}}\\;}&{\\displaystyle\\sum_{i=1}^{L}\\left(\\frac{q_{i}}{L-i+1}\\sum_{j=i}^{L}\\omega_{j}\\right)}\\\\ {\\mathrm{subject~to}\\;}&{\\displaystyle\\sum_{i=1}^{L}S^{(q_{i})}\\leq\\mathcal{B}}\\\\ &{0\\leq q_{i}\\leq1,\\quad\\forall i\\in\\{1,2,\\ldots,L\\}}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where S(qi) represents the model size of the $i$ -th layer under sparsity ratio $q_{i}$ , and $\\textbf{q}=$ $[q_{1},q_{2},\\dots,q_{L}]^{\\dot{T}}$ is the vector of sparsity ratios for all $L$ layers. The objective function (Equation 22) aims to allocate higher sparsity ratios to layers with higher importance factors. The constraint (Equation 23) ensures that the total model size after pruning does not exceed the budget $\\boldsymbol{\\mathrm{\\Delta}}\\boldsymbol{\\mathrm{\\Omega}}_{\\boldsymbol{B}}$ . ", "page_idx": 16}, {"type": "text", "text": "C More Experimental Results ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "C.1 Zero-Shot results Details ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Results in LLaMA-V1,V2,V3 and OPT series at ${\\bf50\\,\\%}$ Sparsity ", "page_idx": 16}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/9f61afa4e5006950d1c59dc35eeb6b258c03dc9beb6388f526c1ee2a9327d8c9.jpg", "table_caption": ["Table 11: Accuracies $(\\%)$ for zero-shot tasks with $50\\%$ sparsity using LLaMA-V1 family. "], "table_footnote": [], "page_idx": 17}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/1241a85ec706234d138496d4454e6fa98cdf3ddc5ce55d32b2ee9105dfef643c.jpg", "table_caption": ["Table 12: Accuracies $(\\%)$ for zero-shot tasks with $50\\%$ sparsity using LLaMA-V2 family. "], "table_footnote": [], "page_idx": 17}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/41c00f5423eaad0c5e1d02d156488f56f321ac5bc27841cefea0acc4a2fd1fb4.jpg", "table_caption": ["Table 13: Accuracies $(\\%)$ for zero-shot tasks with $50\\%$ sparsity using LLaMA-V3. "], "table_footnote": [], "page_idx": 17}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/a08ec923bee567c6f841647a1811b18d17eb8c48ed085b7e0d9c32241b7e9552.jpg", "table_caption": ["Table 14: Accuracies $(\\%)$ for zero-shot tasks with $50\\%$ sparsity using OPT family. "], "table_footnote": [], "page_idx": 18}, {"type": "text", "text": "Results in LLaMA-V2 7B/13B at various sparsity level ", "text_level": 1, "page_idx": 18}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/b1506169e73501eaeeabe8e1215457b13b9fc03320a42ab5b9ce89be6b891da8.jpg", "table_caption": ["Table 15: LLaMA-V2 13B at various sparsity level "], "table_footnote": [], "page_idx": 18}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/1ede3938770b8abaac6ae762eee7a9bf4462965a4b650b95ebd2ab4164eb2032.jpg", "table_caption": ["Table 16: LLaMA-V2 7B at various sparsity level "], "table_footnote": [], "page_idx": 19}, {"type": "text", "text": "D Visualization of Correlation Matrices ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "In this section, we present the visualization of correlation matrices obtained by solving the problem under different experimental settings. Additionally, we provide the numerical results of the Sparse Ratio Allocation. The RM heat maps are different with different models. ", "page_idx": 19}, {"type": "text", "text": "D.1 Visualization of RM Matrices ", "text_level": 1, "page_idx": 19}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/173bd6f493c041fcafd3659f09cd9762990a4e9fcf97f29a5d6e931f04847436.jpg", "img_caption": ["${\\bf50\\%}$ sparsity in LLAMA-V1/V2/V3 family. "], "img_footnote": ["Figure 3: $50\\%$ sparsity in LLAMA-V1/V2/V3 family. "], "page_idx": 19}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/875c32390c952e2433ab4d0b3f46f182503a35bae4acb56d598d78496c69a82e.jpg", "img_caption": ["Figure 4: various sparsity in LLAMA-V2 7B/13B family. "], "img_footnote": [], "page_idx": 20}, {"type": "text", "text": "D.2 Ratio allocation ", "page_idx": 20}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/c558deec38213f6c703d3a8cdce09b377ed217a8933fc6d3cb2501d96b714d6e.jpg", "img_caption": ["Figure 5: The sparsity ratio allocation in $50\\%$ sparsity in LLAMA-V1/V2/V3 family. "], "img_footnote": [], "page_idx": 20}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/e09034c431b61b5434d7792035675740299627a616761883c7f40e080ecf6265.jpg", "img_caption": ["D.3 Ratio allocation ", "Figure 6: The sparsity ratio allocation in various sparsity in LLAMA-V2 7B/13B family. "], "img_footnote": [], "page_idx": 21}, {"type": "text", "text": "E Extra Figures and Explanations ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "E.1 Experimental Environment and Hyperparameters ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Granularity. The granularity for linear optimization results is set to $0.5\\%$ , meaning the sparsity percentages can only have decimal places of $0.5\\%$ or $0.0\\%$ . The experiment is based on LLaMA-V2 13B, this study in Fig 7 examines the impact of granularity on perplexity (PPL) across selected values. Initially, PPL remains relatively constant at 10.07 for granularities of 0.1 and 0.5. It then decreases to 9.86 at a granularity of 1 and further to 9.67 at a granularity of 5. However, beyond this point, the smoothed curve indicates a subsequent rise in PPL, suggesting that excessively high granularity may negatively impact model performance. This analysis highlights a critical balance in optimizing granularity to minimize PPL and enhance model accuracy and efficiency. ", "page_idx": 21}, {"type": "text", "text": "Environment. All pruning experiments are performed on dual NVIDIA A100 GPUs with 80GB memory. However, our ALS method mainly runs on CPU, while the baseline methods Wanda, SparseGPT, and Magnitude require GPU. The CPU used is an AMD EPYC\u21229554 64-core processor. ", "page_idx": 21}, {"type": "text", "text": "Hyperparameters We set weight and feature normalization, calibration data $=2$ , feature selection $\\equiv$ in, granularity ${\\it\\mathrm{=}}0.05$ , boundes $=0.3\u20130.7$ for $3070\\%$ sparsity and 0.1-0.3 for $20\\%$ sparsity. ", "page_idx": 21}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/04becbda733fcb71bceadc0b6ec2d4d4cea3ac0e23850935e438cc1df0a3c831.jpg", "img_caption": ["Figure 7: The granularity experiment in LLAMA-V2 7B. "], "img_footnote": [], "page_idx": 21}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/a8a4a65aaeed68f3c1e74a7b7100274882732d78b305187f0bafb1345dd7392f.jpg", "img_caption": ["E.2 Ratio allocation ", "Figure 8: The comparison of decreasing function "], "img_footnote": [], "page_idx": 22}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/bb97fae9121c8020e5e6c13d60c578fdd3d679b3ea87acfd89877b59f2610b5a.jpg", "img_caption": [], "img_footnote": [], "page_idx": 22}, {"type": "text", "text": "E.3 Error Bar ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "In this subsection, we present LLaMA-V2 family error bar in $50\\%$ sparsity. The standard deviations are runing multiple experiments and get from the EleutherAI LM Harness [47] package. ", "page_idx": 23}, {"type": "table", "img_path": "Jup0qZxH7U/tmp/23277158730f7f30894d37c6797a5d949e9b2fcaa643e9f12b0f6ec64b5f724b.jpg", "table_caption": ["Table 17: Standard Deviations for Zero-Shot Tasks with $50\\%$ Sparsity using LLaMA-V2 Family (Scaled by 100). "], "table_footnote": [], "page_idx": 23}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/9d0f8a2ef5ba46ceda03d923631ef2538f0f157a7c5c0f839de48419cb9dd090.jpg", "img_caption": ["Figure 9: The error bar in $50\\%$ sparisity experiment in LLAMA-V2 7B. "], "img_footnote": [], "page_idx": 23}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/9e0bd78a8843cef15d037dd5bf2cf436e5d55cf58b58905f1f721f36655b9946.jpg", "img_caption": ["Figure 10: The error bar in $50\\%$ sparisity experiment in LLAMA-V2 13B. "], "img_footnote": [], "page_idx": 24}, {"type": "image", "img_path": "Jup0qZxH7U/tmp/99b4b03e4e270d913b90293bc86f5a85776caf85be564e375556e0b535e96219.jpg", "img_caption": ["Figure 11: The error bar in $50\\%$ sparisity experiment in LLAMA-V2 70B. "], "img_footnote": [], "page_idx": 24}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: See abstract and introduction. See abstract and introduction. The main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope, providing a clear overview of the research objectives and findings. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 25}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: See Appendix A. Our paper discusses the limitations of the work performed by the authors, providing insights into potential weaknesses and areas for improvement. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 25}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 25}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: Our paper does not include theoretical results, and therefore does not provide assumptions or proofs. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 26}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: See Experiment. Our paper fully discloses all the information needed to reproduce the main experimental results, including detailed descriptions of the experimental setup, parameters, and methodologies used, which are essential for verifying the main claims and conclusions. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 26}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: Our paper provides open access to the data and code, along with sufficient instructions in the supplemental material to enable others to faithfully reproduce the main experimental results. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 27}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 27}, {"type": "text", "text": "Answer:[Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: See Experiment. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 27}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: See Appendix E.3. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 27}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 28}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: See Experiment. Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 28}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 28}, {"type": "text", "text": "Answer: [No] ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 28}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 28}, {"type": "text", "text": "Answer: [No] Justification: Only technical reports. ", "page_idx": 28}, {"type": "text", "text": "Guidelines: \u2022 The answer NA means that there is no societal impact of the work performed. \u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact. ", "page_idx": 28}, {"type": "text", "text": "\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 29}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 29}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 29}, {"type": "text", "text": "Justification: No high risk for misuse. Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 29}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 29}, {"type": "text", "text": "Answer: [No] ", "page_idx": 29}, {"type": "text", "text": "Justification: No. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets. ", "page_idx": 29}, {"type": "text", "text": "\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 29}, {"type": "text", "text": "", "page_idx": 30}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 30}, {"type": "text", "text": "Answer: [No] ", "page_idx": 30}, {"type": "text", "text": "Justification: No. ", "page_idx": 30}, {"type": "text", "text": "Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 30}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 30}, {"type": "text", "text": "Answer: [No] ", "page_idx": 30}, {"type": "text", "text": "Justification: NO Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 30}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 30}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 30}, {"type": "text", "text": "Justification: NO. ", "page_idx": 30}, {"type": "text", "text": "Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 30}]