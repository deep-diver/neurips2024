[{"figure_path": "0qb8KoPsej/tables/tables_26_1.jpg", "caption": "Algorithm 4: Augmenting path via dirty oracles", "description": "This algorithm takes a feasible solution X and two lists of false dirty queries F1 and F2 as inputs. It computes an augmenting path P in the exchange graph using the dirty oracles. If such a path does not exist, the algorithm returns X as optimal. If P is a valid augmenting path for both clean matroids, the solution is updated. Otherwise, it performs a binary search to identify an edge that violates the condition and adds the corresponding set to the lists of false queries to repeat the process. The algorithm is designed for partition matroids and ensures the feasibility of solutions by verifying augmenting paths using clean oracle calls.", "section": "4.3 Matroid intersection"}, {"figure_path": "0qb8KoPsej/tables/tables_27_1.jpg", "caption": "Table 3.1: Summary of our results for computing a maximum-weight basis. For every integer k \u2265 1, there is an algorithm which computes a maximum-weight basis of a matroid M using at most min{n \u2212 r + k + \u03b7A \u00b7 (k + 1) + \u03b7R \u00b7 (k + 1)[log2 rd], (1 + 1/k)n} oracle calls to M.", "description": "This table summarizes the performance guarantees of the algorithms presented in the paper for finding a maximum-weight basis of a matroid.  It shows the upper bound on the number of clean oracle calls required, expressed as a minimum of two functions, one that depends on the quality of a dirty oracle (represented by parameters \u03b7A and \u03b7R), and another that is robust to poor dirty oracle quality. The parameter k allows for tuning the algorithm's robustness. The table highlights a trade-off between consistency (good performance with a high-quality dirty oracle) and robustness (good performance regardless of the dirty oracle's quality).", "section": "3 Computing a maximum-weight basis"}]