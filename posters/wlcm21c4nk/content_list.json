[{"type": "text", "text": "Advancing Training Efficiency of Deep Spiking Neural Networks through Rate-based Backpropagation ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Chengting $\\mathbf{Y}\\mathbf{u}^{1,2}$ , Lei $\\mathbf{Liu^{2}}$ , Gaoang Wang2, Erping $\\mathbf{Li}^{1,2}$ , Aili Wang1,2\u2217 1 College of Information Science and Electronic Engineering, Zhejiang University 2 ZJU-UIUC Institute, Zhejiang University chengting.21@intl.zju.edu.cn, ailiwang@intl.zju.edu.cn ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Recent insights have revealed that rate-coding is a primary form of information representation captured by surrogate-gradient-based Backpropagation Through Time (BPTT) in training deep Spiking Neural Networks (SNNs). Motivated by these findings, we propose rate-based backpropagation, a training strategy specifically designed to exploit rate-based representations to reduce the complexity of BPTT. Our method minimizes reliance on detailed temporal derivatives by focusing on averaged dynamics, streamlining the computational graph to reduce memory and computational demands of SNNs training. We substantiate the rationality of the gradient approximation between BPTT and the proposed method through both theoretical analysis and empirical observations. Comprehensive experiments on CIFAR-10, CIFAR-100, ImageNet, and CIFAR10-DVS validate that our method achieves comparable performance to BPTT counterparts, and surpasses state-of-the-art efficient training techniques. By leveraging the inherent benefits of rate-coding, this work sets the stage for more scalable and efficient SNNs training within resource-constrained environments. Our code is available at https://github.com/Tab-ct/rate-based-backpropagation. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Spiking Neural Networks (SNNs) are conceptualized as biologically inspired neural systems, incorporating spiking neurons that closely mimic biological neural dynamics [46, 56]. Unlike Artificial Neural Networks (ANNs) based on continuous data representations, SNNs adopt spike-coding strategies to facilitate data transmission through discrete binary spike trains [52]. The intrinsic binary mechanism eliminates the need for the extensive multiply-accumulate operations typically required for synaptic connectivity [56], thereby enhancing energy efficiency and inference speed when deployed on neuromorphic hardware systems [1, 10, 54]. ", "page_idx": 0}, {"type": "text", "text": "The mainstream training methods for SNNs primarily utilize Backpropagation Through Time (BPTT) with surrogate gradients to overcome non-differentiable spike events, allowing SNNs to achieve comparable results with ANNs counterparts [51, 62, 74]. However, the direct training method necessitates the storage of all temporal activations for backward propagation across the network\u2019s depth and duration, leading to high training costs in terms of both computational time and memory demands [43, 86, 35, 77, 76, 47, 13]. To alleviate memory burdens, online training techniques have been developed that partially decouple the time dependencies of backward computations in BPTT [2, 4, 76, 48, 89]. However, online methods still require iterative computations based on the time dimension, increasing training time complexity as the number of timesteps grows. ", "page_idx": 0}, {"type": "text", "text": "Observed across most biological sensory systems, rate coding is a phenomenon where information is encoded through the rate of neuronal spikes, regardless of precise spike timing [52, 64, 23]. Recent explorations into spike representation have demonstrated the significant role of rate coding in enhancing the robustness of SNNs, further confirming its dominant position as the encoding representation in networks [38, 60, 18]. A significant observation has shown that BPTT-trained SNNs on static benchmark exhibit spike representation primarily following the rate-coding manner by highlighting strong similarities in representation between SNNs and their ANN counterparts [44]. A similar conclusion resonated with findings in fields of adversarial attacks, where recent methods significantly benefit from rate-based representations to enhance attack effectiveness [6, 29, 50]. ", "page_idx": 1}, {"type": "text", "text": "Motivated by rate coding\u2019s status as the most effective and predominant form of representation in SNNs, we posit that targeted training based on rate-based information could offer a high costeffectiveness ratio. We propose to decouple BPTT based on rate-coding approximation and simplify rate-based derivative computations to a single spatial backpropagation. We further provide theoretical analysis and empirical evidence to reveal the rationality of the gradient approximation between BPTT and the proposed method. Experimental results demonstrate that the proposed method achieves performance comparable to BPTT counterparts while significantly reducing memory and computational demands. Comparison results also indicate that the proposed method outperforms state-of-the-art efficient training methods on benchmarks. We expect our work to facilitate more efficient and scalable training for SNNs in resource-constrained environments. Our main contributions are as follows: ", "page_idx": 1}, {"type": "text", "text": "\u2022 We propose rate-based backpropagation that leverages rate-coded information for efficient training of deep SNNs. This method simplifies the computational graph by decoupling and compressing temporal dependencies, reducing training time and memory requirements. \u2022 Alongside the proposed method, we conduct theoretical analysis and empirical validation to demonstrate its effectiveness in approximating the gradient computations performed by BPTT-based SNNs training. \u2022 We conduct experiments on CIFAR-10, CIFAR-100, CIFAR10-DVS, and ImageNet, demonstrating that our proposed method matches the comparable performance of the BPTT counterpart and achieves state-of-the-art results among efficient SNN training methods. ", "page_idx": 1}, {"type": "text", "text": "2 Related Work ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Training Methods for Deep SNNs. Deep SNNs are trained primarily through two principal strategies: (1) conversion methods that establish links between SNNs and ANNs through equivalent closed-form mappings, and (2) direct training from scratch utilizing Backpropagation Through Time (BPTT). Conversion methods develop closed-form formulations for spike representations [39, 67, 72, 88, 73, 47], enabling seamless transitions of pre-trained ANNs into SNNs and facilitating comparable performance on large-scale datasets [8, 15, 27, 59, 57, 12, 42, 16]. However, the precision of these mappings under ultra-low latency conditions is not consistently reliable, often necessitating extensive time steps to accumulate spikes, which may compromise performance [7, 40, 31, 28, 34]. Direct training methods permit SNNs\u2019 performance with extremely low time steps by employing BPTT along with surrogate gradients to compute derivatives of discrete spiking events [51, 62, 74, 22, 81, 87, 85, 43, 66, 69, 13]. The strategy fosters innovation in SNN-specific modules, including optimized neurons, synapses, and network architectures, thereby enhancing performance [25, 21, 20, 17, 79, 83, 24, 80, 61]. Despite the advantages of low latency, direct training imposes substantial memory and time burdens to maintain the backward computational graph [43, 86, 35, 77, 76, 47, 13]. To mitigate training costs associated with direct methods, light training strategies have attracted considerable attention [49, 35, 86, 55, 70]. Several studies have explored the concept of decoupling the forward and backward passes in SNNs, which generally assumes that neuronal dynamics follow deterministic processes and aims to establish closed-form fixed-point equivalences between spike representations and corresponding rate-based activations [72, 73, 77, 47, 68]. Drawing on online training techniques from recurrent neural networks, several studies have adapted the principles of Real-time Recurrent Learning (RTRL) [71] to streamline the online training process for SNNs, aiming to decrease memory demands while preserving biologically plausible online properties of the networks [84, 2, 4, 82, 55, 76, 47, 89]. The online methodologies have proven effective in large-scale tasks [76, 47, 89]. Nevertheless, the significant time costs associated with training methods continue to challenge SNNs\u2019 broader application. ", "page_idx": 1}, {"type": "image", "img_path": "wlcm21C4nk/tmp/e7539ca32fae58ec205ed33558fb54dcf479a4871902263ff831bd9c69e7c217.jpg", "img_caption": ["(a) Standard BPTT Training (b) Online Training (c) Rate-based Backpropagation Figure 1: Illustration of the forward and backward procedures of different training methods. "], "img_footnote": [], "page_idx": 2}, {"type": "text", "text": "Spike Coding in SNNs. SNNs transmit information through spike trains [52], with encoding mechanisms classified into temporal and rate coding. Temporal coding is defined on firing times, employed by several direct trainings [49, 75, 88] and ANN-to-SNN conversions [26, 65], is noted for its low energy consumption due to sparse spiking. However, temporal coding schemes often require specialized neuron configurations and are generally effective only on simpler datasets [26, 65, 88]. Conversely, rate coding is widely adopted across both conversion [12, 15, 16, 27, 36, 57, 59, 78] and direct training approaches [73, 77, 47], consistently achieving superior performance and facilitating low-latency operations [77, 47]. Moreover, rate coding has demonstrated significant potential in enhancing the robustness of SNNs against adversarial attacks [38, 60, 18], with attack methods specifically designed to exploit rate-based representations showing promise in surpassing benchmarks for SNNs defense against attacks [6, 30, 50]. By employing representation similarity analysis to compare BPTT-trained SNNs with their ANN counterparts, Li et al. [44] has indicated that rate coding serves as the primary mode of information representation [44]. Inspired by previous findings, we consider that rate-coded information represents the most effective and predominant form of signal expression in SNNs, and the targeted training based on rate-based spike representations may offer a high cost-effectiveness ratio. Therefore, we propose to decouple BPTT towards rate-based backpropagation with the purpose of enhancing the efficiency of SNNs training. ", "page_idx": 2}, {"type": "text", "text": "3 Preliminaries ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "3.1 Spiking Neural Networks ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Inspired by the brain\u2019s ability to transmit information through discrete spikes, the Leaky Integrateand-Fire (LIF) model serves as the basic building block of SNNs due to its simplicity. For practical implementation of SNNs based on connected spiking neurons, the dynamics of the LIF model are typically rendered in a discrete iterative format: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\pmb{u}_{t}^{l}=\\lambda(\\pmb{u}_{t-1}^{l}-V_{\\mathrm{th}}\\pmb{s}_{t-1}^{l})+\\pmb{W}^{l}\\pmb{s}_{t}^{l-1},\\quad\\pmb{s}_{t}^{l}=\\pmb{H}(\\pmb{u}_{t}^{l}-V_{\\mathrm{th}})}\\end{array}\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $\\pmb{u}_{t}^{l}$ and $\\boldsymbol{s}_{t}^{l}$ represent the membrane potential and output spike of neurons in layer $l$ at time $t$ , respectively. $\\boldsymbol{W}^{l}$ denotes the linear synaptic connections between layers $l-1$ and $l$ , and $\\lambda$ acts as the decay term for the membrane potential. The Heaviside step function, $H(\\cdot)$ , determines spike generation, ensuring $\\boldsymbol{s}_{t}^{l}$ in binary forms. Noting that $H(\\cdot)$ is not differentiable, SNNs\u2019 direct training employs surrogate gradients to achieve error propagation by creating various pseudo-derivatives [51, 74, 19], following the basic idea of Straight-Through Estimator (STE) [3]. ", "page_idx": 2}, {"type": "text", "text": "3.2 Training SNNs with BPTT ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "The network outputs at each timestep $t$ are given by $\\pmb{o}_{t}=\\pmb{W}^{L}\\pmb{s}_{t}^{L}$ , where $W^{L}$ denotes the classifier\u2019s weights. Classification is based on the average of these outputs across all timesteps, computed as $\\begin{array}{r}{{y}_{\\mathrm{pred}}=\\frac{1}{T}\\sum_{t=1}^{T}{o_{t}}}\\end{array}$ . The loss function $\\mathcal{L}$ is defined over averaged outputs and is typically formulated as $\\begin{array}{r}{\\mathcal{L}\\,=\\,\\ell\\left(\\frac{1}{T}\\sum_{t=1}^{T}\\pmb{o}_{t},\\pmb{y}\\right)}\\end{array}$ , where $\\textit{\\textbf{y}}$ represents the true labels and $\\ell$ could be the cross-entropy function, as noted in various studies [87, 48, 19, 69]. BPTT unfolds the iterations described in Eq. (1), and propagates gradients back along the computational graphs across both temporal and spatial dimensions, as illustrated in Fig. 1a. The gradients of the membrane potential $\\textbf{\\em u}$ incorporate elements from both (spatial) spike generation and (temporal) potential accumulation, expressed as: ", "page_idx": 2}, {"type": "image", "img_path": "wlcm21C4nk/tmp/bd87f74fee858727fbf63e359697ed87f7be34192b128c8acc36c9a118313913.jpg", "img_caption": ["Figure 2: The implementation of rate-based backpropagation across layers. A rate-coding approximation is utilized for the forward procedure to connect average inputs with rate outputs, enabling fast rate-based error backpropagation throughout the training process. "], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{c}{\\displaystyle\\frac{\\partial\\mathcal{L}}{\\partial\\boldsymbol{u}_{t}^{l}}=\\frac{\\partial\\mathcal{L}}{\\partial s_{t}^{l}}\\frac{\\partial s_{t}^{l}}{\\partial\\boldsymbol{u}_{t}^{l}}+\\frac{\\partial\\mathcal{L}}{\\partial\\boldsymbol{u}_{t+1}^{l}}\\left(\\frac{\\partial\\boldsymbol{u}_{t+1}^{l}}{\\partial\\boldsymbol{u}_{t}^{l}}+\\frac{\\partial\\boldsymbol{u}_{t+1}^{l}}{\\partial s_{t}^{l}}\\frac{\\partial s_{t}^{l}}{\\partial\\boldsymbol{u}_{t}^{l}}\\right)}\\\\ {\\displaystyle=\\frac{\\partial\\mathcal{L}}{\\partial s_{t}^{l}}\\frac{\\partial s_{t}^{l}}{\\partial\\boldsymbol{u}_{t}^{l}}+\\sum_{\\tau>t}\\frac{\\partial\\mathcal{L}}{\\partial s_{\\tau}^{l}}\\frac{\\partial s_{\\tau}^{l}}{\\partial\\boldsymbol{u}_{\\tau}^{l}}\\prod_{i=\\tau-1}^{t}\\left(\\frac{\\partial\\boldsymbol{u}_{i+1}^{l}}{\\partial\\boldsymbol{u}_{i}^{l}}+\\frac{\\partial\\boldsymbol{u}_{i+1}^{l}}{\\partial s_{i}^{l}}\\frac{\\partial s_{i}^{l}}{\\partial\\boldsymbol{u}_{i}^{l}}\\right)}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Subsequently, the weight update for layer $l$ is determined among all timesteps $T$ , i.e. $\\nabla_{\\mathbf{W}^{l}}\\mathcal{L}=$ $\\begin{array}{r}{\\sum_{t=1}^{T}\\frac{\\partial\\mathcal{L}}{\\partial\\mathbf{u}_{t}^{l}}\\frac{\\partial\\mathbf{\\dot{u}}_{t}^{l}}{\\partial{W}^{l}}=\\sum_{t=1}^{T}\\frac{\\partial\\bar{\\mathcal{L}}}{\\partial\\mathbf{u}_{t}^{l}}s_{t}^{l-1}{^{\\top}}}\\end{array}$ , and the gradient is further propagated to previous layers through the linear part by $\\begin{array}{r}{\\frac{\\partial\\mathcal{L}}{\\partial\\pmb{s}_{t}^{l-1}}=\\frac{\\partial\\mathcal{L}}{\\partial\\pmb{u}_{t}^{l}}\\pmb{W}^{l}}\\end{array}$ . ", "page_idx": 3}, {"type": "text", "text": "4 Rate-based Backpropagation for SNNs Training ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "4.1 Derivation of Rate-based Backpropagation ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Incorporating rate-based representation. Under the rate coding assumption, essential information is effectively encapsulated within the spike frequency averages. We start by defining the rate-based representation as an approximation for the forward procedure in SNNs, as shown in Figure 2. The average firing rate at each layer $l$ , denoted as $r^{l}$ , is calculated as the expected value of the spike outputs $\\boldsymbol{s}_{t}^{l}$ over the temporal dimension $\\begin{array}{r}{\\pmb{r}^{l}=\\mathbb{E}[\\pmb{s}_{t}^{l}]=\\frac{1}{T}\\sum_{t\\leq T}\\pmb{s}_{t}^{l}}\\end{array}$ . ", "page_idx": 3}, {"type": "text", "text": "Considering the forward propagation through linear operators with weights $\\boldsymbol{W}^{l}$ that compute the inputs as $\\pmb{I}_{t}^{l}=\\pmb{W}^{l}\\pmb{s}_{t}^{l-1}$ , instead of transmitting distinct spikes over multiple timesteps, we transform the average rates into average inputs $c^{l}$ in the approximate representation: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\boldsymbol{c}^{l}=\\mathbb{E}[I_{t}^{l}]=\\mathbb{E}[W^{l}\\boldsymbol{s}_{t}^{l-1}]=W^{l}\\mathbb{E}[\\boldsymbol{s}_{t}^{l-1}]=W^{l}\\boldsymbol{r}^{l-1}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Supposing input representations are well captured within $c^{l}$ , we approximate the exact inputs with the average inputs for all timesteps, $I_{t}^{l}\\approx c^{l}$ , and follow the neuronal dynamics in Eq. (1) to derive the output rates ${\\pmb r}^{l}=\\mathbb{E}[{\\pmb s}_{t}^{l}]$ . With the rate-coding approximation in place, we can derive the gradients with respect to the weights in the linear part based on the error propagated through the average inputs: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\left(\\nabla_{W^{l}}{\\mathcal{L}}\\right)_{\\mathrm{rate}}\\equiv{\\frac{\\partial{\\mathcal{L}}}{\\partial c^{l}}}{\\frac{\\partial c^{l}}{\\partial W^{l}}}={\\frac{\\partial{\\mathcal{L}}}{\\partial c^{l}}}{r^{l-1}}^{\\top}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Handling temporal dependency during backward. For back-propagating the error, the linear parts operate smoothly as $\\frac{\\bar{\\partial\\mathbf{c}^{l}}}{\\partial\\mathbf{r}^{l-1}}=\\bar{\\mathbf{W}}^{l^{\\top}}$ . The next step is to define the correlation between the averages of inputs and output spike rates, $\\frac{\\partial\\mathbf{r}^{l}}{\\partial\\mathbf{c}^{l}}$ , within the neurons of layer $l$ . Since there is no deterministic relationship between $r^{l}$ and $c^{l}$ , we first look into the influence of separated inputs following the exact ", "page_idx": 3}, {"type": "text", "text": "gradients in Eq. (2): ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\frac{\\partial s_{\\tau}^{l}}{\\partial I_{t}^{l}}=\\frac{\\partial s_{\\tau}^{l}}{\\partial u_{t}^{l}}=\\left\\{\\begin{array}{l l}{\\frac{\\partial s_{\\tau}^{l}}{\\partial u_{\\tau}^{l}}\\prod_{i=\\tau-1}^{t}\\left(\\frac{\\partial u_{i+1}^{l}}{\\partial u_{i}^{l}}+\\frac{\\partial u_{i+1}^{l}}{\\partial s_{i}^{l}}\\frac{\\partial s_{i}^{l}}{\\partial u_{i}^{l}}\\right)}&{\\mathrm{if}\\ \\tau\\geq t}\\\\ {\\frac{\\partial s_{t}^{l}}{\\partial u_{t}^{l}}}&{\\mathrm{if}\\ \\tau=t}\\\\ {0}&{\\mathrm{if}\\ \\tau<t}\\end{array}\\right.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "By accumulating the intricate dynamics over time, we can derive the gradients of the overall spikes with respect to the inputs at time $t$ : ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\pmb{\\mathscr{H}}_{t}^{l}=\\sum_{\\tau}\\frac{\\partial s_{\\tau}^{l}}{\\partial I_{t}^{l}}=\\left(\\frac{\\partial s_{t}^{l}}{\\partial\\pmb{u}_{t}^{l}}+\\sum_{\\tau>t}\\frac{\\partial s_{\\tau}^{l}}{\\partial\\pmb{u}_{\\tau}^{l}}\\prod_{i=\\tau-1}^{t}\\left(\\frac{\\partial\\pmb{u}_{i+1}^{l}}{\\partial\\pmb{u}_{i}^{l}}+\\frac{\\partial\\pmb{u}_{i+1}^{l}}{\\partial\\pmb{s}_{i}^{l}}\\frac{\\partial\\pmb{s}_{i}^{l}}{\\partial\\pmb{u}_{i}^{l}}\\right)\\right)\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Here, with rate-coding approximating $I_{t}^{l}\\approx c^{l}$ , we follow the idea of Straight-Through Estimator [3] and define the backward gradients as $\\begin{array}{r}{\\frac{\\partial I_{t}^{l}}{\\partial\\pmb{c}^{l}}=I d}\\end{array}$ , with $I d$ representing the identity matrix. Then, we can derive the surrogate gradients of neural dynamics through the mean estimator: ", "page_idx": 4}, {"type": "equation", "text": "$$\n(\\frac{\\partial r^{l}}{\\partial c^{l}})_{\\mathrm{rate}}\\equiv\\sum_{\\tau}\\left(\\frac{\\partial(\\mathbb{E}\\left[s_{t}^{l}\\right])}{\\partial I_{\\tau}^{l}}\\frac{\\partial I_{\\tau}^{l}}{\\partial c^{l}}\\right)=\\frac{1}{T}\\sum_{t}\\sum_{\\tau}\\left(\\frac{\\partial s_{t}^{l}}{\\partial I_{\\tau}^{l}}\\right)=\\mathbb{E}\\left[\\pmb{\\mathscr{H}}_{t}^{l}\\right]\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "With the compressed gradients of neuron parts, the error backpropagation of the rate-based representation is then determined, dependent only on the spatial domain: ", "page_idx": 4}, {"type": "equation", "text": "$$\n(\\frac{\\partial\\mathcal{L}}{\\partial c^{l}})_{\\mathrm{rate}}=\\left(\\frac{\\partial\\mathcal{L}}{\\partial c^{L}}\\prod_{i=L-1}^{l}\\left(\\frac{\\partial c^{i+1}}{\\partial r^{i}}(\\frac{\\partial r^{i}}{\\partial c^{i}})_{\\mathrm{rate}}\\right)\\right)=\\left(\\frac{\\partial\\mathcal{L}}{\\partial c^{L}}\\prod_{i=L-1}^{l}\\left({W^{i}}^{\\top}\\mathbb{E}\\left[\\varkappa_{t}^{l}\\right]\\right)\\right)\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where we define the objective $\\begin{array}{r}{\\mathcal{L}=\\frac{1}{T}\\ell(\\mathbb{E}[\\pmb{o}_{t}],y)=\\frac{1}{T}\\ell(\\pmb{c}^{L},\\pmb{y})}\\end{array}$ . Note that the rate-based representation, while instrumental in constructing the backward computational graph for learning, does not necessitate actual implementation during the forward pass. ", "page_idx": 4}, {"type": "text", "text": "4.2 Rate-based Gradient Computation for Memory and Time Efficiency ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "As previously discussed, rate-based backpropagation can be executed on spatial-dimension computation by decoupling BPTT. We now show how rate-based backpropagation can be efficiently implemented within the overall learning framework. As depicted in Figure 2b, online schemes apply eligibility traces $e_{t}^{l}$ locally within neurons to store historical information, effectively blocking backward access to past gradients. The gradient computation is optimized by compressing all past temporal dependencies into $e_{t}^{l}$ . Similarly, we utilize iterative variables $\\{g_{t}^{l}\\}_{l\\leq L}$ and $\\{e_{t}^{l}\\}_{l\\le L}$ as the accumulated post- and pre-synaptic dependencies, synchronously recorded during the neural dynamics computations. The iteration of $\\{e_{t}^{l}\\}_{l\\leq L}$ dynamically records the firing rates, where $\\pmb{e}_{t}^{l}=\\frac{1}{t}((t-1)\\pmb{e}_{t-1}^{l}+\\pmb{s}_{t}^{l})$ , and it is straightforward to derive ${\\boldsymbol{r}}^{l}=e_{T}^{l}$ . Considering the surrogate gradients of neural dynamics, $\\frac{\\partial\\mathbf{r}^{l}}{\\partial\\mathbf{c}^{l}}$ , to estimate future-dependent terms outlined in Eq. 5, we first construct equivalent eligibility trace forms, $\\{\\rho_{t}^{l}\\}_{t\\le T}$ , with iterative expressions starting at $\\rho_{1}^{l}=1$ : ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\rho_{t}^{l}=1+\\rho_{t-1}^{l}\\left(\\frac{\\partial u_{t}^{l}}{\\partial u_{t-1}^{l}}+\\frac{\\partial u_{t}^{l}}{\\partial s_{t-1}^{l}}\\frac{\\partial s_{t-1}^{l}}{\\partial u_{t-1}^{l}}\\right)=1+\\sum_{\\tau<t}\\prod_{i=t-1}^{\\tau}\\left(\\frac{\\partial u_{i+1}^{l}}{\\partial u_{i}^{l}}+\\frac{\\partial u_{i+1}^{l}}{\\partial s_{i}^{l}}\\frac{\\partial s_{i}^{l}}{\\partial u_{i}^{l}}\\right)\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "with the equivalence that: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\sum_{t}\\varkappa_{t}^{l}=\\sum_{t}\\left(\\frac{\\partial s_{t}^{l}}{\\partial u_{t}^{l}}+\\sum_{\\tau>t}\\left(\\frac{\\partial s_{\\tau}^{l}}{\\partial u_{\\tau}^{l}}\\prod_{i=\\tau-1}^{t}\\left(\\frac{\\partial u_{i+1}^{l}}{\\partial u_{i}^{l}}+\\frac{\\partial u_{i+1}^{l}}{\\partial s_{i}^{l}}\\frac{\\partial s_{i}^{l}}{\\partial u_{i}^{l}}\\right)\\right)\\right)}\\\\ &{\\qquad=\\sum_{t}\\left(\\frac{\\partial s_{t}^{l}}{\\partial u_{t}^{l}}\\left(1+\\sum_{\\tau<t}\\prod_{i=t-1}^{\\tau}\\left(\\frac{\\partial u_{i+1}^{l}}{\\partial u_{i}^{l}}+\\frac{\\partial u_{i+1}^{l}}{\\partial s_{i}^{l}}\\frac{\\partial s_{i}^{l}}{\\partial u_{i}^{l}}\\right)\\right)\\right)=\\sum_{t}\\left(\\frac{\\partial s_{t}^{l}}{\\partial u_{t}^{l}}\\rho_{t}^{l}\\right)}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "By iteratively accumulating $\\begin{array}{r}{\\pmb{g}_{t}^{l}=\\frac{1}{t}((t-1)\\pmb{g}_{t-1}^{l}+\\frac{\\partial\\pmb{s}_{t}^{l}}{\\partial\\pmb{u}_{t}^{l}}\\pmb{\\rho}_{t})}\\end{array}$ , we obtain $\\begin{array}{r}{\\pmb{g}_{T}^{l}=\\mathbb{E}[\\frac{\\partial\\pmb{s}_{t}^{l}}{\\partial\\pmb{u}_{t}^{l}}\\pmb{\\rho}_{t}^{l}]=\\mathbb{E}[\\pmb{\\mathscr{z}}_{t}^{l}]}\\end{array}$ . Now, we have collapsed the required computation graph through the iterative calculation to complexity $\\mathcal{O}(L)$ . The rate-based propagation is then conducted in one go, relying only on the intermediate variables $e_{T}^{l},g_{T}^{l}$ , and $\\boldsymbol{W}^{l}$ , within one-time spatial-dimension backpropagation. ", "page_idx": 4}, {"type": "text", "text": "4.3 Connecting Error Backward of Rate-based Backpropagation to BPTT ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Having derived the fundamental form of rate-based backpropagation through the rate-encoding approximation, we now explore potential divergences with BPTT during error propagation. Although rate-based backpropagation is derived from the approximated forward pass, it still provides valid gradients for the original network parameters. ", "page_idx": 5}, {"type": "text", "text": "The primary divergence between rate-back and BPTT in backward computation primarily arises from the assumptions regarding the approximation of rate-based representation through mean estimators, as outlined in Eq.(3) and Eq.(6). The rate-coding motivations establish equivalence with BPTT by assuming temporal components are independent, which is formalized in Theorem 1. ", "page_idx": 5}, {"type": "text", "text": "Theorem 1. Given $\\begin{array}{r}{\\pmb{\\delta}_{t}^{(s^{l})}=\\frac{\\partial\\mathcal{L}}{\\partial\\mathbf{s}_{t}^{l}}}\\end{array}$ that refers to gradients computed following lthe chain rule olf BPTT in Eq. (2), and $\\begin{array}{r}{\\kappa_{t}^{l}=\\sum_{\\tau}\\frac{\\partial\\pmb{s}_{t}^{l}}{\\partial\\pmb{I}_{\\tau}^{l}}}\\end{array}$ (where $\\mathbb{E}\\left[\\pmb{\\kappa}_{t}^{l}\\right]=\\mathbb{E}\\left[\\pmb{\\varkappa}_{t}^{l}\\right]$ in Eq.(6-7)) , if E \u03b4t(s)\u03balt = E \u03b4t(s) E \u03balt holds for $\\forall l$ , we have $\\begin{array}{r}{\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\right]=\\left(\\frac{\\partial\\mathcal{L}}{\\partial r^{l}}\\right)_{r a t e}}\\end{array}$ . Furthermore, given $\\begin{array}{r}{\\delta_{t}^{(\\bar{I^{\\bar{\\imath}}})}=\\frac{\\partial\\bar{\\mathcal{L}^{\\prime}}}{\\partial I_{t}^{\\bar{\\imath}}},\\,i f\\mathbb{E}\\left[\\bar{\\delta}_{t}^{(I^{l})}\\bar{s}_{t}^{l-1}\\right]=}\\end{array}$ $\\mathbb{E}\\left[\\pmb{\\delta}_{t}^{(\\pmb{I}^{l})}\\right]\\mathbb{E}[\\pmb{\\mathscr{s}}_{t}^{l-1}]f o r\\,\\forall l$ , we then obtain $\\begin{array}{r}{\\bigl(\\nabla_{W^{l}}\\mathcal{L}\\bigr)_{r a t e}=\\frac{1}{T}\\bigl(\\nabla_{W^{l}}\\mathcal{L}\\bigr)}\\end{array}$ . Here, $\\begin{array}{r}{\\mathbb{E}\\left[\\pmb{x}_{t}\\right]=\\frac{1}{T}\\sum_{t}\\pmb{x}_{t}}\\end{array}$ refers the mean value of tensor $\\pmb{x}_{t}$ over temporal dimension $T$ . ", "page_idx": 5}, {"type": "text", "text": "To confirm our hypotheses, we carried out empirical experiments, the results of which are detailed in the experimental section. Our empirical findings support the core assumptions outlined in Theorem 1, demonstrating the relative independence between \u03b4t(s) and $\\kappa_{t}^{l}$ (Figure 3a,b), as well as between $\\delta_{t}^{(I^{l})}$ and $\\boldsymbol{s}_{t}^{l}$ (Figure 3c). For minor discrepancies that may arise, we introduced Theorem 2, which tolerates small deviations and confirms that approximation errors in rate-based backpropagation can be effectively bounded, ensuring the robustness of training under practical conditions. ", "page_idx": 5}, {"type": "text", "text": "Theorem 2. For gradients $\\begin{array}{r}{\\delta_{t}^{(s^{l})}=\\frac{\\partial\\mathcal{L}}{\\partial s_{t}^{l}}}\\end{array}$ and $\\begin{array}{r}{\\pmb{\\kappa}_{t}^{l}=\\sum_{\\tau}\\frac{\\partial\\pmb{s}_{t}^{l}}{\\partial\\pmb{I}_{\\tau}^{l}}}\\end{array}$ , given the approximation error bound \u03f5 > 0 s.t. $\\left\\|\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\kappa_{t}^{l}\\right]-\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\right]\\mathbb{E}\\left[\\kappa_{t}^{l}\\right]\\right\\|\\leq\\epsilon(1+\\left\\|\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\right]\\right\\|)f o r\\,\\forall l.$ . Denote the stacked tensor $\\pmb{I}^{l}=[I_{1}^{l},...,I_{T}^{l}]$ and $\\pmb{\\mathscr{s}}^{l}=[\\pmb{\\mathscr{s}}_{1}^{l},...,\\pmb{\\mathscr{s}}_{T}^{l}]$ . Assuming the backward procedure follows non-expansivity s.t. $\\begin{array}{r}{\\frac{\\partial I^{l+1}}{\\partial I^{l}}=W^{l+1^{\\top}}\\frac{\\partial{\\pmb\\mathscr{s}}^{l}}{\\partial I^{l}}}\\end{array}$ is $^{\\,l}$ -lipschitz continuous without loss of generality and the biases are bounded uniformly by $B_{z}$ , i.e. $\\begin{array}{r}{\\left\\|x\\frac{\\partial{\\pmb I}^{l+1}}{\\partial{\\pmb I}^{l}}-\\hat{\\pmb x}\\frac{\\partial{\\pmb I}^{l+1}}{\\partial{\\pmb I}^{l}}\\right\\|\\leq\\left\\|\\pmb x-\\hat{\\pmb x}\\right\\|}\\end{array}$ for $\\forall\\pmb{x},\\hat{\\pmb{x}}.$ . Define $\\begin{array}{r}{\\delta_{r a t e}^{l}\\,=\\,\\left(\\frac{\\partial\\mathcal{L}}{\\partial c^{l}}\\right)_{r a t e}}\\end{array}$ as the error propagated through Eq. (7), and $\\begin{array}{r}{\\pmb{\\delta}_{t}^{(\\pmb{I}^{l})}=\\frac{\\partial\\mathcal{L}}{\\partial\\pmb{I}_{t}^{l}}}\\end{array}$ as the error propagated through BPTT, with $\\delta_{r a t e}^{L}=\\mathbb{E}[\\delta_{t}^{(I^{L})}]$ . We have the gradient difference bounded by $\\left\\|\\delta_{r a t e}^{L-k}-\\mathbb{E}[\\delta_{t}^{(I^{L-k})}]\\right\\|=\\mathcal{O}(k^{2}\\epsilon).$ . ", "page_idx": 5}, {"type": "text", "text": "Theorem 2 elucidates the stability of rate-based backpropagation relative to BPTT, showing that the proposed method can provide a bound on the overall objective solution. The bounded error could further be interpreted as a form of randomness suitable for stochastic optimization. The similarity measurement of the descent directions between the two methods provides empirical evidence for the effectiveness of the proposed method (Figure 3d). Detailed proof is provided in Appendix A. ", "page_idx": 5}, {"type": "text", "text": "4.4 Implementation Details ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "For implementations of direct training, two distinct training modes are recognized: (multi-step) activation-based and (single-step) time-based [19], differing fundamentally in handling the timesteps loop. We implement our rate-based propagation in both modes: rate $M$ denotes the multi-step training mode where $T$ loops are embedded within layers, and rate $S$ refers to the single-step training mode with $T$ loops outside the layers. A detailed discussion of training modes is included in Appendix B. ", "page_idx": 5}, {"type": "text", "text": "Another aspect of our implementation concerns handling batch normalization (BN), especially given its critical role in BPTT, which adjusts mean and variance statistics during the forward pass. The application of BN varies depending on the training mode. In the multi-step mode, BN beneftis from access to information across all timesteps and can normalize based on statistics aggregated over temporal dimensions. We employed tdBN [87] in rate $M$ since it has been widely adopted in direct training on various benchmarks. In contrast, the single-step mode limits BN to current timestep inputs, necessitating normalization across spatial dimensions only. In line with online schemes, SLTT [48] demonstrates the feasibility of implementing spatial BN iteratively across timesteps, an approach we adopt for rate $_S$ . Further details on the BN implementation are provided in Appendix B. ", "page_idx": 5}, {"type": "image", "img_path": "wlcm21C4nk/tmp/6f1fa2793677557e357461503ea3aafd29c1551524f32ae8e790dfc3ee7f391f.jpg", "img_caption": ["Figure 3: Empirical measurements conducted on the training procedure of BPTT. The experiments are carried out on the CIFAR-100 dataset using ResNet-18. Each subplot is labeled according to the naming convention \u201cA{test#}-T{timesteps#}-{target}-L{layer#}B{block#}N{LIF#}/C{conv#}.\u201d "], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "5 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "In this section, we conduct experiments on CIFAR-10 [37], CIFAR-100 [37], ImageNet [11], and CIFAR10-DVS [41] to evaluate the proposed training method. We implement SNNs training on the Pytorch [53] and SpikingJelly [19] frameworks. We set $V_{t h}\\,=\\,1$ , $\\lambda\\,=\\,0.2$ , and employ the sigmoid-based surrogate function [19] for LIF neurons. Detailed setups are provided in Appendix C. ", "page_idx": 6}, {"type": "text", "text": "5.1 Empirical Validation ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Empirical experiments are conducted to support the preconditions of theorems discussed in Section 4.3. These preconditions assert the independence of paired variables across the temporal dimension: $\\mathbb{E}\\left[\\bar{\\pmb{\\delta}}_{t}^{(\\bar{\\mathbf{s}}^{l})}\\pmb{\\kappa}_{t}^{l}\\right]=\\mathbb{E}\\left[\\bar{\\pmb{\\delta}}_{t}^{(s^{l})}\\right]\\mathbb{E}\\left[\\pmb{\\kappa}_{t}^{l}\\right]$ (A1) and $\\mathbb{E}\\left[\\delta_{t}^{(I^{\\bar{l}})}s_{t}^{l-1}\\right]=\\mathbb{E}\\left[\\delta_{t}^{(I^{l})}\\right]\\mathbb{E}[s_{t}^{l-1}]$ (A2). To explore these relationships, we conducted experiments training ResNet-18 on CIFAR-100 using BPTT. Cosine similarity measures were employed to compare the empirical expectation products, $c o s\\langle\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\kappa_{t}^{l}\\right],\\mathbb{E}\\left[\\delta_{t}^{(\\bar{s}^{l})}\\right]\\mathbb{E}\\left[\\kappa_{t}^{l}\\right]\\rangle$ as shown in Figure 3a, where values approaching 1 indicate a high degree of alignment, suggesting that the variables\u2019 directions are similar. Additionally, the correlation coefficient, $\\rho$ was measured to further assess the independence of these variables $\\rho=\\frac{\\mathcal{C}\\mathcal{O}\\mathcal{V}(\\kappa_{t},\\delta_{t}^{(s^{l})})}{\\sqrt{\\mathrm{var}(\\kappa_{t})\\mathrm{var}(\\delta_{t}^{(s^{l})})}}$ where $\\mathcal{C O V}(\\kappa_{t},\\delta_{t}^{(s^{l})})=\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\kappa_{t}^{l}\\right]-\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\right]\\mathbb{E}\\left[\\kappa_{t}^{l}\\right]$ It is clear that $\\rho$ equals the cosine distance between the variables after centering by their means, $\\rho=c o s\\langle\\pmb{\\delta}_{t}^{(s^{l})}-\\mathbb{E}[\\pmb{\\delta}_{t}^{(s^{l})}],\\pmb{\\kappa}_{t}^{l}-\\mathbb{E}\\left[\\pmb{\\kappa}_{t}^{l}\\right]\\rangle$ . Results, shown in Figure 3b, reveal that the correlation coefficients are constrained within a very small range, typically around the magnitude of $\\sim10^{-5}$ , supporting the hypothesis of their relative independence. We also conducted cosine similarity measurements to validate the assumption $\\mathbb{E}\\left[\\delta_{t}^{(I^{l})}\\dot{\\mathbf{s}}_{t}^{l-1}\\right]=\\mathbb{E}\\left[\\delta_{t}^{(I^{l})}\\right]\\mathbb{E}[\\mathbf{s}_{t}^{l-1}]$ , as shown in Figure 3c. Additionally, we implement both BPTT and the proposed method simultaneously within the same training iteration, allowing direct observation of the gradient descent directions. The relation $\\begin{array}{r}{\\bigl(\\nabla_{W^{l}}\\mathcal{L}\\bigr)_{\\mathrm{rate}}\\stackrel{\\smile}{=}\\frac1T\\bigl(\\nabla_{W^{l}}\\mathcal{L}\\bigr)}\\end{array}$ (A3) was visualized in Figure 3d, which revealed that the convergence directions for rate-based backpropagation and BPTT are closely aligned. Remarkably, all tests consistently demonstrate that configurations with $\\mathrm{T}{=}6$ better adhere to the theoretical assumptions than $\\mathrm{T}{=}4$ , suggesting that the proposed method can more closely mimic BPTT computations as the timestep increases. This observation also highlights the intrinsic link between our method and rate-coding, suggesting that a larger temporal window may facilitate more stable manifestations of rate-coding. ", "page_idx": 6}, {"type": "text", "text": "5.2 Comparison with the State-of-the-Art ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We present comparison results in Table 1. In single-step mode, rate $_S$ offers fair comparisons with online schemes, while rate $^M$ in multi-step mode competes fairly with other methods employing one-step backpropagation. Unlike online methods such as OTTT[76], SLTT[48], and OS[89], which necessitate spatial backpropagation at every timestep, our proposed method conducts this process only once at the final timestep. Although methods of DSR [47] and SSF[68] delay decoupled backpropagation until the final timestep, allowing for parallel processing across all timesteps to enhance computational speed, they still require each timestep\u2019s backpropagation to be managed independently within the backward computation graph. In contrast, our method fully compresses the temporal dimension, achieving one-step time-independent spatial backpropagation. As shown in Table 1, our method yields comparable performance with BPTT counterparts on benchmarks, showcasing promising capabilities compared to other efficient training methods. While our theoretical ", "page_idx": 6}, {"type": "text", "text": "Table 1: Performance on CIFAR-10, CIFAR-100, ImageNet, and CIFAR10-DVS. Results are averaged over three runs of experiments, except for single crop evaluations on ImageNet. Models marked with $(^{*})$ employ scaled weight standardization, adapting to normalizer-free architectures. ", "page_idx": 7}, {"type": "table", "img_path": "wlcm21C4nk/tmp/08d1fa369f8200e20caa8c1122511c318383215ac2a62f679e59c3497f6a761b.jpg", "table_caption": [], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "analysis and motivation primarily adhere to rate-coding approximations, the performance on static datasets aligns with expectations. The results on the dynamic dataset CIFAR10-DVS also achieve comparable levels, implying a significant presence of rate-based representation within CIFAR10-DVS. More results regarding the performance comparisons between the proposed method and BPTT across various architectures and settings have been detailed in Appendix D. ", "page_idx": 7}, {"type": "text", "text": "5.3 Impact of Time Expansion ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "we assess the impact of extending timesteps on both accuracy and training efficiency. Figure 4a validates that our method capably manages increased timesteps, thereby confirming the scalability of the proposed method for larger $T$ values. Figure 4b displays the computational and memory expenses incurred during the backward phase, which, as anticipated, do not escalate with increasing $T$ . ", "page_idx": 7}, {"type": "image", "img_path": "wlcm21C4nk/tmp/4563e03ad6525366f5dd2a7960222bc0c30977671df1b94edddc2ea6ad85c828.jpg", "img_caption": ["(a) Comparison of Classification Performance (b) Comparison of Training Costs Figure 4: Results of BPTT and rate $M$ across various timesteps. "], "img_footnote": [], "page_idx": 8}, {"type": "table", "img_path": "wlcm21C4nk/tmp/3d784096cb2c7d5c88b903da401df9a31b877b6d32021e637b1aa3cd0c7009b0.jpg", "table_caption": ["Table 2: Performance w/o and w/ temporal shuffle for models trained by rate $M$ "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "5.4 Analysis of Rate Statistics ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "Our method, derived from the principles of rate-based representation, necessitates examining the impact of rate coding on model behavior. Following an insightful approach from [6], we assess the robustness of our models by shuffilng the temporal order of spike sequences while maintaining their rate consistency. This experiment, designed to disrupt temporal information without changing the firing rate, was applied to models trained using rate-based backpropagation. During inference on the test dataset, we introduced perturbations by randomly shuffling the temporal dimensions of input tensors across all neurons, as reported in Table 2. Notably, models mostly resisted these changes to some degree, which suggests that they follow the basic rules of rate coding, where the reordering of timesteps does not significantly impact overall accuracy. Furthermore, we tracked the average firing rates across each layer over time, presented in Figure 5. As layers increase, the average spike rates per layer are closely aligned with the temporal mean, validating the idea of rate-coding approximation. Those two experiments support the notion that rate-based backpropagation proficiently captures rate-based representations during training. ", "page_idx": 8}, {"type": "image", "img_path": "wlcm21C4nk/tmp/562966408a79b9d9c4e1f1b4169390fcbf4eb99de4b9d5a85f9db9ce6c60dcf0.jpg", "img_caption": ["(a) Rate Statistics of SEW-Resnet-34 on Imagenet  (b) Rate Statistics of Resnet-18 on CIFAR-100 Figure 5: Firing rates statistics for models trained by rate $M$ . "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "6 Conclusion ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "In this work, we propose rate-based backpropagation, utilizing rate-coding approximation to streamline the gradient computational graph, significantly reducing both memory usage and training time. Through theoretical analyses and empirical validation, we show the method\u2019s feasibility in approximating the optimization direction of BPTT. Experimental results across benchmarks reveal that our method achieves comparable performance with BPTT and surpasses other state-of-the-art efficient training methods. We expect our work to pave the way for more scalable and resource-efficient training of SNNs. ", "page_idx": 8}, {"type": "text", "text": "", "page_idx": 9}, {"type": "text", "text": "Acknowledgment ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "This work was supported by the National Natural Science Foundation of China (Grant No. 62304203), the Natural Science Foundation of Zhejiang Province, China (Grant No. LQ22F010011), and the ZJU-UIUC Center for Heterogeneously Integrated Brain-Inspired Computing. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Filipp Akopyan, Jun Sawada, Andrew Cassidy, Rodrigo Alvarez-Icaza, John Arthur, Paul Merolla, Nabil Imam, Yutaka Nakamura, Pallab Datta, Gi-Joon Nam, et al. Truenorth: Design and tool flow of a $65\\:\\mathrm{mw}\\;1$ million neuron programmable neurosynaptic chip. IEEE transactions on computer-aided design of integrated circuits and systems, 34(10):1537\u20131557, 2015.   \n[2] Guillaume Bellec, Franz Scherr, Anand Subramoney, Elias Hajek, Darjan Salaj, Robert Legenstein, and Wolfgang Maass. A solution to the learning dilemma for recurrent networks of spiking neurons. Nature communications, 11(1):3625, 2020.   \n[3] Yoshua Bengio, Nicholas L\u00e9onard, and Aaron Courville. Estimating or propagating gradients through stochastic neurons for conditional computation. arXiv preprint arXiv:1308.3432, 2013.   \n[4] Thomas Bohnstingl, Stanis\u0142aw Woz\u00b4niak, Angeliki Pantazi, and Evangelos Eleftheriou. Online spatio-temporal learning in deep neural networks. IEEE Transactions on Neural Networks and Learning Systems, 2022.   \n[5] Andy Brock, Soham De, Samuel L Smith, and Karen Simonyan. High-performance large-scale image recognition without normalization. In International Conference on Machine Learning, pages 1059\u20131071. PMLR, 2021.   \n[6] Tong Bu, Jianhao Ding, Zecheng Hao, and Zhaofei Yu. Rate gradient approximation attack threats deep spiking neural networks. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 7896\u20137906, 2023.   \n[7] Tong Bu, Wei Fang, Jianhao Ding, PengLin Dai, Zhaofei Yu, and Tiejun Huang. Optimal ann-snn conversion for high-accuracy and ultra-low-latency spiking neural networks. arXiv preprint arXiv:2303.04347, 2023.   \n[8] Yongqiang Cao, Yang Chen, and Deepak Khosla. Spiking deep convolutional neural networks for energy-efficient object recognition. International Journal of Computer Vision, 113:54\u201366, 2015.   \n[9] Ekin D Cubuk, Barret Zoph, Dandelion Mane, Vijay Vasudevan, and Quoc V Le. Autoaugment: Learning augmentation strategies from data. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 113\u2013123, 2019.   \n[10] Mike Davies, Narayan Srinivasa, Tsung-Han Lin, Gautham Chinya, Yongqiang Cao, Sri Harsha Choday, Georgios Dimou, Prasad Joshi, Nabil Imam, Shweta Jain, et al. Loihi: A neuromorphic manycore processor with on-chip learning. Ieee Micro, 38(1):82\u201399, 2018.   \n[11] Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. Imagenet: A largescale hierarchical image database. In 2009 IEEE conference on computer vision and pattern recognition, pages 248\u2013255. Ieee, 2009.   \n[12] Shikuang Deng and Shi Gu. Optimal conversion of conventional artificial neural networks to spiking neural networks. arXiv preprint arXiv:2103.00476, 2021.   \n[13] Shikuang Deng, Hao Lin, Yuhang Li, and Shi Gu. Surrogate module learning: Reduce the gradient error accumulation in training spiking neural networks. In International Conference on Machine Learning, pages 7645\u20137657. PMLR, 2023.   \n[14] Terrance DeVries and Graham W Taylor. Improved regularization of convolutional neural networks with cutout. arXiv preprint arXiv:1708.04552, 2017.   \n[15] Peter U Diehl, Daniel Neil, Jonathan Binas, Matthew Cook, Shih-Chii Liu, and Michael Pfeiffer. Fast-classifying, high-accuracy spiking deep networks through weight and threshold balancing. In 2015 International joint conference on neural networks (IJCNN), pages 1\u20138. ieee, 2015.   \n[16] Jianhao Ding, Zhaofei Yu, Yonghong Tian, and Tiejun Huang. Optimal ann-snn conversion for fast and accurate inference in deep spiking neural networks. arXiv preprint arXiv:2105.11654, 2021.   \n[17] Chaoteng Duan, Jianhao Ding, Shiyan Chen, Zhaofei Yu, and Tiejun Huang. Temporal effective batch normalization in spiking neural networks. Advances in Neural Information Processing Systems, 35:34377\u201334390, 2022.   \n[18] Rida El-Allami, Alberto Marchisio, Muhammad Shafique, and Ihsen Alouani. Securing deep spiking neural networks against adversarial attacks through inherent structural parameters. In 2021 Design, Automation & Test in Europe Conference & Exhibition (DATE), pages 774\u2013779. IEEE, 2021.   \n[19] Wei Fang, Yanqi Chen, Jianhao Ding, Zhaofei Yu, Timoth\u00e9e Masquelier, Ding Chen, Liwei Huang, Huihui Zhou, Guoqi Li, and Yonghong Tian. Spikingjelly: An open-source machine learning infrastructure platform for spike-based intelligence. Science Advances, 9(40):eadi1480, 2023.   \n[20] Wei Fang, Zhaofei Yu, Yanqi Chen, Tiejun Huang, Timoth\u00e9e Masquelier, and Yonghong Tian. Deep residual learning in spiking neural networks. Advances in Neural Information Processing Systems, 34:21056\u201321069, 2021.   \n[21] Wei Fang, Zhaofei Yu, Yanqi Chen, Timoth\u00e9e Masquelier, Tiejun Huang, and Yonghong Tian. Incorporating learnable membrane time constant to enhance learning of spiking neural networks. In Proceedings of the IEEE/CVF international conference on computer vision, pages 2661\u20132671, 2021.   \n[22] Pengjie Gu, Rong Xiao, Gang Pan, and Huajin Tang. Stca: Spatio-temporal credit assignment with delayed feedback in deep spiking neural networks. In IJCAI, volume 15, pages 1366\u20131372, 2019.   \n[23] Wenzhe Guo, Mohammed E Fouda, Ahmed M Eltawil, and Khaled Nabil Salama. Neural coding in spiking neural networks: A comparative study for robust neuromorphic systems. Frontiers in Neuroscience, 15:638474, 2021.   \n[24] Yufei Guo, Yuanpei Chen, Liwen Zhang, Xiaode Liu, Yinglei Wang, Xuhui Huang, and Zhe Ma. Im-loss: information maximization loss for spiking neural networks. Advances in Neural Information Processing Systems, 35:156\u2013166, 2022.   \n[25] Yufei Guo, Xuhui Huang, and Zhe Ma. Direct learning-based deep spiking neural networks: a review. Frontiers in Neuroscience, 17:1209795, 2023.   \n[26] Bing Han and Kaushik Roy. Deep spiking neural network: Energy efficiency through time based coding. In European Conference on Computer Vision, pages 388\u2013404. Springer, 2020.   \n[27] Bing Han, Gopalakrishnan Srinivasan, and Kaushik Roy. Rmp-snn: Residual membrane potential neuron for enabling deeper high-accuracy and low-latency spiking neural network. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 13558\u201313567, 2020.   \n[28] Zecheng Hao, Tong Bu, Jianhao Ding, Tiejun Huang, and Zhaofei Yu. Reducing ann-snn conversion error through residual membrane potential. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 37, pages 11\u201321, 2023.   \n[29] Zecheng Hao, Tong Bu, Xinyu Shi, Zihan Huang, Zhaofei Yu, and Tiejun Huang. Threaten spiking neural networks through combining rate and temporal information. In The Twelfth International Conference on Learning Representations.   \n[30] Zecheng Hao, Tong Bu, Xinyu Shi, Zihan Huang, Zhaofei Yu, and Tiejun Huang. Threaten spiking neural networks through combining rate and temporal information. In The Twelfth International Conference on Learning Representations.   \n[31] Zecheng Hao, Jianhao Ding, Tong Bu, Tiejun Huang, and Zhaofei Yu. Bridging the gap between anns and snns by calibrating offset spikes. arXiv preprint arXiv:2302.10685, 2023.   \n[32] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 770\u2013778, 2016.   \n[33] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Identity mappings in deep residual networks. In Computer Vision\u2013ECCV 2016: 14th European Conference, Amsterdam, The Netherlands, October 11\u201314, 2016, Proceedings, Part IV 14, pages 630\u2013645. Springer, 2016.   \n[34] Haiyan Jiang, Srinivas Anumasa, Giulia De Masi, Huan Xiong, and Bin Gu. A unified optimization framework of ann-snn conversion: Towards optimal mapping from activation values to firing rates. In International Conference on Machine Learning, pages 14945\u201314974. PMLR, 2023.   \n[35] Jinseok Kim, Kyungsu Kim, and Jae-Joon Kim. Unifying activation-and timing-based learning rules for spiking neural networks. Advances in neural information processing systems, 33:19534\u2013 19544, 2020.   \n[36] Seijoon Kim, Seongsik Park, Byunggook Na, and Sungroh Yoon. Spiking-yolo: spiking neural network for energy-efficient object detection. In Proceedings of the AAAI conference on artificial intelligence, volume 34, pages 11270\u201311277, 2020.   \n[37] Alex Krizhevsky, Geoffrey Hinton, et al. Learning multiple layers of features from tiny images. 2009.   \n[38] Souvik Kundu, Massoud Pedram, and Peter A Beerel. Hire-snn: Harnessing the inherent robustness of energy-efficient deep spiking neural networks by training with crafted input noise. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 5209\u20135218, 2021.   \n[39] Jun Haeng Lee, Tobi Delbruck, and Michael Pfeiffer. Training deep spiking neural networks using backpropagation. Frontiers in neuroscience, 10:228000, 2016.   \n[40] Chen Li, Lei Ma, and Steve Furber. Quantization framework for fast spiking neural networks. Frontiers in Neuroscience, 16:918793, 2022.   \n[41] Hongmin Li, Hanchao Liu, Xiangyang Ji, Guoqi Li, and Luping Shi. Cifar10-dvs: an eventstream dataset for object classification. Frontiers in neuroscience, 11:244131, 2017.   \n[42] Yuhang Li, Shikuang Deng, Xin Dong, Ruihao Gong, and Shi Gu. A free lunch from ann: Towards efficient, accurate spiking neural networks calibration. In International conference on machine learning, pages 6316\u20136325. PMLR, 2021.   \n[43] Yuhang Li, Yufei Guo, Shanghang Zhang, Shikuang Deng, Yongqing Hai, and Shi Gu. Differentiable spike: Rethinking gradient-descent for training spiking neural networks. Advances in Neural Information Processing Systems, 34:23426\u201323439, 2021.   \n[44] Yuhang Li, Youngeun Kim, Hyoungseob Park, and Priyadarshini Panda. Uncovering the representation of spiking neural networks trained with surrogate gradient. arXiv preprint arXiv:2304.13098, 2023.   \n[45] Ilya Loshchilov and Frank Hutter. Sgdr: Stochastic gradient descent with warm restarts. arXiv preprint arXiv:1608.03983, 2016.   \n[46] Wolfgang Maass. Networks of spiking neurons: the third generation of neural network models. Neural networks, 10(9):1659\u20131671, 1997.   \n[47] Qingyan Meng, Mingqing Xiao, Shen Yan, Yisen Wang, Zhouchen Lin, and Zhi-Quan Luo. Training high-performance low-latency spiking neural networks by differentiation on spike representation. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 12444\u201312453, 2022.   \n[48] Qingyan Meng, Mingqing Xiao, Shen Yan, Yisen Wang, Zhouchen Lin, and Zhi-Quan Luo. Towards memory-and time-efficient backpropagation for training spiking neural networks. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 6166\u20136176, 2023.   \n[49] Hesham Mostafa. Supervised learning based on temporal coding in spiking neural networks. IEEE transactions on neural networks and learning systems, 29(7):3227\u20133235, 2017.   \n[50] Bhaskar Mukhoty, Hilal AlQuabeh, Giulia De Masi, Huan Xiong, and Bin Gu. Certified adversarial robustness for rate encoded spiking neural networks. In The Twelfth International Conference on Learning Representations, 2023.   \n[51] Emre O Neftci, Hesham Mostafa, and Friedemann Zenke. Surrogate gradient learning in spiking neural networks: Bringing the power of gradient-based optimization to spiking neural networks. IEEE Signal Processing Magazine, 36(6):51\u201363, 2019.   \n[52] Stefano Panzeri and Simon R Schultz. A unified approach to the study of temporal, correlational, and rate coding. Neural Computation, 13(6):1311\u20131349, 2001.   \n[53] Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, et al. Pytorch: An imperative style, high-performance deep learning library. Advances in neural information processing systems, 32, 2019.   \n[54] Jing Pei, Lei Deng, Sen Song, Mingguo Zhao, Youhui Zhang, Shuang Wu, Guanrui Wang, Zhe Zou, Zhenzhi Wu, Wei He, et al. Towards artificial general intelligence with hybrid tianjic chip architecture. Nature, 572(7767):106\u2013111, 2019.   \n[55] Nitin Rathi and Kaushik Roy. Diet-snn: A low-latency spiking neural network with direct input encoding and leakage and threshold optimization. IEEE Transactions on Neural Networks and Learning Systems, 34(6):3174\u20133182, 2021.   \n[56] Kaushik Roy, Akhilesh Jaiswal, and Priyadarshini Panda. Towards spike-based machine intelligence with neuromorphic computing. Nature, 575(7784):607\u2013617, 2019.   \n[57] Bodo Rueckauer, Iulia-Alexandra Lungu, Yuhuang Hu, Michael Pfeiffer, and Shih-Chii Liu. Conversion of continuous-valued deep networks to efficient event-driven networks for image classification. Frontiers in neuroscience, 11:294078, 2017.   \n[58] David E Rumelhart, Geoffrey E Hinton, and Ronald J Williams. Learning representations by back-propagating errors. nature, 323(6088):533\u2013536, 1986.   \n[59] Abhronil Sengupta, Yuting Ye, Robert Wang, Chiao Liu, and Kaushik Roy. Going deeper in spiking neural networks: Vgg and residual architectures. Frontiers in neuroscience, 13:95, 2019.   \n[60] Saima Sharmin, Nitin Rathi, Priyadarshini Panda, and Kaushik Roy. Inherent adversarial robustness of deep spiking neural networks: Effects of discrete input encoding and non-linear activations. In Computer Vision\u2013ECCV 2020: 16th European Conference, Glasgow, UK, August 23\u201328, 2020, Proceedings, Part XXIX 16, pages 399\u2013414. Springer, 2020.   \n[61] Guobin Shen, Dongcheng Zhao, and Yi Zeng. Exploiting high performance spiking neural networks with efficient spiking patterns. arXiv preprint arXiv:2301.12356, 2023.   \n[62] Sumit B Shrestha and Garrick Orchard. Slayer: Spike layer error reassignment in time. Advances in neural information processing systems, 31, 2018.   \n[63] Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014.   \n[64] Kyle H Srivastava, Caroline M Holmes, Michiel Vellema, Andrea R Pack, Coen PH Elemans, Ilya Nemenman, and Samuel J Sober. Motor control by precisely timed spike patterns. Proceedings of the National Academy of Sciences, 114(5):1171\u20131176, 2017.   \n[65] Christoph St\u00f6ckl and Wolfgang Maass. Optimized spiking neurons can classify images with high accuracy through temporal coding with two spikes. Nature Machine Intelligence, 3(3):230\u2013238, 2021.   \n[66] Kazuma Suetake, Shin-ichi Ikegawa, Ryuji Saiin, and Yoshihide Sawada. S3nn: Time step reduction of spiking surrogate gradients for training energy efficient single-step spiking neural networks. Neural Networks, 159:208\u2013219, 2023.   \n[67] Johannes Christian Thiele, Olivier Bichler, and Antoine Dupret. Spikegrad: An annequivalent computation model for implementing backpropagation with spikes. arXiv preprint arXiv:1906.00851, 2019.   \n[68] Jingtao Wang, Zengjie Song, Yuxi Wang, Jun Xiao, Yuran Yang, Shuqi Mei, and Zhaoxiang Zhang. Ssf: Accelerating training of spiking neural networks with stabilized spiking flow. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 5982\u20135991, 2023.   \n[69] Ziming Wang, Runhao Jiang, Shuang Lian, Rui Yan, and Huajin Tang. Adaptive smoothing gradient learning for spiking neural networks. In International Conference on Machine Learning, pages 35798\u201335816. PMLR, 2023.   \n[70] Ziming Wang, Shuang Lian, Yuhao Zhang, Xiaoxin Cui, Rui Yan, and Huajin Tang. Towards lossless ann-snn conversion under ultra-low latency with dual-phase optimization. arXiv preprint arXiv:2205.07473, 2022.   \n[71] Ronald J Williams and David Zipser. A learning algorithm for continually running fully recurrent neural networks. Neural computation, 1(2):270\u2013280, 1989.   \n[72] Hao Wu, Yueyi Zhang, Wenming Weng, Yongting Zhang, Zhiwei Xiong, Zheng-Jun Zha, Xiaoyan Sun, and Feng Wu. Training spiking neural networks with accumulated spiking flow. In Proceedings of the AAAI conference on artificial intelligence, volume 35, pages 10320\u201310328, 2021.   \n[73] Jibin Wu, Yansong Chua, Malu Zhang, Guoqi Li, Haizhou Li, and Kay Chen Tan. A tandem learning rule for effective training and rapid inference of deep spiking neural networks. IEEE Transactions on Neural Networks and Learning Systems, 34(1):446\u2013460, 2021.   \n[74] Yujie Wu, Lei Deng, Guoqi Li, and Luping Shi. Spatio-temporal backpropagation for training high-performance spiking neural networks. Frontiers in neuroscience, 12:323875, 2018.   \n[75] Timo C Wunderlich and Christian Pehle. Event-based backpropagation can compute exact gradients for spiking neural networks. Scientific Reports, 11(1):12829, 2021.   \n[76] Mingqing Xiao, Qingyan Meng, Zongpeng Zhang, Di He, and Zhouchen Lin. Online training through time for spiking neural networks. Advances in neural information processing systems, 35:20717\u201320730, 2022.   \n[77] Mingqing Xiao, Qingyan Meng, Zongpeng Zhang, Yisen Wang, and Zhouchen Lin. Training feedback spiking neural networks by implicit differentiation on the equilibrium state. Advances in neural information processing systems, 34:14516\u201314528, 2021.   \n[78] Zhanglu Yan, Jun Zhou, and Weng-Fai Wong. Near lossless transfer learning for spiking neural networks. In Proceedings of the AAAI conference on artificial intelligence, volume 35, pages 10577\u201310584, 2021.   \n[79] Man Yao, Huanhuan Gao, Guangshe Zhao, Dingheng Wang, Yihan Lin, Zhaoxu Yang, and Guoqi Li. Temporal-wise attention spiking neural networks for event streams classification. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 10221\u2013 10230, 2021.   \n[80] Xingting Yao, Fanrong Li, Zitao Mo, and Jian Cheng. Glif: A unified gated leaky integrate-andfire neuron for spiking neural networks. Advances in Neural Information Processing Systems, 35:32160\u201332171, 2022.   \n[81] Bojian Yin, Federico Corradi, and Sander M Boht\u00e9. Effective and efficient computation with multiple-timescale spiking recurrent neural networks. In International Conference on Neuromorphic Systems 2020, pages 1\u20138, 2020.   \n[82] Bojian Yin, Federico Corradi, and Sander M Boht\u00e9. Accurate online training of dynamical spiking neural networks through forward propagation through time. Nature Machine Intelligence, 5(5):518\u2013527, 2023.   \n[83] Chengting Yu, Zheming Gu, Da Li, Gaoang Wang, Aili Wang, and Erping Li. Stsc-snn: Spatio-temporal synaptic connection with temporal convolution and attention for spiking neural networks. Frontiers in Neuroscience, 16:1079357, 2022.   \n[84] Friedemann Zenke and Surya Ganguli. Superspike: Supervised learning in multilayer spiking neural networks. Neural computation, 30(6):1514\u20131541, 2018.   \n[85] Friedemann Zenke and Tim P Vogels. The remarkable robustness of surrogate gradient learning for instilling complex function in spiking neural networks. Neural computation, 33(4):899\u2013925, 2021.   \n[86] Wenrui Zhang and Peng Li. Temporal spike sequence learning via backpropagation for deep spiking neural networks. Advances in neural information processing systems, 33:12022\u201312033, 2020.   \n[87] Hanle Zheng, Yujie Wu, Lei Deng, Yifan Hu, and Guoqi Li. Going deeper with directly-trained larger spiking neural networks. In Proceedings of the AAAI conference on artificial intelligence, volume 35, pages 11062\u201311070, 2021.   \n[88] Shibo Zhou, Xiaohua Li, Ying Chen, Sanjeev T Chandrasekaran, and Arindam Sanyal. Temporalcoded deep spiking neural network with easy training and robust performance. In Proceedings of the AAAI conference on artificial intelligence, volume 35, pages 11143\u201311151, 2021.   \n[89] Yaoyu Zhu, Jianhao Ding, Tiejun Huang, Xiaodong Xie, and Zhaofei Yu. Online stabilization of spiking neural networks. In The Twelfth International Conference on Learning Representations. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "", "page_idx": 14}, {"type": "text", "text": "A Proof of Theorems ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Theorem 1. Given $\\begin{array}{r}{\\pmb{\\delta}_{t}^{(s^{l})}=\\frac{\\partial\\mathcal{L}}{\\partial\\mathbf{s}_{t}^{l}}}\\end{array}$ that refers to gradients computed following the chain rule of BPTT in Eq. (2), and $\\begin{array}{r}{\\kappa_{t}^{l}=\\sum_{\\tau}\\frac{\\partial\\pmb{s}_{t}^{l}}{\\partial\\pmb{I}_{\\tau}^{l}}}\\end{array}$ (where E \u03balt = E \u03ba\u03ba\u03balt in Eq.(6-7)) , if E \u03b4t(s)\u03balt = E \u03b4t(s) E \u03balt holds for $\\forall l$ , we have $\\begin{array}{r}{\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\right]=\\left(\\frac{\\partial\\mathcal{L}}{\\partial r^{l}}\\right)_{r a t e}}\\end{array}$ . Furthermore, given $\\begin{array}{r}{\\pmb{\\delta}_{t}^{(I^{l})}=\\frac{\\partial\\mathcal{L}}{\\partial I_{t}^{l}}}\\end{array}$ \u2202\u2202ILtl , if E $\\Xi\\left[\\delta_{t}^{(I^{l})}s_{t}^{l-1}\\right]=$ $\\mathbb{E}\\left[\\pmb{\\delta}_{t}^{(\\pmb{I}^{l})}\\right]\\mathbb{E}[\\pmb{\\mathscr{s}}_{t}^{l-1}]f o r\\,\\forall l$ , we then obtain $\\begin{array}{r}{\\bigl(\\nabla_{W^{l}}\\mathcal{L}\\bigr)_{r a t e}=\\frac{1}{T}(\\nabla_{W^{l}}\\mathcal{L})}\\end{array}$ . Here, $\\begin{array}{r}{\\mathbb{E}\\left[\\pmb{x}_{t}\\right]=\\frac{1}{T}\\sum_{t}\\pmb{x}_{t}}\\end{array}$ refers the mean value of tensor $\\pmb{x}_{t}$ over temporal dimension $T$ . ", "page_idx": 15}, {"type": "text", "text": "dPyronoafm. icGs ibvaesne $\\begin{array}{r}{\\pmb{\\delta}_{t}^{(s^{l})}\\,=\\,\\frac{\\partial\\mathcal{L}}{\\partial\\pmb{s}_{t}^{l}}}\\end{array}$ n arnudl $\\begin{array}{r}{\\pmb{\\kappa}_{t}^{l}\\,=\\,\\sum_{\\tau}\\frac{\\partial\\pmb{s}_{t}^{l}}{\\partial\\pmb{I}_{\\tau}^{l}}}\\end{array}$ , we establish the mean gradients through neural ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbb{E}\\left[\\frac{\\partial\\mathcal{L}}{\\partial I_{t}^{l}}\\right]=\\mathbb{E}\\left[\\sum_{\\tau}\\frac{\\partial\\mathcal{L}}{\\partial s_{\\tau}^{l}}\\frac{\\partial s_{\\tau}^{l}}{\\partial I_{t}^{l}}\\right]=\\frac{1}{T}\\sum_{t}\\sum_{\\tau}\\frac{\\partial\\mathcal{L}}{\\partial s_{\\tau}^{l}}\\frac{\\partial s_{\\tau}^{l}}{\\partial I_{t}^{l}}=\\mathbb{E}[\\delta_{t}^{(s^{l})}\\kappa_{t}^{l}],\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Considering the output layer $l=L$ , the objective for BPTT can be expressed as $\\mathcal{L}=\\ell(\\mathbb{E}[\\pmb{o}_{t}],\\pmb{y})=$ $\\ell(\\mathbb{E}[W^{L}\\pmb{s}_{t}^{L}],\\pmb{y})\\ =\\ \\ell(\\dot{W}^{L}\\mathbb{E}[\\pmb{s}_{t}^{L}],\\pmb{y})\\ =\\ \\ell(\\pmb{W}^{L}\\pmb{r}^{L},\\pmb{y})$ . Under the rate-based objective ${\\mathcal{L}}\\ =$ T1 \u2113(cL, y) = T1 \u2113(W LrL\u22121, y), it is clear that E[\u03b4t(sL\u22121)] =  \u2202r\u2202LL\u22121 rate. Applying the precondition $\\mathbb{E}[\\pmb{\\delta}_{t}^{(s^{L-1})}\\pmb{\\kappa}_{t}^{L}]=\\mathbb{E}[\\pmb{\\delta}_{t}^{(s^{L-1})}]\\mathbb{E}[\\pmb{\\kappa}_{t}^{L-1}].$ , we obtain: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\left(\\displaystyle\\frac{\\partial\\mathcal{L}}{\\partial r^{L-1}}\\frac{\\partial r^{L-1}}{\\partial c^{L-2}}\\frac{\\partial c^{L-2}}{\\partial r^{L-2}}\\right)_{\\mathrm{rate}}=\\left(\\displaystyle\\frac{\\partial\\mathcal{L}}{\\partial r^{L-1}}\\right)_{\\mathrm{rate}}\\mathbb{E}[\\kappa_{t}^{L-1}]W^{(L-1)^{\\top}}}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\quad=\\mathbb{E}[\\delta_{t}^{(s^{L-1})}]\\mathbb{E}[\\kappa_{t}^{L-1}]W^{(L-1)^{\\top}}=\\mathbb{E}[\\delta_{t}^{(s^{L-1})}\\kappa_{t}^{L-1}]W^{(L-1)^{\\top}}}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\quad=\\mathbb{E}\\left[\\displaystyle\\frac{\\partial\\mathcal{L}}{\\partial I_{t}^{L-1}}\\right]W^{(L-1)^{\\top}}=\\mathbb{E}\\left[\\displaystyle\\frac{\\partial\\mathcal{L}}{\\partial I_{t}^{L-1}}W^{(L-1)^{\\top}}\\right]}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\quad=\\mathbb{E}\\left[\\displaystyle\\frac{\\partial\\mathcal{L}}{\\partial s_{t}^{L-2}}\\right]=\\mathbb{E}[\\delta_{t}^{(s^{L-2})}],}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Continuing this induction process, we can derive that $\\begin{array}{r}{\\mathbb{E}[\\delta_{t}^{(\\pmb{s}^{l})}]=\\left(\\frac{\\partial\\mathcal{L}}{\\partial\\pmb{r}^{l}}\\right)_{\\mathrm{rate}}}\\end{array}$ for all layers $l$ . Further, given \u03b4t(Il) = $\\begin{array}{r}{\\pmb{\\delta}_{t}^{(\\pmb{I}^{l})}=\\frac{\\partial\\mathcal{L}}{\\partial\\pmb{I}_{t}^{l}}}\\end{array}$ , the gradient for the weight matrix under BPTT: $\\begin{array}{r}{\\nabla_{W^{l}}\\mathcal{L}=\\sum_{t}\\left(\\frac{\\partial\\mathcal{L}}{\\partial I_{t}^{l}}\\frac{\\partial I_{t}^{l}}{\\partial W^{l}}\\right)=}\\end{array}$ $\\sum_{t}\\delta_{t}^{(I^{l})}s_{t}^{l-1}$ . The gradients passing through the linear parts maintain the equivalence: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\left(\\ensuremath{\\frac{\\partial\\mathcal{L}}{\\partial c^{l}}}\\right)_{\\mathrm{rate}}=\\left(\\ensuremath{\\frac{\\partial\\mathcal{L}}{\\partial r^{l+1}}}\\ensuremath{\\frac{\\partial r^{l+1}}{\\partial c^{l}}}\\right)_{\\mathrm{rate}}=\\left(\\ensuremath{\\frac{\\partial\\mathcal{L}}{\\partial r^{l+1}}}W^{l+1^{\\top}}\\right)_{\\mathrm{rate}}}\\\\ &{=\\left(\\ensuremath{\\frac{\\partial\\mathcal{L}}{\\partial r^{l+1}}}\\right)_{\\mathrm{rate}}W^{l+1^{\\top}}=\\mathbb{E}[\\delta_{t}^{(s^{l+1})}W^{l+1^{\\top}}]=\\mathbb{E}[\\delta_{t}^{(I^{l})}].}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "With the precondition that $\\mathbb{E}[\\pmb{\\delta}_{t}^{(\\pmb{I}^{l})}\\pmb{s}_{t}^{l-1}]=\\mathbb{E}[\\pmb{\\delta}_{t}^{(\\pmb{I}^{l})}]\\mathbb{E}[\\pmb{s}_{t}^{l-1}]$ holds for $\\forall l$ , we obtain: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\left(\\nabla_{W^{l}}\\mathcal{L}\\right)_{\\mathrm{rate}}=\\left(\\frac{\\partial\\mathcal{L}}{\\partial c^{l}}\\frac{\\partial c^{l}}{\\partial W^{l}}\\right)_{\\mathrm{rate}}=\\left(\\frac{\\partial\\mathcal{L}}{\\partial c^{l}}\\right)_{\\mathrm{rate}}r^{l-1}}\\\\ &{~~=\\mathbb{E}[\\delta_{t}^{(I^{l})}]\\mathbb{E}[s_{t}^{l-1}]=\\mathbb{E}[\\delta_{t}^{(I^{l})}s_{t}^{l-1}]=\\frac{1}{T}\\nabla_{W^{l}}\\mathcal{L}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Theorem 2. For gradients $\\begin{array}{r}{\\delta_{t}^{(s^{l})}=\\frac{\\partial\\mathcal{L}}{\\partial s_{t}^{l}}}\\end{array}$ and $\\begin{array}{r}{\\pmb{\\kappa}_{t}^{l}=\\sum_{\\tau}\\frac{\\partial\\pmb{s}_{t}^{l}}{\\partial\\pmb{I}_{\\tau}^{l}}}\\end{array}$ , given the approximation error bound \u03f5 > 0 s.t. $\\left\\|\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\kappa_{t}^{l}\\right]-\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\right]\\mathbb{E}\\left[\\kappa_{t}^{l}\\right]\\right\\|\\leq\\epsilon(1+\\left\\|\\mathbb{E}\\left[\\delta_{t}^{(s^{l})}\\right]\\right\\|)f o r\\,\\forall l.$ . Denote the stacked tensor $\\mathbfcal{I}^{l}=[I_{1}^{l},...,\\bar{I}_{T}^{l}]$ and $\\pmb{\\mathscr{s}}^{l}=[\\pmb{\\mathscr{s}}_{1}^{l},...,\\pmb{\\mathscr{s}}_{T}^{l}]$ . Assuming the backward procedure follows non-expansivity s.t. $\\begin{array}{r}{\\frac{\\partial I^{l+1}}{\\partial I^{l}}=W^{l+1^{\\top}}\\frac{\\partial{\\pmb\\mathscr{s}}^{l}}{\\partial I^{l}}}\\end{array}$ is $^{\\,l}$ -lipschitz continuous without loss of generality and the biases are bounded uniformly by $B_{z}$ , i.e. $\\begin{array}{r}{\\left\\|x\\frac{\\partial{\\pmb I}^{l+1}}{\\partial{\\pmb I}^{l}}\\,-\\,\\hat{\\pmb x}\\frac{\\partial{\\pmb I}^{l+1}}{\\partial{\\pmb I}^{l}}\\right\\|\\,\\le\\,\\left\\|\\pmb x-\\hat{\\pmb x}\\right\\|\\,f o r\\,\\forall\\pmb x,\\hat{\\pmb x}}\\end{array}$ . Define $\\begin{array}{r}{\\delta_{r a t e}^{l}\\,=\\,\\left(\\frac{\\partial\\mathcal{L}}{\\partial c^{l}}\\right)_{r a t e}}\\end{array}$ as the error propagated through Eq. (7), and $\\begin{array}{r}{\\pmb{\\delta}_{t}^{(I^{l})}=\\frac{\\partial\\mathcal{L}}{\\partial I_{t}^{l}}}\\end{array}$ as the error propagated through BPTT, with $\\delta_{r a t e}^{L}=\\mathbb{E}[\\delta_{t}^{(I^{L})}]$ . We have the gradient difference bounded by $\\left\\|\\delta_{r a t e}^{L-k}-\\mathbb{E}[\\delta_{t}^{(I^{L-k})}]\\right\\|=\\mathcal{O}(k^{2}\\epsilon).$ . bPorouonfd.e dG ibvye $B$ t fhoart  tahlle $l$ ,e rrwoer  cbaanc kdperriovpea $\\begin{array}{r}{\\left\\|\\mathbb{E}[\\delta_{t}^{(I^{l})}]\\right\\|=\\left\\|\\mathbb{E}[\\delta_{t}^{(I^{l+1})}\\frac{\\partial I^{l+1}}{\\partial I^{l}}]\\right\\|\\le\\left\\|\\mathbb{E}[\\delta_{t}^{(I^{l+1})}]\\right\\|+B}\\end{array}$ $\\frac{\\partial\\pmb{I}^{l+1}}{\\partial\\pmb{I}^{l}}$ sbeys non-expansivity. Then, by induction, we obtain the gradient bound between the intermediate layers and the final layer: ", "page_idx": 15}, {"type": "text", "text": "", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left\\|(\\mathbb{E}[\\delta_{t}^{(I^{l})}])\\right\\|\\leq(L-l)B+\\left\\|\\mathbb{E}[\\delta_{t}^{(I^{L})}]\\right\\|.}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Since \u2202Il+1 $\\begin{array}{r}{\\frac{\\partial I^{l+1}}{\\partial I_{t}^{l}}\\;=\\;W^{l+1^{\\top}}\\kappa_{t}^{l}}\\end{array}$ is also 1-Lipschitz continuous without loss of generality, given the approximated approximated error $\\epsilon>0$ s.t. ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\left\\|\\mathbb{E}[\\delta_{t}^{(I^{l+1})}W^{l+1^{\\top}}\\mathbb{E}[\\pmb{\\kappa}_{t}^{l}]-\\mathbb{E}[\\delta_{t}^{(I^{l+1})}W^{l+1^{\\top}}\\pmb{\\kappa}_{t}^{l}]\\right\\|=\\left\\|\\mathbb{E}[\\delta_{t}^{(s^{l})}\\mathbb{E}[\\pmb{\\kappa}_{t}^{l}]-\\mathbb{E}[\\delta_{t}^{(s^{l})}\\pmb{\\kappa}_{t}^{l}]\\right\\|}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\leq\\epsilon(1+\\left\\|\\mathbb{E}[\\delta_{t}^{(s^{l})}\\pmb{\\kappa}_{t}^{l}]\\right\\|)=\\epsilon(1+\\left\\|\\mathbb{E}[\\delta_{t}^{(I^{l+1})}W^{l+1^{\\top}}\\pmb{\\kappa}_{t}^{l}]\\right\\|)}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "we have ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\bigg\\|\\delta_{\\mathrm{rate}}^{l}-\\mathbb{E}[\\delta_{t}^{(I^{l})}]\\bigg\\|=\\bigg\\|\\delta_{\\mathrm{rate}}^{l+1}W^{l+1^{\\top}}\\mathbb{E}[\\kappa_{t}^{l}]-\\mathbb{E}[\\delta_{t}^{(I^{l+1})}]W^{l+1^{\\top}}\\kappa_{t}^{l}\\bigg\\|}\\\\ &{\\qquad\\qquad=\\bigg\\|\\bigg(\\delta_{\\mathrm{rate}}^{l+1}W^{l+1^{\\top}}\\mathbb{E}[\\kappa_{t}^{l}]-\\mathbb{E}[\\delta_{t}^{(I^{l+1})}]W^{l+1^{\\top}}\\mathbb{E}[\\kappa_{t}^{l}]\\bigg)}\\\\ &{\\qquad\\qquad\\qquad\\qquad+\\left(\\mathbb{E}[\\delta_{t}^{(I^{l+1})}W^{l+1^{\\top}}\\mathbb{E}[\\kappa_{t}^{l}]-\\mathbb{E}[\\delta_{t}^{(I^{l+1})}W^{l+1^{\\top}}\\kappa_{t}^{l}]\\right)\\bigg\\|}\\\\ &{\\qquad\\qquad\\leq\\bigg\\|\\delta_{\\mathrm{rate}}^{l+1}-\\mathbb{E}[\\delta_{t}^{(I^{l+1})}]\\bigg\\|+\\epsilon(1+\\bigg\\|\\mathbb{E}[\\delta_{t}^{(I^{l+1})}W^{l+1^{\\top}}\\kappa_{t}^{l}]\\bigg\\|)}\\\\ &{\\qquad\\qquad\\leq\\bigg\\|\\delta_{\\mathrm{rate}}^{l+1}-\\mathbb{E}[\\delta_{t}^{(I^{l+1})}]\\bigg\\|+\\epsilon(1+(L-l)B+\\bigg\\|\\mathbb{E}[\\delta_{t}^{(I^{l})}]\\bigg\\|)}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "By induction, we obtain ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\Big\\|\\delta_{\\mathrm{rate}}^{l}-\\mathbb{E}[\\delta_{t}^{(I^{l})}]\\Big\\|\\leq\\epsilon\\Big((L-l)+\\frac{(L-l+1)(L-l)}{2}B+(L-l)\\Big\\|\\mathbb{E}[\\delta_{t}^{(I^{L})}]\\Big\\|\\Big)=\\mathcal{O}\\Big((L-l)^{2}\\epsilon\\Big)\\,,\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "B Implementation Details ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "B.1 Pseudocode of the Rate-based Backpropagation ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "The pseudocode for rate-based backpropagation, illustrating the implementations for both rate $M$ and rate $\\boldsymbol{S}$ , is provided in Algorithm 1. ", "page_idx": 16}, {"type": "text", "text": "B.2 About Training Modes in Rate-based Backpropagation ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "In direct training, two distinct implementation modes are recognized, activation-based and time-based [19], differing fundamentally in their handling of the simulation timestep $T$ . The activation-based, also known as multi-step mode, processes the $T$ loop separately within each layer, transmitting inter-layer tensors within dimensions $[T,B,S]$ , where $B$ and $S$ refer to batch and spatial dimensions, respectively. The configuration enables the multi-step mode to enhance computational efficiency by reformatting the tensor dimensions as $[T\\times B,S]$ to optimize parallelism in linear parts. However, the coupled processing with temporal calculations embedded within the layers increases memory retention on GPUs, potentially obscuring the benefits of memory cost optimization in both online training and our proposed methods. In contrast, the time-based mode externalizes the $T$ loop, facilitating single-step forward computations at each timestep. This single-step mode aligns well with the dynamic modeling of temporal dimensions and facilitates memory optimization strategies more effectively. However, its restriction on parallel computation in linear components compared to multi-step mode necessitates increased forward time on GPUs, albeit with enhanced support for memory optimization. Our proposed method has been adapted to operate effectively within both frameworks to ensure comprehensiveness, as shown in Algorithm 1. ", "page_idx": 16}, {"type": "text", "text": "Input: Timesteps $T$ ; Network depth $L$ ; Trainable parameters $\\{\\pmb{W}^{l}\\}_{l\\leq L}$ ; Training Mini-batch $\\{(x_{t}^{0},y)\\}$ ; Training Mode rate $_S$ or $\\pmb{r a t e}_{M}$ . ", "page_idx": 17}, {"type": "text", "text": "1 Initialize input spikes $\\pmb{s}_{t}^{0}=\\pmb{x}_{t}^{0}$ for all $\\bar{t}\\in[1,T]$ . ", "page_idx": 17}, {"type": "text", "text": "if rate $M$ then for $l=1$ to $L$ do Compute input currents through linear operators $\\pmb{I}_{t}^{l}=\\pmb{W}^{l}\\pmb{s}_{t}^{l-1}$ for all $t\\in[1,T]$ ; Initialize $\\pmb{\\rho}_{0}^{l}=0,\\pmb{g}_{0}^{l}=0,e_{0}^{l}=0$ . for $t=1$ to $T$ do Compute output spikes $\\boldsymbol{s}_{t}^{l}$ from ${\\pmb I}_{t}^{l}$ following neural dynamics in Eq. (1); Compute the eligibility trace $\\begin{array}{r}{\\pmb{\\rho}_{t}^{l}=1+\\pmb{\\rho}_{t-1}^{l}\\left(\\frac{\\partial\\pmb{u}_{t}^{l}}{\\partial\\pmb{u}_{t-1}^{l}}+\\frac{\\partial\\pmb{u}_{t}^{l}}{\\partial\\pmb{s}_{t-1}^{l}}\\frac{\\partial\\pmb{s}_{t-1}^{l}}{\\partial\\pmb{u}_{t-1}^{l}}\\right)}\\end{array}$ in Eq. (8); Accumulate $\\begin{array}{r}{e_{t}^{l}=\\frac{1}{t}((t-1)e_{t-1}^{l}+s_{t}^{l})}\\end{array}$ ; Accumulate $\\begin{array}{r}{\\pmb{g}_{t}^{l}=\\frac{1}{t}((t-1)\\pmb{g}_{t-1}^{l}+\\frac{\\partial\\pmb{s}_{t}^{l}}{\\partial\\pmb{u}_{t}^{l}}\\pmb{\\rho}_{t})}\\end{array}$ end Save $e_{T}^{l},g_{T}^{l}$ and $\\boldsymbol{W}^{l}$ for backwards, and free intermediate variables. end else Initialize $\\rho_{0}^{l}=0$ , $g_{0}^{l}=0$ , $e_{0}^{l}=0$ for all $l\\in[1,L]$ . for $t=1$ to $T$ do for $l=1$ to $L$ do Compute input currents through linear operators $\\pmb{I}_{t}^{l}=\\pmb{W}^{l}\\pmb{s}_{t}^{l-1}$ ; Initialize $\\pmb{\\rho}_{0}^{l}=0,\\pmb{g}_{0}^{l}=0,\\pmb{e}_{0}^{l}=0;$ ; Compute output spikes $\\boldsymbol{s}_{t}^{l}$ from ${\\pmb I}_{t}^{l}$ following neural dynamics in Eq. (1); Compute the eligibility trace $\\begin{array}{r}{\\pmb{\\rho}_{t}^{l}=1+\\pmb{\\rho}_{t-1}^{l}\\left(\\frac{\\partial\\pmb{u}_{t}^{l}}{\\partial\\pmb{u}_{t-1}^{l}}+\\frac{\\partial\\pmb{u}_{t}^{l}}{\\partial\\pmb{s}_{t-1}^{l}}\\frac{\\partial\\pmb{s}_{t-1}^{l}}{\\partial\\pmb{u}_{t-1}^{l}}\\right)}\\end{array}$ in Eq. (8); Accumulate $\\begin{array}{r}{e_{t}^{l}=\\frac{1}{t}((t-1)e_{t-1}^{l}+s_{t}^{l})}\\end{array}$ ;   \n3 Accumulate $\\begin{array}{r}{\\pmb{g}_{t}^{l}=\\frac{1}{t}((t-1)\\pmb{g}_{t-1}^{l}+\\frac{\\partial\\pmb{s}_{t}^{l}}{\\partial\\pmb{u}_{t}^{l}}\\pmb{\\rho}_{t})}\\end{array}$ ; Save $\\pmb{u}_{t}^{l}$ , $\\boldsymbol{s}_{t}^{l}$ for neuron states; Save $\\begin{array}{r}{\\mathbf{\\nabla}g_{t}^{l},e_{t}^{l},}\\end{array}$ $\\rho_{t}^{l}$ as eligibility traces. end end   \n8 end ", "page_idx": 17}, {"type": "text", "text": "29 Compute the outputs gradient $\\frac{\\partial\\mathcal{L}}{\\partial\\mathbf{c}^{L}}$ from the objective function. ", "page_idx": 17}, {"type": "text", "text": "30 for $l=L-1$ to 1 do   \n31 Compute error backpropagated through the linear part $\\begin{array}{r}{\\frac{\\partial\\mathcal{L}}{\\partial\\boldsymbol{r}^{l}}=\\frac{\\partial\\mathcal{L}}{\\partial\\boldsymbol{c}^{l+1}}W^{l+1}^{\\top}}\\end{array}$   \n32 Compute error backpropagated through the neuron part $\\begin{array}{r}{\\frac{\\partial\\mathcal{L}}{\\partial\\pmb{c}^{l}}=\\frac{\\partial\\mathcal{L}}{\\partial\\pmb{r}^{l}}\\pmb{g}_{T}^{l}}\\end{array}$   \n33 Compute the weight gradients $\\begin{array}{r}{\\nabla_{W^{l}}\\mathcal{L}=\\frac{\\partial\\mathcal{L}}{\\partial c^{l}}(e_{T}^{l-1})^{\\top}}\\end{array}$ ;   \n34 Update parameters $\\{W^{l}\\}_{l\\leq L}$ based on the gradient-based optimizer. ", "page_idx": 17}, {"type": "text", "text": "B.3 Implementation of Batch Normalization in Rate-based Backpropagation ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "In the forward pass, batch normalization (BN) precedes neuron activation, scaling inputs $I_{t}^{l}$ and introduces a bias in the average inputs $\\pmb{c}=\\mathbb{E}[\\pmb{I}_{t}]$ . We denote $\\tilde{c}$ to represent the biased average inputs as $\\tilde{c}=\\mathbb{E}[\\tilde{I}_{t}]=\\mathbb{E}[{\\bf B N}(I_{t})]$ instead of $^c$ . Note that BN acts as a linear operation during inference, where ${\\tilde{c}}\\,=\\,\\mathbb{E}[{\\tilde{I}}_{t}]\\,=\\,\\mathbb{E}[\\mathrm{BN}(I_{t})]\\,=\\,\\mathrm{BN}(\\mathbb{E}[I_{t}])\\,=\\,\\mathrm{BN}(c)$ . Implementing rate-based propagation requires considering how gradients pass through the BN layers and affect their intrinsic parameters during training. Initially, we explore the spatial BN [48] design for the single-step mode, which computes mean and variance statistics independently at each time step $t$ : ", "page_idx": 17}, {"type": "text", "text": "", "page_idx": 18}, {"type": "equation", "text": "$$\n\\tilde{I}_{t}=\\mathrm{BN}(I_{t})=\\gamma\\left(\\frac{I_{t}-\\mu_{t}}{\\sqrt{\\sigma_{t}^{2}+\\epsilon}}\\right)+\\beta,\\mathrm{~where~}\\mu_{t}=\\frac{1}{B}\\sum_{b}I_{t}^{(b)}\\mathrm{~and~}\\sigma_{t}^{2}=\\frac{1}{B}\\sum_{b}(I_{t}^{(b)}-\\mu_{t})^{2}.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Defining $\\begin{array}{r}{\\chi_{t}^{(I)}=\\frac{\\partial\\tilde{I}_{t}}{\\partial I_{t}},\\chi_{t}^{(\\gamma)}=\\frac{\\partial\\tilde{I}_{t}}{\\partial\\gamma},\\chi_{t}^{(\\beta)}=\\frac{\\partial\\tilde{I}_{t}}{\\partial\\beta}}\\end{array}$ = \u2202\u2202I\u02dc\u03b2t , the following expressions are obtained: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\chi_{t}^{(I)}=\\gamma\\frac{1}{\\sqrt{\\sigma_{t}^{2}+\\epsilon}}+\\frac{\\partial\\tilde{I}_{t}^{l}}{\\partial\\sigma_{t}^{2}}\\frac{\\partial\\sigma_{t}^{2}}{\\partial I_{t}^{l}}+\\frac{\\partial\\tilde{I}_{t}^{l}}{\\partial\\mu_{t}}\\frac{\\partial\\mu_{t}}{\\partial I_{t}^{l}},\\quad\\chi_{t}^{(\\gamma)}=\\frac{I_{t}^{l}-\\mu_{t}}{\\sqrt{\\sigma_{t}^{2}+\\epsilon}},\\quad\\chi_{t}^{(\\beta)}=I d.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "time, we implement For the backward derivation of BN in a rate-based setting based on mean estimations through $\\begin{array}{r}{\\frac{\\partial\\mathcal{L}}{\\partial c}=\\frac{\\partial\\mathcal{L}}{\\partial\\tilde{c}}\\mathbb{E}[\\chi_{t}^{(I)}],\\frac{\\partial\\mathcal{L}}{\\partial\\gamma}=\\frac{\\partial\\mathcal{L}}{\\partial\\tilde{c}}\\mathbb{E}[\\chi_{t}^{(\\gamma)}],\\frac{\\partial\\tilde{L}}{\\partial\\beta}=\\frac{\\partial\\mathcal{L}}{\\partial\\tilde{c}}\\mathbb{E}[\\chi_{t}^{(\\beta)}]=\\frac{\\partial\\mathcal{L}}{\\partial\\tilde{c}}}\\end{array}$ . Since gradient computation at each timestep is independent, the dynamic estimations of $\\mathbb{E}[{\\boldsymbol{\\chi}}_{t}^{(I)}]$ and $\\mathbb{E}[x_{t}^{(\\gamma)}]$ are performed in the same manner of $\\{e_{t}^{l}\\}_{t\\le T}$ and $\\{\\pmb{g}_{t}^{l}\\}_{t\\le T}$ . ", "page_idx": 18}, {"type": "text", "text": "In the multi-step mode, tdBN [87] accounts for mean and variance statistics over the entire time horizon: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\tilde{\\Gamma}_{t}=\\mathrm{BN}(I_{t})=\\gamma\\left(\\frac{I_{t}-\\mu}{\\sqrt{\\sigma^{2}+\\epsilon}}\\right)+\\beta,\\mathrm{where~}\\mu=\\frac{1}{B T}\\sum_{t}\\sum_{b}I_{t}^{(b)},\\sigma^{2}=\\frac{1}{B T}\\sum_{t}\\sum_{b}(I_{t}^{(b)}-\\mu)^{2}.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "The rate-based representation integrates the input across the time dimension, with the mean $\\pmb{\\mu}_{c}=$ $\\sum_{b}\\pmb{c}^{(b)}$ , and variance $\\begin{array}{r}{\\pmb{\\sigma}_{c}^{2}=\\frac{1}{B}\\sum_{b}\\overline{{(\\pmb{c}^{(b)}-\\pmb{\\mu}_{c})^{2}}}}\\end{array}$ . Since $^c$ is the temporal mean of inputs, it is clear that $\\pmb{\\mu}_{c}=\\pmb{\\mu}$ and $\\pmb{\\sigma}_{c}^{2}\\leq\\pmb{\\sigma}^{2}$ . Note that $\\begin{array}{r}{\\frac{\\partial{\\pmb\\sigma}^{2}}{\\partial I_{t}}=\\frac{1}{B T}\\sum_{t}\\sum_{b}({\\pmb I}_{t}^{(b)}-{\\pmb\\mu})=\\frac{1}{B}\\sum_{b}({\\pmb c}^{(b)}-{\\pmb\\mu}_{c})=\\frac{\\partial{\\pmb\\sigma}_{c}^{2}}{\\partial c}}\\end{array}$ . Assuming \u2202\u2202Ict = Id, we derive \u2202\u2202I\u00b5t $\\begin{array}{r}{\\frac{\\partial\\mu}{\\partial I_{t}}=\\frac{\\partial\\mu_{c}}{\\partial c}}\\end{array}$ . For the forward approximation specifically tailored for tdBN in rate-based backpropagation, we define: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\tilde{c}=\\mathrm{BN}(c)=\\gamma\\left(\\frac{c-\\mu}{\\sqrt{\\hat{\\pmb{\\sigma}}_{c}^{2}+\\epsilon}}\\right)+\\beta,\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where $\\gamma$ and $\\beta$ refer to the same intrinsic parameters shared with $\\mathbf{B}\\mathbf{N}(\\pmb{I}_{t})$ , and $\\hat{\\pmb{\\sigma}}_{c}^{2}$ is defined distinctly in forward and backward passes: $\\hat{\\pmb{\\sigma}}_{c}^{2}=\\pmb{\\sigma}^{2}$ in forward and $\\begin{array}{r}{\\frac{\\partial\\hat{\\pmb{\\sigma}}_{c}^{2}}{\\partial\\pmb{\\sigma}_{c}^{2}}=I d}\\end{array}$ in backward. The implementation utilizes gradient replacement with the detach operation in PyTorch: $\\hat{\\pmb{\\sigma}}_{c}^{2}=d e t a c h(\\pmb{\\sigma}^{2}\\!-\\!\\pmb{\\sigma}_{c}^{2})\\!+\\!\\pmb{\\sigma}_{c}^{2}$ . Thus, in the forward phase, $\\tilde{\\pmb{c}}=\\hat{\\bf B N}(\\pmb{c})=\\mathbb{E}[\\mathbf{BN}(\\pmb{I}_{t})]$ , and in the backward phase, $\\begin{array}{r}{\\frac{\\partial\\tilde{\\pmb{c}}}{\\partial\\pmb{c}}=\\mathbb{E}[\\frac{\\partial\\tilde{\\pmb{c}}}{\\partial\\pmb{I}_{t}}]}\\end{array}$ , aligning perfectly with the foundational principles of rate-based backpropagation. ", "page_idx": 18}, {"type": "text", "text": "C Experimental Settings ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "C.1 Datasets ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "CIFAR-10 and CIFAR-100. The CIFAR-10 and CIFAR-100 [37] datasets contain $32\\mathtt{x32}$ color images across different classes, licensed under MIT. CIFAR-10 includes 60,000 images across 10 classes, with 50,000 for training and 10,000 for testing, whereas CIFAR-100 is spread over 100 classes. Both datasets have been normalized for zero mean and unit variance. Image data augmentation is applied using AutoAugment [9] and Cutout [14] strategies, similar to the implementations in recent studies [42, 7, 24, 69, 13]. The pixel values are directly fed into the input layer at each timestep as direct encoding [55]. ", "page_idx": 18}, {"type": "text", "text": "ImageNet. The ImageNet-1K dataset [11] comprises 1,281,167 training images and 50,000 validation images distributed across 1,000 classes, licensed for non-commercial use. ImageNet-1K images are normalized for zero mean and unit variance. Training images undergo random resized cropping to $224\\mathrm{x}224$ pixels and horizontal flipping, while validation images are resized to $256\\mathrm{x}256$ and then center-cropped to $224\\!\\!\\times\\!224$ . The images are transformed into time sequences through direct encoding [55], following the approach used for CIFAR datasets. ", "page_idx": 18}, {"type": "text", "text": "CIFAR10-DVS. The CIFAR10-DVS dataset [41] is a neuromorphic version of CIFAR-10, which includes 10,000 event-based images captured by the DVS camera with pixel dimensions expanded to ", "page_idx": 18}, {"type": "image", "img_path": "wlcm21C4nk/tmp/2adda57c23d4f574f56a6e60e58298b7db5c45ae25af239973d4156f8825cb75.jpg", "img_caption": ["Figure 6: Empirical measurements conducted on the CIFAR10-DVS dataset. "], "img_footnote": [], "page_idx": 19}, {"type": "text", "text": "$128\\!\\times\\!128$ , licensed under CC BY 4.0. We split the whole dataset into 9000 training images and 1000 testing images. Data preprocessing involves integrating events into frames [21, 19] and reducing the spatial resolution to $48\\mathrm{x}48$ through interpolation. Additional data augmentation includes random horizontal flips and random rolls within a 5-pixel range, mirroring previous methods [76, 48]. ", "page_idx": 19}, {"type": "text", "text": "C.2 Training Setup ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Network Architectures. For the CIFAR-10, CIFAR-100, and CIFAR10-DVS datasets, our method is tested on standard network architectures, including ResNet-18, ResNet-19, and VGG-11 [63, 32, 87, 76, 19, 69]. On the ImageNet dataset, we adapt two variations on ResNet architecture [32], SEW-ResNet-34 [87] specially proposed for SNNs, and ResNet-34 with pre-activation residual blocks [33], aligning with previous works [76, 48, 89]. While OTTT [76] and SLTT [48] frameworks utilize normalization-free techniques under the ResNet-34 framework [5], Zhu et al. [89] substitute these with their custom-designed batch normalization. We directly employ tdBN [87] instead of normalization-free methods in our experiments. ", "page_idx": 19}, {"type": "text", "text": "Training Details. This work utilizes the widely adopted sigmoid-based surrogate gradient [19] to approximate the Heaviside step function using $\\begin{array}{r}{h(x,\\alpha)\\ \\stackrel{\\cdot}{=}\\ \\frac{1}{1+e^{\\alpha x}}}\\end{array}$ and sets $\\alpha\\,=\\,4$ to ensure the maximum derivative of the surrogate function is 1 for preventing gradient explosion. All implementations are based on the PyTorch [53] and SpikingJelly [19] frameworks. The experiments on CIFAR-10, CIFAR-100, and CIFAR10-DVS datasets run on one NVIDIA GeForce RTX 3090 GPU. For ImageNet, distributed data parallel processing is utilized across eight NVIDIA GeForce RTX 4090 GPUs. We use the SGD optimizer [58] with a momentum of 0.9 for all tasks, integrating a cosine annealing strategy [45] for the learning rate schedule. Other hyperparameters are listed in Table 3. ", "page_idx": 19}, {"type": "table", "img_path": "wlcm21C4nk/tmp/7d473fcdfb0125650fd7bfa6243b8cc39db835c0b6ca92586ff0f87d6f078e4c.jpg", "table_caption": ["Table 3: Training hyperparameters. "], "table_footnote": [], "page_idx": 19}, {"type": "text", "text": "D More Results ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "D.1 Empirical Validation on CIFAR10-DVS ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "As shown in Figure 6, we extend conduct empirical experiments on CIFAR10-DVS as avalidation in the case of dynamic datasets. The observations confirm that, even in data with a degree of temporal information, the empirical validation of the assumptions remains consistent with expectations. This alignment emphasizes that the approximate relationship between rate-based backpropagation and BPTT remains substantially consistent. As a result, this stability ensures that our approach continues to effectively extract rate-based representations from neuromorphic datasets with a degree of temporal dynamics, thereby maintaining robust performance across diverse data scenarios. ", "page_idx": 19}, {"type": "text", "text": "D.2 Extended Performance Comparisons with BPTT ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "We conduct additional experiments to illustrate the comparative performance of rate-based backpropagation versus BPTT, as presented in Table 4 for CIFAR-10 and Table 5 for CIFAR-100. These experiments span various configurations, including different network architectures\u2014ResNet-18, ", "page_idx": 19}, {"type": "table", "img_path": "wlcm21C4nk/tmp/e86f386dba7640e16788cd5cd8502c99e5ae4e76250d63fd94ca31162475cbe0.jpg", "table_caption": ["Table 4: Performance comparison of rate-based backpropagation and BPTT on CIFAR-10. "], "table_footnote": [], "page_idx": 20}, {"type": "table", "img_path": "wlcm21C4nk/tmp/9b537fbeb999af9a7ebe014cd70756d5e754d1805b78047fcffb5b573bf10812.jpg", "table_caption": ["Table 5: Performance comparison of rate-based backpropagation and BPTT on CIFAR-100. "], "table_footnote": [], "page_idx": 21}, {"type": "text", "text": "Table 6: Comparison results of performance and training costs across various timesteps. All units for time measurements are in seconds per batch. Experiments were conducted on NVIDIA GeForce RTX 4090, with training settings consistent with other experiments. ", "page_idx": 22}, {"type": "table", "img_path": "wlcm21C4nk/tmp/6063ddabf7e08b7ef7c62b4c477f17fb5ade7d4c1eee30d106b75d1ed404ad9e.jpg", "table_caption": [], "table_footnote": [], "page_idx": 22}, {"type": "text", "text": "ResNet-19, and VGG-11\u2014and timesteps $(\\mathrm{T}{=}2,4,6)$ ). The results demonstrate that rate-based backpropagation maintains competitive accuracy with BPTT across different architectures and timestep settings on benchmark datasets. ", "page_idx": 22}, {"type": "text", "text": "D.3 Comprehensive Evaluation of Training Costs ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "To enhance the understanding of the scalability of the proposed method, we extended our analysis to include training costs across the CIFAR-100 and ImageNet datasets, utilizing additional network architectures as detailed in Table 6. This comprehensive evaluation aimed to assess the impact of varying time steps on performance, memory, and time costs. We integrated the computation of eligibility traces during the forward process, ensuring a fair comparison by incorporating these iterative computations into the overall cost assessment. The results reveal that the total cost of rate-based backpropagation demonstrates a clear advantage over BPTT when timesteps $T\\geq2$ , which underscores the efficiency of the proposed method approach in managing computational resources while maintaining comparative performance across various datasets and network architectures. ", "page_idx": 22}, {"type": "text", "text": "", "page_idx": 23}, {"type": "text", "text": "E Social Impacts and Limitations ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "There is no direct negative societal impact since this work centers on enhancing the training efficiency of SNNs. SNNs inherently require less energy for inference compared to ANNs, helping reduce carbon dioxide emissions. The methods developed in this work further optimize SNNs training by improving both memory and time efficiency, potentially reducing the overall resource consumption and environmental footprint of training processes. Regarding limitations, this work primarily compares with BPTT baselines, and there is potential for incorporating strategies from state-of-the-art techniques in future work. Moreover, the proposed method is tailored for tasks that utilize rate-coding, designed to efficiently capture spatial rate-based feature representations to enhance training; therefore, it necessitates further adaptation to effectively manage sequential tasks. Future efforts may need to delve deeper into adapting the dynamic characteristics of spikes and robustly designing training hyperparameters, ensuring compatibility with rate-based backpropagation and extending applicability to a wider range of applications. ", "page_idx": 23}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: See Abstract and Section 1. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 24}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Justification: See Appendix E. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 24}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: See Section 4 and Appendix A. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 25}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: See Section 4.4, Appendix B and Appendix C. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 25}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: See Supplementary Materials. Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 26}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: See Appendix C. Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 26}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Justification: See Section 5. Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 26}, {"type": "text", "text": "", "page_idx": 27}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: See Appendix C. Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 27}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: This research conforms to the NeurIPS Code of Ethics. Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 27}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Justification: See Appendix E. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to ", "page_idx": 27}, {"type": "text", "text": "generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster. ", "page_idx": 28}, {"type": "text", "text": "\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology. \u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 28}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 28}, {"type": "text", "text": "Justification: No such risks. Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 28}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: See Appendix C. Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 28}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 29}, {"type": "text", "text": "Justification: We do not use new assets. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 29}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 29}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 29}, {"type": "text", "text": "Justification: We use the existing common datasets. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 29}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 29}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 29}, {"type": "text", "text": "Justification: We use the existing common datasets. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 29}]