[{"type": "text", "text": "SnapKV: LLM Knows What You Are Looking for before Generation ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Yuhong ${\\bf L i}^{1*}$ Yingbing Huang1\u2217 Bowen Yang2 Bharat Venkitesh2 Acyr Locatelli2 Hanchen $\\mathbf{Y}\\mathbf{e}^{1}$ Tianle Cai3 Patrick Lewis2 Deming Chen1 ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "1 University of Illinois Urbana-Champaign 2 Cohere 3 Princeton University 1{leeyh, yh21, hanchen8, dchen}@illinois.edu 2{bowen, bharat, acyr, patrick}@cohere.com 3tianle.cai@princeton.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Large Language Models (LLMs) have made remarkable progress in processing extensive contexts, with the Key-Value (KV) cache playing a vital role in enhancing their performance. However, the growth of the KV cache in response to increasing input length poses challenges to memory and time efficiency. To address this problem, this paper introduces SnapKV, an innovative and fine-tuning-free approach that efficiently minimizes KV cache size while still delivering comparable accuracy in real-world applications. ", "page_idx": 0}, {"type": "text", "text": "We discover that each attention head in the model consistently focuses on specific prompt attention features during generation. Meanwhile, this robust pattern can be obtained from an \u2018observation\u2019 window located at the end of the prompts. Drawing on this insight, SnapKV automatically compresses KV caches by selecting clustered important KV positions for each attention head. Our approach significantly reduces the growing computational overhead and memory footprint when processing long input sequences. Specifically, SnapKV achieves a consistent decoding speed with a $3.6\\mathrm{x}$ increase in generation speed and an $8.2\\mathbf{x}$ enhancement in memory efficiency compared to the baseline when processing inputs of 16K tokens. At the same time, it maintains comparable performance to the baseline models across 16 long sequence datasets. Moreover, SnapKV can process up to 380K context tokens on a single A100-80GB GPU using HuggingFace implementation with minor changes, exhibiting only a negligible accuracy drop in the Needle-in-a-Haystack test. Further comprehensive studies suggest SnapKV\u2019s potential for practical applications. Our code is available at https://github.com/FasterDecoding/SnapKV. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Many leading LLMs have started to handle longer contexts, overcoming the difficulties in context maintenance and attention mechanism scalability, such as GPT-4 [1] and Command-R [2] with context length 128K, Claude-3 [3] with 200K, and Gemini-Pro-1.5 with 1M [4]. Despite their impressive capabilities, LLMs still face significant challenges when dealing with long context prompts. Specifically, the KV cache in attention calculation becomes less efficient when processing long context. During inference time, as prompt length increases, the decoding latency per step grows linearly due to the attention calculation across past KVs. Moreover, the large KV cache requires significant memory capacity, increasing hardware demands and limiting model scalability. ", "page_idx": 0}, {"type": "image", "img_path": "poE54GOq2l/tmp/d1eba9a7f8ae1cc7b5ed2a2fc9f8a321d983bea20dd55349a55e3019af11e21f.jpg", "img_caption": ["Figure 1: The graph shows the simplified workflow of SnapKV, where the orange area represents the cluster of features per head selected by SnapKV. These features are then used to form new Key-Value pairs concatenated with the features in the observation window. Together, the selected prefix and observation windows constitute the new KV cache utilized for the generation. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "There are many approaches to mitigate these problems, such as KV cache eviction during generation stage [5\u20138]. However, most of these methods lack a detailed evaluation in long-context settings. Moreover, they mainly focus on compressing the KV cache appended during decoding steps, while overlooking the realistic problem of compressing KV cache for prompts, which is typically the bottleneck in memory efficiency. In practical applications like chatbots and agents, where prompts range from multi-turn conversations to extensive articles or codebases [1, 9\u201311], prompts are often much larger than generated responses such as summaries and code pieces, thus creating significant inference latency and memory utilization overhead. Additional challenge lies in compressing KV cache for such vast prompts without losing crucial information for accurate generation, especially in scenarios with various noisy contexts. ", "page_idx": 1}, {"type": "text", "text": "In our paper, we find an vital attention allocation phenomenon: only a subset of prompt tokens convey essential information for response generation, and these tokens remain unchanged during generation. To validate the robustness, we design extensive experiments across diverse prompts in terms of length, format, and content. From our observations, we derive an innovative and intuitive method, SnapKV, which can smartly identify the attention allocation pattern and compress the KV cache for long sequence prompts without compromising the model\u2019s accuracy. With its comprehensive design, SnapKV demonstrates its effectiveness on various datasets and can be easily integrated into popular deep-learning frameworks with just a few code adjustments. Our contributions are as follows: ", "page_idx": 1}, {"type": "text", "text": "\u2022 We design experiments to explore the attention allocation pattern during generation, focusing on two key questions: 1. Is there a consistent attention allocation pattern for input sequence tokens? 2. Is it feasible to identify this pattern prior to the generation stage? Our finding suggests that for LLMs, the attention allocation of most input sequence tokens stay consistent during generation. Thus, LLMs knows what you are looking for before generation.   \n\u2022 Inspired by our observations above, we develop an efficient and fine-tuning-free algorithm, SnapKV, which efficiently identifies critical attention features and compresses KV cache correspondingly with minimal model modification (See Fig. 1).   \n\u2022 We evaluate SnapKV across diverse LLMs and long-sequence datasets. SnapKV shows comparable accuracy with full KV caching method while achieving improved decoding speed and memory efficiency. Meanwhile, we conduct the pressure test with Needle-in-a-Haystack to further demonstrate its memory efficiency and information retrieval ability. ", "page_idx": 1}, {"type": "text", "text": "2 Related Works ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Many previous works compress the KV cache by selectively dropping KVs using different algorithms. In StreamLLM [5], only the most recent tokens and attention sinks (first few tokens) are retained to reduce the KV cache size, making it lose the important information carried by the discarded middle tokens 2. Heavy-Hitter Oracle (H2O) [6] introduces a policy that greedily drops KVs during generation based on a scoring function derived from cumulative attention. While this approach effectively compresses the KVs appended to the cache during generation, it overlooks compression of prompt KVs, which is crucial for reducing memory and computational overhead. Building on a similar concept, Adaptive KV Compression (FastGen) [8] implements a dual-phase algorithm that encompasses four KV cache compression policies. Initially, it identifies optimal policies through profliing results obtained from prompt encoding. Subsequently, it dynamically evicts caches during the generation phase based on these policies. Nonetheless, it faces the similar problem with H2O. ScissorHands [7] focuses on identifying and retaining pivotal tokens that exhibit a consistent attention weight pattern with previous token windows during generation steps. However, this method concentrates solely on the window of previous pivotal tokens in generation and neglects the extensive prompt that contains essential information for generating accurate responses. This oversight could lead to an inability to extract detailed information from prompts. ", "page_idx": 1}, {"type": "image", "img_path": "poE54GOq2l/tmp/2fcbef7aaf8b3cd88e3fa02080a86212eea9ba386f3616bf76840c459153b1c4.jpg", "img_caption": ["Figure 2: The overlap rates between attention features of the input sequence, selected by various windows along the input and during generation, with each line representing a model layer. "], "img_footnote": [], "page_idx": 2}, {"type": "image", "img_path": "poE54GOq2l/tmp/818dcbd207978e26c3ed5dd6567697a8a1e539f6b1b2fc8326c88961c3231406.jpg", "img_caption": ["Figure 3: The layer-wise overlap rates between input sequence attention features selected by the last window of input sequence and those selected by 4 windows along generation. "], "img_footnote": [], "page_idx": 2}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "In summary, existing methods have not effectively addressed the challenges encountered in realworld applications, where prompts are exceptionally long yet require accurate information retrieval. Although these techniques may reduce the KV cache size during generation, they do not address the primary challenges of understanding complex prompt contexts, leaving critical issues unresolved. ", "page_idx": 2}, {"type": "text", "text": "3 Observations ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this section, we present our observations regarding the attention allocation patterns in the QueryKey matrix during token generation. Our analysis utilizes samples from Ultrachat [12], a multi-turns, high-quality instruction dataset consisting of 1.4 million dialogues. We further filter the sequences with response length greater than 512 and prompt length greater than 3k. Our findings are concluded into two key observations as follows: ", "page_idx": 2}, {"type": "text", "text": "\u2022 Pattern can be identified before generation. In this experiment, we split the attention features of input sequence of each layer into multiple windows, each with 128 tokens, and calculate the averaged attention weights of the last 20 windows separately. To understand the attention allocation patterns along input sequences, we calculate the overlap rates between important attention features of input sequence (those with high average attention weights) identified by each window and the actual ones used by generation. The experimental results are shown in Fig. 2. ", "page_idx": 2}, {"type": "text", "text": "We observe that the last window of input sequence recognizes highly similar attention allocation pattern with the actual generation. ", "page_idx": 3}, {"type": "text", "text": "\u2022 Pattern is consistent during generation. We study if the positions of features identified as crucial in the last window of input sequence maintain their significance in the subsequent token generation. In the experiment, we split the generated tokens into 4 windows for every layer, each spanning 128 tokens, to compute the averaged overlap rates of these windows versus the last window of input sequence. As shown in Fig. 3, active attention features of input sequence obtained from the last window exhibit remarkable consistency throughout the generation process, as evidenced by high overlap rates. ", "page_idx": 3}, {"type": "text", "text": "4 SnapKV ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "In the attention mechanism, the growth in prompts will significantly increase time complexity for generation due to the Query-Key matrix multiplication. SnapKV addresses this issue by maintaining a constant amount of prompt KVs during generation, significantly reducing serving times for longcontext LLMs. To structure our method coherently, we propose the following terminologies: ", "page_idx": 3}, {"type": "text", "text": "\u2022 Prompt Length $({L_{\\mathrm{prompt}}})$ : The total length of the user-provided input. ", "page_idx": 3}, {"type": "text", "text": "\u2022 Observation Window $(L_{\\mathrm{obs}})$ : The last segment of the prompt. This window is crucial for analyzing the influence of different contexts on attention allocation patterns. ", "page_idx": 3}, {"type": "text", "text": "\u2022 Prefix Length $(L_{\\mathrm{prefix}})$ : The length of the input preceding the observation window. It is part of the prompt and does not include the observation window. Overall, we have: ", "page_idx": 3}, {"type": "equation", "text": "$$\nL_{\\mathrm{prompt}}=L_{\\mathrm{prefix}}+L_{\\mathrm{obs}}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "\u2022 Voting: The process of calculating attention weights for each query within the observation window across all heads, aggregating these weights to highlight the prefix positions that are considered most significant. For a single batch of sequence, formally: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{C}=\\displaystyle\\sum_{i=0}^{L_{\\mathrm{obs}}}\\mathbf{W}_{\\mathrm{obs}}[:,i,:]}\\\\ {I=\\mathrm{Top}_{k}(\\mathbf{C},k)}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\mathrm{Top}_{k}(\\mathbf{C},k)$ selects the indices $I$ of the top $k$ values in tensor $\\mathbf{C}$ per head. $k$ is defined as $\\lfloor(1-p)\\times L_{\\mathrm{prefix}}\\rfloor$ , where $p$ stands for the compression rate. The tensor $\\mathbf{W}_{\\mathrm{obs}}\\in\\mathbb{R}^{N\\times L_{\\mathrm{obs}}\\times L_{\\mathrm{prefix}}}$ represents the subset of the prompt softmax-normalized attention features over $N$ heads. ", "page_idx": 3}, {"type": "text", "text": "\u2022 Hit Rate: We define attention features above a predefined threshold $\\theta$ during generation as important features. The hit rate, $H$ , is the number of important features successfully selected by the previous voting process over the total number of important features. $H$ quantifies the effectiveness of the voting mechanism and is calculated as follows: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\mathbf{M}_{\\mathrm{vote\\_obs}}=\\mathrm{zeros\\_like}(\\mathbf{A}_{\\mathrm{cur}})}\\\\ &{\\mathbf{M}_{\\mathrm{vote\\_obs}}[I]=1}\\\\ &{\\mathbf{M}_{\\mathrm{threshold\\_cur}}=\\mathbb{1}(\\mathbf{A}_{\\mathrm{cur}}>\\theta)}\\\\ &{\\quad\\quad\\quad\\quad\\mathbf{O}=\\mathbf{M}_{\\mathrm{threshold\\_cur}}\\wedge\\mathbf{M}_{\\mathrm{vote\\_obs}}}\\\\ &{\\quad\\quad\\quad\\quad H=\\frac{\\sum\\mathbf{O}}{\\sum\\mathbf{M}_{\\mathrm{threshold\\_cur}}}}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "$\\mathbf{A}_{\\mathrm{cur}}\\,\\in\\,\\mathbb{R}^{N\\times L_{\\mathrm{prefix}}}$ represents the attention features between the current generated query and prefix keys. M selects attention features by indices. The threshold operation fliters $\\mathbf{A}_{\\mathrm{cur}}$ to retain only features with values over $\\theta$ , indicating important attention activations. The $\\mathbf{O}$ measures the overlap between attention features selected by $\\mathbf{M}_{\\mathrm{threshold\\_cur}}$ and $\\mathbf{M}_{\\mathrm{vote\\_obs}}$ , quantifying the alignment of the current attention with previously identified important features. The hit rate $H$ is then computed as the ratio of the sum of overlap $\\mathbf{O}$ to the sum of important features Mthreshold_cur, providing a metric for the efficacy of the attention mechanism in recognizing and emphasizing important attention features within the context. We use $\\mathcal{H}(\\mathbf{M}_{\\mathrm{threshold\\_cur}},\\mathbf{M}_{\\mathrm{vote\\_obs}})$ to denote combination of Eq. 7 and Eq. 8. ", "page_idx": 3}, {"type": "text", "text": "4.1 Observation Window-based Algorithm ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "The core approach of SnapKV involves identifying and selecting the most crucial attention features per head to create the compressed KV cache. Listing 1 shows the PyTorch-style pseudo code of SnapKV. Overall, SnapKV operates through two stages as follows: ", "page_idx": 4}, {"type": "text", "text": "\u2022 Vote for important previous features. By the voting process defined above (Eq. 2), we select the important attention features based on the observation window. Sec. 3 highlights the consistency of the attention allocation pattern within observation windows throughout the generation, suggesting that these selected attention features are also vital for subsequent generation. Furthermore, we implement clustering to retain the features surrounding the selected attention features (Sec. 4.3). Line 8-17 shows the pseudo code of the voting process. ", "page_idx": 4}, {"type": "text", "text": "\u2022 Update and store compressed keys and values. We concatenate the selected attention features with all features within the observation window, which encompasses all features containing the necessary prompt information. Line 18- 24 shows the compressing process. The concatenated KVs are stored for later use in generation, thereby saving memory usage. ", "page_idx": 4}, {"type": "text", "text": "def snap_kv(query_states , key_states , value_states , window_size , max_capacity_prompt ,   \nkernel_size ):   \n2 bsz , num_heads , q_len , head_dim $=$ query_states .shape   \n3 # Ensure it is the prompt phase.   \n4 assert key_states.shape $\\begin{array}{r l}{\\left[-2\\right]}&{{}==}\\end{array}$ query_states .shape [-2]   \n5 if q_len $<$ max_capacity_prompt :   \n6 return key_states , value_states   \n7 else:   \n8 # Compute attention weights of observing window 's queries and prefix context 's Keys.   \n9 attn_weights $=$ compute_attn ( query_states [... , -window_size :, :], key_states ,   \nattention_mask )   \n10 # Sum the weight along the query dimension.   \n1 vote $=$ attn_weights [... , -window_size :, :- window_size ]. sum( ${\\tt d i m}\\!=\\!-2$ )   \n12 # Apply 1D pooling for clustering .   \n3 pool_vote $=$ pool1d(vote , kernel_size $=$ kernel_size , padding= kernel_size //2, stride $=\\!1$ )   \n4 # Select top -k indices based on the pooled weights to identify important positions.   \n15 indices $=$ pool_vote.topk( max_capacity_prompt - window_size , dim $=-1$ ).indices   \n16 # Expand the indices to match the head dimension for gathering.   \n7 indices $=$ indices.unsqueeze (-1).expand (-1, -1, -1, head_dim)   \n18 # Gather the compressed past key and value states based on the selected indices.   \n19 k_past_compress $=$ key_states [... , :-window_size , :]. gather( ${\\tt d i m}\\!=\\!2$ , inde $\\tt x=$ indices)   \n20 v_past_compress $=$ value_states [... , :-window_size , :]. gather( ${\\tt d i m}\\!=\\!2$ , inde $\\mathbf x=;$ indices)   \n21 k_obs $=$ key_states [... , -window_size :, :]   \n22 v_obs $=$ value_states [... , -window_size :, :]   \n23 key_states $=$ torch.cat ([ k_past_compress , k_obs], ${\\tt d i m}\\!=\\!2$ )   \n24 value_states $=$ torch.cat ([ v_past_compress , v_obs], ${\\tt d i m}\\!=\\!2$ )   \n25 return key_states , value_states ", "page_idx": 4}, {"type": "text", "text": "4.2 Robustness Analysis of Hit Rate ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "To understand the robustness of the observation window-based algorithm, we analyze its hit rate on multiple long documents QA datasets including QMSum [13], a query-based multi-domain meeting summarization; Openreview [14], a collection of papers from openreview.net; SPACE [15], an extractive opinion summarization in quantized transformer spaces. The model we probe is Mistral-7B-Instruct-v0.2. Overall, we want to answer the following two questions: ", "page_idx": 4}, {"type": "text", "text": "1. Does the nature of instructions in the prompt affect the hit rate?   \n2. Does the context and instruction positioning affect the hit rate? ", "page_idx": 4}, {"type": "text", "text": "4.2.1 Contextual Dependency of Patterns ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "We analyze whether instructions will affect the selection of important features even if the provided context is the same. Our experiment utilizes different instructions on the same document and selects the important features based on the observation window that consists of both the instructions and their corresponding responses. Then we calculate the hit rates between important features selected by different instruction-response pairs $(A,B)$ within the same document by using $\\mathcal{H}(\\mathbf{M}_{\\mathrm{vote\\_A}},\\mathbf{M}_{\\mathrm{vote\\_B}})$ ", "page_idx": 4}, {"type": "image", "img_path": "poE54GOq2l/tmp/075d3da28ca2eb77ca5847ac0dabded88b49fcc7beed61cb88ec0012f9c8463c.jpg", "img_caption": ["Figure 4: The layer-wise overlap of important positions utilized by different question-answer pairs in the same dataset. "], "img_footnote": [], "page_idx": 5}, {"type": "image", "img_path": "poE54GOq2l/tmp/239f0bff986b83a8459e035b39047089e965d0b9c2559259b21cd016fbbe6b1e.jpg", "img_caption": ["Figure 5: The layer-wise average hit rate of important positions used by prompts with questions at the beginning and the end. "], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "as previously defined. By varying the instructions, we observe that different instructions prioritize different prefix attention features, as indicated by the descending trend in hit rates shown in Fig. 4. Our findings reveal an interesting aspect of KV cache in LLMs: the important attention features change with different instructions. This variability challenges the effectiveness of static compression methods that depend on constant weighted importance or fixed policies [7, 6, 8]. Thus, the complex relationship between context and related KV cache emphasizes the need for context-aware compression strategies and highlights the capability of SnapKV that recognizes this dynamic. In contrast, context-independent compression fail in capturing the dynamic, resulting in a misalignment between the attention distribution during profliing and inference, diminishing the generation quality of LLMs. ", "page_idx": 5}, {"type": "text", "text": "4.2.2 Invariance to Instruction Positions ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Our analysis also extends to the significance of instruction positioning on the interpretability of LLMs and their selection of important features. We calculate the average hit rate for the responses using the same observation window size as in the previous experiment. Our results shown in Fig. 5 indicate that across all three datasets, the hit rates are consistently high regardless of whether instructions are positioned before or after extensive supplementary contexts. This consistency suggests that SnapKV is able to identify attention allocation patterns regardless of the question\u2019s positions. ", "page_idx": 5}, {"type": "text", "text": "4.3 Efficient Clustering via Pooling ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "In LLMs, information retrieval and generation rely on features with high attention weight and are supplemented by copying the rest of features in context using induction heads [16]. Hence, naively selecting the top features results in retaining only portions of details and then losing the completeness of the information. For example, such compression might cause the LLMs to retrieve only the country code of a phone number and hallucinate the rest. Our experiment also revealed that only selecting the features with the highest weights is insufficient (Sec. 5.2). Such sparse selection risks compromising ", "page_idx": 5}, {"type": "image", "img_path": "poE54GOq2l/tmp/742dd4bcf7ad892761d4776f724aab32ba858cc8e4590060bc4d90e3a2005014.jpg", "img_caption": [], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "Figure 6: Needle-in-a-Haystack test performance comparison on single A100-80GB GPU, native HuggingFace implementation with only a few lines of code changed. The ${\\bf X}$ -axis denotes the length of the document (the \u201chaystack\u201d) from 1K to 380K tokens; the y-axis indicates the position that the \u201cneedle\u201d (a short sentence) is located within the document. For example, $50\\%$ indicates that the needle is placed in the middle of the document. Here LWMChat with SnapKV is able to retrieve the needle correctly before 140k and with only a little accuracy drop after. Meanwhile, the original implementation encounters OOM error with $33\\mathbf{k}$ input tokens (white dashed line). ", "page_idx": 6}, {"type": "text", "text": "the contextual integrity encapsulated in between features, thereby reducing accuracy. Based on the insights, we propose a fine-grained clustering algorithm utilizing a pooling layer shown in Line 13. ", "page_idx": 6}, {"type": "text", "text": "5 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "In our experimental setup, we explore the performance of SnapKV across models that can handle extended prompt sequence contexts. First, we deliver a pressure test and benchmark the speed of LWM-Text-Chat-1M [17], which is state-of-the-art regarding its context length. We then conduct an ablation study on Mistral-7B-Instruct-v0.2 to understand the influence of pooling on the model\u2019s information retrieval performance. We assess model performances using the LongBench [18] dataset. Further experiments on compatibility with other acceleration strategies, such as parallel decoding [19], are elaborated in Appendix A. To assess the overhead of SnapKV during the prefliling stage, we present time and memory analysis results in Appendix B. ", "page_idx": 6}, {"type": "text", "text": "5.1 Benchmarks on LWM-Text-Chat-1M ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "LWM-Text-Chat-1M [17] is a 7B instruction-fine-tuned model with up to one million context length.   \nIn this section, we conduct a pressure test on this model and examine its algorithmic efficiencies. ", "page_idx": 6}, {"type": "text", "text": "5.1.1 Needle-in-a-Haystack ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "The Needle-in-a-Haystack test [20] challenges the model to accurately retrieve information from a specific sentence (\"needle\") concealed within an extensive document (the \"haystack\"), with the sentence placed at a random location. Typically, sentences that are inserted in the middle of prompts are harder to retrieve. To rigorously evaluate SnapKV\u2019s capabilities, we extended the document length to 380k tokens which is the longest content that can be processed by a single A100-80GB GPU. We configured the prompt KV cache size to 1024, enabling SnapKV to select the most crucial 1024 attention features from the prompt for answer generation, with a maximum pooling kernel size of 5 and an observation window size of 16, both of which are hyperparameters that can be customized. The compelling outcomes in Fig. 6 from the Needle-in-a-Haystack test underscore SnapKV\u2019s potential to precisely manage small details on extremely long input contexts with a $380\\mathrm{x}$ compression ratio. ", "page_idx": 6}, {"type": "image", "img_path": "poE54GOq2l/tmp/34d544788473d6d32f0b467d259502d479db25e6fc12038d0abedecdb638b513.jpg", "img_caption": ["Figure 7: Decoding latency comparison of baseline implementation and SnapKV optimized solutions on various batch sizes. The ${\\bf X}$ -axis denotes the input sequence length; the y-axis indicates decoding latency (ms/token). All experiments are conducted on an A100 80GB GPU. The red dotted line denotes the common context length of state-of-the-art long sequence models. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "5.1.2 Decoding Speed and Memory Bound ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "We further benchmark the speed of LWM-Text-Chat-1M under different batch-size settings using SnapKV. We set the maximum KV cache size as 2048 for SnapKV, and fix the generation length at 512 to ensure a fair comparison. There are two main takeaways from our experiment on decoding speed and prompt sequence length on various batch sizes, as shown in Fig. 7. First, as the input sequence length increases, the decoding latency of the baseline implementation escalates linearly. Conversely, the SnapKV-optimized model maintains a constant decoding speed since the compressed KV cache size of prompt stays the same regardless of input sequence length and there is no extra update during the inference. For instance, at a sequence length of $16\\mathrm{k}$ and a batch size of 2, the decoding time for the baseline model surpasses $100\\;\\mathrm{ms}$ , whereas for SnapKV-optimized model, the decoding time consistently remains below $40\\,\\mathrm{ms}$ , achieving approximately a $3.6\\mathrm{x}$ speedup. Second, with the same batch size, the model integrated with SnapKV can decode significantly longer sequences. For example, at a batch size of 2, the baseline model encounters an OOM error beyond $16\\mathrm{k}$ input tokens, whereas the SnapKV-enhanced model extends this limit to $131\\mathrm{k}$ input tokens, indicating an approximately $8.2\\mathbf{x}$ improvement. This demonstrates SnapKV\u2019s effectiveness in minimizing memory consumption. ", "page_idx": 7}, {"type": "text", "text": "5.2 Ablation Study of Effectiveness of Pooling ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "We perform an ablation study on Mistral-7B-Instruct-v0.2 to assess the impact of our pooling technique, a straightforward but efficient method for consolidating information through clustering. Our evaluation utilizes the modified LongEval-Lines benchmark [21], incorporating randomly generated pairs and averaged scores. LongEval-Lines presents a greater challenge compared to Needle-in-a-Haystack because it involves identifying key-value pairs in noisy contexts of the same format, while in Needle-in-a-Haystack, the relevant information is more distinctly separated from other contexts. We apply max pooling with a kernel size of 5 and use the observation window with a size of 16, which are hyperparameters and could be customized according to different models. As illustrated in our results (Fig. 8), we find that pooling significantly enhances retrieval accuracy compared to methods not utilizing pooling. We hypothesize that this is because the initial portions of critical token clusters are weighted higher by attention mechanisms. Typically, large language models tend to copy the tokens surrounding the initial portions to keep the contextual integrity. However, naively compressed KV cache breaks this mechanism and could lead to partially correct ", "page_idx": 7}, {"type": "image", "img_path": "poE54GOq2l/tmp/0597f0905003efecc8650c51254c062376a7170352c11bfc75f938b8da01c5c8.jpg", "img_caption": [], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "Figure 8: Ablation study of pooling on LongEval-Lines. The evaluation includes inputs, each comprised of lines formatted as \"line makeshift-penguin: REGISTER_CONTENT is $<\\!10536\\!>^{\\prime\\prime}$ , where the key is an adjective-noun pair and the value is a random 5-digit number. The model needs to retrieve the value based on a given key. The ${\\bf X}$ -axis denotes the length of the input; the y-axis indicates the position of the groundtruth, from 5K to 30K tokens. With the pooling, the model can retrieve correct values before 16k and performs significantly better than the one without pooling. ", "page_idx": 8}, {"type": "table", "img_path": "poE54GOq2l/tmp/6ebe506b974113fd21d2135a956ed4eb4235227e25148fc41301db1dbca4dc27.jpg", "table_caption": ["Table 1: Performance comparison of SnapKV and H2O across various LLMs on LongBench. "], "table_footnote": ["\\* Credit to Jin et al. [22] for the template used in the table. "], "page_idx": 8}, {"type": "text", "text": "results (Fig. 8). Note that throughout our experiments, the choice between max pooling and average pooling did not yield significant differences in performance. ", "page_idx": 8}, {"type": "text", "text": "5.3 Experiments on LongBench ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We evaluate SnapKV on these four models using LongBench [18], a multi-task benchmark designed to rigorously evaluate long context understanding capabilities across various datasets, spanning single and multi-document QA, summarization, few-shot learning, synthetic tasks, and code completion. The average prompt length of LongBench ranges from $5\\mathrm{k}$ to 7k, and more details can be found in Appendix D. We choose LWM-Text-Chat-1M with 1 million context length, LongChat-7b-v1.5-32k, Mistral-7B-Instruct-v0.2, Mixtral-8x7B-Instruct-v0.1 with 32k context length as our baselines. For each model, we test SnapKV with various settings: compressing KV caches in the prompt to 1024, 2048, and 4096 tokens. We use max pooling with kernel size 7 and observation window size 32. Table 1 illustrates a negligible performance drop from models with SnapKV compared with original implementations for 16 different datasets, even with prompt-KV with 1024 tokens. Some models even outperform the baseline. Our results substantiate that SnapKV can grasp the key information in the long context and give comprehensive summaries with details. Moreover, our ", "page_idx": 8}, {"type": "text", "text": "Table 2: The sensitivity analysis was conducted on Mistral-7B-Instruct-v0.2 with a prompt KV cache size set to 1024, evaluating its performance on LongBench across different observation window sizes and pooling kernel dimensions. In previous experiments, a configuration with an observation window size $_{\\mathrm{W}=32}$ and a kernel size $k{=}7$ was employed as the baseline. $\\mathrm{w}{=}32\\,\\mathrm{k}{=}1$ refers to SnapKV without pooling, where we focus on tasks that do not involve information retrieval since we already demonstrate that in Sec. 5.2. ", "page_idx": 9}, {"type": "table", "img_path": "poE54GOq2l/tmp/9f28f1b6cd8472d9247a0fb567d0ade4c83f437bb8a49a4b7c505f61381c9e60.jpg", "table_caption": [], "table_footnote": [], "page_idx": 9}, {"type": "text", "text": "results also indicate the effectiveness of SnapKV in compressing the prompt KV cache. For these 4 models, the average input token length is around $13\\mathbf{k}$ . Thus, using 1024, SnapKV achieves an average compression rate of $92\\%$ , and using 4096, it reaches $68\\%$ , all with negligible drops in accuracy. We compare SnapKV and H2O on the LongBench dataset to further demonstrate the performance of SnapKV. To fairly evaluate the accuracy, we set the prompt capacity for H2O to 4096. As Table 1 shows, SnapKV delivers significantly better performance than H2O. Even with 1024 prompt KV caches, SnapKV on Mistral-7B-Instruct-v0.2 achieves better performance than H2O with 4096 caches on 11 out of 16 benchmarks. ", "page_idx": 9}, {"type": "text", "text": "5.4 Sensitivity Analysis on Hyperparameters ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In SnapKV, we introduce two key hyperparameters: observation window size and pooling kernel size. To further assess the robustness of our method, we perform a sensitivity analysis on Mistral-7B-Instruct-v0.2 with these hyperparameters using the LongBench dataset. As shown in Table 2, different configurations yield the best score across various types of tasks, with no single configuration consistently outperforming others. This indicates that SnapKV demonstrates robustness across a range of configurations. ", "page_idx": 9}, {"type": "text", "text": "Additionally, to better understand the effectiveness of the pooling strategy, we conduct an experiment with a kernel size of 1, representing a configuration without pooling. This analysis focuses primarily on non-retrieval tasks, complementing the retrieval task results in Sec. 5.2. The findings indicate that, in eight out of nine tasks, the model accuracy with pooling exceeds that of configurations without pooling, underscoring the importance of pooling in SnapKV. ", "page_idx": 9}, {"type": "text", "text": "6 Discussions ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "SnapKV is an effective yet straightforward solution that compresses the KV cache to mitigate the computational and memory burdens of processing extensive prompts. Observing that specific tokens within prompts gain consistent attention from each head during generation, our methodology not only retrieve crucial information but also enhances processing efficiency. Despite its strengths, SnapKV\u2019s scope is primarily confined to the generative aspect of models, specifically targeting the KV cache during the generation. This limitation implies that SnapKV cannot extend a model\u2019s long context capability if the model inherently struggles with long contexts or exhibits poor performance. Additionally, SnapKV\u2019s design does not cover the processing of the prompt inference, which limits its effectiveness in scenarios where the system cannot handle prompts of extensive length. Nonetheless, our contributions offer significant insights and tools for the community, paving the way for more refined approaches on managing the challenges of large-scale language modeling. The appendix provides more experiments with parallel decoding and the discussion about generation speedup. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[1] Josh Achiam, Steven Adler, Sandhini Agarwal, Lama Ahmad, Ilge Akkaya, Florencia Leoni Aleman, Diogo Almeida, Janko Altenschmidt, Sam Altman, Shyamal Anadkat, et al. Gpt-4 technical report. arXiv preprint arXiv:2303.08774, 2023.   \n[2] Cohere. Command r: Retrieval-augmented generation at production scale, March 2024. URL https://txt.cohere.com/command-r.   \n[3] Anthropic. The claude 3 model family: Opus, sonnet, haiku, March 2024. URL https://www-cdn.anthropic.com/de8ba9b01c9ab7cbabf5c33b80b7bbc618857627/ Model_Card_Claude_3.pdf.   \n[4] Machel Reid, Nikolay Savinov, Denis Teplyashin, Dmitry Lepikhin, Timothy Lillicrap, Jeanbaptiste Alayrac, Radu Soricut, Angeliki Lazaridou, Orhan Firat, Julian Schrittwieser, et al. Gemini 1.5: Unlocking multimodal understanding across millions of tokens of context. arXiv preprint arXiv:2403.05530, 2024.   \n[5] Guangxuan Xiao, Yuandong Tian, Beidi Chen, Song Han, and Mike Lewis. Efficient streaming language models with attention sinks. arXiv preprint arXiv:2309.17453, 2023.   \n[6] Zhenyu Zhang, Ying Sheng, Tianyi Zhou, Tianlong Chen, Lianmin Zheng, Ruisi Cai, Zhao Song, Yuandong Tian, Christopher R\u00e9, Clark Barrett, et al. H2o: Heavy-hitter oracle for efficient generative inference of large language models. Advances in Neural Information Processing Systems, 36, 2024.   \n[7] Zichang Liu, Aditya Desai, Fangshuo Liao, Weitao Wang, Victor Xie, Zhaozhuo Xu, Anastasios Kyrillidis, and Anshumali Shrivastava. Scissorhands: Exploiting the persistence of importance hypothesis for llm kv cache compression at test time. Advances in Neural Information Processing Systems, 36, 2024.   \n[8] Suyu Ge, Yunan Zhang, Liyuan Liu, Minjia Zhang, Jiawei Han, and Jianfeng Gao. Model tells you what to discard: Adaptive kv cache compression for llms. arXiv preprint arXiv:2310.01801, 2023.   \n[9] Bing Liu and Sahisnu Mazumder. Lifelong and continual learning dialogue systems: learning during conversation. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 35, pages 15058\u201315063, 2021.   \n[10] Ramakrishna Bairi, Atharv Sonwane, Aditya Kanade, Arun Iyer, Suresh Parthasarathy, Sriram Rajamani, B Ashok, Shashank Shet, et al. Codeplan: Repository-level coding using llms and planning. arXiv preprint arXiv:2309.12499, 2023.   \n[11] Jingru Jia, Zehua Yuan, Junhao Pan, Paul McNamara, and Deming Chen. Decision-making behavior evaluation framework for llms under uncertain context. arXiv preprint arXiv:2406.05972, 2024.   \n[12] Ning Ding, Yulin Chen, Bokai Xu, Yujia Qin, Zhi Zheng, Shengding Hu, Zhiyuan Liu, Maosong Sun, and Bowen Zhou. Enhancing chat language models by scaling high-quality instructional conversations. arXiv preprint arXiv:2305.14233, 2023.   \n[13] Ming Zhong, Da Yin, Tao Yu, Ahmad Zaidi, Mutethia Mutuma, Rahul Jha, Ahmed Hassan Awadallah, Asli Celikyilmaz, Yang Liu, Xipeng Qiu, et al. Qmsum: A new benchmark for query-based multi-domain meeting summarization. arXiv preprint arXiv:2104.05938, 2021.   \n[14] Chenxin An, Shansan Gong, Ming Zhong, Mukai Li, Jun Zhang, Lingpeng Kong, and Xipeng Qiu. L-eval: Instituting standardized evaluation for long context language models. arXiv preprint arXiv:2307.11088, 2023.   \n[15] Stefanos Angelidis, Reinald Kim Amplayo, Yoshihiko Suhara, Xiaolan Wang, and Mirella Lapata. Extractive opinion summarization in quantized transformer spaces. Transactions of the Association for Computational Linguistics, 9:277\u2013293, 2021.   \n[16] Catherine Olsson, Nelson Elhage, Neel Nanda, Nicholas Joseph, Nova DasSarma, Tom Henighan, Ben Mann, Amanda Askell, Yuntao Bai, Anna Chen, et al. In-context learning and induction heads. arXiv preprint arXiv:2209.11895, 2022.   \n[17] Hao Liu, Wilson Yan, Matei Zaharia, and Pieter Abbeel. World model on million-length video and language with ringattention. arXiv preprint arXiv:2402.08268, 2024.   \n[18] Yushi Bai, Xin Lv, Jiajie Zhang, Hongchang Lyu, Jiankai Tang, Zhidian Huang, Zhengxiao Du, Xiao Liu, Aohan Zeng, Lei Hou, et al. Longbench: A bilingual, multitask benchmark for long context understanding. arXiv preprint arXiv:2308.14508, 2023.   \n[19] Tianle Cai, Yuhong Li, Zhengyang Geng, Hongwu Peng, Jason D Lee, Deming Chen, and Tri Dao. Medusa: Simple llm inference acceleration framework with multiple decoding heads. arXiv preprint arXiv:2401.10774, 2024.   \n[20] G Kamradt. Needle in a haystack\u2013pressure testing llms, 2023.   \n[21] Dacheng Li, Rulin Shao, Anze Xie, Ying Sheng, Lianmin Zheng, Joseph Gonzalez, Ion Stoica, Xuezhe Ma, and Hao Zhang. How long can context length of open-source llms truly promise? In NeurIPS 2023 Workshop on Instruction Tuning and Instruction Following, 2023.   \n[22] Hongye Jin, Xiaotian Han, Jingfeng Yang, Zhimeng Jiang, Zirui Liu, Chia-Yuan Chang, Huiyuan Chen, and Xia Hu. Llm maybe longlm: Self-extend llm context window without tuning. arXiv preprint arXiv:2401.01325, 2024.   \n[23] Mitchell Stern, Noam Shazeer, and Jakob Uszkoreit. Blockwise parallel decoding for deep autoregressive models. Advances in Neural Information Processing Systems, 31, 2018.   \n[24] Yaniv Leviathan, Matan Kalman, and Yossi Matias. Fast inference from transformers via speculative decoding. In International Conference on Machine Learning, pages 19274\u201319286. PMLR, 2023.   \n[25] Charlie Chen, Sebastian Borgeaud, Geoffrey Irving, Jean-Baptiste Lespiau, Laurent Sifre, and John Jumper. Accelerating large language model decoding with speculative sampling. arXiv preprint arXiv:2302.01318, 2023.   \n[26] Xupeng Miao, Gabriele Oliaro, Zhihao Zhang, Xinhao Cheng, Zeyu Wang, Rae Ying Yee Wong, Zhuoming Chen, Daiyaan Arfeen, Reyna Abhyankar, and Zhihao Jia. Specinfer: Accelerating generative llm serving with speculative inference and token tree verification. arXiv preprint arXiv:2305.09781, 2023.   \n[27] Aonan Zhang, Chong Wang, Yi Wang, Xuanyu Zhang, and Yunfei Cheng. Recurrent drafter for fast speculative decoding in large language models. arXiv preprint arXiv:2403.09919, 2024.   \n[28] Tri Dao, Dan Fu, Stefano Ermon, Atri Rudra, and Christopher R\u00e9. Flashattention: Fast and memory-efficient exact attention with io-awareness. Advances in Neural Information Processing Systems, 35:16344\u201316359, 2022.   \n[29] Tri Dao. Flashattention-2: Faster attention with better parallelism and work partitioning. arXiv preprint arXiv:2307.08691, 2023.   \n[30] Tri Dao, Daniel Haziza, Francisco Massa, and Grigory Sizov. Flash-decoding for long-context inference, 2023.   \n[31] Pradeep Dasigi, Kyle Lo, Iz Beltagy, Arman Cohan, Noah A Smith, and Matt Gardner. A dataset of information-seeking questions and answers anchored in research papers. arXiv preprint arXiv:2105.03011, 2021. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "A Case Study: Compatibility with Parallel Decoding ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "In this section, we provide a novel perspective on employing KV cache compression synergistically with parallel decoding [23\u201327]. Parallel decoding leverages a lightweight model or an adaptor to draft initial tokens, which are subsequently verified by larger LLMs. This strategy effectively reduces memory overhead, a critical concern given the autoregressive nature of LLMs that renders them more memory-intensive than computationally demanding. Specifically, in LLMs, each decoding step involves generating a single token, with the transfer of weights between High Bandwidth Memory (HBM) and cache contributing to significant overhead [28, 29]. ", "page_idx": 12}, {"type": "text", "text": "Our investigation incorporates SnapKV with Medusa $[19]^{3}$ , a cutting-edge parallel decoding framework that utilizes multiple classifiers and tree attention mechanisms for drafting tokens, subsequently verified by LLMs. One of the challenges identified is the issue of speculative decoding in processing long sequences since generating multiple tokens per decoding step introduces computational bottlenecks during long sequence processing, such as query-key matrix multiplication tiling [30]. By maintaining a constant size for the KV cache associated with prompts during generation, SnapKV enhances generation efficiency. ", "page_idx": 12}, {"type": "text", "text": "Empirical results shown in Figure 9 highlight the performance across various prompt lengths, with Mistral-7B-Instruct-v0. $2^{4}$ undergoing a maximum of 128 generation steps unless preemptively halted. The experiments utilized a subset of the QASPER [31], with a fixed prompt instructing the LLM to summarize the paper. The truncation strategy adopted aligns with LongBench [18] standards, by removing the context in the middle to achieve the desired sequence length for benchmarking. ", "page_idx": 12}, {"type": "text", "text": "The findings indicate a slowdown in Medusa\u2019s performance as sequence lengths extend, a challenge effectively mitigated by SnapKV\u2019s intervention, which achieved a $1.3\\mathbf{x}$ speedup for sequences with $10\\mathbf{k}$ length compared to Medusa and a $2.2\\mathbf{x}$ speedup compared to the native decoding. This improvement underscores the potential of combining KV cache compression with parallel decoding frameworks to enhance LLM efficiency, particularly in long-context scenarios. ", "page_idx": 12}, {"type": "image", "img_path": "poE54GOq2l/tmp/4a9cb0e7de724b57ecaa79a6ac3be147edafb514a2f3892e0e69c4c6cbef4f95.jpg", "img_caption": ["Figure 9: Comparison of generation latency (ms/token). The baseline is the Huggingface implementation of naive decoding. "], "img_footnote": [], "page_idx": 12}, {"type": "text", "text": "B Overhead Analysis of Prefilling Stage ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "We evaluate the prefilling time and memory usage on Mistral-7B-Instruct-v0.2 with input sequence lengths ranging from $5\\mathrm{k}$ to $45\\mathrm{k}$ in Fig. 10. The results show no overhead in either aspect. SnapKV only introduces extra top-k and pooling operations which are trivial regarding computation complexity compared with original prefilling calculations. ", "page_idx": 13}, {"type": "image", "img_path": "poE54GOq2l/tmp/fb2d7b6f20198197e5b8e5db7ad7df4bb683d691852bcd3e2def66a8bfaa8331.jpg", "img_caption": ["Figure 10: The prefilling time and maximum memory allocated comparison between Mistral-7B-Instruct-v0.2 with and without SnapKV on an H100. "], "img_footnote": [], "page_idx": 13}, {"type": "text", "text": "C Discussion of Generation Time Speedup ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "To better assess SnapKV\u2019s effectiveness across different stages, we documented a detailed time breakdown for Mistral-7B-Instruct-v0.2 during both the prompting and generation stages. We configured the model to consistently generate 512 tokens, facilitating a direct comparison with the prompting stage. As illustrated in Fig. 11, generation time dominates the whole processing time for LLMs over input sequences, introducing significant overhead. While the generation time for the original model increases with input length, SnapKV maintains a consistent decoding speed regardless of input length, significantly reducing generation time. Especially, SnapKV is able to achieve balanced prompting time and generation time with input length smaller than 100k. ", "page_idx": 13}, {"type": "image", "img_path": "poE54GOq2l/tmp/070b84374edb0d8e8250f827ef08f9533431980de5b74843500e25da793de1dc.jpg", "img_caption": ["Figure 11: The prompting time and generation time comparison between Mistral model with and without SnapKV. "], "img_footnote": [], "page_idx": 13}, {"type": "text", "text": "D Statistics of LongBench Dataset ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Here we provide more statistical information on LongBench in Table 3 to provide more insights on our results in 5.3. ", "page_idx": 14}, {"type": "text", "text": "Table 3: Sequence Length Statistics for LongBench Benchmark ", "page_idx": 14}, {"type": "table", "img_path": "poE54GOq2l/tmp/4f652610579ac43a2a589714f7e13eba991878449d83036bceca6467c939d03e.jpg", "table_caption": [], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "E Visulization of the Generated Context ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Prompt(length 20581)  from Qasper ", "text_level": 1, "page_idx": 15}, {"type": "image", "img_path": "poE54GOq2l/tmp/f35a26be3618404cbbe46532d32ebc144e12634bc2e0e3e13727ef58c29adec8.jpg", "img_caption": [], "img_footnote": [], "page_idx": 15}, {"type": "text", "text": "Figure 12: Visualization of generation examples from Samsum, Qasper, HotpotQA datasets with mistral-7B-instruct-v0.2. Results are compared between ground truth, SnapKV with 1024 prompt tokens, with 2048, with 4096, the baseline model with full KV cache. ", "page_idx": 15}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "The checklist is designed to encourage best practices for responsible machine learning research, addressing issues of reproducibility, transparency, research ethics, and societal impact. Do not remove the checklist: The papers not including the checklist will be desk rejected. The checklist should follow the references and follow the (optional) supplemental material. The checklist does NOT count towards the page limit. ", "page_idx": 16}, {"type": "text", "text": "Please read the checklist guidelines carefully for information on how to answer these questions. For each question in the checklist: ", "page_idx": 16}, {"type": "text", "text": "\u2022 You should answer [Yes] , [No] , or [NA] . ", "page_idx": 16}, {"type": "text", "text": "\u2022 [NA] means either that the question is Not Applicable for that particular paper or the relevant information is Not Available. \u2022 Please provide a short (1\u20132 sentence) justification right after your answer (even for NA). ", "page_idx": 16}, {"type": "text", "text": "The checklist answers are an integral part of your paper submission. They are visible to the reviewers, area chairs, senior area chairs, and ethics reviewers. You will be asked to also include it (after eventual revisions) with the final version of your paper, and its final version will be published with the paper. ", "page_idx": 16}, {"type": "text", "text": "The reviewers of your paper will be asked to use the checklist as one of the factors in their evaluation. While \"[Yes] \" is generally preferable to \"[No] \", it is perfectly acceptable to answer \"[No] \" provided a proper justification is given (e.g., \"error bars are not reported because it would be too computationally expensive\" or \"we were unable to find the license for the dataset we used\"). In general, answering \"[No] \" or \"[NA] \" is not grounds for rejection. While the questions are phrased in a binary way, we acknowledge that the true answer is often more nuanced, so please just use your best judgment and write a justification to elaborate. All supporting evidence can appear either in the main paper or the supplemental material, provided in appendix. If you answer [Yes] to a question, in the justification please point to the section(s) where related material for the question can be found. ", "page_idx": 16}, {"type": "text", "text": "IMPORTANT, please: ", "page_idx": 16}, {"type": "text", "text": "\u2022 Delete this instruction block, but keep the section heading \u201cNeurIPS paper checklist\", \u2022 Keep the checklist subsection headings, questions/answers and guidelines below. ", "page_idx": 16}, {"type": "text", "text": "", "page_idx": 16}, {"type": "text", "text": "\u2022 Do not modify the questions and only use the provided macros for your answers. ", "page_idx": 16}, {"type": "text", "text": "1. Claims ", "page_idx": 16}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 16}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Justification: the contribution and scope can be found in Sec. 4, 5 ", "page_idx": 16}, {"type": "text", "text": "Guidelines: ", "page_idx": 16}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper. ", "page_idx": 16}, {"type": "text", "text": "\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers. ", "page_idx": 16}, {"type": "text", "text": "\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings. \u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 17}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 17}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 17}, {"type": "text", "text": "Justification: we discuss the limitations and future directions in conclusion Sec. 6 ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 17}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 17}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 17}, {"type": "text", "text": "Justification: we do not include any theoretical results in this paper. ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results. \u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced. ", "page_idx": 17}, {"type": "text", "text": "\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems. \u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition. \u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material. \u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 18}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 18}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 18}, {"type": "text", "text": "Justification: we include needed experiment details in Sec. 5 ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 18}, {"type": "text", "text": "5. Open access to data and code ", "page_idx": 18}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: we provide psudo code in Listing. 1 to implement SnapKV and include needed experiment details in Sec. 5 ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 19}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Justification: for every experiment, we mention all the needed details in Sec. 5 ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 19}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: all experiments detailed results are included in Sec. 5 ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 20}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: we mention computer resources we use for experiments and provide the memory and latency information, which could all be found in Sec. 5 ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 20}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: we keep all information credential and strictly follow the NeurIPS Code of Ethics. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 21}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: we discuss the contribution and weakness in discussion Sec, 6 ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 21}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 21}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 21}, {"type": "text", "text": "Justification: we do not release any new models or datasets in the paper. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 22}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: we credit all mentioned assets in reference ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 22}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: we provide a new algorithm that can be used on many existing models, and do not introduce any more assets. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets. ", "page_idx": 22}, {"type": "text", "text": "\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc. ", "page_idx": 22}, {"type": "text", "text": "\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 23}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 23}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 23}, {"type": "text", "text": "Justification: we do not include crowdsourcing nor research with human subjects. All are based on existing automatic evaluator and models. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 23}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 23}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 23}, {"type": "text", "text": "Justification: we do not include crowdsourcing nor research with human subjects. All are based on existing automatic evaluator and models. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 23}]