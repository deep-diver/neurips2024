[{"type": "text", "text": "Bayesian Adaptive Calibration and Optimal Design ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Rafael Oliveira\u2217 Dino Sejdinovic David Howard Edwin V. Bonilla CSIRO\u2019s Data61 University of Adelaide CSIRO\u2019s Data61 CSIRO\u2019s Data61 Sydney, Australia Adelaide, Australia Brisbane, Australia Sydney, Australia ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "The process of calibrating computer models of natural phenomena is essential for applications in the physical sciences, where plenty of domain knowledge can be embedded into simulations and then calibrated against real observations. Current machine learning approaches, however, mostly rely on rerunning simulations over a fixed set of designs available in the observed data, potentially neglecting informative correlations across the design space and requiring a large amount of simulations. Instead, we consider the calibration process from the perspective of Bayesian adaptive experimental design and propose a data-efficient algorithm to run maximally informative simulations within a batch-sequential process. At each round, the algorithm jointly estimates the parameters of the posterior distribution and optimal designs by maximising a variational lower bound of the expected information gain. The simulator is modelled as a sample from a Gaussian process, which allows us to correlate simulations and observed data with the unknown calibration parameters. We show the benefits of our method when compared to related approaches across synthetic and real-data problems. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "In many scientific and engineering disciplines, computer simulation models form an essential part of the process of predicting and reasoning about complex phenomena, especially when real data is scarce. These simulation models depend on the inputs set by the user, commonly referred to as designs, and on a number of parameters representing unknown physical quantities, known as calibration parameters. The problem of setting these parameters so as to closely match observations of the real phenomenon is known as the calibration of computer models. ", "page_idx": 0}, {"type": "text", "text": "The seminal work by Kennedy and O\u2019Hagan [1] introduces the Bayesian framework for calibration of simulation models, using Gaussian processes [2] to account for the differences between the model and reality, as well as for uncertainty in the calibration parameters. While the simulator is an essential tool when obtaining real data is expensive or unfeasible, each run of a simulator may itself involve significant computational resources, especially in applications such as climate science or complex engineering systems. In this situation, it is imperative to run simulations at carefully chosen settings of designs as well as of calibration inputs, using current knowledge to optimise resource use [3\u20135]. ", "page_idx": 0}, {"type": "text", "text": "In this contribution, we bridge Bayesian calibration with adaptive experimental design [6] and use information-theoretic criteria [7] to guide the selection of simulation settings so that they are most informative about the true value of the calibration parameters. We refer to our approach as BACON (Bayesian Adaptive Calibration and Optimal desigN). BACON allows computational resources to be focused on simulations that provide the most value in terms of reducing epistemic uncertainty. Importantly, in contrast to prior work, it optimises designs jointly with calibration inputs in order to capture informative correlations across both spaces. Experimental results on synthetic experiments and a robotic gripper design problem demonstrate the benefits of BACON compared to competitive baselines in terms of computational savings and the quality of the estimated posterior under similar computational constraints. ", "page_idx": 0}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "2 Problem formulation ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Let $f:\\mathcal X\\to\\mathcal Y$ represent a mapping of experimental designs $\\mathbf{x}\\in\\mathcal{X}$ to the outcomes of a physical process $f(\\mathbf{x})\\in\\mathcal{V}\\subset\\mathbb{R}$ . We are given a set of observed outcomes $\\mathbf{y}_{R}=[y_{1},\\cdot\\cdot\\cdot,y_{R}]^{\\mathsf{T}}$ and their associated designs $\\chi_{R}:=\\{\\mathbf{x}_{i}\\}_{i=1}^{R}\\subset\\chi$ . Observations are corrupted by noise as $y_{i}=f(\\mathbf{x}_{i})+\\nu_{i}$ , where $\\nu_{i}\\sim\\mathcal{N}(0,\\sigma_{\\nu}^{2})$ is zero-mean Gaussian noise, for $i\\in\\{1,\\ldots,R\\}$ . In addition, we have access to the output of a computer model $h:\\mathcal{X}\\times\\Theta\\to\\mathbb{R}$ given a design input and simulation parameters. Given an optimal setting for the calibration parameters $\\pmb{\\theta}^{\\ast}\\ \\in\\ \\Theta$ , the simulator $h(\\mathbf{x},\\pmb{\\theta}^{*})$ , can be used to approximate the outcomes of the real physical process $f(\\mathbf{x})$ . However, $\\pmb{\\theta}^{*}$ is unknown, and evaluations of the simulator $h$ are costly, though cheaper than executing real experiments evaluating $f$ . Our task is to optimally estimate $\\pmb{\\theta}^{*}$ given the real data $\\mathbf{y}_{R}$ , outputs of the simulator $h$ and a prior distribution $p(\\pmb{\\theta}^{*})$ , representing initial assumptions about $\\pmb{\\theta}^{*}$ . ", "page_idx": 1}, {"type": "text", "text": "More concretely, let $\\hat{\\mathbf{y}}_{S}:=[h(\\hat{\\mathbf{x}}_{i},\\hat{\\pmb{\\theta}}_{i})]_{i=1}^{S}$ represent simulated outcomes for a set of designs $\\widehat{\\chi}_{S}:=$ $\\{\\hat{\\mathbf{x}}_{i}\\}_{i=1}^{S}\\subset\\mathcal{X}$ and simulation parameters $\\widehat{\\Theta}_{S}:=\\{\\widehat{\\pmb{\\theta}}_{i}\\}_{i=1}^{S}\\subset\\Theta$ . Given the cost of running simulations, we will associate the simulator $h$ with a  latent function (usually referred to as emulator) drawn from a Gaussian process (GP) prior and assume simulation outputs and real data follow a joint probability distribution $p(\\mathbf{y}_{R},\\hat{\\mathbf{y}}_{S},\\pmb{\\theta}^{*})$ . ", "page_idx": 1}, {"type": "text", "text": "In this setting, the Bayesian experimental design objective is to propose a sequence of simulations which will maximise the expected information gain (EIG) about $\\pmb{\\theta}^{*}$ : ", "page_idx": 1}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathrm{EIG}(\\widehat{\\mathcal{X}}_{S},\\widehat{\\Theta}_{S}):=\\mathbb{H}\\!\\big(p(\\pmb{\\theta}^{*}|\\mathbf{y}_{R})\\big)-\\mathbb{E}_{p(\\widehat{\\mathbf{y}}_{S}|\\widehat{\\mathcal{X}}_{S},\\widehat{\\Theta}_{S},\\mathbf{y}_{R})}[\\mathbb{H}\\!\\big(p(\\pmb{\\theta}^{*}|\\mathbf{y}_{R},\\widehat{\\mathbf{y}}_{S})\\big)]}\\\\ &{\\quad\\quad\\quad\\quad\\quad=\\mathbb{E}_{p(\\widehat{\\mathbf{y}}_{S}|\\widehat{\\mathcal{X}}_{S},\\widehat{\\Theta}_{S},\\mathbf{y}_{R})}\\left[\\mathbb{D}_{\\mathrm{KL}}\\!\\big(p(\\pmb{\\theta}^{*}|\\mathbf{y}_{R},\\widehat{\\mathbf{y}}_{S})||p(\\pmb{\\theta}^{*}|\\mathbf{y}_{R})\\big)\\right]}\\\\ &{\\quad\\quad\\quad\\quad\\quad=\\mathbb{I}(\\pmb{\\theta}^{*};\\widehat{\\mathbf{y}}_{S}\\mid\\mathbf{y}_{R},\\widehat{\\mathcal{X}}_{S},\\widehat{\\Theta}_{S})\\,,}\\end{array}\n$$", "text_format": "latex", "page_idx": 1}, {"type": "text", "text": "where $\\mathbb{H}(\\cdot)$ represents the entropy of a probability distribution, $\\mathbb{D}_{\\mathrm{KL}}(\\cdot||\\cdot)$ denotes the Kullback-Leibler divergence, and $\\mathbb{I}(\\pmb{\\theta}^{*};\\hat{\\mathbf{y}}_{S}\\mid\\mathbf{y}_{R})$ is the mutual information between $\\pmb{\\theta}^{*}$ and the simulator output $\\hat{\\mathbf{y}}_{S}$ given the real observations $\\mathbf{y}_{R}$ and the simulator inputs to be optimized. We note here that, in our setting, the real observations $\\mathbf{y}_{R}$ are always fixed. Therefore, intuitively, the EIG above captures the reduction in uncertainty that will be obtained when selecting $(\\widehat{\\mathcal{X}}_{S},\\widehat{\\Theta}_{S})$ averaged over all the possible outcomes $\\hat{\\mathbf{y}}_{S}$ . ", "page_idx": 1}, {"type": "text", "text": "3 Related work ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Our work consists of deriving a Bayesian adaptive experimental design (BAED) approach to the problem of calibration. Therefore, in the following, we will briefly discuss current literature on these two main research areas. ", "page_idx": 1}, {"type": "text", "text": "3.1 Adaptive experimental design ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "The problem of experimental design has a long history [8], spanning from classical fixed design patterns to modern adaptive approaches [9]. Optimal experimental design consists of selecting experiments which will maximise some form of criterion involving a measure of utility of the experiment and its associated costs [10]. Under the Bayesian formulation, uncertainty in the outcomes of the process is considered, and the optimality of a design is measured in terms of its expected utility [11]. Information theory then allows us to quantify information gain as a utility function, which is commonly applied in modern approaches to Bayesian experimental design [12]. ", "page_idx": 1}, {"type": "text", "text": "The estimation of posterior distributions becomes a computational bottleneck for information-theoretic Bayesian frameworks. Recent work has focused on addressing the difficulties in estimating the expected information gain by means of, e.g., variational inference [13], density-ratio estimation [14], importance sampling [15], and the learning of efficient policies to propose designs [16, 17]. These methods, however, usually assume that the simulator is known and inexpensive to evaluate. In contrast, the simulations themselves are modelled as expensive experiments for us, and we apply ", "page_idx": 1}, {"type": "text", "text": "Gaussian process models as emulators to capture uncertainty over the black-box simulator. In addition, traditional BAED approaches assume the prior is trivial to sample from and evaluate densities of, while in our case the starting prior is $p(\\pmb{\\theta}^{*}\\bar{|}\\mathbf{y}_{R})$ , which is likely non-trivial. We refer the reader to the recent review on modern Bayesian methods for experimental design by Rainforth et al. [18] for further details on BAED. ", "page_idx": 2}, {"type": "text", "text": "3.2 Active learning for calibration ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Experimental design approaches generally aim towards the selection of designs for physical experiments, whereas we are concerned with the problem of running optimal simulated experiments for model calibration in the presence of real data. When simulations are resource-intensive, a few methods have been derived based on the Bayesian calibration framework proposed by Kennedy and O\u2019Hagan [1]. Busby and Feraille [19] present an algorithm to learn GP emulators for a simulator which can then be combined with Bayesian inference algorithms, such as Markov chain Monte Carlo [20], to provide a posterior distribution over parameters. In their approach, the optimised variables are solely the calibration parameters, and the selection criterion is based on minimising the integrated mean-square error of the GP predictions. Many other approaches can be applied to this setting by modelling the simulator or its associated likelihood function as a GP, including Bayesian optimisation [3, 21, 22] and methods for adaptive Bayesian quadrature [23, 24]. Besides GPs, other algorithms based on selecting calibration parameters have been derived using ensembles of neural networks [25] and deep reinforcement learning [26]. These frameworks, however, do not allow for the selection of design points, keeping them fixed. ", "page_idx": 2}, {"type": "text", "text": "Allowing for design point decisions to be included, Leatherman et al. [4] presented approaches for combined simulation and physical experimental design based on geometric and prediction-error-based criteria, but using an offline, non-sequential framework. More recently, Marmin and Filippone [5] derived a deep Gaussian process [27] framework for Bayesian calibration problems and discussed an application to experimental design among other examples. Their experimental design approach to calibration was based on choosing simulations that maximally reduce the variational posterior variance over the calibration parameters, as measured by the derivatives of the evidence lower bound with respect to (w.r.t.) variance parameters. In contrast, we aim to directly maximise the information gain w.r.t. the unknown calibration parameters. ", "page_idx": 2}, {"type": "text", "text": "4 Gaussian processes for Bayesian calibration ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "To estimate information gain, we need a probabilistic model which can correlate simulations with real data and the unknown parameters $\\pmb{\\theta}^{*}$ . Ideally, the model needs to allow for a computationally tractable conditioning on the parameters $\\pmb{\\theta}^{*}$ and account for the differences between real and simulated data. Hence, we follow the Bayesian calibration approach in Kennedy and O\u2019Hagan [1] and model: ", "page_idx": 2}, {"type": "equation", "text": "$$\nf(\\mathbf{x})=\\rho h(\\mathbf{x},\\pmb{\\theta}^{*})+\\varepsilon(\\mathbf{x})\\,,\\quad\\mathbf{x}\\in\\mathcal{X},\\quad\\pmb{\\theta}^{*}\\sim p(\\pmb{\\theta}^{*}),\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $\\varepsilon:\\mathcal{X}\\rightarrow\\mathbb{R}$ represents the error (or discrepancy) between simulations and real outcomes, and $\\rho\\in\\mathbb{R}$ accounts for possible differences in scale. We place Gaussian process priors on the simulator $h\\sim\\mathcal{G P}(0,\\hat{k})$ and on the error function $\\varepsilon\\sim\\mathcal{G P}(0,k_{\\varepsilon})$ . ", "page_idx": 2}, {"type": "text", "text": "4.1 Bi-fidelity exact Gaussian process model ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Since both $h$ and $\\varepsilon$ are GPs, simulations and real outcomes can be jointly modelled as a single Gaussian process. In fact, both the simulator $h$ and the true function $f$ can be seen as different levels of fidelity of the same underlying process, with $h$ representing a coarser version of $f$ . Let $s\\in\\mathcal{S}:=\\{0,1\\}$ denote a fidelity parameter. The combined model is then given by: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\hat{f}(\\mathbf x,\\pmb\\theta,s):=\\left\\{\\!\\!\\!\\begin{array}{l l}{h(\\mathbf x,\\pmb\\theta),\\quad}&{s=0}\\\\ {\\rho h(\\mathbf x,\\pmb\\theta)+\\varepsilon(\\mathbf x),\\quad}&{s=1\\,.}\\end{array}\\right.\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "such that $f(\\mathbf{x})=\\hat{f}(\\mathbf{x},\\pmb{\\theta}^{*},1)$ and $h(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}})=\\hat{f}(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},0)$ , for any $\\mathbf{x},\\hat{\\mathbf{x}}\\in\\mathcal{X}$ and $\\hat{\\pmb{\\theta}}\\in\\Theta$ . As a result, for arbitrary points in the joint space $\\mathbf{z},\\mathbf{z}^{\\prime}\\in\\mathcal{Z}:=\\mathcal{X}\\times\\Theta\\times\\mathcal{S}$ , the following covariance function parameterises the combined GP model $\\hat{f}\\sim\\mathcal{G P}(0,k)$ : ", "page_idx": 2}, {"type": "equation", "text": "$$\nk(\\mathbf{z},\\mathbf{z}^{\\prime}):=k_{\\rho}(s,s^{\\prime})\\hat{k}((\\mathbf{x},\\pmb{\\theta}),(\\mathbf{x}^{\\prime},\\pmb{\\theta}^{\\prime}))+s s^{\\prime}k_{\\varepsilon}(\\mathbf{x},\\mathbf{x}^{\\prime})\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $k_{\\rho}(s,s^{\\prime}):=(1+s(\\rho-1))(1+s^{\\prime}(\\rho-1))$ , $\\mathbf{z}:=(\\mathbf{x},\\pmb{\\theta},s)$ , and $\\mathbf{z}^{\\prime}:=(\\mathbf{x}^{\\prime},\\pmb{\\theta}^{\\prime},s^{\\prime})$ . Therefore, any set of real and simulated evaluations are joint normally distributed under a combined GP model. ", "page_idx": 3}, {"type": "text", "text": "4.2 Joint probabilistic model and predictions ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Let $\\mathbf{Z}_{R}:=\\mathbf{Z}_{R}(\\pmb{\\theta}^{*}):=[(\\mathbf{x}_{i},\\pmb{\\theta}^{*},\\mathbf{1})]_{i=1}^{R}$ represent the set of partially observed inputs for real data $\\mathbf{y}_{R}$ , and let $\\widehat{\\mathbf{Z}}_{S}:=[(\\widehat{\\mathbf{x}}_{i},\\widehat{\\pmb{\\theta}},0)]_{i=1}^{S}$ denote the current set of simulation inputs for the observations $\\hat{\\mathbf{y}}_{S}$ . Under the  GP prior, the joint probability model $p(\\hat{\\mathbf{y}}_{S},\\mathbf{y}_{R},\\pmb{\\theta}^{*})$ can be decomposed as: ", "page_idx": 3}, {"type": "equation", "text": "$$\np(\\hat{\\mathbf{y}}_{S},\\mathbf{y}_{R},\\pmb{\\theta}^{*})=p(\\hat{\\mathbf{y}}_{S},\\mathbf{y}_{R}|\\pmb{\\theta}^{*})p(\\pmb{\\theta}^{*})=\\int_{\\hat{\\mathbf{f}}}p(\\hat{\\mathbf{y}}_{S}|\\hat{\\mathbf{f}})p(\\mathbf{y}_{R}|\\hat{\\mathbf{f}},\\pmb{\\theta}^{*})p(\\hat{\\mathbf{f}}|\\pmb{\\theta}^{*})p(\\pmb{\\theta}^{*})\\,\\mathrm{d}\\hat{\\mathbf{f}}\\,,\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\widehat{\\mathbf{f}}:=\\widehat{f}(\\mathbf{Z}(\\pmb{\\theta}^{*}))\\in\\mathbb{R}^{R+S}$ , and ${\\bf Z}(\\pmb{\\theta}^{*}):=\\{{\\bf Z}_{R}(\\pmb{\\theta}^{*}),\\widehat{{\\bf Z}}_{S}\\}$ corresponds to the full set of inputs. The GP prior then allows us to model real and simulated outcomes jointly as a Gaussian random vector $\\hat{\\bf f}$ : ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\hat{\\mathbf{f}}|\\theta^{*}\\sim\\mathcal{N}(\\mathbf{0},\\mathbf{K}(\\theta^{*}))\\,,\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\mathbf{K}(\\pmb\\theta^{*}):=k(\\mathbf{Z}(\\pmb\\theta^{*}),\\mathbf{Z}(\\pmb\\theta^{*}))=[k(\\mathbf{z},\\mathbf{z}^{\\prime})]_{\\mathbf{z},\\mathbf{z}^{\\prime}\\in\\mathbf{Z}(\\pmb\\theta^{*})}$ denotes the prior covariance matrix. Assuming a Gaussian noise model for the observations $y=f(\\mathbf{x},\\pmb{\\theta}^{*})+\\varepsilon(\\mathbf{x})+\\nu$ , with $\\nu\\sim\\mathcal{N}(0,\\sigma_{\\nu}^{2})$ , the marginal distribution over the observations $\\mathbf{y}:=[\\mathbf{y}_{R}^{\\mathsf{T}},\\hat{\\mathbf{y}}_{S}^{\\mathsf{T}}]^{\\mathsf{T}}$ is available in closed form as: ", "page_idx": 3}, {"type": "equation", "text": "$$\np(\\hat{\\mathbf{y}}_{S},\\mathbf{y}_{R}|\\pmb{\\theta}^{*})=\\mathcal{N}(\\mathbf{y};\\mathbf{0},\\mathbf{K}(\\pmb{\\theta}^{*})+\\pmb{\\Sigma}_{\\mathbf{y}})\\,,\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\Sigma_{\\mathbf{y}}$ denotes the covariance matrix of the observation noise, i.e., $[\\pmb{\\Sigma}_{\\mathbf{y}}]_{i i}=\\sigma_{\\nu}^{2}$ for any $\\mathbf{z}_{i}$ with $s_{i}=1$ , and $[\\pmb{\\Sigma}_{\\mathbf{y}}]_{i j}=0$ elsewhere.2 ", "page_idx": 3}, {"type": "text", "text": "Under the GP assumptions, we can make predictions about $\\hat{y}=h(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}})$ at any pair of $\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}}\\in\\mathcal{X}\\times\\Theta$ Conditioning on $\\pmb{\\theta}^{*}$ and a dataset $\\mathcal{D}_{t}:=\\{\\mathcal{X}_{R},\\mathbf{y}_{R},\\widehat{\\mathcal{X}}_{t},\\widehat{\\Theta}_{t},\\hat{\\mathbf{y}}_{t}\\}$ , let $\\mathbf{Z}_{t}(\\pmb{\\theta}^{*}):=\\{\\mathbf{Z}_{R}(\\pmb{\\theta}^{*}),\\widehat{\\mathbf{Z}}_{t}\\}$ denote the set of inputs up to time $t$ conditional on $\\pmb{\\theta}^{*}$ , and $\\mathbf{y}_{t}$ the corresponding outputs. We then have that: ", "page_idx": 3}, {"type": "equation", "text": "$$\np(\\hat{y}|\\pmb{\\theta}^{*},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t})=\\mathcal{N}(\\hat{y};\\mu_{t}(\\hat{\\mathbf{z}};\\pmb{\\theta}^{*}),\\sigma_{t}^{2}(\\hat{\\mathbf{z}};\\pmb{\\theta}^{*}))\\,,\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "for $\\hat{\\mathbf{z}}:=(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}})$ , where: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\mu_{t}(\\hat{\\mathbf{z}};\\theta^{*}):=\\mathbf{k}_{t}^{\\mathsf{T}}(\\hat{\\mathbf{z}};\\theta^{*})^{\\mathsf{T}}(\\mathbf{K}_{t}(\\theta^{*})+\\Sigma_{\\mathbf{y}_{t}})^{-1}\\mathbf{y}_{t}}\\\\ &{k_{t}(\\hat{\\mathbf{z}},\\hat{\\mathbf{z}}^{\\prime};\\theta^{*}):=k(\\hat{\\mathbf{z}},\\hat{\\mathbf{z}}^{\\prime})-\\mathbf{k}_{t}(\\hat{\\mathbf{z}};\\theta^{*})^{\\mathsf{T}}(\\mathbf{K}_{t}(\\theta^{*})+\\Sigma_{\\mathbf{y}_{t}})^{-1}\\mathbf{k}_{t}(\\hat{\\mathbf{z}}^{\\prime};\\theta^{*})}\\\\ &{\\quad\\sigma_{t}^{2}(\\mathbf{z};\\theta^{*}):=k_{t}(\\hat{\\mathbf{z}},\\hat{\\mathbf{z}};\\theta^{*})\\,,}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "with $\\mathbf{k}_{t}(\\hat{\\mathbf{z}};\\pmb{\\theta}^{*}):=k(\\mathbf{Z}_{t}(\\pmb{\\theta}^{*}),\\hat{\\mathbf{z}})$ and $\\mathbf{K}_{t}(\\pmb{\\theta}^{*}):=k(\\mathbf{Z}_{t}(\\pmb{\\theta}^{*}),\\mathbf{Z}_{t}(\\pmb{\\theta}^{*}))$ . We next describe how to apply this model to derive a Bayesian adaptive calibration algorithm. ", "page_idx": 3}, {"type": "text", "text": "5 Bayesian adaptive calibration and optimal design ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "In this section, we describe an approach to design experiments for calibration of computer models that incorporates information gathered during the experiments iteratively. We refer to these types of designs as adaptive. Thus, we consider the sequential design of experiments setting, where at each iteration $t\\in\\mathbb{N}$ , we optimise: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathrm{EIG}_{t}(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}}):=\\mathbb{I}(\\pmb{\\theta}^{*};\\hat{y}\\mid\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})}\\\\ &{\\quad\\quad\\quad\\quad=\\mathbb{I}\\!\\mathbb{I}(p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t-1}))-\\mathbb{E}_{\\hat{y}\\sim p(\\hat{y}\\mid\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})}[\\mathbb{H}(p(\\pmb{\\theta}^{*}|\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1}))]}\\\\ &{\\quad\\quad\\quad\\quad=\\mathbb{E}_{p(\\hat{y},\\pmb{\\theta}^{*}\\mid\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})}\\left[\\log\\frac{p(\\pmb{\\theta}^{*}\\mid\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})}{p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t-1})}\\right],}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "given the dataset $\\mathcal{D}_{t-1}:=\\{\\mathcal{X}_{R},\\mathbf{y}_{R},\\widehat{\\mathcal{X}}_{t-1},\\widehat{\\Theta}_{t-1},\\hat{\\mathbf{y}}_{t-1}\\}$ of observations. Given that the expected information gain is submodular [28], a sequential approach allows us to get close enough (usually a factor of at least $1-1/e$ [29]) to the optimal EIG over the whole experiment, while also allowing algorithmic decisions to adapt to current estimates for $p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t})$ . ", "page_idx": 3}, {"type": "text", "text": "In general, computing the full EIG objective (1), or its sequential version (12), is intractable, as that requires estimating the true posterior and its density conditioned on sampled data. Note that both $p(\\bar{\\pmb\\theta}^{*}|\\hat{y},\\hat{\\mathbf x},\\hat{\\pmb\\theta},\\mathcal D_{t-1}\\bar{)}$ and $p(\\hat{y},\\pmb{\\theta}^{*}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})$ depend on the posterior $p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t-1})$ , as: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{p(\\theta^{*}|\\hat{y},\\hat{\\mathbf{x}},\\hat{\\theta},\\mathcal{D}_{t-1})=\\frac{p(\\hat{y},\\theta^{*}|\\hat{\\mathbf{x}},\\hat{\\theta},\\mathcal{D}_{t-1})}{p(\\hat{y}|\\hat{\\mathbf{x}},\\hat{\\theta},\\mathcal{D}_{t-1})}}\\\\ &{p(\\hat{y},\\theta^{*}|\\hat{\\mathbf{x}},\\hat{\\theta},\\mathcal{D}_{t-1})=p(\\hat{y}|\\theta^{*},\\hat{\\mathbf{x}},\\hat{\\theta},\\mathcal{D}_{t-1})p(\\theta^{*}|\\mathcal{D}_{t-1})\\,,}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where the conditional predictive density $p(\\hat{y}|\\pmb{\\theta}^{*},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})$ is Gaussian and available in closed form (Eq. 8). Clearly, in general, the true posterior is intractable, since p(\u03b8\u2217|Dt) = p(Dtp|(\u03b8D\u2217)tp)(\u03b8\u2217) and $\\begin{array}{r}{p(\\mathcal{D}_{t})=\\int_{\\Theta}p(\\mathcal{D}_{t}|\\pmb{\\theta}^{*})p(\\pmb{\\theta}^{*})\\,\\mathrm{d}\\pmb{\\theta}^{*}}\\end{array}$ involves integration over the entire parameter space $\\Theta$ , which can be high dimensional and passed through highly non-linear operations such as inverse covariances. In addition, the marginal predictive $\\begin{array}{r}{p(\\hat{y}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})=\\int_{\\Theta}p(\\hat{y},\\pmb{\\theta}^{*}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})\\,\\mathrm{d}\\pmb{\\theta}^{*}}\\end{array}$ is usually also intractable for the same reasons. ", "page_idx": 4}, {"type": "text", "text": "5.1 Variational EIG lower bound ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "Following Foster et al. [13], we replace the EIG by a variational objective which does not directly involve the true posterior over $\\pmb{\\theta}^{*}$ . This formulation allows us to jointly estimate an approximation to the posterior and select optimal design points $\\hat{\\bf x}$ and simulation parameters $\\hat{\\pmb\\theta}$ . Applying the variational lower bound by Barber and Agakov [30] to Eq. 12 yields the following alternative to the EIG: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\widehat{\\mathrm{EIG}}_{t}(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},q):=\\mathbb{E}_{p(\\hat{y},\\pmb{\\theta}^{*}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})}\\left[\\log\\frac{q(\\pmb{\\theta}^{*}|\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}})}{p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t-1})}\\right]\\leq\\mathrm{EIG}_{t}(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}}),\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $q(\\theta^{\\ast}|\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}})$ is any conditional probability density model. The gap is given by the expected Kullback-Leibler (KL) divergence between the true and the variational posterior [13]:3 ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathrm{EIG}_{t}(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}})-\\widehat{\\mathrm{EIG}}_{t}(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},q)=\\mathbb{E}_{p(\\hat{y}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})}[\\mathbb{D}_{\\mathrm{KL}}(p(\\theta^{*}|\\mathcal{D}_{t-1},\\hat{y})||q(\\theta^{*}|\\hat{y}))]\\geq0\\,.}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Maximising the variational EIG lower bound w.r.t. the variational distribution $q$ then provides us with an approximation to $p(\\pmb{\\theta}^{*}|\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})$ . Therefore, we can simultaneously obtain maximally informative designs and optimal variational posteriors by jointly optimising the EIG lower bound w.r.t. the simulator inputs and the variational distribution as: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\hat{\\mathbf{x}}_{t},\\hat{\\theta}_{t},q_{t}\\in\\underset{\\hat{\\mathbf{x}}\\in\\mathcal{X},\\hat{\\theta}\\in\\Theta,q\\in\\mathcal{Q}}{\\arg\\operatorname*{max}}\\ \\underset{\\hat{\\mathbf{x}}\\in\\mathcal{X},\\hat{\\theta}\\in\\Theta,q\\in\\mathcal{Q}}{\\widehat{\\mathrm{EIG}}}=\\underset{\\hat{\\mathbf{x}}\\in\\mathcal{X},\\hat{\\theta}\\in\\Theta,q\\in\\mathcal{Q}}{\\arg\\operatorname*{max}}\\mathbb{E}_{p(\\hat{y},\\theta^{*}|\\hat{\\mathbf{x}},\\hat{\\theta},\\mathcal{D}_{t-1})}[\\log q(\\theta^{*}|\\hat{y})]\\,,\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "given a suitable variational family $\\mathcal{Q}$ of conditional distributions. ", "page_idx": 4}, {"type": "text", "text": "5.2 Algorithm ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "Algorithm 1 summarises the method we propose for Bayesian adaptive calibration and optimal design (BACON). The algorithm is given an initial dataset $\\mathcal{D}_{0}$ containing the real data (and possibly previously available simulation data) and an estimate of the posterior given the real data $p_{0}p(\\pmb{\\theta}^{*}|\\mathcal{X}_{R},\\mathbf{y}_{R})$ . Posterior estimates in BACON can be represented by samples obtained via Markov chain Monte Carlo (MCMC) or variational inference over the GP model and the real data $\\mathcal{D}_{0}\\,:=\\,\\{\\boldsymbol{\\chi}_{R},\\mathbf{y}_{R}\\}$ . Note that we only need samples from the previous posterior to estimate the expectation in Eq. 17, with no need to directly evaluate their probability densities. Each iteration starts by optimising the variational EIG lower bound using the objective in Eq. 17 to jointly select an optimal design $\\hat{\\mathbf{x}}_{t}$ , simulation parameters $\\widehat{\\pmb{\\theta}}_{t}$ and variational posterior $q_{t}$ . Given the new design $\\hat{\\mathbf{x}}_{t}$ , we run the simulation with the chosen parameters $\\widehat{\\pmb{\\theta}}_{t}$ , observing a new outcome $\\hat{y}_{t}$ . The calibration posterior $p_{t}(\\pmb{\\theta}^{*})$ and the GP model are then updated with the new data, potentially including a re-estimation of the GP hyper-parameters via, for example, maximum likelihood estimation. The process then repeats given the updated GP and posterior for up to a given number of iterations $T$ . At the end, a final posterior $p_{T}(\\bar{\\pmb{\\theta^{*}}})=p(\\pmb{\\theta^{*}}|\\mathbf{y}_{R},\\bar{\\mathbf{y}}_{T})$ and a conditional density model $q_{T}$ are obtained. ", "page_idx": 4}, {"type": "text", "text": "5.3 Variational posteriors ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Any conditional probability density model $q(\\pmb\\theta^{*}|\\hat{y})$ estimating probability densities over the parameter space $\\Theta$ given an observation $\\hat{y}$ could suit our method. In the following, we describe two possible parameterisations for this model. The first facilitates marginalising latent inputs in GP regression [31, 32], while the second better captures multi-modality in the posterior. ", "page_idx": 5}, {"type": "text", "text": "Conditional Gaussian models. Assuming we can approximate $p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t})$ as a Gaussian, we may set: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r}{q_{\\phi}(\\pmb{\\theta}^{*}|\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}}):=\\mathcal{N}(\\pmb{\\theta}^{*};\\mathbf{m}_{\\phi}(\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}}),\\pmb{\\Sigma}_{\\phi}(\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}}))\\,,}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\mathbf{m}_{\\phi}$ and $\\Sigma_{\\phi}$ are given by parametric models, such as neural networks, with parameters $\\phi$ . To ensure $\\Sigma_{\\phi}(\\cdot)$ is positive-definite, it can be parameterised by its Cholesky decomposition $\\begin{array}{r}{\\Sigma_{\\phi}(\\cdot)=\\mathbf{L}_{\\phi}(\\cdot)\\mathbf{L}_{\\phi}(\\cdot)^{\\sf T}}\\end{array}$ , where $\\mathbf{L}_{\\phi}(\\cdot)$ is a lower-triangular matrix with positive diagonal entries. ", "page_idx": 5}, {"type": "text", "text": "Conditional normalising flows Normalising flows [33] apply the change-of-variable formula to derive composable, invertible transformations $\\mathbf{g}_{\\mathbf{w}}$ of a fixed base distribution $p_{0}$ : ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{g}_{\\mathbf{w}}(\\pmb{\\xi}_{0}):=\\mathbf{g}_{\\mathbf{w}}^{(K)}\\circ\\cdots\\circ\\mathbf{g}_{\\mathbf{w}}^{(1)}(\\pmb{\\xi}_{0}),\\quad\\pmb{\\xi}_{0}\\sim p_{0}}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "The log-probability density of a point $\\pmb{\\xi}=\\mathbf{g}_{\\mathbf{w}}(\\pmb{\\xi}_{0})$ under this model can be calculated as: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\log p_{K}(\\pmb{\\xi};\\mathbf{w})=\\log p_{0}(\\pmb{\\xi}_{0})-\\sum_{j=1}^{K}\\log\\left|\\mathbf{J}_{\\mathbf{w}}^{(j)}(\\pmb{\\xi}_{j-1})\\right|\\,,\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\pmb{\\xi}_{0}:=\\mathbf{g}_{\\mathbf{w}}^{-1}(\\pmb{\\xi}),\\pmb{\\xi}_{j}:=\\mathbf{g}_{\\mathbf{w}}^{(j)}(\\pmb{\\xi}_{j-1})$ , and $\\mathbf{J}_{\\mathbf{w}}^{(j)}$ is the Jacobian matrix of the $j$ th transform $\\mathbf{g}_{\\mathbf{w}}^{(j)}$ , for $j\\in\\{1,\\ldots,K\\}$ . Several invertible flow architectures have been proposed in the literature, including radial and planar flows [33], autoregressive models [34\u201336] and models based on splines [37]. ", "page_idx": 5}, {"type": "text", "text": "To derive a conditional density model $q_{\\phi}(\\pmb{\\theta}^{*}|\\hat{y})$ , conditional normalising flows map the original flow parameters w via a neural network model $\\mathbf{r}_{\\phi}:\\hat{y}\\mapsto\\mathbf{w}$ [38, 39]. In this case, the variational model is given by: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\log q_{\\phi}(\\pmb{\\theta}^{*}|\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}})=\\log p_{K}(\\pmb{\\theta}^{*};\\mathbf{r}_{\\phi}(\\hat{y},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}}))\\,.\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "5.4 Batch parallel evaluations ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Often simulations can be run in parallel by spawning multiple processes in a single machine or over a compute cluster. In this case, proposing batches of simulation inputs can be more effective than running single simulations in a sequence. Optimising the EIG w.r.t. a batch of inputs $B:=$ $\\{\\hat{\\mathbf{x}}_{i},\\hat{\\pmb{\\theta}}_{i}\\}_{i=1}^{B}$ , instead of single points, we obtain a batch version of Algorithm 1. In this case, we are seeking a batch that maximises the mutual information between the parameters $\\pmb{\\theta}^{*}$ and the resulting observations, i.e.: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathrm{EIG}_{t}(\\mathcal{B})=\\mathbb{I}(\\pmb{\\theta}^{*};\\{\\hat{y}_{i}\\}_{i=1}^{B}|\\mathcal{B},\\mathcal{D}_{t-1})\\ge\\mathbb{E}_{p(\\{\\hat{y}_{i}\\}_{i=1}^{B},\\pmb{\\theta}^{*}|\\mathcal{B},\\mathcal{D}_{t-1})}\\left[\\log\\frac{q(\\pmb{\\theta}^{*}|\\{\\hat{y}_{i}\\}_{i=1}^{B})}{p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t-1})}\\right]\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "We approximate this objective by using variational models that accept multiple conditioning observations $q(\\theta^{*}|\\hat{y}_{1},\\dots,\\hat{y}_{B})$ . In the case of scalar observations, this simply amounts to replacing the scalar inputs to the conditional models in Sec. 5.3 by vector-valued inputs. ", "page_idx": 5}, {"type": "image", "img_path": "m906PS5G9x/tmp/ccbcf25d80c40c12cfa60f6d08f8e655295e830549ed857eeee24d9f8a671f6b.jpg", "img_caption": ["Figure 1: Experimental results on synthetic data where the target posterior $p^{*}$ is unimodal. The first 3 plots show estimates for performance metrics as a function of the number of simulations run (not including the initial data). Estimates were computed based on the posterior estimates for each method available during their run, with random using $p(\\pmb{\\theta}^{*})$ , D-optimal and BACON using MCMC posteriors, and IMSPE using a Dirac delta (reverse KL undefined, not shown) on the MAP estimate as posterior estimates. Results are averaged over 10 trials, and shaded areas indicate $\\pm1$ standard deviation. The rightmost plot shows the target posterior, with the true $\\pmb{\\theta}^{*}$ indicated by a star. "], "img_footnote": [], "page_idx": 6}, {"type": "image", "img_path": "m906PS5G9x/tmp/902b32308ae2fb3272c5fcf24d8b1ecba53e11ed7099738b3b79c2714c330ad9.jpg", "img_caption": ["Figure 2: Experimental results on synthetic data where the target posterior $p^{*}$ is bimodal. See Fig. 1 for details, with the exception that the rightmost plot now shows the bimodal target posterior. "], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "6 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "In this section, we present experimental results on synthetic and real-data problems evaluating the proposed variational Bayesian adaptive calibration framework against baselines. Further experiment details can be found in Appendix A and in our code repository. ", "page_idx": 6}, {"type": "text", "text": "Performance metrics. We evaluated each method against a set of performance metrics, which we now describe. The maximum-a-posteriori (MAP) approximation error measures the distance between the mode of the variational distribution and the true parameters $\\pmb{\\theta}^{*}$ . To measure the quality of the learnt model in predicting real outcomes, we also evaluated the root mean square error (RMSE) between the expected GP predictions under the learnt variational distribution and real outcomes: $\\begin{array}{r}{\\mathrm{RMSE}:=\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(\\mathbb{E}_{q(\\pmb{\\theta})}[\\mu(\\mathbf{x}_{i}^{\\ast},\\pmb{\\theta}^{\\ast};\\pmb{\\theta})]-y_{i}^{\\ast})^{2}}}\\end{array}$ , where $y_{i}^{*}=f(\\mathbf{x}_{i}^{*})+\\nu_{i}^{*}$ are observations of the true function over a set of designs $\\{\\mathbf{x}_{i}^{*}\\}_{i=1}^{N}\\subset\\mathcal{X}$ placed on a uniform grid the design space. ", "page_idx": 6}, {"type": "text", "text": "Information gain. Lastly, we also evaluated two sample-based estimates of the KL divergence [40]. Namely, $\\mathbb{D}_{\\mathrm{KL}}(p_{T}||p_{0})$ corresponds to the KL divergence between the final MCMC posterior (given all simulations and real data) and the initial one (given only the real data and an initial set of randomised simulations) both estimated over the learnt GP model. The column $\\mathbb{D}_{\\mathrm{KL}}(p_{T}||p^{*})$ indicates the KL divergence between the final MCMC posterior $p_{T}$ and the posterior $p^{*}$ with full knowledge of the simulator, which can be cheaply evaluated in this synthetic scenario. The average of $\\mathbb{D}_{\\mathrm{KL}}(p_{T}\\|p_{0})$ is an indicator for the expected information gain (1) of an algorithm, given that it is the expected relative entropy across the possible trajectories of observations. Meanwhile $\\mathbb{D}_{\\mathrm{KL}}(p_{T}||p^{*})$ indicates how far the estimates are from the best possible posterior given the available real data. ", "page_idx": 6}, {"type": "table", "img_path": "m906PS5G9x/tmp/5f3c1e8ce4c067f83387822607b50e3a1a5afc3a00d8189374ee9a082c9efbe3.jpg", "table_caption": ["(b) Bimodal posterior "], "table_footnote": ["(a) Unimodal posterior "], "page_idx": 7}, {"type": "text", "text": "Table 1: Results for $2+2\\mathrm{D}$ synthetic problem after $T\\,=\\,50$ iterations (batch of $B\\,=\\,4,$ ). Here $\\mathbb{D}_{\\mathrm{KL}}(p_{T}||p_{0})$ corresponds to the KL divergence between the final posterior (estimated after each algorithm\u2019s run with all the data it collected) and the starting one (higher is better), while $\\mathbb{D}_{\\mathrm{KL}}(p_{T}||p^{*})$ is the KL between the final posterior and the posterior with full knowledge of the simulator $p^{*}$ (lower is better). All posteriors were sampled via MCMC using 4000 samples. Averages and standard deviations were estimated from 10 independent runs. ", "page_idx": 7}, {"type": "text", "text": "6.1 Baselines ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "Our algorithmic baselines were chosen to illustrate the main approaches currently available in the literature. Both are employed as adaptive baselines, in the sense that their GP models are updated with the latest observations before proceeding to the next iteration. ", "page_idx": 7}, {"type": "text", "text": "Random search. This baseline samples simulation designs $\\hat{\\mathbf{x}}_{t}\\sim\\mathcal{U}(\\mathcal{X})$ from a uniform distribution over the design space $\\mathcal{X}$ and calibration parameters from the prior $\\hat{\\theta}_{t}\\sim p(\\theta^{*})$ . ", "page_idx": 7}, {"type": "text", "text": "IMSPE with MAP estimates. The integrated mean squared prediction error (IMSPE) [41] criterion chooses designs $\\hat{\\mathbf{x}}_{t}$ and calibration $\\widehat{\\pmb{\\theta}}_{t}$ parameters by minimising the GP prediction error: ", "page_idx": 7}, {"type": "equation", "text": "$$\n\\mathrm{IMSPE}_{t}(\\hat{\\mathbf{z}}):=\\int_{\\mathcal{Z}}\\mathbb{E}[(\\hat{f}(\\mathbf{z})-\\mu_{t+1}(\\mathbf{z};\\theta^{*}))^{2}\\mid\\hat{f}(\\hat{\\mathbf{z}}),\\mathcal{D}_{t}]\\,\\mathrm{d}\\mathbf{z}=\\int_{\\mathcal{Z}}\\sigma_{t+1}^{2}(\\mathbf{z};\\theta^{*}|\\mathcal{D}_{t},\\hat{f}(\\hat{\\mathbf{z}}))\\,\\mathrm{d}\\mathbf{z}.\n$$", "text_format": "latex", "page_idx": 7}, {"type": "text", "text": "The posterior\u2019s MAP estimate $\\pmb{\\theta}_{t}^{*}\\in\\operatorname{argmax}_{\\pmb{\\theta}}p(\\pmb{\\theta}|\\mathcal{D}_{t-1})$ is used as a point estimate for the true $\\pmb{\\theta}^{*}$ . The integral is approximated as a sum over a uniform grid of designs and samples from the calibration prior,5 making IMSPE equivalent to active learning Cohn [42] and a form of A-optimality [28]. ", "page_idx": 7}, {"type": "text", "text": "D-optimal designs. We provide experimental results with an additional baseline following a Doptimality criterion, a classic experimental design objective. Optimal candidate designs according to this criterion are points of maximum uncertainty according to the model [28]. If we model the simulator as the unknown variable of interest, this corresponds to selecting designs where we have maximum entropy of the Gaussian predictive distribution $p(\\hat{y}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})$ . This approach, therefore, simply attempts to collect an informative set of simulations according to the GP prior over the simulator $h$ only, without considering the information in the real data. Running D-optimality on $\\pmb{\\theta}^{*}$ , in contrast, would lead back to the EIG criterion we use. ", "page_idx": 7}, {"type": "text", "text": "Variational Bayesian Monte Carlo (VBMC). Acerbi [43] presents an adaptive Bayesian quadrature method to learn posterior distributions over models with black-box likelihood functions. The method estimates the posterior $p(\\pmb{\\theta}^{*}|\\mathbf{y}_{R},h)$ by modelling the log-joint $\\log p(\\mathbf{y}_{R},\\pmb{\\theta}^{*}|h)$ as a sample from a Gaussian process. VBMC then learns a variational posterior approximation by maximising a lower-confidence bound over the ELBO given by the GP estimates. Calibration parameter queries $\\widehat{\\pmb{\\theta}}_{t}$ are obtained by optimising quadrature-based acquisition functions. Regarding design points, simulations are always run on the set of real design points $\\scriptstyle{\\mathcal{X}}_{R}$ in the observed data, which is fixed. ", "page_idx": 7}, {"type": "text", "text": "6.2 Synthetic experiments ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "For this experiment, we sampled a function $\\hat{f}\\sim\\mathcal{G P}(0,k)$ to use as our simulator and compared different algorithms. Following a sparse GP approach, a function sampled from a GP can be approximated as $\\hat{f}(\\mathbf{z})\\approx k(\\mathbf{z},\\mathbf{Z}_{M})\\mathbf{K}_{M}^{-1}\\mathbf{u}_{M}$ , where $\\mathbf{u}_{M}\\sim\\mathcal{N}(\\hat{\\mathbf{u}}_{M},\\pmb{\\Sigma}_{M})$ is a sample from an $M$ - dimensional Gaussian, ${\\bf Z}_{M}:=\\{{\\bf z}_{i}\\}_{i=1}^{M}\\subset\\boldsymbol{\\mathcal{X}}\\times\\Theta\\times\\{0,1\\}$ , for a given $M$ . As the number of points $M\\to\\infty$ , if the pseudo-inputs $\\mathbf{Z}_{M}$ form a dense set, we have that $\\hat{f}$ converges in distribution to a sample from the Gaussian process $\\mathcal{G P}(0,k)$ . In our case, to sample $\\mathbf{Z}_{M}$ , we sample designs from a uniform distribution over the design space, calibration parameters from the prior, and fidelities from a Bernoulli distribution with parameter set to 0.5. We also set $\\hat{\\mathbf{u}}_{M}:=\\mathbf{0}$ and $\\pmb{\\Sigma}_{M}:=\\mathbf{K}_{M}=$ $k(\\mathbf{Z}_{M},\\mathbf{Z}_{M})$ . We repeatedly run a loop of $T$ iterations for each algorithm, with each repetition running on independent $\\hat{f}$ sampled from the same GP prior. ", "page_idx": 7}, {"type": "table", "img_path": "m906PS5G9x/tmp/4ed85c915179b58b7208f376bd7947387178601aaaaa0a4b3e082fda64f2873a.jpg", "table_caption": [], "table_footnote": ["Table 2: Results on the location finding problem after $\\overline{{T=30}}$ iterations with $B=4$ , $R=20$ \u201creal\u201d data points and an initial set of 20 simulations. Estimates were averaged over 10 independent runs. "], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "We run each algorithm for $T:=50$ iterations using a batch of $B:=4$ designs per iteration. Each of the methods using GP approximations for the simulator are initialised with 20 observations and $R=5$ real data. To configure VBMC, we allow it to run an equivalent maximum amount of objective function evaluations. The design space is set as the 2-dimensional unit box $\\mathcal{X}:=[0,1]^{2}$ and the \u201ctrue\u201d parameters for each run are sampled from a standard normal prior $p(\\pmb{\\theta}^{*}):=\\mathcal{N}(\\bar{\\pmb{\\theta}}^{*};\\bar{\\mathbf{0}},\\mathbf{I})$ also over a 2D space, totalling a 4-dimensional problem space. ", "page_idx": 8}, {"type": "text", "text": "Fig. 1 shows a case where the GP-sampled simulator led to a unimodal target posterior. In this case, we see that BACON is able to achieve fast convergence in terms of MAP estimates and KL divergence towards the target posterior, while IMSPE dominates in terms of simulator approximation error as measured by the RMSE. As the posterior is unimodal and quite concentrated around the true parameter, it is natural that a method relying on MAP estimates, such as RMSE, would perform well. In contrast, when the posterior is multimodal, as shown in the bimodal case in Fig. 2, MAP estimates are not necessarily reliable any more, as they might get stuck on a non-informative mode, leading to biased estimates for IMSPE and a significant drop in performance. Lastly, note that D-optimal and random designs can also lead to RMSE approaching the lowest (as determined by the noise level with $\\sigma_{\\nu}=0.5)$ ) in some circumstances. However, these approaches do not directly provide posterior approximations and may fail in more complex scenarios. ", "page_idx": 8}, {"type": "text", "text": "In terms of final posterior estimates, Table 1 shows that VBMC estimates reach the closest to the full-knowledge target posterior $p^{*}$ in the unimodal case, while BACON is able to surpass the other GP-emulation approaches in terms of information gain. For the bimodal case, however, we see that BACON gains an advantage over VBMC. Recall that VBMC relies on a mixture of Gaussians, while BACON applies conditional normalising flows for its posterior approximations, which lead to increased generalisability. In addition, despite the slightly worse performance than VBMC, BACON also provides a GP model that can be used as an emulator for the simulator (and approximates the real process), while VBMC\u2019s focus is on approximating the log-likelihood. ", "page_idx": 8}, {"type": "text", "text": "6.3 Finding the location of hidden sources ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We consider the problem of finding the location of 2 hidden sources in a 2D environment following the setting in Foster et al. [16]. We are provided with $R=20$ initial measurements and an initial set of $S\\,=\\,20$ randomised simulations without knowledge of the true parameters which the data was generated with. Our results are presented in Table 2, which show a similar tendency in higher information gain for our method, and a very low KL w.r.t. $p^{*}$ . Note that a high information gain indicates a more informative posterior, whose entropy will be much lower relative to the starting distribution, compared to the other methods. In addition, the ideal $p^{*}$ , which a GP-based posterior should converge to in the limit of infinite data, is not known by the methods, only $p_{0}$ . Therefore, besides obtaining maximally informative data, we have shown that BACON is also efficient in approximating posteriors over black-box simulators, while also learning a GP emulator model. ", "page_idx": 8}, {"type": "image", "img_path": "m906PS5G9x/tmp/81a86d0d11635402c68aab58875066d34e7d19698573d1a55133d9556b225749.jpg", "img_caption": ["Figure 3: Soft-robotics grasping experiment. We calibrate a soft materials simulator against real data from physical grasping from an automated experimentation platform "], "img_footnote": [], "page_idx": 9}, {"type": "table", "img_path": "m906PS5G9x/tmp/72331f4c3746b991ecf4f221fac91b5e252568087b5552e6e4d2a99d74b25a33.jpg", "table_caption": [], "table_footnote": [], "page_idx": 9}, {"type": "text", "text": "Table 3: Soft-robotics simulator calibration final results after $\\overline{{T=10}}$ with $B=16$ points per batch. The target posterior $p^{*}$ was inferred using a large set of 1024 random simulations uniformly covering the design and parameter space. Performance was averaged over 4 independent runs. ", "page_idx": 9}, {"type": "text", "text": "6.4 Soft-robotic grasping simulator calibration ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "For this experiment, we are provided with a dataset containing $R=10$ real measurements of the peak grasping force of soft-robotic gripper designs on a range of testing objects (see Fig. 3). The gripper designs follow a fin-ray pattern parameterised by 9 geometric parameters [44], and we are interested in estimating 2 unknown physics parameters, the Young\u2019s modulus of elasticity and the coefficient of static friction with the objects. To simulate the gripper designs, we use the SOFA framework [45] to reproduce the grasping scenario and provide an estimate of the peak grasping force. In particular, for this paper, we focus on the grasping of a spherical object, which provides a simpler geometry and lower discrepancy with respect to real data measurements compared to more complex objects. This experiment provides us with a benchmark where simulations are expensive to run, taking from minutes to a few hours to run (depending on mesh resolution) on a high-performance computing platform. Therefore, it is important to choose a minimum amount of informative simulations. ", "page_idx": 9}, {"type": "text", "text": "Our results are shown in Table 3. Each algorithm was initialised with a set of 123 random simulations and run for $T=10$ iterations. The results show that BACON achieves the closest approximation to the target posterior. IMSPE highly concentrated its parameter choices around its posterior mode estimate, while other baselines were too spread, both leading to inferior posterior approximations (see Fig. 4 in the appendix) and showing the advantage of BACON\u2019s joint optimisation and inference. ", "page_idx": 9}, {"type": "text", "text": "7 Conclusion, limitations and future work ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We have developed BACON, a Bayesian approach that carries out parameter calibration of computer models and optimal design of experiments jointly. It does so by optimizing an information-theoretic criterion so that input designs and calibration parameters are selected to be maximally informative about the optimal parameters. Our method provides a full posterior over optimal calibration parameters as well as an accurate Gaussian process based estimation of the computer model (i.e., an emulator). One of the main limitations of the presented framework is scalability to large datasets, due to the cubic computational complexity of exact inference with GPs. However, our method can be extended to work with scalable sparse variational GP models [46] by using a conditional distribution model for the inducing points (see Sec. B.2). We emphasize that our proposed method is still applicable to many real practical settings, where the problem constraints do not demand a very large number of simulation samples. Lastly, we also note that the method can be adapted to work with multi-output observations by the use of multi-output GP models [47]. Further discussions on limitations and future work can be found in our appendix (see Appendix B and C). ", "page_idx": 9}, {"type": "text", "text": "Acknowledgements ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "This project was supported by resources and expertise provided by CSIRO IMT Scientific Computing. We are also grateful for the support of CSIRO\u2019s Data61 soft-robotics team, especially Josh Pinskier, Xing Wang, Lois Liow, Sarah Baldwin, James Brett and Vinoth Viswanathan, in the experimental data collection and simulations setup for the soft-robotics calibration problem. ", "page_idx": 10}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[1] Marc C. Kennedy and Anthony O\u2019Hagan. Bayesian calibration of computer models. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 63(3):425\u2013464, 2001.   \n[2] Carl E. Rasmussen and Christopher K. I. Williams. Gaussian Processes for Machine Learning. The MIT Press, Cambridge, MA, 2006.   \n[3] Michael U. Gutmann and Jukka Corander. Bayesian optimization for likelihood-free inference of simulator-based statistical models. Journal of Machine Learning Research, 17, 2016.   \n[4] Erin R. Leatherman, Angela M. Dean, and Thomas J. Santner. Designing combined physical and computer experiments to maximize prediction accuracy. Computational Statistics and Data Analysis, 113:346\u2013362, 2017.   \n[5] Se\u00b4bastien Marmin and Maurizio Filippone. Deep Gaussian processes for calibration of computer models (with discussion). Bayesian Analysis, 17(4):1301\u20131350, 2022.   \n[6] Tom Rainforth, Adam Foster, Desi R. Ivanova, and Freddie Bickford Smith. Modern Bayesian Experimental Design. Statistical Science, 39(1):100 \u2013 114, 2024.   \n[7] Thomas M. Cover and Joy A. Thomas. Elements of Information Theory. John Wiley & Sons, 2005.   \n[8] Ronald A. Fisher. The design of experiments. Oliver & Boyd, Oxford, England, 1935. [9] Stewart Greenhill, Santu Rana, Sunil Gupta, Pratibha Vellanki, and Svetha Venkatesh. Bayesian optimization for adaptive experimental design: A review. IEEE Access, 8:13937\u201313948, 2020.   \n[10] J. Kiefer. Optimum experimental designs. Journal of the Royal Statistical Society. Series B (Methodological), 21(2):272\u2013319, 1959.   \n[11] Kathryn Chaloner and Isabella Verdinelli. Bayesian experimental design: A review. Statistical Science, 10(3):273\u2013304, 1995.   \n[12] Elizabeth G. Ryan, Christopher C. Drovandi, James M. Mcgree, and Anthony N. Pettitt. A review of modern computational algorithms for Bayesian optimal design. International Statistical Review, 84(1):128\u2013154, 2016.   \n[13] Adam Foster, Martin Jankowiak, Eli Bingham, Paul Horsfall, Yee Whye Teh, Tom Rainforth, and Noah Goodman. Variational Bayesian optimal experimental design. In 33rd Conference on Neural Information Processing Systems (NeurIPS 2019), Vancouver, Canada, 2019.   \n[14] Steven Kleinegesse and Michael U. Gutmann. Efficient Bayesian experimental design for implicit models. In Kamalika Chaudhuri and Masashi Sugiyama, editors, Proceedings of the 22nd International Conference on Artificial Intelligence and Statistics (AISTATS), Proceedings of Machine Learning Research, Naha, Okinawa, Japan, 2019. PMLR.   \n[15] Joakim Beck, Ben Mansour Dia, Luis FR Espath, Quan Long, and Raul Tempone. Fast Bayesian experimental design: Laplace-based importance sampling for the expected information gain. Computer Methods in Applied Mechanics and Engineering, 334:523\u2013553, 2018.   \n[16] Adam Foster, Desi R. Ivanova, Ilyas Malik, and Tom Rainforth. Deep Adaptive Design: Amortizing sequential Bayesian experimental design. In Marina Meila and Tong Zhang, editors, Proceedings of the 38th International Conference on Machine Learning (ICML 2021), volume 139 of Proceedings of Machine Learning Research, pages 3384\u20133395. PMLR, 2021.   \n[17] Tom Blau, Edwin V. Bonilla, Iadine Chades, and Amir Dezfouli. Optimizing sequential experimental design with deep reinforcement learning. In Proceedings of the 39th International Conference on Machine Learning, volume 162 of Proceedings of Machine Learning Research, Baltimore, Maryland, USA, 2022. PMLR.   \n[18] Tom Rainforth, Adam Foster, Desi R Ivanova, and Freddie Bickford Smith. Modern bayesian experimental design. arXiv preprint arXiv:2302.14545, 2023.   \n[19] D. Busby and M. Feraille. Adaptive design of experiments for calibration of complex simulators - An application to uncertainty quantification of a mature oil field. Journal of Physics: Conference Series, 135, 2008.   \n[20] Christophe Andrieu, Nando De Freitas, Arnaud Doucet, and Michael I. Jordan. An introduction to MCMC for machine learning. Machine Learning, 50(1-2):5\u201343, 2003.   \n[21] Soumalya Sarkar, Sudeepta Mondal, Michael Joly, Matthew E. Lynch, Shaunak D. Bopardikar, Ranadip Acharya, and Paris Perdikaris. Multifidelity and multiscale Bayesian framework for high-dimensional engineering design and calibration. Journal of Mechanical Design, 141(12), 2019.   \n[22] Rafael Oliveira, Lionel Ott, and Fabio Ramos. No-regret approximate inference via Bayesian optimisation. In 37th Conference on Uncertainty in Artificial Intelligence (UAI). PMLR, 2021.   \n[23] Luigi Acerbi. Variational Bayesian Monte Carlo with noisy likelihoods. In H Larochelle, M Ranzato, R Hadsell, M F Balcan, and H Lin, editors, 34th Conference on Neural Information Processing Systems (NeurIPS 2020), volume 33, pages 8211\u20138222, 2020.   \n[24] Marko J\u00a8arvenp\u00a8a\u00a8a, Michael U. Gutmann, Aki Vehtari, and Pekka Marttinen. Parallel Gaussian process surrogate Bayesian inference with noisy likelihood evaluations. Bayesian Analysis, 2020.   \n[25] Mucahit Cevik, Mehmet Ali Ergun, Natasha K Stout, Amy Trentham-Dietz, Mark Craven, and Oguzhan Alagoz. Using Active Learning for Speeding up Calibration in Simulation Models. Medical decision making: an international journal of the Society for Medical Decision Making, 36(5):581\u2013593, 2016.   \n[26] Yuan Tian, Manuel Arias Chao, Chetan Kulkarni, Kai Goebel, and Olga Fink. Real-time model calibration with deep reinforcement learning. Mechanical Systems and Signal Processing, 165 (July 2021):108284, 2022.   \n[27] Andreas C. Damianou and Neil D. Lawrence. Deep Gaussian processes. Proceedings of the 16th International Conference on Artificial Intelligence and Statistics (AISTATS), 31, 2013.   \n[28] Andreas Krause, Ajit Singh, and Carlos Guestrin. Near-optimal sensor placements in Gaussian processes: Theory, efficient algorithms and empirical studies. Journal of Machine Learning Research, 9:235\u2013284, 2008.   \n[29] Daniel Golovin and Andreas Krause. Adaptive submodularity: Theory and applications in active learning and stochastic optimization. Journal of Artificial Intelligence Research, 42: 427\u2013486, 2011.   \n[30] David Barber and Felix Agakov. The im algorithm: A variational approach to information maximization. In Proceedings of the 16th International Conference on Neural Information Processing Systems, NIPS\u201903, page 201\u2013208, Cambridge, MA, USA, 2003. MIT Press.   \n[31] Patrick Dallaire, Camille Besse, and Brahim Chaib-Draa. An approximate inference with Gaussian process to latent functions from uncertain data. Neurocomputing, 74:1945\u20131955, 2011.   \n[32] Andreas C. Damianou, Michalis K Titsias, and Neil D Lawrence. Variational inference for latent variables and uncertain inputs in Gaussian processes. Journal of Machine Learning Research, 17(1):1\u201362, 2016.   \n[33] Danilo Jimenez Rezende and Shakir Mohamed. Variational inference with normalizing flows. In International Conference on Machine Learning (ICML 2015), volume 2, pages 1530\u20131538, Lille, France, 2015.   \n[34] Durk P Kingma, Tim Salimans, Rafal Jozefowicz, Xi Chen, Ilya Sutskever, and Max Welling. Improved variational inference with inverse autoregressive flow. In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 29, 2016.   \n[35] George Papamakarios, Theo Pavlakou, and Iain Murray. Masked autoregressive flow for density estimation. In I. Guyon, U. Von Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 30, 2017.   \n[36] Chin Wei Huang, David Krueger, Alexandre Lacoste, and Aaron Courville. Neural autoregressive flows. In 35th International Conference on Machine Learning (ICML 2018), volume 5, pages 3309\u20133324, Stockholm, Sweden, 2018.   \n[37] Conor Durkan, Artur Bekasov, Iain Murray, and George Papamakarios. Neural spline flows. In H. Wallach, H. Larochelle, A. Beygelzimer, F. d'Alch\u00b4e-Buc, E. Fox, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 32, 2019.   \n[38] Christina Winkler, Daniel Worrall, Emiel Hoogeboom, and Max Welling. Learning likelihoods with conditional normalizing flows. arXiv preprint arXiv:1912.00042, 2019.   \n[39] Abdelrahman Abdelhamed, Marcus A Brubaker, and Michael S Brown. Noise flow: Noise modeling with conditional normalizing flows. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 3165\u20133173, 2019.   \n[40] Zolt\u00b4an Szab\u00b4o. Information theoretical estimators toolbox. Journal of Machine Learning Research, 15:283\u2013287, 2014.   \n[41] Scott Koermer, Justin Loda, Aaron Noble, and Robert B. Gramacy. Active Learning for Simulator Calibration. arXiv, 2023. URL http://arxiv.org/abs/2301.10228.   \n[42] Annie Sauer, Robert B. Gramacy, and David Higdon. Active Learning for Deep Gaussian Process Surrogates. Technometrics, 65(1):1\u201339, 2022. ISSN 15372723. doi: 10.1080/00401706. 2021.2008505. URL https://doi.org/10.1080/00401706.2021.2008505.   \n[43] Luigi Acerbi. Variational Bayesian Monte Carlo. In 32nd Conference on Neural Information Processing Systems (NeurIPS 2018), Montr\u00b4eal, Canada, 2018.   \n[44] Xing Wang, Bing Wang, Joshua Pinskier, Yue Xie, James Brett, Richard Scalzo, and David Howard. Fin-bayes: A multi-objective bayesian optimization framework for soft robotic fingers. Soft Robotics, 2024.   \n[45] Franc\u00b8ois Faure, Christian Duriez, Herve\u00b4 Delingette, Je\u00b4re\u00b4mie Allard, Benjamin Gilles, Ste\u00b4phanie Marchesseau, Hugo Talbot, Hadrien Courtecuisse, Guillaume Bousquet, Igor Peterlik, and St\u00b4ephane Cotin. SOFA: A Multi-Model Framework for Interactive Physical Simulation. In Yohan Payan, editor, Soft Tissue Biomechanical Modeling for Computer Assisted Surgery, volume 11 of Studies in Mechanobiology, Tissue Engineering and Biomaterials, pages 283\u2013321. Springer, June 2012. URL https://inria.hal.science/hal-00681539.   \n[46] Michalis K. Titsias. Variational learning of inducing variables in sparse Gaussian processes. In International Conference on Artificial Intelligence and Statistics (AISTATS), Clearwater Beach, Florida, USA, 2009.   \n[47] Mauricio A Alvarez, Lorenzo Rosasco, Neil D Lawrence, et al. Kernels for vector-valued functions: A review. Foundations and Trends\u00ae in Machine Learning, 4(3):195\u2013266, 2012.   \n[48] Eli Bingham, Jonathan P. Chen, Martin Jankowiak, Fritz Obermeyer, Neeraj Pradhan, Theofanis Karaletsos, Rohit Singh, Paul Szerlip, Paul Horsfall, and Noah D. Goodman. Pyro: Deep Universal Probabilistic Programming. Journal of Machine Learning Research, 2018.   \n[49] Maximilian Balandat, Brian Karrer, Daniel R. Jiang, Samuel Daulton, Benjamin Letham, Andrew Gordon Wilson, and Eytan Bakshy. BoTorch: A Framework for Efficient Monte-Carlo Bayesian Optimization. In Advances in Neural Information Processing Systems 33, 2020. URL http://arxiv.org/abs/1910.06403.   \n[50] Matthew D. Hoffman and Andrew Gelman. The no-U-turn sampler: Adaptively setting path lengths in Hamiltonian Monte Carlo. Journal of Machine Learning Research, 15:1593\u20131623, 2014.   \n[51] Michalis Titsias and Neil Lawrence. Bayesian Gaussian process latent variable model. In International Conference on Artificial Intelligence and Statistics (AISTATS), pages 844\u2013851, 2010.   \n[52] Vidhi Lalchand, Aditya Ravuri, and Neil D. Lawrence. Generalised GPLVM with stochastic variational inference. In Gustau Camps-Valls, Francisco J. R. Ruiz, and Isabel Valera, editors, Proceedings of The 25th International Conference on Artificial Intelligence and Statistics, volume 151 of Proceedings of Machine Learning Research, pages 7841\u20137864. PMLR, 2022.   \n[53] James Hensman, Nicol\\`o Fusi, and Neil D. Lawrence. Gaussian processes for big data. In Proceedings of the Twenty-Ninth Conference on Uncertainty in Artificial Intelligence, UAI\u201913, page 282\u2013290, Arlington, Virginia, USA, 2013. AUAI Press.   \n$\\mathcal{D}_{0}:=\\{\\mathcal{X}_{R},\\mathbf{y}_{R}\\}$ ;   \nfor $t\\in\\{1,\\ldots,T\\}$ do $\\begin{array}{r l r}&{\\mu_{t-1}^{*}\\dots\\stackrel{\\leftarrow}{\\longleftrightarrow}\\mathrm{fy}\\mathrm{\\bar{dateGP}}(\\mathcal{D}_{t-1})}\\\\ &{\\{\\theta_{i}^{*1}\\}_{i=1}^{S_{A}}\\stackrel{\\mathrm{MCMC}}{\\sim}p(\\theta^{*}|\\mathcal{D}_{t-1})\\propto p(\\theta^{*})\\mathcal{N}(\\mathbf{y}_{R};\\mu_{t-1}(\\mathbf{Z}_{R}(\\theta^{*});\\theta^{*}),\\boldsymbol{\\Sigma}_{t-1}(\\mathbf{Z}_{R}(\\theta^{*});\\theta^{*})+\\sigma_{\\nu}^{2}\\mathbf{I})}\\\\ &{p(\\theta^{*}|\\mathcal{D}_{t-1})\\approx\\hat{\\mathcal{P}}_{t-1}:=\\frac{1}{S_{A}}\\sum_{i=1}^{S_{A}}\\delta_{\\theta_{i}^{*}}}\\\\ &{q_{t}\\leftarrow\\mathrm{TrainFlow}(\\hat{\\mathcal{p}}_{t-1},\\mathcal{D}_{t-1})}\\\\ &{\\{\\hat{\\mathbf{x}}_{t,i},\\hat{\\theta}_{t,i}\\}_{i=1}^{B}\\leftarrow\\mathrm{OptimiseDesigns}(q_{t},\\hat{\\mathcal{p}}_{t-1},\\mathcal{D}_{t-1})}\\\\ &{\\hat{\\mathcal{H}}_{t,i}:=h(\\hat{\\mathbf{x}}_{t,i},\\hat{\\theta}_{t,i})\\ \\mathrm{(parallel)\\;for\\;}i\\in\\{1,\\dots,B\\}}&{\\{\\mathrm{Run~batch\\;of\\;simulationset}}\\\\ &{\\mathcal{D}_{t}:=\\mathcal{D}_{t-1}\\cup\\{\\hat{\\mathbf{x}}_{t,i},\\hat{\\theta}_{t,i},\\hat{\\mathcal{y}}_{t,i}\\}_{i=1}^{B}}&{\\{\\mathrm{Update\\;GP\\;dataset}}\\end{array}$ } }   \nend for ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "", "page_idx": 14}, {"type": "text", "text": "A Additional details on the experiments ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "For all experiments, we use conditional normalising flows as the variational model for BACON. Our implementation for BACON and most of the baselines, except for VBMC,6 is based on Pyro probabilistic programming models [48]. Gaussian process modelling code is based on BoTorch7 [49]. The flow architecture is chosen for each synthetic-data problem by running hyper-parameter tuning with a simplified version of the problem. Most Gaussian process models are parameterised with Mat\u00b4ern kernels [2, Ch. 4] and constant or zero mean functions. Pyro\u2019s MCMC with its default no-U-turn (NUTS) sampler [50] was applied to obtain samples from $p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t-1})$ at each iteration $t$ KL divergences are computed from samples using a nearest neighbours estimator implemented in the information theoretical estimators (ITE) package8 [40]. ", "page_idx": 14}, {"type": "text", "text": "A.1 Synthetic GP problem ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "The GP prior was set with $\\hat{k}$ given by a squared exponential kernel and $k_{\\varepsilon}$ given by a Mat\u00b4ern kernel with smoothness parameter set to 2.5 [2]. The conditional normalising flow was configured with 2 layers of neural spline flows [37]. Batches of arbitrary size are used for conditioning via a permutation invariant set encoder, similar to Blau et al. [17], with a 2-layer, 32-units-wide fullyconnected hyperbolic tangent neural network passing through a summation at the end. Gradient-based optimisation is run using Adam with a learning rate $10^{-{\\bar{3}}}$ for the flow parameters and 0.05 for the simulation design points, both using cosine annealing with warm restarts as a learning rate scheduler. 256 samples were subsampled from the MCMC posterior to estimate expectations for both this and the location-finding problem. ", "page_idx": 14}, {"type": "text", "text": "Algorithm with split training. For the synthetic GP problem, we provide a more detailed pseudocode of our algorithmic implementation using an option for training the conditional normalising flow and optimising the designs separately. Specifically, we applied MCMC to estimate our posteriors and had a flexible optimisation loop, where we had the option to separate the training of the conditional normalising flow model from the optimisation of the design points, as shown in Algorithm 2. This approach can make the algorithm more stable, though at the cost of a longer runtime. This option was only applied to the GP-based synthetic experiments, while for the other experiments we ran the full joint optimisation over both the simulation inputs $({\\hat{\\mathbf{x}}},{\\hat{\\pmb{\\theta}}})$ and the variational parameters of the conditional model $q$ . ", "page_idx": 14}, {"type": "text", "text": "A.2 Location finding problem ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "For this experiment we used more up-to-date $Z\\mathrm{uko}^{9}$ implementations of the conditional normalising flow models, which were again set as neural spline flows [37] combined with a set encoder to condition on arbitrary batch sizes. Further architectural details can be found in our code repository. 256 samples ", "page_idx": 14}, {"type": "text", "text": "Algorithm 3 TrainFlow ", "page_idx": 15}, {"type": "text", "text": "input $\\hat{p}_{t},\\mathcal{D}_{t}$ for $n\\in\\{1,\\ldots,N\\}$ do {\u03b8\u02c6i}iB=1 \u223c(1 \u2212\u03f5)p\u02c6t + \u03f5p {\u02c6xi}iB=1 \u223cU(X) $\\{\\pmb{\\theta}_{i}^{*}\\}_{i=1}^{S}\\sim\\hat{p}_{t}$ $\\{\\hat{y}_{i,j}\\}_{i,j=1}^{S,B}\\sim\\mathcal{N}(\\mu_{t}(\\{\\hat{\\mathbf{x}}_{i},\\hat{\\pmb{\\theta}}_{i}\\}_{i=1}^{B};\\{\\pmb{\\theta}_{i}^{*}\\}_{i=1}^{S}),\\Sigma_{t}(\\{\\hat{\\mathbf{x}}_{i},\\hat{\\pmb{\\theta}}_{i}\\}_{i=1}^{B};\\{\\pmb{\\theta}_{i}^{*}\\}_{i=1}^{S}))$ $\\begin{array}{r}{\\phi\\leftarrow\\phi+\\frac{\\eta}{S}\\sum_{i=1}^{S}\\nabla_{\\phi}\\log q_{\\phi}\\left(\\pmb{\\theta}_{i}^{*}\\;\\Big|\\;\\mathcal{D}_{t}\\cup\\{\\hat{\\mathbf{x}}_{j},\\hat{\\pmb{\\theta}}_{j},\\hat{y}_{i,j}\\}_{j=1}^{B}\\right)}\\end{array}$ end for   \noutput $q_{\\phi}$   \ninput $q_{t},\\hat{p}_{t-1},\\mathcal{D}_{t-1}$ $\\widehat{\\Theta}=\\{\\widehat{\\pmb{\\theta}}_{i}\\}_{i=1}^{B}\\sim(1-\\epsilon)\\widehat{p}_{t-1}+\\epsilon p$ $\\hat{\\mathbf{X}}=\\{\\hat{\\mathbf{x}}_{i}\\}_{i=1}^{B}\\sim\\mathcal{U}(\\mathcal{X})$ for $n\\in\\{1,\\ldots,N\\}$ do $\\{\\pmb{\\theta}_{i}^{*}\\}_{i=1}^{S}\\sim\\hat{p}_{t-1}$ {y\u02c6i}iS=1 \u223cN(\u00b5t\u22121(X\u02c6,\u0398 ; {\u03b8i\u2217 }iS=1), \u03a3t\u22121(X\u02c6,\u0398 ; {\u03b8i\u2217 }iS=1)) (X\u02c6,\u0398 ) \u2190(X\u02c6,\u0398 ) + S\u03b7 iS=1 \u2207\u02c6X,\u0398 log qt \u03b8i\u2217  Dt \u222a{X\u02c6,\u0398 , y\u02c6i} end for   \noutput $\\{\\hat{\\mathbf{x}}_{i},\\hat{\\pmb{\\theta}}_{i}\\}_{i=1}^{B}$ ", "page_idx": 15}, {"type": "text", "text": "", "page_idx": 15}, {"type": "text", "text": "were subsampled from the MCMC posterior at each iteration to estimate expectations for EIG lower bound computations. The simulations kernel $\\hat{k}$ was a Mat\u00b4ern 2.5 kernel. For this experiment we did not model the error term, leaving it with a zero kernel, since data is generated directly from the simulator with no further error component, only Gaussian noise with a standard deviation of 0.5. Final KL estimates were computed using the maximum-a-posteriori hyper-parameters of the GP model learnt with the random search approach to minimise biases in the estimate of $\\mathbb{D}_{\\mathrm{KL}}(p_{T}||p_{0})$ due to differing GP hyper-parameters across baselines. ", "page_idx": 15}, {"type": "text", "text": "A.3 Soft-robotics simulation problem ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "The prior for the calibration parameters $p(\\pmb{\\theta}^{*})$ in this experiment consisted of a 2-dimensional standard normal transformed through a sigmoid and an affine transform composition to provide a smooth uniform distribution over a pre-specified range for the calibration parameters. Such smooth approximation allows gradients to be computed near the edges of the parameter space while not allowing optimisation to take the calibration parameter candidates outside the uniform prior boundaries, since these would be placed at infinity under the normalised space. The conditional normalising flow model used Zuko\u2019s implementation of neural spline flows with 10 transform layers. The set encoder consisted of a 2-layer fully connected 32-unit-wide neural network encoding each input into an 8-dimensional output which was then summed and passed through as the context input to condition the flow. Adam again was used for optimisation with a learning rate of 0.001 for the flow and 0.05 for the simulation inputs. Monte Carlo expectation estimates used 256 samples from the current MCMC posterior at each joint optimisation step. ", "page_idx": 15}, {"type": "text", "text": "A.4 Hyper-parameter tuning ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Besides the GP hyperparameters (e.g., lengthscales, noise variance, etc.), which had to be tuned for the non-GP-based problems, there are optimisation settings (i.e., step sizes, scheduling rates, etc.), conditional density model hyper-parameters (i.e., normalising flow architecture), and other algorithmic settings, e.g., the designs batch size $B$ . The latter is dependent on the available computing resources (e.g., number of CPU cores or compute nodes for simulations in a high-performance computing system). We tuned optimisation settings and architectural parameters for the conditional ", "page_idx": 15}, {"type": "image", "img_path": "m906PS5G9x/tmp/dade5b4c21bef2759d5c8d0eb5ff53c517027f7093d079962f37d3dfe7de62bf.jpg", "img_caption": ["(a) Reference posterior $p^{*}$ "], "img_footnote": [], "page_idx": 16}, {"type": "image", "img_path": "m906PS5G9x/tmp/2d78fbc0b64d97808318aa4d5ba7e1cab67b07c1d4e774004986b3111ee21c7c.jpg", "img_caption": ["(b) BACON final posterior "], "img_footnote": [], "page_idx": 16}, {"type": "image", "img_path": "m906PS5G9x/tmp/ef62dd027fba192796e099e9e2e6e49bfa64a71b93b73f49015de81cd0d40b32.jpg", "img_caption": ["(c) IMSPE baseline final posterior "], "img_footnote": [], "page_idx": 16}, {"type": "image", "img_path": "m906PS5G9x/tmp/0a769a85b6c2c7b189ec1c4f579617cc6462d41fdb20d7d413d5607d77c9d32c.jpg", "img_caption": ["(d) D-optimal baseline final posterior "], "img_footnote": [], "page_idx": 16}, {"type": "image", "img_path": "m906PS5G9x/tmp/ef3bd5db176f4eccdbe62f068b3624248ba561bdd306613aedc1fad280e0bf33.jpg", "img_caption": ["(e) Random baseline final posterior "], "img_footnote": [], "page_idx": 16}, {"type": "text", "text": "Figure 4: Final posterior approximations $p(\\pmb{\\theta}^{*}|\\mathcal{D}_{T})$ and simulation parameter $\\hat{\\pmb\\theta}$ (red crosses) choices by each method for the soft-robotics simulator calibration problem after one of the runs. The target/reference posterior (a) was inferred using a large number (1024) of simulations following a Latin hypercube pattern over the combined design $\\mathcal{X}$ and calibration parameters space $\\Theta$ and a uniform prior $p(\\pmb\\theta)$ over the same range as the smooth uniform prior the algorithms used. The posteriors are plotted as a 2D histogram over the normalised range (after an affine and sigmoid transform), which the algorithms used for optimisation. The KL divergences in Table 3 are computed with respect to this reference posterior. Also note that the simulation parameters $\\hat{\\pmb\\theta}$ in the plot correspond to different algorithmic choices for design inputs $\\hat{\\bf x}$ , which are 9-dimensional variables that are not plotted here. ", "page_idx": 16}, {"type": "text", "text": "normalising flows via Bayesian optimisation with short runs (e.g., 10-20 iterations) on the synthetic problem. However, depending on the number of parameters, a simpler approach, like grid search, might be enough. GP hyper-parameters were optimised online via maximum a posteriori estimation after each iteration\u2019s batch update. Further implementation details can be found in our code repository.10 ", "page_idx": 17}, {"type": "text", "text": "B Extensions of the proposed approach ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "In the following, we present two extensions to deal with limitations of the current approach. Namely, we can amortise inference over the calibration posterior by reutilising the learnt conditional distribution models as priors, instead of having to run, for example, MCMC. Secondly, we present derivations for a scalable sparse GP version of our method. ", "page_idx": 17}, {"type": "text", "text": "B.1 Amortisation ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "We use a conditional variational distribution model for $q(\\pmb\\theta^{*}|\\hat{y})$ . The main advantage of training a conditional model is that, once new data $\\hat{y}_{t}$ is observed, we readily obtain an approximation to the new posterior as $p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t})=p(\\pmb{\\theta}^{*}|\\hat{y}_{t},\\hat{\\mathbf{x}}_{t},\\hat{\\pmb{\\theta}}_{t},\\mathcal{D}_{t-1})\\approx q_{t}(\\pmb{\\theta}^{*}|\\hat{y}_{t})$ . There is, therefore, potential to reuse the variational posterior as the prior for the next iteration, and all the optimisation is concentrated within a single loop. ", "page_idx": 17}, {"type": "text", "text": "Approximate objective. We are still left with terms dependent on the posterior from the previous iteration $p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t-1})$ in Eq. 15. Firstly, however, note that the denominator inside the expectation is constant w.r.t. the optimisation variables, not affecting the maximiser. Secondly, we may replace the joint predictive distribution $p(\\hat{y},\\pmb{\\theta}^{*}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})$ by an approximation using the previous optimal variational posterior qt\u22121 as: ", "page_idx": 17}, {"type": "equation", "text": "$$\np(\\hat{y},\\pmb{\\theta}^{*}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})\\approx q_{t-1}(\\hat{y},\\pmb{\\theta}^{*}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}}):=p(\\hat{y}|\\pmb{\\theta}^{*},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t-1})q_{t-1}(\\pmb{\\theta}^{*})\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "where $q_{t-1}\\bigl(\\pmb{\\theta}^{*}\\bigr)\\,:=\\,q_{t-1}\\bigl(\\pmb{\\theta}^{*}|\\hat{y}_{t-1}\\bigr)\\,\\approx\\,p\\bigl(\\pmb{\\theta}^{*}|\\mathcal{D}_{t-1}\\bigr)$ . The following objective then approximately shares the same set of maximisers as the variational lower bound $\\widehat{\\mathrm{EIG}}_{t}(\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},q)$ : ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\hat{\\mathbf{x}}_{t},\\hat{\\pmb{\\theta}}_{t},q_{t}\\in\\underset{\\hat{\\mathbf{x}}\\in\\mathcal{X},\\hat{\\pmb{\\theta}}\\in\\Theta,q\\in\\mathcal{Q}}{\\mathrm{argmax}}\\mathbb{E}_{q_{t-1}(\\hat{y},\\pmb{\\theta}^{*}|\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}})}\\left[\\log q(\\pmb{\\theta}^{*}|\\hat{y})\\right]\\,.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "In practice, reusing the variational conditional posterior may tend to degenerate the approximation over time. However, that can be corrected by rerunning MCMC or a variational inference scheme over the data to obtain a fresh new posterior at every few iterations. ", "page_idx": 17}, {"type": "text", "text": "B.2 Conditional sparse models for large datasets ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Computing the variational EIG requires evaluating expectations with respect to the posterior predictive distribution $p(\\hat{y}|\\pmb{\\theta}^{*},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t})$ . Note, however, that, as $\\pmb{\\theta}^{*}$ appears inside a matrix inversion in the GP predictive (Eq. 8), each sample of $p(\\hat{y}|\\pmb{\\theta}^{*},\\hat{\\mathbf{x}},\\hat{\\pmb{\\theta}},\\mathcal{D}_{t})$ requires a $\\mathcal{O}(N_{t}^{3})$ computation cost, where $N_{t}:=R+t$ is the number of data points at iteration $t\\in\\mathbb{N}$ . This cost may quickly become prohibitive for reasonably large datasets, which are easily obtainable in batch settings (Sec. 5.4), rendering EIG computations infeasible. To scale our method to handle large amounts of data, we then need GP models that can reduce this computational complexity, while still allowing us to obtain reasonable EIG estimates. ", "page_idx": 17}, {"type": "text", "text": "B.2.1 Variational sparse GP approximation ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "We consider an augmentation to the original GP model which allows us to sparsify its covariance matrix, reducing the computational complexity of GP predictions. Following the variational sparse GP approach [46], let $\\mathbf{u}:=\\hat{f}(\\mathbf{Z}_{u})\\in\\mathbb{R}^{M}$ denote a vector of $M$ inducing variables representing unknown function values at a given set of pseudo-inputs $\\mathbf{Z}_{u}$ . The joint distribution between observations $\\mathbf{y}$ , function values $\\widehat{\\mathbf{f}}:=\\widehat{f}(\\mathbf{Z}(\\pmb{\\theta}^{*}))$ , inducing variables $\\mathbf{u}$ and the unknown parameters $\\pmb{\\theta}^{*}$ can be written as: ", "page_idx": 17}, {"type": "text", "text": "", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r}{p(\\mathbf{y},\\hat{\\mathbf{f}},\\mathbf{u},\\pmb{\\theta}^{*})=p(\\mathbf{y},\\hat{\\mathbf{f}},\\mathbf{u}|\\pmb{\\theta}^{*})p(\\pmb{\\theta}^{*})=p(\\mathbf{y}|\\hat{\\mathbf{f}})p(\\hat{\\mathbf{f}}|\\mathbf{u},\\pmb{\\theta}^{*})p(\\mathbf{u})p(\\pmb{\\theta}^{*})\\,,}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where $p(\\mathbf{y}|\\hat{\\mathbf{f}})=\\mathcal{N}(\\mathbf{y};\\hat{\\mathbf{f}},\\pmb{\\Sigma}_{\\mathbf{y}})$ , ", "page_idx": 18}, {"type": "equation", "text": "$$\np(\\hat{\\mathbf{f}}|\\mathbf{u},\\boldsymbol{\\theta}^{*})=\\mathcal{N}(\\hat{\\mathbf{f}};\\mathbf{K}_{\\hat{f}u}(\\boldsymbol{\\theta}^{*})\\mathbf{K}_{u u}^{-1}\\mathbf{u},\\mathbf{K}_{\\hat{f}\\hat{f}}(\\boldsymbol{\\theta}^{*})-\\mathbf{K}_{\\hat{f}u}(\\boldsymbol{\\theta}^{*})\\mathbf{K}_{u u}^{-1}\\mathbf{K}_{u\\hat{f}}(\\boldsymbol{\\theta}^{*}))\\,,\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "and $p(\\mathbf{u})=\\mathcal{N}(\\mathbf{u};\\mathbf{0},\\mathbf{K}_{u u})$ , using notation shortcuts ${\\bf K}_{u u}:=k({\\bf Z}_{u},{\\bf Z}_{u}),{\\bf K}_{\\hat{f}u}(\\pmb{\\theta}^{*}):=k({\\bf Z}(\\pmb{\\theta}^{*}),{\\bf Z}_{u})$ , and $\\mathbf{K}_{\\hat{f}\\hat{f}}(\\pmb{\\theta}^{*}):=k(\\mathbf{Z}(\\pmb{\\theta}^{*}),\\mathbf{Z}(\\pmb{\\theta}^{*}))$ . We may now formulate an evidence lower bound (ELBO) based on the joint variational density $q(\\hat{\\mathbf{f}},\\mathbf{u},\\pmb{\\theta}^{*})$ as: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\log p({\\bf y})=\\mathbb{E}_{q(\\hat{\\bf f},{\\bf u},\\theta^{*})}\\left[\\log\\frac{p({\\bf y},\\hat{\\bf f},{\\bf u},\\theta^{*})}{q(\\hat{\\bf f},{\\bf u},\\theta^{*})}\\right]+\\mathbb{D}_{\\mathrm{KL}}(q(\\hat{\\bf f},{\\bf u},\\theta^{*})||p(\\hat{\\bf f},{\\bf u},\\theta^{*}|{\\bf y}))}\\\\ &{\\qquad\\qquad\\geq\\mathbb{E}_{q(\\hat{\\bf f},{\\bf u},\\theta^{*})}\\left[\\log\\frac{p({\\bf y},\\hat{\\bf f},{\\bf u},\\theta^{*})}{q(\\hat{\\bf f},{\\bf u},\\theta^{*})}\\right]\\,.}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Since $\\mathbb{D}_{\\mathrm{KL}}\\big(q(\\hat{\\mathbf{f}},\\mathbf{u},\\pmb{\\theta}^{*})||p(\\hat{\\mathbf{f}},\\mathbf{u},\\pmb{\\theta}^{*}|\\mathbf{y})\\big)\\geq0$ , and 0 if and only if $q(\\hat{\\mathbf{f}},\\mathbf{u},\\pmb{\\theta}^{*})=p(\\hat{\\mathbf{f}},\\mathbf{u},\\pmb{\\theta}^{*}|\\mathbf{y})$ , maximising the ELBO above w.r.t. $q$ provides us with an approximation to the joint posterior. Choosing $q(\\hat{{\\mathbf{f}}},{\\mathbf{u}},\\pmb{\\theta}^{*}):=p(\\hat{{\\mathbf{f}}}|{\\mathbf{u}},\\pmb{\\theta}^{*})q({\\mathbf{u}},\\pmb{\\theta}^{*})$ simplifies the ELBO to [51]: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\log p(\\mathbf{y})\\geq\\mathbb{E}_{q(\\hat{\\mathbf{f}},\\mathbf{u},\\theta^{*})}\\left[\\log\\frac{p(\\mathbf{y}|\\hat{\\mathbf{f}})p(\\mathbf{u})p(\\theta^{*})}{q(\\mathbf{u},\\theta^{*})}\\right]\\,.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Sparse variational GP approaches can reduce the computational complexity of Bayesian inference on GPs to $\\mathcal{O}(N M^{2})$ or even $\\mathcal{O}(M^{3})$ [46, 52], where $N$ is the number of data points. ", "page_idx": 18}, {"type": "text", "text": "B.2.2 Structure of the joint variational posterior ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "If we would take a mean-field approach setting $q(\\mathbf{u},\\pmb{\\theta}^{*}):=q(\\mathbf{u})q(\\pmb{\\theta}^{*})$ , the ELBO above would further simplify, leading to a few computational advantages, as explored by Bayesian GP-LVM methods [51, 32, 52]. However, in our experimental design context, this approach leads to a few issues. Firstly, using the mean-field posterior as a replacement for our joint posterior breaks the dependence between $\\hat{y}$ and $\\pmb{\\theta}^{*}$ , leading their mutual information (a.k.a. EIG) to be zero regardless of the design inputs $\\hat{\\bf x}$ and $\\hat{\\pmb\\theta}$ . Secondly, although $\\mathbf{u}$ and $\\pmb{\\theta}^{*}$ are independent according to their priors (Eq. 25), they become dependent when conditioned on the data. In fact, the true posterior over u given the data and the true parameters $\\pmb{\\theta}^{*}$ is exactly Gaussian: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r}{p(\\mathbf{u}|\\mathcal{D}_{t},\\pmb{\\theta}^{*})=\\mathcal{N}(\\mathbf{u};\\mu_{t}(\\mathbf{Z}_{u};\\pmb{\\theta}^{*}),k_{t}(\\mathbf{Z}_{u},\\mathbf{Z}_{u};\\pmb{\\theta}^{*}))\\,,}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where $\\mu_{t}(\\cdot;\\pmb\\theta^{*})$ and $k_{t}(\\cdot,\\cdot;\\pmb\\theta^{*})$ are given by Eq. 9 and Eq. 10, respectively. Note, however, that the posterior over $\\pmb{\\theta}^{*}$ should not be Gaussian for a general non-linear kernel $k$ . Therefore, it makes more sense for us to model $q(\\mathbf{u},\\pmb{\\theta}^{*}):=q(\\mathbf{u}|\\pmb{\\theta}^{*})q(\\pmb{\\theta}^{*})$ . Moreover, learning a Gaussian conditional model over $\\mathbf{u}$ and a flexible variational distribution over $\\pmb{\\theta}^{*}$ should be enough to allow us to recover the true posterior, since $p(\\mathbf{u},\\pmb{\\theta}^{*}|\\mathcal{D}_{t})=p(\\mathbf{u}|\\mathcal{D}_{t},\\pmb{\\theta}^{*})p(\\pmb{\\theta}^{*}|\\mathcal{D}_{t}).$ . ", "page_idx": 18}, {"type": "text", "text": "Optimal variational inducing-point distribution. Given $\\pmb{\\theta}^{*}\\in\\Theta$ , we have a standard sparse GP model. The optimal variational inducing-point distribution is available in closed form following standard results [46] as: ", "page_idx": 18}, {"type": "equation", "text": "$$\nq^{*}(\\mathbf{u}|\\boldsymbol{\\theta}^{*})=\\mathcal{N}(\\mathbf{u};\\pmb{\\mu}_{u}(\\boldsymbol{\\theta}^{*}),\\pmb{\\Sigma}_{u}(\\boldsymbol{\\theta}^{*}))\\,,\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where the distribution parameters are: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{{\\boldsymbol\\mu}_{u}({\\boldsymbol\\theta}):=\\mathbf{K}_{u u}(\\mathbf{K}_{u u}+\\boldsymbol\\Psi_{2}({\\boldsymbol\\theta}))^{-1}\\boldsymbol\\Psi_{1}({\\boldsymbol\\theta})^{\\top}\\mathbf{y}}\\\\ &{\\sum_{u}({\\boldsymbol\\theta}):=\\mathbf{K}_{u u}(\\mathbf{K}_{u u}+\\boldsymbol\\Psi_{2}({\\boldsymbol\\theta}))^{-1}\\mathbf{K}_{u u}\\,,}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "and the conditional $\\Psi$ matrices are given by: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\Psi_{1}(\\pmb\\theta):=\\mathbf{K}_{\\hat{f}u}(\\pmb\\theta)\\Sigma_{\\mathbf{y}}^{-1}}\\\\ &{\\Psi_{2}(\\pmb\\theta):=\\mathbf{K}_{u\\hat{f}}(\\pmb\\theta)\\Sigma_{\\mathbf{y}}^{-1}\\mathbf{K}_{\\hat{f}u}(\\pmb\\theta)\\,,}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "for $\\pmb\\theta\\in\\Theta$ . The computational cost of sampling predictions with this model then reduces from $\\mathcal{O}(N^{3})$ to $\\mathcal{O}(N M^{2})$ . ", "page_idx": 18}, {"type": "text", "text": "Parametric variational inducing distribution. To further reduce the computational cost of predictions, we may accept a sub-optimal conditional variational inducing-point distribution given by a parametric model: ", "page_idx": 19}, {"type": "equation", "text": "$$\nq_{\\zeta}(\\mathbf{u}|\\pmb{\\theta}^{*}):=\\mathcal{N}(\\mathbf{u};\\mathbf{m}_{\\zeta}(\\pmb{\\theta}^{*}),\\pmb{\\Sigma}_{\\zeta}(\\pmb{\\theta}^{*}))\\,,\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "following the architecture in Sec. 5.3. This formulation allows us to approximate the evidence lower bound in Eq. 28 w.r.t. $q(\\mathbf{u}|\\pmb{\\theta}^{*})$ via mini-batching [see 53]. To do so, we approximate ${\\hat{f}}_{i}:={\\hat{f}}(\\mathbf{z}_{i})$ via conditionally independent samples given $\\mathbf{u}$ , for $i\\in\\{1,\\ldots,N\\}$ . As a result, the data-dependent term in Eq. 28 decomposes as a sum which is amenable to mini-batching: ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\mathbb{E}_{q_{\\zeta}(\\hat{\\mathbf{f}},\\mathbf{u}|\\theta^{*})}[\\log p(\\mathbf{y}|\\hat{\\mathbf{f}})]\\approx\\sum_{i=1}^{N}\\mathbb{E}_{q_{\\zeta}(\\hat{f}_{i},\\mathbf{u}|\\theta^{*})}[\\log p(y_{i}|\\hat{f}_{i})]\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "where $q_{\\zeta}(\\hat{f}_{i},\\mathbf{u}|\\pmb{\\theta}^{*})=p(\\hat{f}_{i}|\\mathbf{u},\\pmb{\\theta}^{*})q_{\\zeta}(\\mathbf{u}|\\pmb{\\theta}^{*})$ . The variational parameters $\\zeta$ need to be optimised within a second optimisation loop after the data update in Algorithm 1 w.r.t.: ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\ell_{t}(\\zeta):=\\mathbb{E}_{q_{t}(\\theta^{\\star})}\\left[\\sum_{i=1}^{N}\\mathbb{E}_{q_{\\zeta}(\\hat{f}(\\mathbf{z}_{i}),\\mathbf{u}\\mid\\theta^{\\star})}[\\log p(y_{i}|\\hat{f}(\\mathbf{z}_{i}))]\\right]-\\mathbb{E}_{q_{t}(\\theta^{\\star})}[\\mathbb{D}_{\\mathrm{KL}}(q_{\\zeta}(\\mathbf{u}\\mid\\theta^{\\star})||p(\\mathbf{u}))]\\,.\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Although the GP update is no longer available in closed form, we gain computational efficiency for large volumes of data. Applying mini-batches of size $L\\ll N$ to Eq. 37 results in a computational cost $\\mathcal{O}(L M^{2})$ (or $\\mathcal{O}(M^{\\bar{3}})$ , if $M>L)$ ), which is smaller than the cost $\\mathcal{O}(N M^{2})$ of the optimal variational distribution $q^{*}(\\mathbf{u}|\\pmb{\\theta}^{*})$ . ", "page_idx": 19}, {"type": "text", "text": "C Further discussions on limitations ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "High-dimensional settings. The dimensionality of our search space consists of the combined dimensionality of the designs $\\mathcal{X}$ and calibration parameters space $\\Theta$ , which can be large in practical applications. In general, in higher dimensions, one is to expect that the algorithm will require a larger number of iterations to find suitable posterior approximations due to the possible increase in complexity of the posterior. The analysis of such complexity, however, is problem-dependent and outside the scope of this work. In addition, note that we do not mean that the per-iteration runtime is directly affected, since what dominates the cost of inference is sampling from the GP, whose runtime complexity is dominated by the cube of the number of data points due to a matrix inversion operation, while being only linear in dimensionality. ", "page_idx": 19}, {"type": "text", "text": "Gaussian assumptions. We make Gaussian assumptions when modelling the simulator and the approximation errors, which can be seen as restrictive for some applications. However, if the errors are sub-Gaussian (i.e., its tail probabilities decay faster than that of a Gaussian), as is the case for bounded errors, we conjecture that a GP model can still be a suitable surrogate, as it would not underestimate the error uncertainty. If the error function is sampled from some form of heavy-tailed stochastic process (e.g., a Student-T process), the GP would, however, tend to under estimate uncertainty and lead to possibly optimistic EIG estimates that make the algorithm under-explore the search space. Changing from a GP model to another type of stochastic process model that can capture heavier tails would be possible, though require significant changes to the algorithm\u2019s predictive equations. We, however, believe that most real-world cases would present errors which are at least bounded (and therefore sub-Gaussian) with respect to the simulations. ", "page_idx": 19}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: Experimental results confirm. ", "page_idx": 20}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Justification: In conclusion section ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \u201dLimitations\u201d section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 20}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 20}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 20}, {"type": "text", "text": "Justification: ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material. ", "page_idx": 20}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: Code is included, though soft-robotics experiment data is protected. Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 21}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Justification: Code (included with submission) will be made public for most of the results, except soft-robotics data, which is subject to internal restrictions. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 21}, {"type": "text", "text": "", "page_idx": 22}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: Main details are provided and code is included. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 22}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \u201dYes\u201d if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 22}, {"type": "text", "text": "8. Experiments Compute Resources ", "page_idx": 22}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 23}, {"type": "text", "text": "Answer: [No] ", "page_idx": 23}, {"type": "text", "text": "Justification: Full experiment details will be provided for camera-ready version. Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 23}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: No data subject to NeurIPS Code of Ethics has been used in this work. ", "page_idx": 23}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 23}, {"type": "text", "text": "Answer: [No] ", "page_idx": 23}, {"type": "text", "text": "Justification: This work is of a theoretical nature introduce new methods for a general class of applications, potentially in science and engineering. ", "page_idx": 23}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 23}, {"type": "text", "text": "Answer: [No] ", "page_idx": 23}, {"type": "text", "text": "Justification: There are currently no plans to release any dataset other than synthetic data ", "page_idx": 23}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: Mostly open-source code has been used to base this project on. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 23}, {"type": "text", "text": "", "page_idx": 24}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 24}, {"type": "text", "text": "Answer: [No] Justification: Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 24}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 24}, {"type": "text", "text": "Answer: [NA] Justification: Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 24}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "page_idx": 24}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 24}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 24}, {"type": "text", "text": "Justification: ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 24}]