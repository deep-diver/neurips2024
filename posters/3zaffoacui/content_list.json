[{"type": "text", "text": "On the Inductive Bias of Stacking Towards Improving Reasoning ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Nikunj Saunshi\u2217 Google Research nsaunshi@google.com ", "page_idx": 0}, {"type": "text", "text": "Stefani Karp Google Research stefanik@google.com ", "page_idx": 0}, {"type": "text", "text": "Shankar Krishnan Google Research skrishnan@google.com ", "page_idx": 0}, {"type": "text", "text": "Sobhan Miryoosef Google Research miryoosefi@google.com ", "page_idx": 0}, {"type": "text", "text": "Sashank J. Reddi Google Research sashank@google.com ", "page_idx": 0}, {"type": "text", "text": "Sanjiv Kumar Google Research sanjivk@google.com ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Given the increasing scale of model sizes, efficient training strategies like gradual stacking [Gong et al., 2019, Reddi et al., 2023] have garnered interest. Stacking enables efficient training by gradually growing the depth of a model in stages and using layers from a smaller model in an earlier stage to initialize the next stage. Although efficient for training, the model biases induced by such growing approaches are largely unexplored. In this work, we examine this fundamental aspect of gradual stacking, going beyond its efficiency benefits. We propose a variant of gradual stacking called MIDAS that can speed up language model training by up to $40\\%$ . Furthermore we discover an intriguing phenomenon: MIDAS is not only training-efficient but surprisingly also has an inductive bias towards improving downstream tasks, especially tasks that require reasoning abilities like reading comprehension and math problems, despite having similar or slightly worse perplexity compared to baseline training. To further analyze this inductive bias, we construct reasoning primitives \u2013 simple synthetic tasks that are building blocks for reasoning \u2013 and find that a model pretrained with stacking is significantly better than standard pretraining on these primitives, with and without fine-tuning. This provides stronger and more robust evidence for this inductive bias towards reasoning. These findings of training efficiency and inductive bias towards reasoning are verified at 1B, 2B and 8B parameter language models. Finally, we conjecture the underlying reason for this inductive bias by exploring the connection of stacking to looped models and provide strong supporting empirical analysis. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "With the advent of very large deep learning models, efficient training to reduce the compute and time requirements is becoming increasingly important. Along with efficient optimization procedures, there has been a surge in interest to design efficient training strategies. One practical approach is to use smaller models to initialize larger models. Usually, this results in much faster convergence compared to vanilla training [Chen et al., 2022, 2016, Gong et al., 2019, Reddi et al., 2023, Wang et al., 2023, Li et al., 2023, Kim et al., 2023, Yao et al., 2024, Wang et al., 2024]. Stacking and growing based approaches have particularly gained traction recently. For instance, gradual stacking [Reddi et al., 2023] is a prominent approach where in each stage the last few layers of the model are stacked onto itself to initialize the model\u2019s next stage, until the desired depth is reached. This has been shown to significantly speed up BERT pretraining and also has some theoretical justification for the efficiency aspect. While these methods can speed up training, such changes can also induce specific biases into the model. However, the effect of stacking-based approaches on generalization remains a fundamental open question and is largely unexplored. ", "page_idx": 0}, {"type": "image", "img_path": "3ZAfFoAcUI/tmp/7b030e23789121246b0d2a5a0850a7df990b4bcc7328b9e41580f77f31fd75db.jpg", "img_caption": ["Figure 1: (a) Pictorial depiction of gradual stacking and MIDAS. (b) Accuracy improvements (in $\\%$ ) for model trained with MIDAS over baseline for various task groups, despite having the same perplexity. For both 1B, 2B and 8B models, we see that improvements are mostly positive, and are much larger for tasks that require a lot of reasoning. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "Modern deep learning models, when trained carefully, have been shown to exhibit interesting inductive biases, and their success is partially attributed to them. Such biases can arise either from model architecture, optimization techniques, or training strategies, and these biases come in various forms including simplicity bias, flatness of learned function, and sparsity. The implicit bias of optimizers, in particular, has been subject to extensive research. For instance, the implicit bias of first-order methods like stochastic gradient descent has been studied extensively in overparametrized settings [Gunasekar et al., 2018, Liu et al., 2023]. Similarly, the inductive biases of architecture components like self-attention and convolution have also been studied [Edelman et al., 2022, Wang and Wu, 2023]. More recently, there has also been interest in constructs like looped models [Lan et al., 2020, Dehghani et al., 2018] that share weights across layers. They have been shown to be powerful enough to emulate programmable computers [Giannou et al., 2023] and have the inductive bias to simulate iterative solutions [Yang et al., 2023], thereby yielding models with algorithmic abilities. However, in this vein, very little is known about the implicit biases of newer training strategies (e.g., greedy layerwise training or gradual stacking) that are gaining popularity. ", "page_idx": 1}, {"type": "text", "text": "In this work, we investigate the inductive bias of stacking-based approaches beyond training efficiency. We uncover an intriguing phenomenon \u2014 pretraining with a variant of stacking is not only efficient, but also has a desirable inductive bias towards improving downstream benchmarks. First, through comprehensive empirical analysis, we discover a novel variant of gradual stacking called MIDAS (MIDdle grAdual Stacking) which copies the middle block of layers of a small network to initialize a larger network (see Figure 1). We demonstrate that MIDAS is more efficient in training compared to standard training and the previous leading stagewise training approach. However, remarkably, it also yields significantly better performance on many downstream reasoning tasks. For instance, we see in Figure 1 that MIDAS has significantly better performance on math word problems and reasoning primitives. This performance boost should come as a surprise, since MIDAS uses exactly the same data and fewer training FLOPS compared to standard training. In fact, the pretraining perplexity of MIDAS on a validation set matches that of standard baseline training. This strongly suggests that there is some inductive bias for MIDAS at play. ", "page_idx": 1}, {"type": "text", "text": "In this paper, we formalize and provide strong evidence for such an \"inductive bias\" \u2013 MIDAS achieves better downstream evaluations despite performing similarly in terms of pretraining validation perplexity. Thus, the improved quality of MIDAS is not because of better generalization in the pretraining objective, but rather due to its ability to extract more skills and abilities from the pretraining process. This kind of inductive bias phenomenon was first formalized in Saunshi et al. [2022] for contrastive learning and later in Liu et al. [2023] for language modeling on synthetic data. However, this is the first evidence of a strong inductive bias for a training procedure in real language model training. While our real-world benchmarks already provide strong evidence, in order to better isolate the contributing factors, we construct simple synthetic tasks that are building blocks for reasoning, called reasoning primitives. We find that a model pretrained with MIDAS has much better performance on the reasoning primitives than a model obtained through standard pretraining, as is evident in Figure 1. In light of the above discussion, we state the main contributions of our paper. ", "page_idx": 1}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "\u2022 We propose a novel variant of gradual stacking, called MIDAS, that achieves better training efficiency than gradual stacking.   \n\u2022 Our investigation of the inductive bias in gradual stacking approaches, particularly with MIDAS, reveals a surprising benefit: beyond enabling efficient training, it also enhances performance on downstream tasks. This improvement is especially notable in tasks that rely on context and reasoning abilities.   \n\u2022 We provide strong evidence of the aforementioned phenomenon on several datasets that have previously been used to demonstrate reasoning capabilities.   \n\u2022 We construct simple synthetic tasks that are building blocks for reasoning and demonstrate that MIDAS performs significantly better than baseline training on these tasks. These datasets may be of independent interest to the LLM reasoning community.   \n\u2022 Finally, we conjecture the reason behind improved reasoning capabilities of MIDAS by presenting connections between gradual stacking and looped models and provide strong empirical evidence to support it. ", "page_idx": 2}, {"type": "text", "text": "2 Problem Setup ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this section, we first present the problem setup and background material needed for this paper.   \nBefore we discuss the problem setting, we set up the following notation for the rest of the paper. ", "page_idx": 2}, {"type": "text", "text": "Notation. For a deep network $f$ , we use $f_{i}$ and $\\#(f)$ to denote the $i^{\\mathrm{th}}$ layer and the number of layers of the network, respectively. With slight abuse of notation, we use $f_{i,b}$ (where $i,b\\in Z^{+})$ to denote the layers between $(i-1)\\cdot b$ to $i\\cdot b$ of a deep network $f$ . In other words, $f_{i,b}$ denotes the $i^{\\mathrm{th}}$ block of $b$ layers in a deep network $f,\\,a_{1:k}$ is used to denote a sequence of $k$ scalars $\\{a_{1},\\ldots,a_{k}\\}$ . ", "page_idx": 2}, {"type": "text", "text": "Our goal is to learn a function $f:\\mathcal X\\to\\mathcal Y$ which minimizes the loss $\\mathbb{E}_{(x,y)\\sim\\mathcal{D}}\\,\\ell(f(x),y)$ , for some loss function $\\ell:\\mathcal{V}\\times\\mathcal{V}\\rightarrow\\mathbb{R}^{+}\\cup\\{0\\}$ and data distribution $\\mathcal{D}$ on $\\mathcal X\\times\\mathcal Y$ . We are interested in functions of the form $f=f_{L}\\circ f_{L-1}\\circ\\cdot\\cdot\\cdot\\circ f_{1}$ where $\\circ$ and $L$ represent function composition and depth of the network, respectively. We use $\\mathcal{F}_{L}$ to denote the function class consisting of functions of this form. Given samples from the distribution $\\mathcal{D}$ , we typically use an iterative stochastic optimizer (e.g., SGD) to learn a function that minimizes the loss. We note that the optimization procedure is inconsequential to the arguments in the paper. For standard training, each iteration is of the form: ", "page_idx": 2}, {"type": "equation", "text": "$$\nf^{t}=f^{t-1}+A(f^{t-1},{\\mathcal{B}}_{t},\\eta_{t}),\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $B_{t}$ is a mini-batch from distribution $\\mathcal{D}$ and $\\mathcal{A}(f^{t-1},\\mathcal{B}_{t},\\eta_{t})$ represents the iterative optimizer update at $f^{t-1}$ on $B_{t}$ and learning rate $\\eta_{t}$ . The computation cost and memory requirement for training typically increases linearly with the depth, making even simple algorithms, like SGD, slow for very large models. Throughout this paper, we use $T$ to denote the total number of training iterations. ", "page_idx": 2}, {"type": "text", "text": "2.1 $k$ -stage training ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Since we primarily focus on stagewise training approaches, it is useful to formally define a stagewise training procedure. In contrast to standard training, $k$ -stage training involves dividing the training process into $k$ stages, and at each stage, using the the model from the previous stage to initialize the model in the current stage. For simplicity, we assume $L$ is divisible by $k$ . The following are the key ingredients: ", "page_idx": 2}, {"type": "text", "text": "1. Function class across stages. At stage $i$ , we use function class ${\\mathcal{F}}_{d(i)}$ where $d(i)$ denotes the depth of the network at that stage. When $d(i)\\ll L$ , training is more efficient. ", "page_idx": 2}, {"type": "text", "text": "2. Training schedules across stages. As training is divided into $k$ stages, we use $T_{1},\\cdot\\cdot\\cdot,T_{k}$ steps across stages such that $\\textstyle\\sum_{i=1}^{k}T_{i}=T$ . ", "page_idx": 2}, {"type": "image", "img_path": "3ZAfFoAcUI/tmp/c5a625a31035539d44d59d956d32d996f76bdab40468d5f82b2a750a40d35485.jpg", "img_caption": [], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "Figure 2: (a) For an ALBert model trained with weight sharing across all layers, we measure the functional similarity between layers by looking at the top $1\\%$ activated neurons in each MLP layer and measure the intersection-over-union (IoU) metric for each pair of layers. Despite all layers having the same parameters, a natural functional similarity structure emerges around the middle. (b) For a UL2 model trained with GRADSTACK, we measure the cosine similarity between every pair of layer blocks for the first feedforward layer weights. (c) The same similarity measured for MIDAS. The cosine similarities for stacking based models suggests a strong connection to looped models, and MIDAS has a closer similarity structure to ALBert style looped models than GRADSTACK. ", "page_idx": 3}, {"type": "text", "text": "3. Stage initialization. This is the key component of stagewise training. Given a network $f\\,\\in$ $\\mathcal{F}_{d(i-1)}$ trained in the $(i-1)^{\\mathrm{th}}$ stage, let $\\mathcal{M}_{i}(f)$ denote the network initialization for the next stage where $\\mathcal{M}_{i}:\\mathcal{F}_{d(i-1)}\\rightarrow\\mathcal{F}_{d(i)}$ is a growth operator. ", "page_idx": 3}, {"type": "text", "text": "Almost all the recent stagewise training procedures are different instantiations of this framework, using different training schedules and stage initializations. We will revisit some prominent instantiations of the framework in the next section. ", "page_idx": 3}, {"type": "text", "text": "2.2 Progressive & Gradual Stacking ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Progressive and gradual stacking are two special instantiations of the aforementioned framework. We provide a brief description of these approaches since they are important for our discussion. ", "page_idx": 3}, {"type": "text", "text": "Progressive Stacking [Gong et al., 2019]. This is a simple instance of $k$ -stage training setup where model in the previous stage is stacked onto itself to initialize the model in the next stage. In particular, (1) depth $d(i)=2^{i-1}d(\\bar{1})$ grows exponentially, (2) schedule $T_{i}$ is typically $T/k$ or proportional to $d(i)$ , and (3) the growth function $\\bar{\\mathcal{M}_{i}}(f)=f\\overset{\\cdot}{\\circ}f$ . ", "page_idx": 3}, {"type": "text", "text": "Gradual Stacking [Reddi et al., 2023]. In contrast to progressive stacking, gradual stacking linearly increases the model depth by $k$ in each stage. It only stacks the last $L/k$ layers of model from the previous stage to initialize the model in the next stage, as follows. ", "page_idx": 3}, {"type": "text", "text": "1. The depth $\\begin{array}{r}{d(i)=\\frac{L\\cdot i}{k}}\\end{array}$ grows linearly with the stage. 2. $T_{i}$ is typically either $T/k$ or allocated proportional or exponential to depth. 3. ${\\cal M}_{i}(f_{d(i-1)}\\circ\\cdot\\cdot\\cdot\\circ f_{1})=f_{d(i-1)}\\cdot\\cdot\\cdot\\circ f_{d(i-1)-(L/k)+1}\\circ f_{d(i-1)}\\cdot\\cdot\\cdot f_{1}$ . This corresponds to stacking the last $L/k$ layers onto the network to initialize the next stage model. ", "page_idx": 3}, {"type": "text", "text": "In the next section, we study a novel variant of gradual stacking that enables faster training and exhibits an interesting inductive bias, which we examine carefully. ", "page_idx": 3}, {"type": "text", "text": "3 Algorithm: MIDAS ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "We present the MIDAS algorithm in this section. We first discuss the motivation behind this variant of gradual stacking and then formally define the algorithm. ", "page_idx": 3}, {"type": "text", "text": "3.1 Motivation ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "The motivation for MIDAS touches upon two crucial aspects: (a) the role of different layers in a deep network and (b) a connection to looped models. Before delving into more technical details, it is important to illustrate these points. We present the case for MIDAS based on three observations. ", "page_idx": 3}, {"type": "text", "text": "Observation 1: gradual stacking breaks the natural role of layers. Recall that gradual stacking initializes a larger model by duplicating and stacking the last block of $b$ from the smaller model. Thus in the newly initialized model, the second-last block of $b$ layers will be the same as the last $b$ layers of the smaller model (see Figure 1). Intuitively, this is undesirable since the last few layers have been shown to play a different role compared to other layers for Transformer models [Belrose et al., 2023]. We further validate this in Figure 6. Thus, duplicating the last few layers can break the natural role of layers at the initialization, making it a suboptimal choice. However, it is plausible that the similarity structure across layers is broken after continued training and the initialization is inconsequential. The next observation shows that this is not true, and establishes a connection to looped models \u2013 networks with shared parameters between layers. ", "page_idx": 4}, {"type": "text", "text": "Observation 2: gradual stacking leads to models resembling looped models. To check the effect of the initialization, we measure the cosine similarity between weights of layers for a model pretrained with gradual stacking. In Figure 2b, we observe that indeed the layers continue to have very high cosine similarity at the end of training, thus establishing a connection between stacking and looped models like ALBert [Lan et al., 2020] and Universal Transformers [Dehghani et al., 2018]. Unsurprisingly, the similarity structure for gradual stacking is lopsided towards the end of the model, which raises the question: Is this similarity structure natural for looped models? ", "page_idx": 4}, {"type": "text", "text": "Observation 3: looped models exhibit similarity in the middle. In order to study this, we train a prototypical looped model, ALBert, where all layers share the same parameters. Surprisingly, despite parameters being shared, a natural similarity structure emerges between layers: yet again the first and last layers tend to be functionally dissimilar to other layers, whereas the functional similarity between layers is the highest in the middle (see Figure 2a). ", "page_idx": 4}, {"type": "text", "text": "The above observations provides a strong motivation for stacking in the middle rather than at the end, thus inspiring our MIDAS algorithm. ", "page_idx": 4}, {"type": "text", "text": "3.2 MIDAS algorithm ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "First we define the following mapping operator that is useful for stage initialization in MIDAS. ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathcal{M}(f,b)=f_{n,b}\\circ\\cdots\\circ\\underbrace{f_{\\lceil n/2\\rceil,b}\\circ f_{\\lceil n/2\\rceil,b}}_{\\mathrm{Replication}}\\circ\\cdots\\circ f_{1,b},}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $n=\\#(f)/b$ is the number of blocks of $b$ layers in deep network $f$ . Note that operator $\\mathcal{M}(f,b)$ expands the size of the network by size $b$ . Based on this operator, MIDAS can again be described as a simple instantiation of the $k$ -stage training framework, as seen below. For completeness, the pseudocode for MIDAS in listed in Algorithm 1. ", "page_idx": 4}, {"type": "equation", "text": "$$\nf^{s,t}\\stackrel{\\cdot}{=}f^{s,t-1}+\\mathcal{A}(f^{s,t-1},\\mathcal{B}_{t},\\eta_{t})\n$$", "text_format": "latex", "page_idx": 4}, {"type": "equation", "text": "$$\nf^{s+1,0}=\\mathcal{M}(f^{s,T_{s}},L/k)\n$$", "text_format": "latex", "page_idx": 4}, {"type": "image", "img_path": "3ZAfFoAcUI/tmp/1f449a036c8e85ae534886c84d58991bfaf3eda2bfb7d11dd8236913d98822b7.jpg", "img_caption": ["Histogram of gain over Baseline for different Midas models "], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "Figure 3: Histogram of accuracy improvements for models trained with MIDAS over baseline. The data points are MIDAS 1B models listed in Table 1. The figure shows that MIDAS-based models have much higher improvement in the contextual version of TyDiQA compared to the non-contextual version. ", "page_idx": 4}, {"type": "text", "text": "1. The depth $\\begin{array}{r}{d(i)=\\frac{L\\cdot i}{k}}\\end{array}$ grows linearly with the stage, similar to gradual stacking. ", "page_idx": 5}, {"type": "text", "text": "2. $T_{i}$ is typically either proportional to $i$ (linear proportional) or $i^{2}$ (square proportional) or $\\exp(i)$ (exponential). We will revisit this during our empirical analysis. 3. We use growth operator $\\mathcal{M}$ in equation 1 for initializing the next stage, which corresponds to replicating the middle $L/k$ layers to initialize the next stage model. ", "page_idx": 5}, {"type": "text", "text": "3.3 Experiments: UL2 Pretraining ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "In this section, we evaluate MIDAS for standard language model pretraining. We train a 24L decoderonly model with 1.5B parameters using the UL2 objective [Tay et al., 2022] on a mixture of C4, Wikipedia, Arxiv and Github. The observations also hold for GPT-style autoregressive language modeling. To enable fair comparison, we cached the pretraining dataset and so all methods are trained for the same number 500B tokens in the same order, using the same batch size (refer to Appendix A.1 for more details on the training setup). We pretrain models with three methods: (a) standard training (Baseline), (b) gradual stacking (GRADSTACK) and (c) our proposed method MIDAS. The goal is to compare them with respect to validation loss and downstream performance on several diverse benchmarks. Motivated by the proportional schedules from prior work, we try the following generalized proportional schedules for gradual stacking and MIDAS. ", "page_idx": 5}, {"type": "text", "text": "Definition 3.1 (PROP- $\\alpha$ schedule). For a total training budget of $T$ steps, the schedule PROP- $\\cdot\\alpha$ spends time $T_{i}$ in each stage such that $T_{i}\\propto i^{\\alpha}$ for all stages $i\\in[k]$ . Thus $\\begin{array}{r}{T_{i}=\\frac{i^{\\alpha}}{\\sum_{j=1}^{k}j^{\\alpha}}T}\\end{array}$ ", "page_idx": 5}, {"type": "text", "text": "PROP-1 schedule has been found to work very well for BERT pretraining [Reddi et al., 2023]. Since UL2 pretraining is a harder task, we also explore less aggressive schedules like PROP-2 and PROP-3 that spend more time on larger models. ", "page_idx": 5}, {"type": "text", "text": "Efficiency and perplexity findings. We summarize the main results in Table 1, for various stacking methods and schedules. Firstly, we note that for all schedules, MIDAS has significantly better validation log perplexity than GRADSTACK at the same speedup level. This suggests that stacking in the middle is a lot more effective for optimization than stacking at the end of the model. With the PROP-2 schedule, MIDAS is $24\\%$ faster and nearly matches the baseline\u2019s log perplexity. Additionally, we observe that the findings are robust to the choice of block size for stacking. ", "page_idx": 5}, {"type": "text", "text": "Downstream benchmark evaluations. While perplexity can serve as a decent proxy for model quality, there is growing evidence that it is not the best measure [Liang et al., 2023]. Downstream benchmark evaluations serve as a more holistic measure for quality and are out-of-distribution evaluations of skills. To this effect, we evaluate MIDAS on many standard benchmarks and these are grouped into task categories in Table 1 (refer to Appendix A.2 for more detailed evaluations on individual tasks). The accuracy for task category is an average over representative tasks from that group. For instance, for closed book QA task, we consider an average accuracy on TriviaQA, TydiQA (no context), NaturalQuestions and WebQuestions. ", "page_idx": 5}, {"type": "text", "text": "Surprisingly, we find that downstream improvements for MIDAS are significantly larger than the improvements in perplexity. In particular, MIDAS with PROP-2 schedule has very similar perplexity to baseline at $24\\%$ speedup, but the average downstream performance for MIDAS $(26.8\\%)$ is much better than baseline $(24.0\\%)$ . In fact, even MIDAS with PROP-1 schedule which has worse log perplexity is much better on downstream evaluations. Similar trends of better downstream evals holds for the 2B parameter model. The improvements are particularly large for open book QA and math word problems, both of which are tasks that require reasoning abilities whereas memorization tasks like closed book QA do not improve. We conjecture that these downstream improvements are due to an inductive bias induced by stacking and we dive deeper into this in the next section. ", "page_idx": 5}, {"type": "text", "text": "4 Inductive bias of stacking ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Results in Table 1 demonstrate that MIDAS not only yields training speedups, but also improves downstream evaluations when trained on the same number of tokens as standard training. This suggests that stacking can extract more skills out of the same data. Here, we take a closer look at these improvements in downstream evaluations through the lens of an inductive bias of stacking. ", "page_idx": 5}, {"type": "text", "text": "Table 1: Downstream evaluations for UL2 pretrained models with 1B, 2B and 8B parameters. Comparisons include standard training (Baseline), gradual stacking (GRADSTACK) from [Reddi et al., 2023] and our proposed method MIDAS. The downstream evaluations are averaged over tasks within 3 task groups. See Appendix A for precise tasks included in each task group. For each cateory and model size, we highlight the top model is bolded and the second best model is underlined. Firstly, MIDAS is much better than GRADSTACK, thus justifying stacking in the middle. Secondly, MIDAS can match the log perplexity of baseline training while being roughly $24\\%$ faster. Furthermore, even the schedule with $40\\%$ speedup has much better downstream evaluations compared to baseline, even though it has worse log perplexity. The improvements are particularly large for task groups that require reasoning (open book QA, math word problems). ", "page_idx": 6}, {"type": "table", "img_path": "3ZAfFoAcUI/tmp/6f8f2615cb471f288270be861231035ea33712f181a9f4e61a7191effb8b5d48.jpg", "table_caption": [], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "4.1 Downstream performance vs log perplexity ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "A reasonable expectation from pretraining is that improvements in the pretraining objective would correlate with improvements in model quality and downstream performance. This notion of transfer has even been theoretically formalized for language modeling in Saunshi et al. [2020], Arora and Goyal [2023]. Thus, based on this, a natural explanation for the downstream improvements of stacking would be that it generalizes better on the pretraining objective. However, as we see in Table 1, downstream performance of MIDAS is better despite having similar or worse validation perplexity \u2013 hence this is not simply the case of better generalization to unseen pretraining data. It is natural to ask: If not perplexity, what explains this downstream phenomenon? ", "page_idx": 6}, {"type": "text", "text": "Since pretraining objective is just a proxy objective for model quality, it is plausible that different training strategies and model architectures can extract different levels of skills from it. This is because there are multiple ways of doing well on the pretraining tasks, and some training strategies can be biased to pick one solution over another one. This behavior has been formalized as the inductive bias in pretraining by recent work [Saunshi et al., 2022, Liu et al., 2023] \u2013 at the same level of validation pretraining loss, different optimization algorithms could have vastly different downstream performance. We hypothesize that a similar phenomenon is at play when it comes to stacking. ", "page_idx": 6}, {"type": "text", "text": "Isoplots. Inspired by this phenomenon of different downstream performance at the same perplexity, we visualize the inductive bias of a method by plotting downstream accuracy vs log perplexity isoplots as training proceeds. We use the UL2 1B models that are pretrained with standard (baseline) training and with MIDAS using the PROP-2 schedule (refer to Section 3.3 for more details). In Figure 4, we visualize the downstream vs log perplexity plots for different task groups \u2013 closed-book QA, open-book QA and math word problems. We observe a very interesting trend \u2013 MIDAS and baseline training can have different isoplot behaviors and the divergence is different for different tasks. ", "page_idx": 6}, {"type": "image", "img_path": "3ZAfFoAcUI/tmp/898b9a0539f6c573271000b35a640d63a858d35c5ef68bcf39cfa9bea99b06c8.jpg", "img_caption": ["Figure 4: Downstream evalulation vs validation log perplexity isoplots as training proceeds for baseline and MIDAS 1B models trained on the same data (stacking is $24\\%$ faster here). On the y-axis we track the performance on various task groups \u2013 closed book QA, open book QA, math word problems and our reasoning primitives from Section 5. On the $\\mathbf{X}$ -axis the log perplexity is presented in the reverse order, thus downstream performance for both methods improves as log perplexity gets lower. For closed book QA (memorization) tasks MIDAS has very similar trends to baseline. For open book QA tasks and math word problems, MIDAS has much better downstream performance at an equivalent log perplexity. This showcases the inductive bias of MIDAS towards better overall quality and better reasoning abilities. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "4.2 Reasoning vs memorization for QA ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "For a clearer display of the inductive bias, we measure the improvements due to MIDAS on closed book vs open book QA tasks. It is reasonable to assume that closed book QA tasks require strong memorization abilities whereas open book QA tasks require some reasoning abilities to infer answers from the context that is provided. On average, we see much larger improvements on open book QA tasks compared to closed book QA tasks, as already evident in Figure 1 and Table 1. ", "page_idx": 7}, {"type": "text", "text": "MIDAS is significantly better on Open book QA. To make a direct comparison, we consider TydiQA-GoldP and TydiQA-NoContext tasks \u2013 the datasets are identical and the only difference is whether or not additional context is provided (the answer for the contextual version is guaranteed to be inferred from the given context). In Figure 3, we see that the improvements by various MIDAS based models on the contextual version of TydiQA are much higher than those on the non-contextual version. This provides direct evidence of the bias of MIDAS towards improving tasks that require reasoning. Furthermore, we find that the memorization performance of stacking improves as the schedule spends more time on the larger model. ", "page_idx": 7}, {"type": "text", "text": "4.3 Reasoning in math tasks ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "To test reasoning abilities, we evaluate the language models on various math word problem datasets like SVAMP [Patel et al., 2021], ASDiv [Miao et al., 2020], AQuA dataset for algebraic word problems, the MAWPS benchmark [Koncel-Kedziorski et al., 2016]. We report 5-shot evaluation for the pretrained model on these tasks. Following Wei et al. [2022], we use an external calculator to do the arithmetic and evaluate the models on their ability to compute the correct expression for the answer. This is because small models have bad arithmetic accuracy. The choice of using calculator or not does not significantly affect the trends of the results. For stacking, we use MIDAS PROP-2 model because it achieves nearly the same perplexity as the baseline model (while being $24\\%$ faster), thus, leading to a fair comparison based on the previous notion of inductive bias. ", "page_idx": 7}, {"type": "text", "text": "MIDAS is significantly better on Math/Reasoning tasks. Detailed results can be found in Table 5. For most math tasks, we observe that the MIDAS-based pretrained model is significantly better than the baseline model, especially for the MAWPs benchmark. This provides further evidence of better math and reasoning capabilities of MIDAS. ", "page_idx": 7}, {"type": "text", "text": "GSM8K fine-tuning. We also evaluate the 2B and 8B models on harder math problems from the GSM8k dataset [Cobbe et al., 2021] through few-shot prompting and fine-tuning. Full results are presented in Table 2. For MIDAS we use the PROP-2 model that has very similar perplexity as the ", "page_idx": 7}, {"type": "text", "text": "Table 2: Evaluation on math tasks, including math word problems from Table 1 and a harder task GSM8k. For GSM8k we report accuracy with 8-shot prompts and with finetuning. We also report accuracy on all tasks after using an external calculator to fix arithmetic errors; this corresponds to w/ calc. Overall the use of calculator improves the accuracy for all models on all tasks. The benefit of MIDAS over baseline is even higher with calculator. ", "page_idx": 8}, {"type": "table", "img_path": "3ZAfFoAcUI/tmp/3b2002bbc13f61eb9cb3e8c8838c7457f4411643dceb552628569cc025ab0edd.jpg", "table_caption": [], "table_footnote": [], "page_idx": 8}, {"type": "image", "img_path": "3ZAfFoAcUI/tmp/97f2fd193a2d3b8802819f2b67ebf62f65da8807658b8ec289fa125ef5d3d24a.jpg", "img_caption": ["Figure 5: Accuracy improvements for model trained with MIDAS over baseline for representative reasoning primitives, despite having the same perplexity. We see clear improvements for MIDAS on almost all the primitives, both with 5-shot evaluation and after fine-tuning (FT) for the depth 1 and 2 primitive. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "baseline model. We find that MIDAS has much higher accuracy after fine-tuning, thus suggesting that the beneftis of the inductive bias continue after fine-tuning and are not just restricted to few-shot evaluations. In particular, on the test set, the accuracy metric increased from $5.3\\%$ (for the baseline model) to $10.4\\%$ (for MIDAS) for the 2B model (these numbers were produced by computing the average score over three runs with different random seeds). Similarly the GSM8k accuracy of the 8B model improves from $12.3\\%$ to $15.2\\%$ . This suggests that MIDAS not only improves the performance on harder math tasks, but also that the gains remain or improve after fine-tuning. ", "page_idx": 8}, {"type": "text", "text": "Effect of calculator. For LLMs with less than 20B parameters, Wei et al. [2022] found that models often solve math problems correctly but make arithmetic errors, leading to low accuracy. Wei et al. [2022] remedied this by computing all arithmetic expressions using a Python program as an external calculator. In Table 2 we find that this improves the accuracy for our models too. Interestingly, the gap between MIDAS and baseline gets even larger with calculator use in almost all comparisons. We believe this is because arithmetic abilities are closer to memorization for smaller models [Razeghi et al., 2022] and calculator use makes the problem closer to reasoning, since now the model only has to infer the right expression. We believe this interplay between reasoning and memorization for math problems deserves further investigation. ", "page_idx": 8}, {"type": "text", "text": "4.4 Connection to looped models ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "Given the nature of the growth operator in each stage, we hypothesize that stacking based models are close to looped models. The layer duplication that happens at every stage ensures that blocks of layers start from a common initialization. We measure the similarity between different blocks of layers by measuring cosine similarities between the parameter vectors (see Figure 2). Since looped models have been conjectured to solve algorithmic problems [Giannou et al., 2023] by finding iterative solutions [Yang et al., 2023], we conjecture that the better reasoning abilities of MIDAS are due to this connection to looped models We believe exploring this further is a very fruitful direction. ", "page_idx": 8}, {"type": "text", "text": "5 Deep dive into reasoning improvements ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "To further investigate the nature of this inductive bias, we construct various simple synthetic tasks to help tease apart the model\u2019s capabilities. We conjecture that these simple tasks capture core basic capabilities needed for contextual reasoning, and we therefore call these tasks \u201ccontextual reasoning primitives\u201d. They are: induction copying, variable assignment, and pre-school math (PSM), discussed further below. Overall, across various few-shot evaluations and fine-tuning, we see significant performance gaps between MIDAS and baseline training, suggesting that we have successfully isolated some of the basic capabilities at which MIDAS excels relative to baseline training. We refer the reader to Appendix B for more results and the exact input format. ", "page_idx": 9}, {"type": "text", "text": "Primitive 1: Induction copying. The \u201cinduction copying\u201d primitive presents a sequence of words, followed by a subsequence selected randomly from within this original sequence, and asks the model to output the next word in the sequence. A simplified example is: \u201cpum nyj gdq ocu rzk jbw mlz eny kyx uni rzk jbw mlz eny kyx\u201d, and the expected output is \u201cuni\u201d. This primitive is inspired by the \u201cinduction head\u201d mechanism introduced in Olsson et al. [2022], which is posited to be the basic mechanism for in-context learning more generally. In Figure 5, task \u201cCopying\u201d, we present results for 3-letter words of random letters, separated by spaces, with a sequence length of 10 and a subsequence length of 5. ", "page_idx": 9}, {"type": "text", "text": "Primitive 2: Variable assignment. The \u201cvariable assignment\u201d primitive tests the model\u2019s ability to associate a value with a variable name and apply this ability compositionally, which we test by varying the \u201cdepth\u201d of the task. We conjecture that this ability is a core function in contextual reasoning, particularly in math. An example of the depth-0 variant is $^{\\bullet}\\mathfrak{u}{=}1$ ; $\\scriptstyle{\\t=0}$ ; $v{=}13$ ; ${\\tt y}\\!=\\!4$ ; $\\tt f\\!=\\!22$ ; $y=$ , and the expected output is 4. An example of the depth-2 variant is $\\therefore y=7$ ; $\\mathtt{f}\\!=\\!0$ ; $_{z=3}$ ; $b{=}9$ ; $\\tt x=8$ ; $\\mathtt{q}{=}\\mathtt{y}$ ; $\\scriptstyle1=\\pm$ ; $\\mathtt{m=z}$ ; $\\scriptstyle{\\mathtt{h}=\\mathtt{x}}$ ; $a{=}b$ ; $\\scriptstyle\\mathtt{n=h}$ ; $\\scriptstyle{\\dot{\\mathtt{J}}}={\\mathtt{m}}$ ; $\\scriptstyle\\mathtt{t}=\\mathtt{a}$ ; $\\mathrm{\\dot{1}}{=}1$ ; $g{=}9$ ; $\\scriptstyle\\mathbf{n}=^{\\,\\bullet}$ , and the expected output is 8. Refer to Appendix B for more details. ", "page_idx": 9}, {"type": "text", "text": "Primitive 3: Pre-school math (PSM). This tests the model\u2019s ability to solve a very simple \u201cpreschool math\u201d problem by correctly associating multiple values and variables simultaneously and applying this association to a particular task. An example is $^{\\bullet\\bullet}z\\!\\!=\\!\\!6$ ; $\\mathtt{b=5}$ ; $\\dot{1}{=}{-}z{+}6$ ; $\\mathrm{i}\\!=\\!^{\\circ}$ , and the expected answer (with chain-of-thought) is $\\scriptstyle{\\cdot-6+5=-1^{\\circ}}$ . ", "page_idx": 9}, {"type": "text", "text": "5-shot evaluation results. Figure 5 presents the results for representative tasks, with more results in Appendix B. Overall, we see that MIDAS outperforms baseline training across all tasks. In particular, we see that MIDAS is significantly stronger than the baseline at Depth 0, Copying, PSM-calc, and Depth 1, in decreasing order of magnitude of the performance gap. Depth-2 is much harder and is at random guessing $(20\\%)$ for both models. ", "page_idx": 9}, {"type": "text", "text": "Fine-tuning results. Due to the difficulty of the variable assignment task at Depths 1 and 2, we investigate fine-tuning on these tasks as well. We fine-tune on a mixture of 32 depth-1 examples and 32 depth-2 examples (i.e., only 64 examples total), using full-batch gradient descent. Figure 5 reports the validation accuracy on Depth 1 and Depth 2 after fine-tuning on this mixture (tasks \u201cDepth 1 (FT)\u201d and \u201cDepth 2 (FT)\u201d). Overall, we see that fine-tuning with just 64 examples significantly improves performance, resulting in MIDAS outperforming the baseline by a gap of over $20\\%$ validation accuracy at both depths. See Appendix B for further fine-tuning and evaluation details. ", "page_idx": 9}, {"type": "text", "text": "6 Conclusions and future work ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In this work we propose a novel stacking method that outperforms previous stacking methods and speeds up language model pretraining by $25{-}40\\%$ . In the process, we uncover a very intriguing inductive bias of stacking \u2013 its ability to improve downstream reasoning tasks. Through extensive empirical analysis, the paper makes a strong case for the presence and significance of this inductive bias. We believe this deserves further attention and exploration since understanding this inductive bias could unlock new approaches to improving model quality, reasoning in particular. The reasoning primitives start to provide more insights by isolating the reasoning improvements and we hope that the dataset is useful for future research on improving reasoning. Finally, understanding the dichotomy between memorization and reasoning, and how this affects the performance on various tasks, is an interesting direction to pursue. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgments. We thank Srinadh Bhojanapalli and Vaishnavh Nagarajan for discussions on the role of layers and memory vs contextual tasks, respectively, in the early stages of the project. We also thank Satyen Kale for valuable feedback throughout the project. ", "page_idx": 10}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "Sanjeev Arora and Anirudh Goyal. A theory for emergence of complex skills in language models. arXiv preprint arXiv:2307.15936, 2023.   \nNora Belrose, Zach Furman, Logan Smith, Danny Halawi, Igor Ostrovsky, Lev McKinney, Stella Biderman, and Jacob Steinhardt. Eliciting latent predictions from transformers with the tuned lens. arXiv preprint arXiv:2303.08112, 2023.   \nCheng Chen, Yichun Yin, Lifeng Shang, Xin Jiang, Yujia Qin, Fengyu Wang, Zhi Wang, Xiao Chen, Zhiyuan Liu, and Qun Liu. bert2BERT: Towards reusable pretrained language models. In Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics, 2022.   \nTianqi Chen, Ian Goodfellow, and Jonathon Shlens. Net2net: Accelerating learning via knowledge transfer. International Conference on Learning Representations, 2016.   \nKarl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, et al. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168, 2021.   \nMostafa Dehghani, Stephan Gouws, Oriol Vinyals, Jakob Uszkoreit, and Lukasz Kaiser. Universal transformers. In International Conference on Learning Representations, 2018.   \nBenjamin L. Edelman, Surbhi Goel, Sham Kakade, and Cyril Zhang. Inductive biases and variable creation in self-attention mechanisms. In International Conference on Machine Learning, 2022.   \nAngeliki Giannou, Shashank Rajput, Jy-yong Sohn, Kangwook Lee, Jason D Lee, and Dimitris Papailiopoulos. Looped transformers as programmable computers. In International Conference on Machine Learning, 2023.   \nLinyuan Gong, Di He, Zhuohan Li, Tao Qin, Liwei Wang, and Tieyan Liu. Efficient training of bert by progressively stacking. In International conference on machine learning, pages 2337\u20132346. PMLR, 2019.   \nSuriya Gunasekar, Jason Lee, Daniel Soudry, and Nathan Srebro. Characterizing implicit bias in terms of optimization geometry. In Proceedings of the 35th International Conference on Machine Learning, Proceedings of Machine Learning Research. PMLR, 10\u201315 Jul 2018.   \nDahyun Kim, Chanjun Park, Sanghoon Kim, Wonsung Lee, Wonho Song, Yunsu Kim, Hyeonwoo Kim, Yungi Kim, Hyeonju Lee, Jihoo Kim, et al. Solar 10.7 b: Scaling large language models with simple yet effective depth up-scaling. arXiv preprint arXiv:2312.15166, 2023.   \nRik Koncel-Kedziorski, Subhro Roy, Aida Amini, Nate Kushman, and Hannaneh Hajishirzi. Mawps: A math word problem repository. In Proceedings of the 2016 conference of the north american chapter of the association for computational linguistics: human language technologies, 2016.   \nZhenzhong Lan, Mingda Chen, Sebastian Goodman, Kevin Gimpel, Piyush Sharma, and Radu Soricut. Albert: A lite bert for self-supervised learning of language representations. In International Conference on Learning Representations, 2020.   \nXiang Li, Yiqun Yao, Xin Jiang, Xuezhi Fang, Xuying Meng, Siqi Fan, Peng Han, Jing Li, Li Du, Bowen Qin, et al. Flm-101b: An open llm and how to train it with $\\mathbb{S}100\\,\\mathrm{k}$ budget. arXiv preprint arXiv:2309.03852, 2023.   \nPercy Liang, Rishi Bommasani, Tony Lee, Dimitris Tsipras, Dilara Soylu, Michihiro Yasunaga, Yian Zhang, Deepak Narayanan, Yuhuai Wu, Ananya Kumar, et al. Holistic evaluation of language models. Transactions on Machine Learning Research, 2023.   \nHong Liu, Sang Michael Xie, Zhiyuan Li, and Tengyu Ma. Same pre-training loss, better downstream: Implicit bias matters for language models. In International Conference on Machine Learning. PMLR, 2023.   \nShen-Yun Miao, Chao-Chun Liang, and Keh-Yih Su. A diverse corpus for evaluating and developing english math word problem solvers. In Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics, pages 975\u2013984, 2020.   \nCatherine Olsson, Nelson Elhage, Neel Nanda, Nicholas Joseph, Nova DasSarma, Tom Henighan, Ben Mann, Amanda Askell, Yuntao Bai, Anna Chen, Tom Conerly, Dawn Drain, Deep Ganguli, Zac Hatfield-Dodds, Danny Hernandez, Scott Johnston, Andy Jones, Jackson Kernion, Liane Lovitt, Kamal Ndousse, Dario Amodei, Tom Brown, Jack Clark, Jared Kaplan, Sam McCandlish, and Chris Olah. In-context learning and induction heads. arXiv preprint arXiv:2209.11895, 2022.   \nArkil Patel, Satwik Bhattamishra, and Navin Goyal. Are nlp models really able to solve simple math word problems? In Proceedings of the 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. Association for Computational Linguistics, 2021.   \nColin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. Exploring the limits of transfer learning with a unified text-to-text transformer. Journal of machine learning research, 2020.   \nYasaman Razeghi, Robert L Logan IV, Matt Gardner, and Sameer Singh. Impact of pretraining term frequencies on few-shot numerical reasoning. In Yoav Goldberg, Zornitsa Kozareva, and Yue Zhang, editors, Findings of the Association for Computational Linguistics: EMNLP 2022. Association for Computational Linguistics, 2022.   \nSashank Reddi, Sobhan Miryoosef,i Stefani Karp, Shankar Krishnan, Satyen Kale, Seungyeon Kim, and Sanjiv Kumar. Efficient training of language models using few-shot learning. In Proceedings of the 40th International Conference on Machine Learning, 2023.   \nNikunj Saunshi, Sadhika Malladi, and Sanjeev Arora. A mathematical exploration of why language models help solve downstream tasks. In International Conference on Learning Representations, 2020.   \nNikunj Saunshi, Jordan Ash, Surbhi Goel, Dipendra Misra, Cyril Zhang, Sanjeev Arora, Sham Kakade, and Akshay Krishnamurthy. Understanding contrastive learning requires incorporating inductive biases. In Proceedings of the 39th International Conference on Machine Learning, 2022.   \nNoam Shazeer and Mitchell Stern. Adafactor: Adaptive learning rates with sublinear memory cost. In International Conference on Machine Learning, pages 4596\u20134604. PMLR, 2018.   \nYi Tay, Mostafa Dehghani, Vinh Q Tran, Xavier Garcia, Jason Wei, Xuezhi Wang, Hyung Won Chung, Dara Bahri, Tal Schuster, Steven Zheng, et al. Ul2: Unifying language learning paradigms. In The Eleventh International Conference on Learning Representations, 2022.   \nHugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288, 2023.   \nPeihao Wang, Rameswar Panda, Lucas Torroba Hennigen, Philip Greengard, Leonid Karlinsky, Rogerio Feris, David Daniel Cox, Zhangyang Wang, and Yoon Kim. Learning to grow pretrained models for efficient transformer training. arXiv preprint arXiv:2303.00980, 2023.   \nYite Wang, Jiahao Su, Hanlin Lu, Cong Xie, Tianyi Liu, Jianbo Yuan, Haibin Lin, Ruoyu Sun, and Hongxia Yang. LEMON: Lossless model expansion. In The Twelfth International Conference on Learning Representations, 2024.   \nZihao Wang and Lei Wu. Theoretical analysis of the inductive biases in deep convolutional networks. In Thirty-seventh Conference on Neural Information Processing Systems, 2023. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Fei Xia, Ed Chi, Quoc V Le, Denny Zhou, et al. Chain-of-thought prompting elicits reasoning in large language models. Advances in neural information processing systems, 2022. Liu Yang, Kangwook Lee, Robert Nowak, and Dimitris Papailiopoulos. Looped transformers are better at learning learning algorithms. arXiv preprint arXiv:2311.12424, 2023. Yiqun Yao, Zheng Zhang, Jing Li, and Yequan Wang. Masked structural growth for $2\\mathbf{x}$ faster language model pre-training. In The Twelfth International Conference on Learning Representations, 2024. ", "page_idx": 12}, {"type": "text", "text": "A Experimental Details ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "A.1 Pretraining details ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Model architecture. We use a decoder-only model and train it using the UL2 objective [Tay et al., 2022] with $60\\%$ causal LM, $20\\%$ prefix LM and $20\\%$ span corruption. The 1B model uses 24 layers, model dimension of 2048, hidden dimension of 5120 and 32 attention heads. The 2B model is very similar to the 1B model, except it uses 48 layers instead of 24. The 8B model uses 72 layers, model dimension of 2048, hidden dimension of 16384 and 16 attention heads. ", "page_idx": 13}, {"type": "text", "text": "Dataset. We use a mixture of C4 $(57\\%)$ [Raffel et al., 2020], Wikipedia $(17\\%)$ , Github $(17\\%)$ , Arxiv $(9\\%)$ ; the proportions are motivated by the dataset used for Llama pretraining [Touvron et al., 2023]. All models are trained for 512B tokens that are precached so that all model see exactly the same data in the same order. This corresponds to 0.86 epochs of C4, 9 epochs of Wikipedia, 0.58 epochs of Arxiv and 0.44 epochs of Github. ", "page_idx": 13}, {"type": "text", "text": "Training details. For the 1B and 2B models, we use a cosine learning schedule with a peak learning rate of 0.01 that decays to 0.001 in the end, and use a batch size of 512. For the 8B model we use a peak learning rate of 0.001 and decay it to 0.0001, and use a batch size of 1024. Peak learning rate was tuned to be optimal for baseline training. All experiments use the AdaFactor optimizer [Shazeer and Stern, 2018] and sequence length of 1280. ", "page_idx": 13}, {"type": "text", "text": "A.2 Additional downstream evaluations ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "In this section we share further experimental details related to the results summarized in the Table 1. ", "page_idx": 13}, {"type": "table", "img_path": "3ZAfFoAcUI/tmp/22984940fc820eb670814fe4c022fd1adec77a1febe900cd7db05e2918b03ecc.jpg", "table_caption": [], "table_footnote": ["Table 3: Closed Book QA "], "page_idx": 13}, {"type": "table", "img_path": "3ZAfFoAcUI/tmp/404aeb5bde79b6f8b69db4ba8cfb07fb535ca74312f9c9c3828f4caa41202576.jpg", "table_caption": [], "table_footnote": ["Table 4: Open Book QA "], "page_idx": 14}, {"type": "table", "img_path": "3ZAfFoAcUI/tmp/768414cae538f23f9e96f1736fafae12fec6a9c413bc064a0e0ef15930e7c403.jpg", "table_caption": ["Table 5: Math World Problems "], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "B Details for contextual reasoning primitives ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "In this section, we provide further details corresponding to Section 5. ", "page_idx": 14}, {"type": "text", "text": "All evaluations in Section 5 were performed on the 1B-parameter models. For MIDAS, we use the variant with block size 4 and the PROP-2 schedule. ", "page_idx": 14}, {"type": "text", "text": "B.1 Exact input format ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Expanding on Section 5, here we provide the format of the inputs and target outputs. The only caveat is that, for simplicity of presentation, we present the inputs in 0-shot form here vs. their 5-shot form. In 5-shot form, which is how we conduct the 5-shot evaluations, each example is separated by two consecutive newline characters. ", "page_idx": 14}, {"type": "image", "img_path": "3ZAfFoAcUI/tmp/16b4d0e9afbfbb205ca57b3a69aa4848620cf9484cf01ea7ff6cb7ab7774d316.jpg", "img_caption": [], "img_footnote": [], "page_idx": 15}, {"type": "text", "text": "Figure 6: Measure of linearity for different layers in pretrained BERT-Base and BERT-Large models. For each layer $i$ , we fit a linear map $A_{i}$ between inputs $Y_{i}$ and the output of the Transformer block (without the residual connection), $Y_{i+1}-Y_{i}$ . We then measure the $_{\\Gamma2}$ score and cosine similarity for the learned linear fit. The first and last few layers demonstrate a much higher level of linearity compared to the rest of the layers. ", "page_idx": 15}, {"type": "text", "text": "For each dataset below, the inputs are separated from the targets by the \u201c|\u201d character (this is not a token in the input), and the targets are colored in red. ", "page_idx": 15}, {"type": "text", "text": "Figure 5 uses the following evaluation datasets, in the following order: ", "page_idx": 15}, {"type": "text", "text": "1. Copying (random-letter words)   \n2. Variable assignment depth 0 (code)   \n3. Variable assignment depth 1 (code)   \n4. Variable assignment depth 1 (code)   \n5. Variable assignment depth 2 (code)   \n6. Variable assignment depth 2 (code)   \n7. Pre-school math (PSM) ", "page_idx": 15}, {"type": "text", "text": "Copying (random-letter words): ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Fill in blank: ", "page_idx": 15}, {"type": "text", "text": "pum nyj gdq ocu rzk jbw mlz eny kyx uni rzk jbw mlz eny kyx ___. ->|uni ", "page_idx": 15}, {"type": "text", "text": "Copying (real words): ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Fill in blank: ", "page_idx": 15}, {"type": "text", "text": "eat fit ban sea vet zit pea cat van tea sea vet zit pea cat ->|van ", "page_idx": 15}, {"type": "text", "text": "Fill in blank: ", "page_idx": 16}, {"type": "text", "text": "$\\scriptstyle0=14$   \n$\\scriptstyle{\\mathtt{s}=4}$   \n$\\scriptstyle{\\mathtt{u}=8}$   \n$\\mathtt{m}{=}10$   \n$\\scriptstyle{\\mathfrak{q}}=12$   \n$\\mathfrak{m}^{=}_{--}$ ->|10 ", "page_idx": 16}, {"type": "text", "text": "Variable assignment depth 1 (basic): ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Fill in blank: ", "page_idx": 16}, {"type": "text", "text": "g=21   \n$b{=}24$   \n$v{=}3$   \n${\\tt s}{=}23$   \n$_{\\mathtt{h}=20}$   \n$\\mathtt{k=b}$   \n$\\mathtt{a}{=}\\mathtt{s}$   \n$_{\\mathtt{n}=\\mathtt{v}}$   \n$\\scriptstyle{\\mathtt{f}}=\\mathtt{g}$   \nd=h   \na=__ ->|23 ", "page_idx": 16}, {"type": "text", "text": "Variable assignment depth 2 (basic): ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Fill in blank: ", "page_idx": 16}, {"type": "text", "text": "$\\mathtt{w}{=}24$   \n$\\mathtt{1}{=}12$   \n$\\mathtt{d=}16$   \n$\\mathtt{e=5}$   \n$\\scriptstyle{\\dot{\\jmath}}=9$   \n$\\mathtt{g}\\mathrm{=}\\mathtt{j}$   \ny=e   \nr=l   \nk=d   \n$\\scriptstyle\\mathtt{h}=\\mathtt{w}$   \nv=g   \ni=r   \n$\\mathtt{c=h}$   \n$\\mathtt{t=k}$   \n$\\mathtt{p=y}$   \nc=___. ->|24 The following is a set of simple mathematical equations. $\\tt n{=}22$   \n$\\mathtt{r=16}$   \n$\\mathtt{w}{=}13$   \n$\\scriptstyle{\\mathtt{v}=6}$   \n$\\mathtt{k}{=}10$   \nWhat is the numerical value of n?   \nAnswer:|22 ", "page_idx": 16}, {"type": "text", "text": "", "page_idx": 17}, {"type": "text", "text": "Variable assignment depth 1 (math): ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "The following is a set of simple mathematical equations. $_{\\mathtt{h}=20}$   \n$\\mathtt{w o s p}$   \n$_{\\mathsf{c}=22}$   \n$\\scriptstyle{\\dot{\\jmath}}=11$   \n$\\mathtt{v=5}$   \n$\\mathtt{g}^{=}\\mathtt{c}$   \n$\\mathtt{k=w}$   \n$a=j$   \n$\\mathtt{s}{=}\\mathtt{h}$   \n$\\tt o=\\tt v$   \nWhat is the numerical value of s?   \nAnswer:|20 ", "page_idx": 17}, {"type": "text", "text": "Variable assignment depth 2 (math): ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "The following is a set of simple mathematical equations. $\\mathsf{g}^{=9}$   \n$v{=}24$   \n$\\mathtt{k}{=}15$   \n$\\mathtt{p}{=}6$   \n$\\mathtt{c}{=}10$   \n$\\scriptstyle\\mathtt{t=p}$   \n$\\mathtt{s}{=}\\mathtt{g}$   \n$\\bumpeq0$   \n$\\mathtt{y=v}$   \n$\\scriptstyle\\mathtt{n=k}$   \n$\\scriptstyle{\\tt I}={\\tt s}$   \n$\\mathbf{w}{=}\\mathbf{n}$   \n$j=t$   \n$\\mathtt{m=y}$   \n$\\mathtt{i}=\\mathtt{a}$   \nWhat is the numerical value of j?   \nAnswer:|6 ", "page_idx": 17}, {"type": "text", "text": "The following is a very short Python program. Use the program to resolve the value of the variable in the question. ", "page_idx": 18}, {"type": "text", "text": "Program:   \n$\\scriptstyle{\\mathfrak{q}}=12$   \n$k{=}17$   \n$\\beth\\!\\!=\\!\\!1$   \ny=3   \n$a{=}6$   \nQuestion:   \nWhat is the value of k? ", "page_idx": 18}, {"type": "text", "text": "Answer:|17", "page_idx": 18}, {"type": "text", "text": "Variable assignment depth 1 (code): ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "The following is a very short Python program. Use the program to resolve the value of the variable in the question. ", "page_idx": 18}, {"type": "text", "text": "Program:   \n$\\mathtt{k}{=}11$   \n$\\scriptstyle{\\tt f}=21$   \n$\\mathtt{e}{=}10$   \n$\\beth=7$   \n${\\tt c}{=}13$   \n$\\scriptstyle{\\mathtt{y}=}{\\mathtt{f}}$   \n$\\circ\\!=\\!\\circ$   \n$\\mathbf{r}{=}\\mathbf{e}$   \n$\\mathtt{u=k}$   \n$\\mathtt{n}{=}1$ ", "page_idx": 18}, {"type": "text", "text": "Question: What is the value of o? ", "page_idx": 18}, {"type": "text", "text": "Answer:|13", "page_idx": 18}, {"type": "text", "text": "Variable assignment depth 2 (code): ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "The following is a very short Python program. Use the program to resolve the value of the variable in the question. ", "page_idx": 18}, {"type": "text", "text": "Program:   \n$\\mathtt{t=13}$   \n$\\scriptstyle{\\dot{\\jmath}}=14$   \n$v{=}4$   \n${\\tt s}{=}17$   \n$y{=}21$   \n$\\mathfrak{q}^{=}\\mathrm{j}$   \n$\\scriptstyle{\\tt I}={\\tt s}$   \ne=y   \nh=t   \n$x=\\mathtt{v}$   \n$\\scriptstyle{\\mathtt{b}=\\mathtt{x}}$   \n$\\scriptstyle{\\mathtt{f}}=\\mathtt{e}$   \n$\\scriptstyle\\mathtt{n=q}$   \n$\\mathtt{a=h}$   \n$\\mathrm{\\dot{1}}{=}1$   \nQuestion:   \nWhat is the value of i?   \nAnswer:   \n|17 ", "page_idx": 18}, {"type": "text", "text": "", "page_idx": 19}, {"type": "text", "text": "Pre-school math (PSM): ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Fill in blank:   \n$\\mathtt{k}{=}1$   \n$\\dot{\\}}^{=}8$   \n$_{2=-\\k+j}$   \nl=_ ->|-1+8=7 ", "page_idx": 19}, {"type": "text", "text": "Arithmetic: ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "-3+2=-1   \n-6+1=-5   \n+9-7=2   \n-6-4=-10   \n-6-1=-7   \n+1+9=|10 ", "page_idx": 19}, {"type": "text", "text": "B.2 Fine-tuning details ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "For fine-tuning, we use the \u201ccode\u201d variant of the variable assignment task, depths 1 and 2, in 0-shot form (i.e., no in-context examples). Due to the randomness of the data generation process and the rather small size of each dataset (64 examples), we randomly generate 3 different 64-example fine-tuning datasets (consisting of 32 depth-1 examples and 32 depth-2 examples), fine tune on each, and report our results as an average across the 3 runs. Table 7 reports the standard deviations as well. ", "page_idx": 19}, {"type": "text", "text": "Regarding hyperparameters, we continue to use AdaFactor [Shazeer and Stern, 2018] with the same hyperparameters as in the pretraining phase, with the exception of learning rate and batch size. We use a constant learning rate of 0.001, which was chosen to match the final learning rate of the pretraining phase. We use full-batch training with our 64-example datasets. We then evaluate performance separately on depth 1 and depth 2. ", "page_idx": 19}, {"type": "text", "text": "", "page_idx": 20}, {"type": "text", "text": "For every step $i\\in\\{200,\\ldots,300\\}$ , chosen to be significantly after training has converged to $100\\%$ accuracy (we do not observe overftiting in this range as training continues), we evaluate performance on a 1000-example holdout set. For smoothing purposes, we average over steps 200 through 300 and report the final averaged performance. ", "page_idx": 20}, {"type": "text", "text": "B.3 Full 5-shot and fine-tuning results ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "5-shot. Table 6 includes 5-shot evaluation results for all contextual reasoning primitives. Rows 1, 9,   \n10, 11, and 14 are the rows which appear in Figure 5. ", "page_idx": 20}, {"type": "text", "text": "When performance is better than random guessing, MIDAS consistently outperforms the baseline in rows 1-11. ", "page_idx": 20}, {"type": "text", "text": "For pre-school math (rows 12-14), the value we report in Figure 5 is \u201cwith calculator\u201d. This is because the pre-school math task actually combines two capabilities: reasoning and arithmetic. Arithmetic can be thought of as a memorization task. We evaluate arithmetic for MIDAS and baseline training, and we see that arithmetic is quite poor for both models ( $7.8\\%$ and $9.6\\%$ , respectively, in Table 6). However, by evaluating PSM with chain-of-thought and only assessing the accuracy of the reasoning chain itself, i.e., $\"6+5\"$ vs. \u201c-1\u201d, we can successfully disentangle reasoning and memorization in our evaluation. This is equivalent to having access to a calculator, so we call it \u201cPSM with calculator\u201d or \u201cPSM-calc\u201d in Figure 5. ", "page_idx": 20}, {"type": "table", "img_path": "3ZAfFoAcUI/tmp/929e145fb33c4504f7c5da1d419a2af81cf22f33ea4bf0fab03b7d3d1eb58453.jpg", "table_caption": [], "table_footnote": ["Table 6: 5-shot results for all variants of the contextual reasoning primitives. This is an expanded set compared to Figure 5. "], "page_idx": 20}, {"type": "table", "img_path": "3ZAfFoAcUI/tmp/dbf7fcc7766ee0ad8e625e0458997b92e73984c48c36be335a99b5f329720657.jpg", "table_caption": ["Fine tuning. Table 7 presents the fine-tuning results from Figure 5 along with corresponding standard deviations (across the 3 trials). "], "table_footnote": [], "page_idx": 20}, {"type": "text", "text": "Table 7: Fine-tuning results corresponding to Figure 5\u2019s 2 fine-tuning tasks. Additionally, this table reports the standard deviation across the 3 runs with $\\pm$ std dev. ", "page_idx": 20}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: The Abstract and Introduction provide a good summary of the paper\u2019s contributions. They express measured excitement about the results without overpromising. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 21}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: It has been discussed throughout the paper. In particular, MIDAS provides limited improvement on memorization-based tasks which has been discussed in Section 3.3 and Section 4. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 21}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: No theoretical result is provided in this paper. Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 22}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: Section 3 and Appendix A are sufficient for reproducing the main results discussed in this paper. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 22}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 23}, {"type": "text", "text": "Answer: [No] ", "page_idx": 23}, {"type": "text", "text": "Justification: We do not provide access to the data and code, but the data and models come from prior works; where differences between our work and prior work appear, we highlight them (Section 3 and Section A). ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 23}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: The experimental details have been provided in Appendix A. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 23}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 23}, {"type": "text", "text": "Answer: [No] ", "page_idx": 23}, {"type": "text", "text": "Justification: Due to the computational demands of exploring a reasonably large set of experiments, it was not feasible to perform multiple runs per setting. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 23}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 24}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 24}, {"type": "text", "text": "Answer: [No] ", "page_idx": 24}, {"type": "text", "text": "Justification: We do not report these details in the submission but can include them in a final version. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 24}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: We have reviewed the NeurIPS Code of Ethics. To the best of our knowledge, this work conforms. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 24}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 24}, {"type": "text", "text": "Answer: [No] ", "page_idx": 24}, {"type": "text", "text": "Justification: This a foundational/analytical paper not tied to any specific application or deployment. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 25}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 25}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 25}, {"type": "text", "text": "Justification: No data or models have been released with this paper. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 25}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 25}, {"type": "text", "text": "Answer: [No] ", "page_idx": 25}, {"type": "text", "text": "Justification: The creators of data and models are cited, but we did not include licenses for all assets. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 25}, {"type": "text", "text": "", "page_idx": 26}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: The paper does not release new assets. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 26}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 26}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects. ", "page_idx": 26}, {"type": "text", "text": "\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 27}]