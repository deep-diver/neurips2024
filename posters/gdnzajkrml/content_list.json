[{"type": "text", "text": "GL-NeRF: Gauss-Laguerre Quadrature Enables Training-Free NeRF Acceleration ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Silong Yong Yaqi Xie Simon Stepputtis Katia Sycara ", "page_idx": 0}, {"type": "text", "text": "Carnegie Mellon University {silongy, yaqix, sstepput, sycara}@andrew.cmu.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Volume rendering in neural radiance fields is inherently time-consuming due to the large number of MLP calls on the points sampled per ray. Previous works would address this issue by introducing new neural networks or data structures. In this work, we propose GL-NeRF, a new perspective of computing volume rendering with the Gauss-Laguerre quadrature. GL-NeRF significantly reduces the number of MLP calls needed for volume rendering, introducing no additional data structures or neural networks. The simple formulation makes adopting GLNeRF in any NeRF model possible. In the paper, we first justify the use of the Gauss-Laguerre quadrature and then demonstrate this plug-and-play attribute by implementing it in two different NeRF models. We show that with a minimal drop in performance, GL-NeRF can significantly reduce the number of MLP calls, showing the potential to speed up any NeRF model. Code can be found in project page https://silongyong.github.io/GL-NeRF_project_page/. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Neural Radiance Fields (NeRFs) [27] have shown promising results for synthesizing images from novel views. Plenty of works extend NeRF towards different aspects applicable in the real world (see related works for details). The core component for NeRF\u2019s success is volume rendering, which requires approximating an integral by densely sampling points along the ray and evaluating volume density and radiance using neural networks for them. In practice, a dense set of points is evaluated by expensive operations like neural network inferences for a single pixel, which could be redundant. Works have been done to reduce the time needed for rendering images, aiming at providing NeRF with a real-time rendering ability [9, 44, 24, 29, 8]. Despite the promising results shown by these works, they propose different approaches for achieving real-time rendering by introducing new networks, new data structures, etc. Therefore, each individual work requires training from scratch with a specific optimization goal. In this work, we propose a novel lightweight method that could be implemented in any existing NeRF-based models that require volume rendering without further training. In contrast to existing works, our approach introduces no additional representation or neural network and is training-free. We make minimal modifications to the computation of the volume rendering integral, making it rely on much fewer samples. ", "page_idx": 0}, {"type": "text", "text": "Our approach arises from revisiting the volume rendering integral, the key discovery is that with a simple change of variable, we can turn the integral into a pure exponentially weighted integral of color. This specific form has a Gauss quadrature (i.e. the Gauss-Laguerre quadrature) which best approximates it mathematically. Naturally, we propose to use the Gauss-Laguerre quadrature to directly compute the volume rendering integral, which we call GL-NeRF (Gauss Laguerre-NeRF), leading to much lower computational cost for approximating the integral and therefore lower time and memory usage. Computing the points needed for the integral requires a dense evaluation of per-point density. However, the efficiency for this step can be improved using modern techniques ", "page_idx": 0}, {"type": "image", "img_path": "GDNZajKrML/tmp/1910d9e81a5cb235d6d9a7f6bd242120698ba702f637a68ce379c5ffd02b8a65.jpg", "img_caption": ["NeRF uniform sample rendering ", "Gauss-Laguerre Quadrature rendering (ours) "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "Figure 1: GL-NeRF method overview. The vanilla volume rendering in NeRF requires uniform sampling in space. This leads to a huge number of computationally heavy MLP calls since we have to assign each point a color value. Our approach, GL-NeRF, significantly reduces the number of points needed for volume rendering and selects points in the most informative area. ", "page_idx": 1}, {"type": "text", "text": "like factorized tensors [6]. Benefiting from the guarantee of the highest precision Gauss quadrature provides, only a very small number of fixed points could provide comparable results to the heavy and redundant strategy NeRF adopts, leading to free speedup. ", "page_idx": 1}, {"type": "text", "text": "To verify the use of the Gauss-Laguerre quadrature, we conduct an empirical study on the landscape of color function. We also analyze the relationship between our approach and other techniques that aim to reduce the sample points for NeRF. We demonstrate the plug-and-play property of our method by directly incorporating it into vanilla NeRF and TensoRF models that are already trained on NeRF-Synthetic and LLFF datasets. Furthermore, we showcase the drop in time and memory usage as a direct outcome of reducing the computational cost. ", "page_idx": 1}, {"type": "text", "text": "GL-NeRF provides a different perspective for computing volume rendering and has the potential to be a direct plug-in for existing NeRF-based products. Specifically, our contributions are three-fold. We propose GL-NeRF, a brand new perspective for computing volume rendering with the Gauss-Laguerre quadrature with no additional component introduced. We analyze the validity of using the GaussLaguerre quadrature for volume rendering integral and the relationship between our approach and existing sample-efficient NeRFs. We demonstrate that GL-NeRF could be incorporated into any NeRF model without further training. To the best of our knowledge, GL-NeRF is the first method that could be used without training in any NeRF models thanks to the simple formulation. We showcase that GL-NeRF reduces computational cost, time and memory usage while keeping the rendering quality. ", "page_idx": 1}, {"type": "text", "text": "2 Related work ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Volume rendering. Volume rendering has been widely used in computer graphics and vision applications [25, 43, 7]. It maps a 3D scene onto 2D images by a weighted integral over the color of the points along the corresponding rays with a function of opacity (volume density) as weight. In practice, the integral is approximated using a finite sum over sampled points along the ray as derived in [25]. Implicit scene models like NeRF [27], Plenoxels [8] and 3D gaussians [18] and most of their follow-up all adopt this technique as the render pipeline. Since randomly sampling in space for approximating the integral may bring unnecessary information (i.e. sampling in empty space) that may cost extra computation, plenty of works aim to address that by introducing different techniques for better approximation of the component needed for volume rendering integral (i.e. volume density, radiance) [40, 44, 29, 23, 21, 2, 36]. PL-NeRF [40] proposes to use piecewise linear function for approximating the volume density throughout the space, leading to fewer points needed for the \u201cfine\u201d stage sampling proposed by [27]. AutoInt and DIVeR [23, 44] introduce a neural network for approximating the integral of volume density instead of using Monte-Carlo sampling. DONeRF [29] reduces the sampled point needed for computing the integral by introducing a depth oracle neural network that predicts the surface position of the underlying scene and samples the points near the ", "page_idx": 1}, {"type": "text", "text": "Input: ray direction $d$ , ray origin $o$ , step size $\\Delta t$ , sample number M, Gauss-Laguerre quadrature   \nweight look-up table $L_{w}$ , point look-up table $L_{p}$   \n1: $t_{\\tt m i n}$ , $t_{\\tt m a x}=$ RayIntersectBoundingBox $(d,o)$   \n2: if $t_{\\tt m i n}>t_{\\tt m a x}$ then return bg_color   \n3: Initialize $t=t_{m i n}$ , transmittance $T=1.0$ , already sampled point number $n=0$   \n4: while $t<t_{\\tt m a x}$ do   \n5: if $n==m)$ ) then break   \n6: $\\mathtt{p o s}=o+t*d$   \n7: \u03c3 = GetVolumeDensity(pos)   \n8: $x=-l o g(T)$   \n9: $x_{\\mathrm{{next}}}=x+\\Delta t*\\sigma$   \n10: if $x<L_{p}[n]$ and $x_{\\mathrm{next}}\\geq L_{p}[n]$ then   \n11: 12: $\\begin{array}{r l}&{t_{\\mathrm{Laguerre}}=(L_{p}[n]-x)/(x_{\\mathrm{next}}-x)}\\\\ &{\\mathsf{p o s}_{\\mathrm{sample}}=o+(t+t_{\\mathrm{Laguerre}}\\ast\\Delta t-\\Delta t)*d}\\\\ &{\\mathsf{r a y}_{-}\\mathsf{c o l o r}+=L_{w}[n]\\ast\\mathrm{GetColor}(\\mathsf{p o s}_{\\mathrm{sample}})}\\\\ &{\\quad n=n+1}\\\\ &{t=t+\\Delta t}\\\\ &{T=T\\ast e x p(-\\sigma\\ast\\Delta t)}\\end{array}$   \n13:   \n14:   \n15:   \n16:   \n17: bg_weight $=s u m(L_{w}[n:])$   \n18: ray_color $=$ ray_color $^+$ bg_weight $^*$ bg_color   \n19: return ray_color ", "page_idx": 2}, {"type": "text", "text": "surface, which contributes the most to the visual effect in the images. MCNeRF [13] proposes to use Monte-Carlo rendering and denoising to do sample efficient rendering, but it still introduces a denoiser network that requires per-scene training. Different from these previous works, Our work proposes to use the Gauss-Laguerre quadrature to directly improve the precision of the volume rendering integral itself, introduces no additional neural networks or data structures and remains in the simplest version, leading to its adaptability into any existing work that relies on volume rendering integral. ", "page_idx": 2}, {"type": "text", "text": "NeRFs. Neural Radiance Fields (NeRFs) have proved to be a powerful tool for novel view synthesis [27]. It uses a coordinate-based multi-layer perceptron (MLP) to represent the scene and render high-fidelity images from different views. The render is done by pixel-wise volumetric rendering [25] with density and color evaluated using the MLP on hundreds of sampled points along the ray. For modeling high-frequency information in the scene, NeRF uses positional encoding to map the input coordinates onto high-frequency bands. The success of NeRF has triggered an explosive emergence of follow-up works. There are plenty of works focusing on improving or extending the ability of NeRF towards different aspects. Aliasing along xy coordinates has been tackled [3], unbounded scenes [4, 47, 39, 34], dynamic scenes [32, 22, 30] and scenes with semantic information [41, 37, 49, 19] have been well explored and demonstrated the potential of implicit scene representation with NeRF. Nonetheless, NeRF requires plenty of time for training and rendering, blocking its way of being used for real-time rendering. The bottleneck of the computation time is the MLP used. There are two main branches of work for extending NeRF towards real-time rendering. The first branch introduces different data structure [46, 9, 14, 33, 8, 6] for scene representation. Another branch, in which our method falls, improves the sample efficiency of the model [20, 29, 31, 38] to accelerate NeRF rendering process. While previous works draw their intuition from the underlying physics perspective and thus need different formulations of the sampling strategy and different neural network architecture for predicting the surface position of the underlying scenes, we propose our method based on a mathematical observation while maintaining the overall pipeline. Beneftiing from this, our work could be seamlessly incorporated into any existing NeRF-related works without further training. On the other hand, despite being derived from the mathematical perspective, our method still intuitively satisfies the underlying physical constraints. ", "page_idx": 2}, {"type": "text", "text": "3 Preliminaries ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "3.1 NeRF and volume rendering ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "NeRF [27] is a powerful implicit 3D scene model for novel view synthesis. At the core of its rendering ability is volume rendering. NeRF uses coordinate-based MLP to encode the scene, assigning volume density (opacity) and radiance (color) to spatial points. When used for synthesizing new views, it casts a ray $\\pmb{r}(t)=\\pmb{o}+t\\pmb{d}$ through the pixel to be rendered, sample points along the ray and compute volume density and radiance for these points. These values are then aggregated together using Eq.1 to give the color of the pixel. ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\hat{C}(\\boldsymbol{r})=\\sum_{i=1}^{N}w_{i}\\pmb{c}(\\pmb{r}(t_{i})),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where ", "page_idx": 3}, {"type": "equation", "text": "$$\nw_{i}=T_{i}(1-e x p(-\\sigma({\\boldsymbol{r}}(t_{i}))\\delta_{i})),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "equation", "text": "$$\nT_{i}=e x p(-\\sum_{j=0}^{i-1}\\sigma(r(t_{j}))\\delta_{j}),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "$t_{i}$ represents the sampled position along the ray and $\\delta_{i}=t_{i+1}-t_{i}$ is the distance between two nearby sampled points. NeRF uses an MLP to represent volume density $\\sigma$ and color $^c$ . The loss function for training NeRF is simply the square error between rendered pixel colors and the corresponding pixel colors over batch of rays $\\mathbf{R}$ . Variants of NeRF like TensoRF[6] use different representations for volume density and color, but the process of volume rendering remains the same. ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathbf{L}=\\sum_{r\\in\\mathbf{R}}\\|\\hat{C}(r)-C(r)\\|_{2}^{2}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "3.2 Gauss quadrature ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "An $n$ -point Gauss quadrature [10] is a method for numerical integration that guarantees to yield exact results for integral of polynomials of degree $2n-1$ or less, which is the highest possible precision for approximating an integral by quadrature. Intuitively, consider approximating an integral using quadrature as in Eq. 5 ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\int_{-1}^{1}p(x)d x=\\sum_{i=1}^{n}w_{i}p(x_{i}),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $p(x)$ is a polynomial of degree $2n-1$ , $w(x)$ is a weight function and $I$ is the interval for computing the integral. We first give the definition of orthogonality of two polynomials $p_{m}(x)$ and $p_{n}(x)$ ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\int_{-1}^{1}p_{m}(x)p_{n}(x)d x=0,\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $p_{m}(x)$ is of degree $m,p_{n}(x)$ is of degree $n$ and $m\\neq n$ . we can use long division for $p(x)$ to obtain ", "page_idx": 3}, {"type": "equation", "text": "$$\np(x)=q(x)L_{n}(x)+r(x),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $L_{n}(x)$ is a polynomial of degree $n$ that is orthogonal to any polynomials that have degree less than $n$ (i.e. $n$ degree Legendre polynomial), $q(x)$ and $r(x)$ are both polynomials with degree less than $n$ . Then ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\int_{-1}^{1}p(x)d x=\\int_{-1}^{1}q(x)L_{n}(x)d x+\\int_{-1}^{1}r(x)d x.\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Since $L_{n}(x)$ is orthogonal to any polynomials with degree less than $n$ , the first term on the right hand side of Eq. 8 should equal to 0. Since it doesn\u2019t contribute to the computation of the integral, we may also neglect it when computing the quadrature. Therefore, we should choose $x_{i}$ that satisfies $L_{n}(x_{i})=0$ [16]. With this intuition bearing in mind, carefully choosing the weights $w_{i}$ for computing the quadrature would help us precisely calculate Eq. 5 because we have $n$ points to compute the second term on the right hand side of Eq. 8, which is an integral of a polynomial of degree less than $n$ . ", "page_idx": 3}, {"type": "text", "text": "In general, given a function $f(x)$ , Gauss quadrature computes its integral on $[-1,1]$ using ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\int_{-1}^{1}f(x)d x\\approx\\sum_{i=1}^{n}w_{i}f(x_{i}),\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $x_{i},i\\,=\\,1,2,\\ldots,n$ corresponds to a root of the orthogonal polynomials on $[-1,1]$ . This quadrature is called Gauss-Legendre quadrature since the orthogonal polynomials on $[-1,1]$ with a weight function $g(x)=1$ are Legendre polynomials. An $n$ -th degree Legendre polynomial takes the form [35, 15, 17] ", "page_idx": 4}, {"type": "equation", "text": "$$\nP_{n}(x)=\\frac{1}{2^{n}n!}\\frac{d^{n}}{d x^{n}}(x^{2}-1)^{n},\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "and $w_{i}$ is computed using Eq. 11 as shown in [1]. ", "page_idx": 4}, {"type": "equation", "text": "$$\nw_{i}=\\frac{2}{(1-x_{i}^{2})[P_{n}^{\\prime}(x_{i})]^{2}}.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Gauss-Laguerre quadrature is an extension of Gauss quadrature for approximating integrals following the form of ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\int_{0}^{\\infty}e^{-x}f(x)d x\\approx\\sum_{i=1}^{n}w_{i}f(x_{i}).\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "In this case, the weight function is $g(x)=e^{-x}$ , the integral interval is $[0,\\infty)$ . $x_{i}$ corresponds to the root of Laguerre polynomials ", "page_idx": 4}, {"type": "equation", "text": "$$\nL_{n}(x)=\\frac{1}{n!}(\\frac{d}{d x}-1)^{n}x^{n},\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "a class of polynomials that are orthogonal over the interval $[0,\\infty)$ with respect to the weight function $g(x)=e^{-x}$ . The weight for computing the quadrature is computed as ", "page_idx": 4}, {"type": "equation", "text": "$$\nw_{i}=\\frac{x_{i}}{(n+1)^{2}[L_{n+1}(x_{i})]^{2}}.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "image", "img_path": "GDNZajKrML/tmp/cad4e06b54a7b1ee0905fa459decf9159a90bca0fe06e30b303eab802bb4a6de.jpg", "img_caption": [], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "While the computation for $x_{i}$ and $w_{i}$ is complicated, in practice we can use a look up table to store corresponding $x_{i}$ and $w_{i}$ for a given $n$ . ", "page_idx": 4}, {"type": "text", "text": "4 GL-NeRF ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "We developed our algorithm based on a simple observation of the integral for volume rendering. Eq. 1 is an approximation to the integral ", "page_idx": 4}, {"type": "text", "text": "Figure 2: Verification on using the Gauss-Laguerre quadrature for volume rendering. We plot the red channel of the color function w.r.t. the ray it corresponds to. The color function remains zero in most of the interval (bottom). We use a 7th-degree polynomial to approximate the non-zero region (top). As can be seen, the color function itself is similar to a polynomial, validating the use of our approach. ", "page_idx": 4}, {"type": "equation", "text": "$$\nC(\\boldsymbol{r})=\\int_{t_{n}}^{t_{f}}T(t)\\sigma(\\boldsymbol{r}(t))c(\\boldsymbol{r}(t),d)d t,\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where ", "page_idx": 4}, {"type": "equation", "text": "$$\nT(t)=e x p(-\\int_{t_{n}}^{t}\\sigma(\\boldsymbol{r}(s))d s).\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "4.1 Volume rendering and Gauss-Laguerre quadrature ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "Let ", "page_idx": 5}, {"type": "equation", "text": "$$\nx(t)=\\int_{t_{n}}^{t}\\sigma(\\pmb{r}(s))d s,\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "we have ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\frac{d x}{d t}=\\sigma(r(t)).\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "Since $\\sigma(\\pmb{r}(t))~\\geq~0$ , $x(t)$ is a monotonically non-decreasing function of $t$ , therefore, $x$ has a unique correspondence with $t$ on increasing intervals. With this observation, we can do a change of variables for Eq. 15 to get ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{l}{{\\displaystyle{\\cal C}({\\pmb r})=\\int_{t_{n}}^{t_{f}}T(t)\\sigma({\\pmb r}(t))c({\\pmb r}(t),d)d t}}\\\\ {~~~~~~=\\int_{t_{n}}^{t_{f}}e^{-x}c({\\pmb r}(t),d)\\frac{d x}{d t}d t}\\\\ {~~~~~=\\int_{x(t_{n})}^{x(t_{f})}e^{-x}c({\\pmb r}(x),d)d x.}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "image", "img_path": "GDNZajKrML/tmp/13691020264b06a6dd441e04d11cd89c61ef05b7d8ee196aec2733ba585be650.jpg", "img_caption": ["Figure 3: Point Selection strategy in GL-NeRF. We choose points along the ray that satisfy the integral from zero to the point of the volume density function should be equal to the roots of Laguerre polynomials. The points selected is then used for querying the color. In the figure above is an example of choosing 5 points using a 5-degree Laguerre polynomial. The number on the plot indicates the value of the integral from zero to the right boundary of the region. "], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "As can be seen from Eq. 19, the integral for volume rendering is a weighted integral of $c(\\pmb{r}(x),d)$ with the weight function to be $g(x)=e^{-x}$ . We can extend the integral interval ", "page_idx": 5}, {"type": "text", "text": "from $[x(t_{n}),x(t_{f})]$ to $[0,\\infty)$ since the integral between $[0,x(t_{n}))$ and $(x(t_{f}),\\infty)$ are zero. Thus, we have ", "page_idx": 5}, {"type": "equation", "text": "$$\nC(r)=\\int_{0}^{\\infty}e^{-x}c(r(t(x)),d)d x,\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "a pure exponentially weighted integral with respect to the color function, which is of the exact same form as required by the Gauss-Laguerre quadrature. ", "page_idx": 5}, {"type": "text", "text": "4.1.1 Gauss-Laguerre quadrature for volume rendering ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "As discussed in Sec. 3, the Gauss-Laguerre quadrature guarantees the highest algebraic precision when computing integral over polynomials. To perform the Gauss-Laguerre quadrature for volume rendering integral calculation, a natural question arises: is the color function a polynomial, or can it be approximated by a polynomial with a satisfactory error rate? ", "page_idx": 5}, {"type": "text", "text": "To answer this question, we first analytically give out a fundamental theorem, and then empirically approximate the color function with polynomials. ", "page_idx": 5}, {"type": "text", "text": "Theorem 4.1 (Stone-Weierstrass theorem). Suppose $f$ is a continuous real-valued function defined on the real interval $[a,b]$ . For every $\\epsilon>0,$ , there exists a polynomial $p$ such that for all $x$ in $[a,b]$ , we have $|f(x)-p(x)|^{\\prime}<\\epsilon$ . ", "page_idx": 5}, {"type": "text", "text": "Since the pixel color is contributed by points that have a density larger than a threshold (i.e. regions near the surface), we can overlook the points in the empty space and only analyze the remaining part of the color function. In Fig. 2 we plot a representative of how the color function looks like. As can be seen from the figure, it has a major region with values greater than zero while the others remain zero. When approximating the non-zero region with a 7-th degree polynomial, we have a relative error rate lower than $6.5\\%$ . While the relative error is not sufficiently low, we argue that we can increase the degree to better approximate it since it\u2019s cintinuous by nature. On the other hand, this specific landscape is fluctuated and for most of the cases, the error rate could be smaller than $1\\%$ . This suggests that Theorem 4.1 holds in our case, thus the Gauss-Laguerre quadrature can be used for computing the volume rendering integral. ", "page_idx": 5}, {"type": "text", "text": "4.1.2 Point selection in GL-NeRF ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Different from NeRF\u2019s sampling strategy, the Gauss-Laguerre quadrature enables us to use a deterministic point selection strategy for the color samples. Recall Eq. 17 is the integral variable for Eq. 20. This means if we want to use the Gauss-Laguerre quadrature to approximate Eq. 20, we have to choose points $x_{i}$ that are the root of nth-degree Laguerre polynomials. Since every $x_{i}$ has a corresponding $t_{i}$ following Eq. 17, we can choose $t_{i}$ based on given value of $x_{i}$ , as depicted in Fig. 3. Specifically, we want the integral Eq. 17 to be equal to the roots of an nth-degree Laguerre polynomial. Fig. 3 gives an example of $n=5$ . In the figure, the numbers in the five regions filled with different colors indicate the integral value of the volume density function from zero to the right boundary of the regions. A pseudocode for GL-NeRF rendering is shown in Algo. 1. ", "page_idx": 5}, {"type": "image", "img_path": "GDNZajKrML/tmp/ec10da1e60af12226f6908fe82a9efaf0fe7049010b34fac811e8e0b0e03b6c0.jpg", "img_caption": ["Figure 4: Comparison between GL-NeRF and vanilla NeRF in terms of render time and quantitative metrics. Each point on the figure represents an individual scene. We showcase that with the drop of computational cost GL-NeRF provides, the average time needed for rendering one image is 1.2 to 2 times faster than the vanilla NeRF. In the mean time, the overall performance remains almost the same despite some minor decreases. "], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "4.1.3 Intuitive understanding of the points selected using the Gauss-Laguerre quadrature ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Since the points near the surface contribute the most to the final color of the pixel as discussed in [20, 29, 31], the optimal point selection strategy should choose points near the surface. The volume density, on the other hand, increases remarkably near the surface and remains close to zero at other areas. Therefore, the integral value of it Eq. 17 should also increases significantly near the surface and remains almost unchanged throughout the rest of the space. Therefore, most of the points chosen using GL-NeRF should lie around the surface of the underlying scene. Consider a case when $n=8$ , we want to choose points $t_{i},i=1,2,\\ldots,8$ such that $x(t_{i})$ in Eq. 17 should be equal to the value $x_{i}$ given in the look-up table Tab. 1. Notice that the first few value for $x_{i}$ (say first three) are small so that they could be reached by the integral of volume density near the surface easily. These values have relatively larger weights assigned to them. Evaluating the color of these points using a neural network and summing them up using the weights $w_{i}$ given in Eq. ", "page_idx": 6}, {"type": "table", "img_path": "GDNZajKrML/tmp/a071e99d680ffac7be2b5836cf02c62b6ef5e510fe38bed8805e7205528219b1.jpg", "table_caption": [], "table_footnote": ["Table 1: Gauss-Laguerre quadrature look-up table when $n=8$ . "], "page_idx": 6}, {"type": "text", "text": "1 following Eq. 12 would contribute mostly to the pixel color. Notice that even though the last few $x_{i}$ are quite large and may not be reached by Eq. 17 along the ray, their corresponding weights are so small that they almost couldn\u2019t affect the final result of the pixel color. Hence, the points selected ", "page_idx": 6}, {"type": "image", "img_path": "GDNZajKrML/tmp/22aabe61120bfd5e79188ed7453da986bf5cbb48a2a4273168640084dc9015ff.jpg", "img_caption": ["Figure 5: Qualitative results on LLFF (top) and NeRF-Synthetic (bottom) datasets. We could tell from the comparisons that the drop in performances has minimal effect on the visual quality. "], "img_footnote": [], "page_idx": 7}, {"type": "table", "img_path": "GDNZajKrML/tmp/a97ab89c2cd704527bc198a7a861ea56a1a327fb6f95d89daf00a727fb805906.jpg", "table_caption": [], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "Table 2: Quantitative comparison. We demonstrate that our method has a minimal performance drop while significantly reducing the number of color MLP calls. ", "page_idx": 7}, {"type": "text", "text": "using GL-NeRF also correspond to the points near the surface, like in previous works [20, 29, 31] that design different neural networks for estimating the surface position, but only without any additional neural networks. Therefore, thanks to the nice property of the Gauss quadrature, ideally we can select the optimal points for computing volume rendering integral if the volume density estimation is oracle. ", "page_idx": 7}, {"type": "text", "text": "5 Experiments ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "Datasets and evaluation metrics. We evaluate our method on the standard datasets: NeRFSynthetic and Real Forward Facing Dataset(LLFF) [26] as in [27] with two different models, i.e. Vanilla NeRF [27], TensoRF [6] and InstantNGP [28]. Since our method is training-free, we conduct render-only experiments with the vanilla volume rendering method and our method. We plot the standard render quality evaluation metrics PSNR, SSIM [42] and LPIPS [48] with respect to the average time needed for rendering one image for each scene in Vanilla NeRF. We also report the metrics with averaged color MLP calls for TensoRF and InstantNGP. For Vanilla NeRF, we use 32 points for our method while the network is trained with more than 100 points. For TensoRF and InstantNGP, the results are produced with 4 MLP calls if not otherwise mentioned. More details can be found in Sec. A.1. ", "page_idx": 7}, {"type": "image", "img_path": "GDNZajKrML/tmp/49367963b63c1fe8fff81f32b07d7e29dd4dd028bf071f15ad2b58bc0b434792.jpg", "img_caption": [], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "Figure 6: Effect of sample number. The first five columns correspond to the number of sampled points on top. The sixth column shows the result of the original sampling strategy adopted in TensoRF (Ori). The last column is the ground truth visualization of the details in the scene. Our method could achieve comparable results using only 4-8 points while the original strategy requires more than 100 points. The blurriness in the first two columns is inherently the inaccuracy of piece-wise constant density estimation. ", "page_idx": 8}, {"type": "table", "img_path": "GDNZajKrML/tmp/852bc1d2687b193fbcb3eb5d06b8225d7002ece607f6f060b1923d4d5b6be073.jpg", "table_caption": [], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "Table 3: Quantitative comparison when training with GL-NeRF. Vanilla refers to the vanilla NeRF and its sampling strategy while ours refers to replacing the fine sample stage in vanilla NeRF with our sampling strategy, i.e. GL-NeRF. The result for Vanilla NeRF is produced by rendering using more than 100 points while GL-NeRF only uses 32 points. ", "page_idx": 8}, {"type": "text", "text": "We showcase that our method can be used for rendering novel views based on pretrained NeRF without further training. We plotted the quantitative metrics of GL-NeRF and original NeRF for an intuitive comparison in Fig. 4. It shows that our method achieves comparable results as the original NeRF while requiring less computation, leading to 1.2 to 2 times faster rendering. We also observed a drop in memory usage due to the fewer MLP calls we have. We further implement our method with TensoRF [6]. As can be seen from Tab. 5, our method significantly ", "page_idx": 8}, {"type": "table", "img_path": "GDNZajKrML/tmp/6116971301fad16fe8dd1f2b99f29d3051e163f78c60c6ae5f5b68921c136181.jpg", "table_caption": ["Table 4: Ablation study on the number of points sampled. The more points we have, the better the performance will be. With 8 points, our method is comparable to the original sampling strategy in TensoRF. "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "reduces the number of MLP calls needed for volume rendering while the rendering quality only drops a little. We observe that the minimal drop in the performance has little effect on the quality of the image. Some qualitative comparisons can be found in Fig. 5. Other than TensoRF, we implement our method on top of InstantNGP [28] to showcase the plug-and-play attribute of our method. Our method performs similarly on Blender dataset to InstantNGP as shown in Tab. 5. ", "page_idx": 8}, {"type": "text", "text": "5.2 Discussion on acceleration ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "The reason why the speed-up in Vanilla NeRF doesn\u2019t lead to real-time performance is that it has another heavy neural network for estimating the volume density. While our method needs cheap density estimation, it can be easily achieved by recent efforts in NeRF like factorized tensors [6]. Therefore, reducing the number of color MLP calls needed could lead to real-time performance as shown by previous work [13]. We therefore follow MC-NeRF [13] and develop a real-time renderer based on WebGL ", "page_idx": 8}, {"type": "table", "img_path": "GDNZajKrML/tmp/6c92a93efcac67fe82d2571875ae10b6a2e9c73ba042b25d0e18191c021b5c85.jpg", "table_caption": [], "table_footnote": [], "page_idx": 9}, {"type": "table", "img_path": "GDNZajKrML/tmp/29e1a88e896d582d35159d81b475d9355bba6bcb36ccd807284b70687fc36412.jpg", "table_caption": ["Table 5: Per-scene results on Blender dataset between InstantNGP and ours. We demonstrate that GL-NeRF is able to be plugged into ANY NeRF models. "], "table_footnote": [], "page_idx": 9}, {"type": "text", "text": "Table 6: Comparison between our method and TensoRF on Lego scene using WebGL-based renderer. The result is collected from an AMD Ryzen 9 5900HS CPU. GL-NeRF is able to provide almost real-time rendering while remaining similar quality as TensoRF. ", "page_idx": 9}, {"type": "text", "text": "and train a small variant of TensoRF with 8 channels for each density component and color component and 32 as hidden size for the color MLP. The result on Lego in the Blender dataset is shown in Tab. 5.4. GL-NeRF is able to provide almost real-time performance in WebGL with similar quality as TensoRF running on an AMD Ryzen 9 5900HS CPU thanks to the reduced number of color MLP calls. ", "page_idx": 9}, {"type": "text", "text": "5.3 Ablation studies ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We further study the effect of sampled points per ray. We conduct experiments using the TensoRF model on the LLFF dataset. We found that 8 points per ray already shows comparable results to the original sampling strategy that uses more than 100 points. Quantitative comparison can be found in Tab. 4. Qualitatively, in Fig. 6 we found that less number of points would lead to blurrier results. Since the points selected using GL-NeRF intuitively correspond to where the surface is, we argue that the blurriness comes from the inherent inaccuracy of piece-wise constant density estimation. ", "page_idx": 9}, {"type": "text", "text": "5.4 Discussion on GL-NeRF usage for training ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "While we mainly showcase that GL-NeRF is a general alternative to the sampling strategy for volume rendering at test time, it is also capable of being used for training. We demonstrate this by replacing the fine sample stage in Vanilla NeRF with GL-NeRF and show the result in Tab. 5 and Tab. 9. GL-NeRF is able to produce on-par results with the vanilla sampling strategy but use a much smaller number of points, i.e. 32 for GL-NeRF and more than 100 for vanilla NeRF. ", "page_idx": 9}, {"type": "text", "text": "6 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In this paper, we propose GL-NeRF, a novel approach for calculating the volume rendering integral. We show that with a simple change of variable, the Gauss-Laguerre quadrature can be used for computing the volume rendering integral. Thanks to the highest algebraic precision guaranteed by the Gauss-Laguerre quadrature, GL-NeRF significantly reduces the number of MLP calls needed for the volume rendering integral. We justify the use of the Gauss-Laguerre quadrature theoretically and empirically and showcase the plug-and-play attribute of GL-NeRF in two different NeRF models. Experiments show the potential of GL-NeRF being used for accelerating any existing NeRF model. We also demonstrate that GL-NeRF can be used for training vanilla NeRF, providing a potential new direction for neural rendering research. ", "page_idx": 9}, {"type": "text", "text": "Limitations. While GL-NeRF shows promising results in reducing the number of MLP calls needed, it still affects the rendering quality despite the theoretical guarantee of the highest precision. How to improve the performance so that it would meet the theoretical results would be interesting. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgement ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "The authors would like to thank the author of MC-NeRF for the useful tips on developing the WebGL renderer. This work has been funded in part by the Army Research Laboratory (ARL) award W911NF-23-2-0007, DARPA award FA8750-23-2-1015, and ONR award N00014-23-1-2840. ", "page_idx": 10}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[1] Milton Abramowitz, Irene A Stegun, and Robert H Romer. Handbook of mathematical functions with formulas, graphs, and mathematical tables, 1988.   \n[2] Relja Arandjelovic\u00b4 and Andrew Zisserman. Nerf in detail: Learning to sample for view synthesis. arXiv preprint arXiv:2106.05264, 2021.   \n[3] Jonathan T Barron, Ben Mildenhall, Matthew Tancik, Peter Hedman, Ricardo Martin-Brualla, and Pratul P Srinivasan. Mip-nerf: A multiscale representation for anti-aliasing neural radiance fields. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 5855\u20135864, 2021.   \n[4] Jonathan T Barron, Ben Mildenhall, Dor Verbin, Pratul P Srinivasan, and Peter Hedman. Mip-nerf 360: Unbounded anti-aliased neural radiance fields. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 5470\u20135479, 2022.   \n[5] Serge Bernstein. D\u00e9mo istration du th\u00e9or\u00e9me de weierstrass fond\u00e9e sur le calcul des probabilit\u00e9s. Commun. Soc. Math. Kharkow, 13(1):1\u20132, 1912.   \n[6] Anpei Chen, Zexiang Xu, Andreas Geiger, Jingyi Yu, and Hao Su. Tensorf: Tensorial radiance fields. In European Conference on Computer Vision, pages 333\u2013350. Springer, 2022.   \n[7] Robert A Drebin, Loren Carpenter, and Pat Hanrahan. Volume rendering. ACM Siggraph Computer Graphics, 22(4):65\u201374, 1988.   \n[8] Sara Fridovich-Keil, Alex Yu, Matthew Tancik, Qinhong Chen, Benjamin Recht, and Angjoo Kanazawa. Plenoxels: Radiance fields without neural networks. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 5501\u20135510, 2022.   \n[9] Stephan J Garbin, Marek Kowalski, Matthew Johnson, Jamie Shotton, and Julien Valentin. Fastnerf: High-fidelity neural rendering at 200fps. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 14346\u201314355, 2021.   \n[10] Carl Friedrich Gauss. Methodvs nova integralivm valores per approximationem inveniendi. Dieterich, 1815.   \n[11] Walter Gautschi. Numerical analysis. Springer Science & Business Media, 2011.   \n[12] Yuan-Chen Guo. Instant neural surface reconstruction, 2022. https://github.com/bennyguo/instant-nsr-pl.   \n[13] Kunal Gupta, Milos Hasan, Zexiang Xu, Fujun Luan, Kalyan Sunkavalli, Xin Sun, Manmohan Chandraker, and Sai Bi. Mcnerf: Monte carlo rendering and denoising for real-time nerfs. In SIGGRAPH Asia 2023 Conference Papers, pages 1\u201311, 2023.   \n[14] Peter Hedman, Pratul P Srinivasan, Ben Mildenhall, Jonathan T Barron, and Paul Debevec. Baking neural radiance fields for real-time view synthesis. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 5875\u20135884, 2021.   \n[15] James Ivory. V. on the figure requisite to maintain the equilibrium of a homogeneous fluid mass that revolves upon an axis. Philosophical Transactions of the Royal Society of London, (114):85\u2013150, 1824.   \n[16] Carl Gustav Jakob Jacobi. Ueber gauss neue methode, die werthe der integrale n\u00e4herungsweise zu finden. 1826.   \n[17] JDG Jacobi. Ueber eine besondere gattung algebraischer functionen, die aus der entwicklung der function (1-2xz+ z2) 1/2 entstehen. 1827.   \n[18] Bernhard Kerbl, Georgios Kopanas, Thomas Leimk\u00fchler, and George Drettakis. 3d gaussian splatting for real-time radiance field rendering. ACM Transactions on Graphics (ToG), 42(4):1\u201314, 2023.   \n[19] Abhijit Kundu, Kyle Genova, Xiaoqi Yin, Alireza Fathi, Caroline Pantofaru, Leonidas J Guibas, Andrea Tagliasacchi, Frank Dellaert, and Thomas Funkhouser. Panoptic neural fields: A semantic object-aware neural scene representation. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 12871\u201312881, 2022.   \n[20] Andreas Kurz, Thomas Neff, Zhaoyang Lv, Michael Zollh\u00f6fer, and Markus Steinberger. Adanerf: Adaptive sampling for real-time rendering of neural radiance fields. In European Conference on Computer Vision, pages 254\u2013270. Springer, 2022.   \n[21] Liangchen Li and Juyong Zhang. l_0-sampler: An l_{0} model guided volume sampling for nerf. arXiv preprint arXiv:2311.07044, 2023.   \n[22] Zhengqi Li, Simon Niklaus, Noah Snavely, and Oliver Wang. Neural scene flow fields for space-time view synthesis of dynamic scenes. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 6498\u20136508, 2021.   \n[23] David B Lindell, Julien NP Martel, and Gordon Wetzstein. Autoint: Automatic integration for fast neural volume rendering. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 14556\u201314565, 2021.   \n[24] Lingjie Liu, Jiatao Gu, Kyaw Zaw Lin, Tat-Seng Chua, and Christian Theobalt. Neural sparse voxel fields. Advances in Neural Information Processing Systems, 33:15651\u201315663, 2020.   \n[25] Nelson Max. Optical models for direct volume rendering. IEEE Transactions on Visualization and Computer Graphics, 1(2):99\u2013108, 1995.   \n[26] Ben Mildenhall, Pratul P Srinivasan, Rodrigo Ortiz-Cayon, Nima Khademi Kalantari, Ravi Ramamoorthi, Ren Ng, and Abhishek Kar. Local light field fusion: Practical view synthesis with prescriptive sampling guidelines. ACM Transactions on Graphics (TOG), 38(4):1\u201314, 2019.   \n[27] Ben Mildenhall, Pratul P Srinivasan, Matthew Tancik, Jonathan T Barron, Ravi Ramamoorthi, and Ren Ng. Nerf: Representing scenes as neural radiance fields for view synthesis. Communications of the ACM, 65(1):99\u2013106, 2021.   \n[28] Thomas M\u00fcller, Alex Evans, Christoph Schied, and Alexander Keller. Instant neural graphics primitives with a multiresolution hash encoding. ACM transactions on graphics (TOG), 41(4):1\u201315, 2022.   \n[29] Thomas Neff, Pascal Stadlbauer, Mathias Parger, Andreas Kurz, Joerg H Mueller, Chakravarty R Alla Chaitanya, Anton Kaplanyan, and Markus Steinberger. Donerf: Towards real-time rendering of compact neural radiance fields using depth oracle networks. In Computer Graphics Forum, volume 40, pages 45\u201359. Wiley Online Library, 2021.   \n[30] Julian Ost, Fahim Mannan, Nils Thuerey, Julian Knodt, and Felix Heide. Neural scene graphs for dynamic scenes. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 2856\u20132865, 2021.   \n[31] Martin Piala and Ronald Clark. Terminerf: Ray termination prediction for efficient neural rendering. In 2021 International Conference on 3D Vision (3DV), pages 1106\u20131114. IEEE, 2021.   \n[32] Albert Pumarola, Enric Corona, Gerard Pons-Moll, and Francesc Moreno-Noguer. D-nerf: Neural radiance fields for dynamic scenes. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 10318\u201310327, 2021.   \n[33] Christian Reiser, Songyou Peng, Yiyi Liao, and Andreas Geiger. Kilonerf: Speeding up neural radiance fields with thousands of tiny mlps. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 14335\u201314345, 2021.   \n[34] Christian Reiser, Rick Szeliski, Dor Verbin, Pratul Srinivasan, Ben Mildenhall, Andreas Geiger, Jon Barron, and Peter Hedman. Merf: Memory-efficient radiance fields for real-time view synthesis in unbounded scenes. ACM Transactions on Graphics (TOG), 42(4):1\u201312, 2023.   \n[35] Olinde Rodrigues. De l\u2019attraction des sph\u00e9ro\u00efdes, Correspondence sur $l^{\\prime}\\acute{E}$ -cole Imp\u00e9riale Polytechnique. PhD thesis, PhD thesis, Thesis for the Faculty of Science of the University of Paris, 1816.   \n[36] Gopal Sharma, Daniel Rebain, Kwang Moo Yi, and Andrea Tagliasacchi. Volumetric rendering with baked quadrature fields. arXiv preprint arXiv:2312.02202, 2023.   \n[37] Yawar Siddiqui, Lorenzo Porzi, Samuel Rota Bul\u00f2, Norman M\u00fcller, Matthias Nie\u00dfner, Angela Dai, and Peter Kontschieder. Panoptic lifting for 3d scene understanding with neural fields. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 9043\u20139052, 2023.   \n[38] Vincent Sitzmann, Semon Rezchikov, Bill Freeman, Josh Tenenbaum, and Fredo Durand. Light field networks: Neural scene representations with single-evaluation rendering. Advances in Neural Information Processing Systems, 34:19313\u201319325, 2021.   \n[39] Matthew Tancik, Vincent Casser, Xinchen Yan, Sabeek Pradhan, Ben Mildenhall, Pratul P Srinivasan, Jonathan T Barron, and Henrik Kretzschmar. Block-nerf: Scalable large scene neural view synthesis. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 8248\u20138258, 2022.   \n[40] Mikaela Angelina Uy, Kiyohiro Nakayama, Guandao Yang, Rahul Krishna Thomas, Leonidas Guibas, and Ke Li. Nerf revisited: Fixing quadrature instability in volume rendering. arXiv preprint arXiv:2310.20685, 2023.   \n[41] Suhani Vora, Noha Radwan, Klaus Greff, Henning Meyer, Kyle Genova, Mehdi SM Sajjadi, Etienne Pot, Andrea Tagliasacchi, and Daniel Duckworth. Nesf: Neural semantic fields for generalizable semantic segmentation of 3d scenes. arXiv preprint arXiv:2111.13260, 2021.   \n[42] Zhou Wang, Alan C Bovik, Hamid R Sheikh, and Eero P Simoncelli. Image quality assessment: from error visibility to structural similarity. IEEE transactions on image processing, 13(4):600\u2013612, 2004.   \n[43] Lee Westover. Interactive volume rendering. In Proceedings of the 1989 Chapel Hill workshop on Volume visualization, pages 9\u201316, 1989.   \n[44] Liwen Wu, Jae Yong Lee, Anand Bhattad, Yu-Xiong Wang, and David Forsyth. Diver: Real-time and accurate neural radiance fields with deterministic integration for volume rendering. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 16200\u201316209, 2022.   \n[45] Lin Yen-Chen. Nerf-pytorch. https://github.com/yenchenlin/nerf-pytorch/, 2020.   \n[46] Alex Yu, Ruilong Li, Matthew Tancik, Hao Li, Ren Ng, and Angjoo Kanazawa. Plenoctrees for real-time rendering of neural radiance fields. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 5752\u20135761, 2021.   \n[47] Kai Zhang, Gernot Riegler, Noah Snavely, and Vladlen Koltun. Nerf $^{++}$ : Analyzing and improving neural radiance fields. arXiv preprint arXiv:2010.07492, 2020.   \n[48] Richard Zhang, Phillip Isola, Alexei A Efros, Eli Shechtman, and Oliver Wang. The unreasonable effectiveness of deep features as a perceptual metric. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 586\u2013595, 2018.   \n[49] Shuaifeng Zhi, Tristan Laidlow, Stefan Leutenegger, and Andrew J Davison. In-place scene labelling and understanding with implicit scene representation. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 15838\u201315847, 2021. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "A Appendix ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Here we introduce the implementation details, give a brief introduction of the Gauss-Laguerre quadrature and present our quantitative results on NeRF-Synthetic and LLFF datasets. ", "page_idx": 13}, {"type": "text", "text": "A.1 Implementation details ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "For Vanilla NeRF, our experiments are conducted based upon NeRF-PyTorch [45], a reproducible PyTorch implementation of the original NeRF [27]. We implement our method by changing the hierarchical sampling strategy into our point selection method using the Gauss-Laguerre quadrature. We follow the standard setting as done in [27] to train a \u201ccoarse\u201d and a \u201cfine\u201d network for evaluation. We use a learning rate of $5\\times10^{-4}$ that exponentially decays to $5\\,\\times\\,10^{-5}$ over the course of optimization. Each scene is trained for $200\\mathbf{k}$ iterations using a single NVIDIA RTX 6000 GPU. We use 128 coarse samples and 32 fine samples to test our method. Since the density estimation for \u201ccoarse\u201d and \u201cfine\u201d network are not aligned, we test our method using only the \u201cfine\u201d network by first using \u201ccoarse\u201d samples to query it for an estimation of density, then use GL-NeRF to select 32 points for final rendering as discussed in Sec. 4.1.2. LLFF scenes are trained and tested with 64 coarse samples and 64 fine samples for baseline method, while NeRF-Synthetic scenes require 128 coarse samples and 64 fine samples. For TensoRF, we directly use the pretrained checkpoints in the folder VM48 provided by the authors. The qualitative results are produced by 4 neural network calls if not otherwise mentioned. For InstantNGP, we build our code on top of the public PyTorch implementation [12] and train it with the default setting. The final results for GL-NeRF are also produced by 4 neural network calls. ", "page_idx": 13}, {"type": "text", "text": "A.2 Gauss-Laguerre quadrature ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "The Gauss-Laguerre quadrature is an approximation formula for computing integrals over the semiinfinite interval $\\lbrack0,+\\infty)$ with the weight function $e^{-x}$ and reads as ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\int_{0}^{+\\infty}e^{-x}f(x)d x\\approx\\sum_{k=0}^{n}w_{k}f(x_{k}).\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "Here $x_{0},x_{1},\\cdot\\cdot\\cdot\\,,x_{n}\\,\\in\\,[0,+\\infty)$ are the zeros of the Laguerre polynomial ${L_{n+1}}\\,=\\,{L_{n+1}}(x)$ of degree $(n+1)$ : ", "page_idx": 13}, {"type": "equation", "text": "$$\nL_{n+1}(x)=\\frac{1}{(n+1)!}e^{x}\\frac{d^{n+1}}{d x^{n+1}}(x^{n+1}e^{-x}),\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "for $n=-1,0,1,\\cdot\\cdot\\cdot$ , and the coefficients ", "page_idx": 13}, {"type": "equation", "text": "$$\nw_{k}={\\frac{1}{x_{k}[L_{n+1}^{\\prime}(x_{k})]^{2}}},\\quad k=0,1,2,\\cdots\\,,n.\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "From the Leibniz formula, it is easy to see that $L_{n}(x)$ is a polynomial of degree $n$ and the coefficient of $x^{n}$ is $\\frac{(-1)^{n}}{n!}$ . In particular, we have ", "page_idx": 13}, {"type": "equation", "text": "$$\nL_{0}=1,\\qquad L_{1}=1-x,\\qquad L_{2}=\\frac12x^{2}-2x+1,\\cdot\\cdot\\cdot\\cdot.\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "The fundamental property of the Laguerre polynomials is ", "page_idx": 13}, {"type": "text", "text": "Theorem A.1. The Laguerre polynomials $L_{n}=L_{n}(x)$ are orthogonal with respect to the weight function $e^{-x}$ , that is, ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\int_{0}^{+\\infty}e^{-x}L_{n}(x)L_{m}(x)d x=\\left\\{\\begin{array}{l l}{0,}&{\\quad n\\neq m,}\\\\ {1,}&{\\quad n=m.}\\end{array}\\right.\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "Proof. Assume $m\\leq n$ and set $g_{k}(x)=x^{k}e^{-x}$ . From the Leibniz formula it follows that, for $j<k$ , $g_{k}^{(j)}(x)$ is a product of $x e^{-x}$ and a polynomial of degree $(k\\!-\\!1)$ and thereby $g_{k}^{(j)}(0)=0=g_{k}^{(j)}(+\\infty)$ ", "page_idx": 13}, {"type": "text", "text": "for $j<k$ . Thus, we deduce that ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad n\\mathrm{i}\\mathrm{J}\\int_{0}^{+\\infty}e^{-z}{\\cal E}_{n}(x){\\cal L}_{m}(x)d x}\\\\ &{=\\int_{0}^{+\\infty}e^{-z}e^{z}e^{z}\\mathrm{i}\\sigma_{n}^{\\prime}(x)e^{\\theta}f_{0}d x}\\\\ &{=\\int_{0}^{+\\infty}e^{z}g_{0}^{\\prime}(x)\\partial_{x}^{(0)}\\theta_{n}^{\\prime}{-}(x)(z)}\\\\ &{=g_{n}^{(0)}{-}(x)(e^{z}\\mathrm{i}\\partial_{x}^{(0)}(x)\\mathrm{i}\\partial_{x}^{(0)}}\\\\ &{\\quad-\\int_{0}^{+\\infty}[e^{z}\\partial_{x}^{(0)}(x)]^{\\prime}\\partial_{x}^{(0)}(x)}\\\\ &{=-g_{0}^{(0)}{-}(x)\\Big[e^{z}\\partial_{y}^{(0)}(x)[\\partial_{z}^{(0)}(x)]^{\\prime}\\partial_{x}^{(0)}}\\\\ &{\\quad+\\int_{0}^{+\\infty}[e^{z}\\partial_{y}^{(0)}(x)[\\partial_{y}^{(0)}\\partial_{z}^{(1)}(x)}\\\\ &{\\quad-\\cdots}\\\\ &{\\quad{=-(1-)^{n}}\\int_{0}^{+\\infty}g_{n}(x)[e^{z}\\partial_{y}^{(0)}(x)]^{\\prime}\\partial_{z}\\mathrm{d}x}\\end{array}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "By the Leibniz formula, we have ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\begin{array}{l}{{\\displaystyle\\left[e^{x}g_{m}^{(m)}(x)\\right]^{(n)}=\\sum_{j=0}^{n}\\frac{n!}{(n-j)!j!}(e^{x})^{(n-j)}g_{m}^{(m+j)}(x)}}\\\\ {{\\displaystyle=e^{x}\\sum_{j=0}^{n}\\frac{n!}{(n-j)!j!}g_{m}^{(m+j)}(x)}}\\end{array}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "and thereby ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad n\\operatorname*{imf}\\int_{0}^{\\infty}\\cdots e^{-L}{\\cal T}_{n}(\\sigma^{\\top}\\!|Z_{n}(x)|)d x}\\\\ &{=\\!(-1)^{n}\\!\\!\\!\\!\\frac{\\sqrt{\\pi}}{\\rho(n-2)!}\\frac{\\pi^{1}}{\\rho(n-2)!}\\!\\int_{0}^{+\\infty}x^{n}\\!\\!\\frac{(n\\!-\\!\\rho^{\\top}\\!)^{n}}{n!}d x}\\\\ &{=\\!\\!\\!\\!\\frac{\\sqrt{\\pi}}{\\rho(n-2)!}\\frac{n(1-\\rho^{\\top}\\!)^{n+m+2}}{(n-2)!!}\\int_{0}^{+\\infty}\\frac{n!\\pi^{1}\\!-\\!n\\!-\\!\\rho^{\\top}\\!}{(n-m-2)!}\\!\\!\\int_{0}^{0}\\!\\!\\!\\!\\!\\alpha(x)d x}\\\\ &{=\\!\\!\\!-\\!\\!\\frac{\\sqrt{\\pi}}{\\rho(n-2)!}\\frac{n(1-\\rho^{\\top}\\!)^{n+m+2}}{(n-2)!!}\\int_{0}^{+\\infty}\\frac{n!}{(n-m-2)!}\\!\\!\\int_{0}^{+\\infty}\\!\\!\\!\\!\\alpha(x)\\!}\\\\ &{=\\!\\!\\!-\\!\\!(\\!1\\!-\\!\\frac{\\pi}{2}\\frac{n!}{\\rho(n-2)!!}\\frac{n!}{(n-2)!!}\\!\\int_{0}^{+\\infty}\\!\\!\\frac{1}{(n-m-2)!!}\\frac{n!}{(n-m-2)!!}}\\\\ &{=\\!\\!(-\\!1)^{n}\\!\\!+\\!\\frac{(n!)^{n}}{2!!}\\frac{\\pi^{1}}{(n-m)!!^{\\frac{n}{2}}!}\\frac{(n!-\\!1)^{n}}{(n-m-2)!!}\\pi^{1}}\\\\ &{=\\!\\!(-\\!1)^{n+m}\\frac{(n!)^{2}}{(n-m)!}\\frac{\\pi^{1}}{\\rho(n-m-2)!}(-1)^{n}}\\\\ &{=\\!(-\\!1)^{n+m}\\frac{(n!)^{2}}{(n-m)!}(1-1)^{n-m}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "Here the second equality is similar to that in 23 and the fourth uses ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\int_{0}^{+\\infty}x^{n-j}e^{-x}d x=(n-j)!.\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "This completes the proof. ", "page_idx": 14}, {"type": "text", "text": "The orthogonality of the Laguerre polynomials ensures that the $L_{n}(x)$ \u2019s are linearly independent and $L_{n+1}(x)$ has $(n+1)$ distinct zeros $x_{0},x_{1},\\dots,x_{n}$ in $\\lbrack0,+\\infty)$ [11]. With the zeros, the coefficients $w_{k}$ are chosen so that the following $(n+1)$ equalities ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\int_{0}^{+\\infty}e^{-x}x^{j}d x=\\sum_{k=0}^{n}w_{k}x_{k}^{j},\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "hold for $j=0,1,\\cdot\\cdot\\cdot,n$ . This leads to a system of $(n\\!+\\!1)$ linear algebraic equations for the unknowns $w_{k}$ and the corresponding coefficient matrix is the Vandermonde matrix $[x_{k}^{j}]_{(n+1)\\times(n+1)}$ . The latter is invertible since the zeros are distinct and therefore the $w_{k}$ \u2019s are uniquely determined. The specific expressions of the $w_{k}$ \u2019s are given in 22 [11]. ", "page_idx": 15}, {"type": "text", "text": "It is remarkable that all the coefficients $w_{k}$ are non-negative. This important property ensures the stability and convergence of the Gauss-Laguerre quadrature [11]. Moreover, we have ", "page_idx": 15}, {"type": "text", "text": "Theorem A.2. The algebraic precision of the Gauss-Laguerre quadrature $2l$ is $(2n+1)$ exactly. Namely, $\"{\\approx}\"$ in $2l$ is $\"=\"$ if $f(x)$ is a polynomial of degree $(2n+1)$ and is not $\\\"=\"\\,i f\\,f(x)$ is $a$ polynomial with degree higher than $(2n+1)$ . ", "page_idx": 15}, {"type": "text", "text": "Proof. Notice that ", "page_idx": 15}, {"type": "equation", "text": "$$\n(n+1)!L_{n+1}(x)=(-1)^{n+1}\\Pi_{k=0}^{n}(x-x_{k})\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "is a polynomial of degree $(n+1)$ . Since ", "page_idx": 15}, {"type": "equation", "text": "$$\n0<\\int_{0}^{+\\infty}e^{-x}L_{n+1}^{2}(x)d x\\neq0=\\sum_{k=0}^{n}w_{k}L_{n+1}^{2}(x_{k}),\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "the precision is less than $2(n\\!+\\!1)$ . On the other hand, for any polynomial $p=p(x)$ of degree $(2n+1)$ there are two polynomials of degree $n$ such that $p(x)=q(\\bar{x)}L_{n+1}^{\\bar{}}(x)+r(\\bar{x)}$ . Notice that $q(x)$ can be written as a linear combination of $L_{0}(x),L_{1}(x),\\cdot\\cdot\\cdot\\,,L_{n}(x)$ . Compute ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\sum_{k=0}^{n}w_{k}p(x_{k})=}&{\\sum_{k=0}^{n}w_{k}[q(x_{k})L_{n+1}(x_{k})+r(x_{k})]}\\\\ {=}&{\\sum_{k=0}^{n}w_{k}r(x_{k})}\\\\ {=}&{\\int_{0}^{+\\infty}e^{-x_{r}}(x)d x}\\\\ {=}&{\\int_{0}^{+\\infty}e^{-x}[q(x)L_{n+1}(x)+r(x)]d x}\\\\ {=}&{\\int_{0}^{+\\infty}e^{-x}p(x)d x.}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Here the third equality is due to 24 (the choice of $w_{k}$ ) and the fourth is due to the orthogonality of $L_{n+1}(x)$ and $q(x)$ with respect to the weight function. Hence the proof is complete. \u53e3 ", "page_idx": 15}, {"type": "text", "text": "For further details on the Gauss-Laguerre quadrature and for other Gauss quadratures, the interested reader is referred to the book [11]. ", "page_idx": 15}, {"type": "text", "text": "A.3 Proof for Theorem 4.1 ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Here we present a proof of the well-known Stone-Weierstrass theorem, basically from [5]. We rephrase the theorem here for readability. ", "page_idx": 15}, {"type": "text", "text": "Theorem A.3. Suppose $f=f(x):[0,1]\\to(-\\infty,\\infty)$ is continuous. Then for any $\\epsilon>0$ there is a polynomial $p=p(x)$ satisfying ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\operatorname*{sup}_{x\\in[0,1]}|f(x)-p(x)|<\\epsilon.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Namely, polynomials are dense in the Banach space $C[0,1]$ . ", "page_idx": 15}, {"type": "table", "img_path": "GDNZajKrML/tmp/6d2e9ed6adaf007dd7876fbda1c2f96abacc1c95dc42d93fc80e866f155eb33f.jpg", "table_caption": ["Table 7: Per-scene quantitative comparison between TensoRF and ours. "], "table_footnote": [], "page_idx": 16}, {"type": "text", "text": "Proof. Fix $f=f(x)\\in C[0,1]$ and $\\epsilon>0$ . Since $f\\,=\\,f(x)$ is continuous on the bounded closed interval $[0,1]$ , it is bounded and uniformly continuous, meaning that there are positive numbers $M>0$ and $\\bar{\\delta}=\\delta(\\epsilon)>0$ such that ", "page_idx": 16}, {"type": "equation", "text": "$$\n|f(x)|\\leq M,\\qquad|f(x)-f(y)|<{\\frac{\\epsilon}{2}}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "for any $x,y\\in[0,1]$ satisfying $|x-y|<\\delta$ . ", "page_idx": 16}, {"type": "text", "text": "With $\\delta$ fixed, let $n\\ge\\frac{M}{\\delta^{2}\\epsilon}$ be a positive integer. Consider the $n$ th-order Bernstein polynomial [5] ", "page_idx": 16}, {"type": "equation", "text": "$$\np(x)=\\sum_{k=0}^{n}f(\\frac{k}{n})C_{n}^{k}x^{k}(1-x)^{n-k}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "with $\\begin{array}{r}{C_{n}^{k}=\\frac{n!}{k!(n-k)!}}\\end{array}$ . Notice that, for $x\\in[0,1]$ ", "page_idx": 16}, {"type": "equation", "text": "$$\nC_{n}^{k}x^{k}(1-x)^{n-k}\\geq0,\\qquad\\sum_{k=0}^{n}C_{n}^{k}x^{k}(1-x)^{n-k}=(x+1-x)^{n}=1,\n$$", "text_format": "latex", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\displaystyle\\sum_{k=0}^{n}k C_{n}^{k}x^{k}(1-x)^{n-k}=}&{\\displaystyle\\sum_{k=1}^{n}k\\frac{n!}{k!(n-k)!}x^{k}(1-x)^{n-k}}\\\\ {=}&{n x\\displaystyle\\sum_{k=1}^{n}\\frac{(n-1)!}{(k-1)!(n-1-(k-1))!}x^{k-1}(1-x)^{n-1-(k-1)}}\\\\ {=}&{n x(x+1-x)^{n-1}=n x,}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\displaystyle\\sum_{k=0}^{n}k^{2}C_{n}^{k}x^{k}(1-x)^{n-k}=}&{\\displaystyle\\sum_{k=0}^{n}k C_{n}^{k}x^{k}(1-x)^{n-k}+\\displaystyle\\sum_{k=0}^{n}k(k-1)C_{n}^{k}x^{k}(1-x)^{n-k}}\\\\ {=}&{n x+\\displaystyle\\sum_{k=2}^{n}k(k-1)\\frac{n!}{k!(n-k)!}x^{k}(1-x)^{n-k}}\\\\ {=}&{n x+n(n-1)x^{2}\\displaystyle\\sum_{k=2}^{n}\\frac{(n-2)!}{(k-2)!(n-k)!}x^{k-2}(1-x)^{n-k}}\\\\ {=}&{n x+n(n-1)x^{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "table", "img_path": "GDNZajKrML/tmp/5b38e8dc166c9f154d0ca94c79d412c6179f211a174aa5965c9713be8a576b7f.jpg", "table_caption": [], "table_footnote": ["Table 8: Per-scene quantitative comparison between Vanilla NeRF and ours. "], "page_idx": 17}, {"type": "text", "text": "Then, for any $x\\in[0,1]$ , we deduce from (25)\u2013(28) that ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathrm{i}\\left[\\begin{array}{l}{-1}\\\\ {1}\\end{array}\\right]}\\\\ &{\\le\\sum_{i=1}^{N}\\left[I_{0}(\\tau)-I_{0}\\right]\\xi_{i}\\xi_{i}\\xi_{i}(x_{i}-x_{i})^{-1}+}\\\\ &{\\le(\\xi_{i}-\\operatorname*{max}_{0}\\xi_{i})\\xi_{i}(x_{i}-x_{i})^{1}}\\\\ &{\\le(\\xi_{i}-\\operatorname*{max}_{0}\\xi_{i}+\\operatorname*{max}_{0}\\xi_{i})(I_{0}(\\tau)-I_{0}\\big[I_{0}^{k}\\big]\\xi_{i}\\xi_{i}\\xi_{i}(x_{i}-x_{i})^{-1}}\\\\ &{+(\\xi_{i}-\\operatorname*{max}_{0}\\xi_{i}-\\operatorname*{max}_{0}\\xi_{i})\\xi_{i}\\xi_{i}(x_{i}-x_{i})^{-1}}\\\\ &{\\le(\\xi_{i}-\\operatorname*{max}_{0}\\xi_{i})\\xi_{i}\\xi_{i}(x_{i}-x_{i})\\xi_{i}(x_{i}-x_{i})^{-1}}\\\\ &{\\le\\xi_{i}^{2}+2M_{\\mathrm{~i~n~}}\\sum_{s=0}^{N}\\frac{(\\xi_{i}-\\operatorname{max}_{0}\\xi_{i})^{2}}{s^{2}\\xi_{i}\\xi_{i}^{3}}c_{s}^{s}(x_{i}-x_{i})^{-s+}}\\\\ &{\\le\\xi_{i}^{2}+\\frac{2M_{\\mathrm{~i~n~}}^{2}}{s^{2}\\xi_{i}\\xi_{i}\\xi_{i}\\xi_{i}}\\frac{1}{\\xi_{i}\\xi_{i}\\xi_{i}}(x_{i}-x_{i})^{-s+}}\\\\ &{\\le\\xi_{i}^{2}+\\frac{2M_{\\mathrm{~i~n~}}^{2}}{s^{2}\\xi_{i}\\xi_{i}\\xi_{i}}\\frac{1}{\\xi_{i}\\xi_{i}\\xi_{i}}(x_{i}-x_{i})^{1}c_{s}^{s}+}\\\\ &{\\le\\xi_{i}^{2}+\\frac{2M_{\\mathrm{~i~n~}}^{2}}{s^{2}\\xi_{i}\\xi_{i}\\xi_{i}}(x_{i}-x_ \n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "This completes the proof. ", "page_idx": 17}, {"type": "text", "text": "A.4 Quantitative results on NeRF-Synthetic and LLFF datasets ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "In this part, we present our per-scene quantitative results on NeRF-Synthetic and LLFF datasets in Tab. 8 for Vanilla NeRF and in Tab. 7 for TensoRF. The full result for training using GL-NeRF is presented in Tab. 9 ", "page_idx": 17}, {"type": "table", "img_path": "GDNZajKrML/tmp/d99e2be7336363ab30afaedef44a8ac35cce9efdbe9c8f65234b5c4d5488a006.jpg", "table_caption": [], "table_footnote": ["Table 9: Quantitative results when training on Blender and LLFF Datasets. "], "page_idx": 18}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: We prove the claim of reducing computation in Sec. 5, the analysis and justification of using the Gauss-Laguerre quadrature are in Sec. 4.1.1 and Sec. 4.1.2. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 19}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Justification: The limitations are discussed in Sec. 6. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 19}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: All theories in the paper are proven in the Appendix, specifically Sec. A.2 and Sec. A.3. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 20}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: Details are provided in Sec. 5 and Sec. A.1. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 20}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: The code can be found in https://silongyong.github.io/GL-NeRF_ project_page/. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 21}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: Experimental settings are discussed in Sec. 5 and Sec. A.1. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 21}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 21}, {"type": "text", "text": "Answer: [No] ", "page_idx": 21}, {"type": "text", "text": "Justification: Our method is training-free, thus no randomness during test time. Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 21}, {"type": "text", "text": "", "page_idx": 22}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: Compute resources are introduced in Sec. 5 and Sec. A.1. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 22}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: We have read and comply to the NeurIPS Code of Ethics. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 22}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: Our work is a foundational research. There is no societal impact of the work performed. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 22}, {"type": "text", "text": "", "page_idx": 23}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 23}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 23}, {"type": "text", "text": "Justification: The paper poses no such risks. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 23}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: The datasets used in the paper i.e. LLFF and NeRF-Synthetic are properly cited, the codebase we use are properly cited in Sec. 5 and Sec. A.1. The license for these assets are CC-BY 3.0 for the two datasets, and MIT License for the two codebases. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 23}, {"type": "text", "text": "", "page_idx": 24}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 24}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 24}, {"type": "text", "text": "Justification: No new assets have been created in the paper. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 24}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 24}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 24}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 24}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 24}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 24}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 24}]