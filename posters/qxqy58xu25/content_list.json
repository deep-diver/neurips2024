[{"type": "text", "text": "Data-Efficient Learning with Neural Programs ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Alaia Solko-Breslin, Seewon Choi, Ziyang Li, Neelay Velingker, Rajeev Alur, Mayur Naik, Eric Wong ", "page_idx": 0}, {"type": "text", "text": "University of Pennsylvania {alaia,seewon,liby99,neelay,alur,mhnaik,exwong}@seas.upenn.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Many computational tasks can be naturally expressed as a composition of a DNN followed by a program written in a traditional programming language or an API call to an LLM. We call such composites \u201cneural programs\u201d and focus on the problem of learning the DNN parameters when the training data consist of end-to-end input-output labels for the composite. When the program is written in a differentiable logic programming language, techniques from neurosymbolic learning are applicable, but in general, the learning for neural programs requires estimating the gradients of black-box components. We present an algorithm for learning neural programs, called ISED, that only relies on input-output samples of black-box components. For evaluation, we introduce new benchmarks that involve calls to modern LLMs such as GPT-4 and also consider benchmarks from the neurosymbolic learning literature. Our evaluation shows that for the latter benchmarks, ISED has comparable performance to state-of-the-art neurosymbolic frameworks. For the former, we use adaptations of prior work on gradient approximations of black-box components as a baseline, and show that ISED achieves comparable accuracy but in a more data- and sample-efficient manner. 1 ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Many computational tasks cannot be solved by neural perception alone but can be naturally expressed as a composition of a neural model $M_{\\theta}$ followed by a program $P$ written in a traditional programming language or an API call to a large language model (LLM). We call such composites \u201cneural programs\u201d and study the problem of learning neural programs in an end-to-end manner with a focus on data and sample efficiency. One problem that is naturally expressed as a neural program is scene recognition [29], where $M_{\\theta}$ classifies objects in an image and $P$ prompts GPT-4 to identify the room type given these objects (Fig. 1). ", "page_idx": 0}, {"type": "text", "text": "Neurosymbolic learning [2] is one instance of neural program learning in which $P$ takes the form of a logic program. DeepProbLog (DPL) [14] and Scallop [13] are frameworks that extend ProbLog and Datalog, respectively, to ensure that the symbolic component $P$ is differentiable. This differentiability requirement is what facilitates learning in many neurosymbolic learning frameworks. There are also abductive learning frameworks that do not explicitly differentiate programs. Instead, they require that the symbolic component expose a method for abducing the function\u2019s inputs for a given output, often using Prolog for the symbolic component as a result [6, 23]. While logic programming languages are expressive enough for these frameworks to solve tasks such as sorting [14], visual question answering [13], and path planning [23], they offer restricted features and a narrow range of libraries, making them incompatible with calls to arbitrary APIs or to modern LLMs. ", "page_idx": 0}, {"type": "text", "text": "Learning neural programs when $P$ is not expressed as a logic program is a difficult problem because gradients across black-box programs cannot be computed explicitly. One possible solution is to use REINFORCE [26] to sample symbols from distributions predicted by $M_{\\theta}$ and compute the expected reward using the output label. However, REINFORCE is not sample-efficient as it produces a weak learning signal, especially when applied to programs with a large number of inputs. There are other REINFORCE-based methods that can be applied to the neural program learning setting, namely IndeCateR [21] and Neural Attention for Symbolic Reasoning (NASR) [5]. However, IndeCateR struggles with sample efficiency despite providing lower variance than REINFORCE, and NASR performs poorly when intermediate labels are unavailable for pretraining. Another possible solution is Approximate Neurosymbolic Inference (A-NeSI) [24], which trains a neural network to estimate the gradient of $P$ , but learning the surrogate neural network becomes more difficult as the complexity of $P$ increases. Moreover, the additional neural models in the learning framework in A-NeSI results in data inefficiency. ", "page_idx": 0}, {"type": "image", "img_path": "QXQY58xU25/tmp/62431cea95cb720affbc1ba93010884db2399434141e1f6d0309f0a09b02320b.jpg", "img_caption": ["Figure 1: Neural program decomposition for scene recognition. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "In this paper, we propose an algorithm for learning neural programs, based on reinforcement learning, which is compatible with arbitrary programs. Our approach, called ISED (Infer-Sample-EstimateDescend), yields a framework that expands the applicability of neural program learning frameworks by providing a data- and sample-efficient method of training neural models with randomly initialized weights. ISED uses outputs of $M_{\\theta}$ as a probability distribution over inputs of $P$ and samples representative symbols $u$ from this distribution. ISED then computes outputs $v$ of $P$ corresponding to these symbols. The resulting symbol-output pairs can be viewed as a symbolic program consisting of clauses of the form if $\\mathbf{symbol}\\;=\\;u$ then output $\\mathbf{\\mu}=\\mathbf{\\mu}v$ summarizing $P$ . The final step is to estimate the gradient across this symbolic summary, inspired by ideas from the neurosymbolic learning literature, to propagate loss across the composite model. ", "page_idx": 1}, {"type": "text", "text": "Our evaluation considers 16 neural program benchmark tasks. Our results show that ISED outperforms purely neural networks and CLIP [19] on neural program tasks involving GPT-4 calls. Additionally, ISED outperforms neurosymbolic methods on 9 of the 14 benchmarks tasks that can be encoded in logic programming languages. ISED is also the top performer on 8 out of the 16 benchmark tasks when compared to REINFORCE-based and black-box gradient estimation baselines. Furthermore, we show that ISED is more data- and sample-efficient than baseline methods. ", "page_idx": 1}, {"type": "text", "text": "In summary, the main contributions of this paper are as follows: 1) we introduce neural programs as a generalization of neurosymbolic programs, 2) we introduce new tasks involving neural programs that use Python and calls to GPT-4 called neuroPython and neuroGPT programs, respectively, 3) we present ISED, a general algorithm for data- and sample-efficient learning with neural programs, and 4) we conduct a thorough evaluation using existing techniques against a diverse set of benchmarks. ", "page_idx": 1}, {"type": "text", "text": "2 Neural Programs ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Problem Statement. In the neural program learning setting, we attempt to optimize model parameters $M_{\\theta}$ which are being supervised by a fixed program $P$ . Specifically, we are given a training dataset $\\mathcal{D}$ of length $N$ containing input-output pairs, i.e., $\\mathcal{D}=\\{(\\bar{x}_{1},y_{1}),\\dot{.}\\cdot(x_{N},y_{N})\\}$ . Each $x_{i}$ represents unstructured data (e.g., image data) whose corresponding structured data (intermediate labels) are not given. Each $y_{i}$ is the result of applying $P$ to the structured data corresponding to $x_{i}$ . Given a loss function $\\mathcal{L}$ , we want to minimize the loss of $\\mathcal{L}(P(M_{\\theta}(x_{i})),y_{i})$ for each $(x_{i},y_{i})$ pair in order to optimize $\\theta$ . Loss minimization is straightforward when there is some mechanism for automatically differentiating programs, but we focus on the setting of optimizing $\\theta$ without assuming the differentiability of $P$ . We now introduce three motivating applications that can be framed in this setting, namely classifying images of leaves [9], scene recognition [29], and hand-written formula evaluation (HWF) [12]. ", "page_idx": 1}, {"type": "image", "img_path": "QXQY58xU25/tmp/bd3256951e380f3043277c2d755001e36f5fc9bbe8a0b51d4d7a170b900c76aa.jpg", "img_caption": ["Figure 2: Illustration of our inference pipeline for the leaf classification task. leaf_id can be written with a decision tree (top program) or with a call to GPT-4 (bottom program). "], "img_footnote": [], "page_idx": 2}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "Leaf Classification. We consider a real-world example that deals with the problem of classifying leaf images. Traditional neural methods predict the species directly, without explicit notion of leaf features such as margin, shape, and texture, resulting in solutions that are data-inefficient, inaccurate, and harder to understand. ", "page_idx": 2}, {"type": "text", "text": "We instead present a neural programming solution, making use of leaf classification decision trees [22]. These decision trees allow identifying plant species based on the visible characteristics of their leaves. Here, the neural model takes a leaf image and predicts its shape, margin, and texture. The program can then be written in two ways: one implementation involves encoding the decision tree in Python; another involves constructing a prompt using the predicted leaf features and calling GPT-4 (see Fig. 2). The latter is possible because ISED allows the use of black-box programs, so programs can also use state-of-the-art foundation models such as GPT-4 for computation. ", "page_idx": 2}, {"type": "text", "text": "Scene Recognition. The goal of this task is to classify images according to their room types. The model receives an image from a scene dataset [16] and predicts among the 9 different room types: bedroom, bathroom, dining room, living room, kitchen, lab, office, house lobby, and basement. ", "page_idx": 2}, {"type": "text", "text": "The traditional neural solution trains a convolutional neural network that directly predicts the room type. On the other hand, the neural program solution decomposes the task into detecting objects in the scene and identifying the room type based on those objects. We use an off-the-shelf object detection model YOLOv8 [20] and finetune it with a custom convolutional neural network to output labels related to scene recognition. We then make a GPT-4 call to predict the most likely room type given the list of detected objects. ", "page_idx": 2}, {"type": "text", "text": "Hand-written Formula. In this task, a model is given a list of hand-written symbols containing digits (0-9) and operators $(+,-,\\times$ , and $\\div$ ) [12]. The dataset contains length 1-7 formulas free of syntax or divide-by-zero errors. The model is trained with supervision on the evaluated floating-point result without the label of each symbol. Since inputs are combinatorial and results are rational numbers, end-to-end neural methods struggle with accuracy. Meanwhile, neurosymbolic methods for this task either use specialized algorithms [12] or handcrafted differentiable programs [13]. ", "page_idx": 2}, {"type": "text", "text": "With ISED, the program can be written in just a few lines of Python. It takes in a list of characters representing symbols, and simply invokes the Python eval function on the joined expression string. The hwf evaluation function can be used just like any other PyTorch [17] module since ISED internally performs sampling and probability estimation to estimate the gradient. ", "page_idx": 2}, {"type": "text", "text": "3 Learning Neural Programs ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this section, we present the intuition behind ISED and the values it approximates. Next, we introduce the programming interface for ISED, which lays the groundwork for presenting the algorithm. We then formally describe the steps of ISED. ", "page_idx": 2}, {"type": "text", "text": "Assuming $P$ is a black-box, we can collect symbol-output samples $(u,v)$ from $P$ . Such collection of samples can be viewed as a summary logic program consisting of rules of the form if $r=u$ then $y=v$ . For instance, in the task of adding two digits $r_{1}$ and $r_{2}$ , one rule of the logic program would be $r_{1}=1\\wedge r_{2}=2\\to y=3$ . Techniques from neurosymbolic literature via exact or approximate weighted model counting (WMC) [10] can then be used for computing the gradient across such a summary of $P$ . However, having the complete summary of all combinations of symbols is not feasible for a black-box $P$ . ISED samples symbols from the probability distribution predicted by the neural network $M_{\\theta}$ , evaluates $P$ on each sample, and takes the gradient across this partial summary of $P$ . This is a good approximation of the complete summary since it is likely to contain symbols with high probability, which contribute the most in exact computation. ", "page_idx": 3}, {"type": "text", "text": "This approach differs from REINFORCE in how it differentiates through this summary of $P$ . REINFORCE rewards sampled symbols that resulted in the correct output through optimizing the log probability of each symbol, weighted by reward values. This weighted-sum style estimation provides a weaker learning signal compared to WMC used by ISED, making learning harder for REINFORCE as the number of inputs to $P$ increases. See Appendix A for further details. ", "page_idx": 3}, {"type": "text", "text": "3.2 Preliminaries and Programming Interface ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "ISED allows programmers to write black-box programs that operate on diverse structured inputs and outputs. To allow such programs to interact with neural networks, we define an interface named structural mapping. This interface serves to 1) define the data-types of black-box programs\u2019 input and output, 2) marshall and un-marshall data between neural networks and logical black-box functions, and 3) define the loss. We define a structural mapping $\\tau$ as either a discrete mapping (with $\\Sigma$ being the set of all possible elements), a floating point, a permutation mapping with $n$ possible elements, a tuple of mappings, or a list of up to $n$ elements. We define $\\tau$ inductively as follows: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\tau:=\\mathrm{DISCRETE}(\\Sigma)\\mid\\mathrm{FLOAT}\\mid\\mathrm{PERMUTATION}_{n}\\mid\\mathrm{TUPLE}(\\tau_{1},\\dots,\\tau_{m})\\mid\\mathrm{LIST}_{n}(\\tau)\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Using this, we may further define data-types such as $\\begin{array}{r}{\\operatorname{INTEGER}_{j}^{k}=\\operatorname{DISCRETE}\\!\\left(\\left\\{j,\\cdot\\,.\\cdot,k\\right\\}\\right)}\\end{array}$ , $\\mathrm{DIGIT}=$ INTEGER $\\mathbf{\\Delta}_{0}^{9}$ , and $\\mathrm{BooL}\\,=\\,\\mathrm{DISCRETE}\\big(\\{\\mathrm{true,false}\\}\\big)$ . These types give ISED the flexibility learn neural programs with diverse types of inputs and outputs, e.g., PERMUTAT $\\mathrm{[ON}_{n}$ input and output types for integer list sorting and $\\mathrm{LIST_{9}}\\big(\\mathrm{LIST_{9}}\\big(\\mathrm{DIGIT}\\big)\\big)$ for sudoku solving. ", "page_idx": 3}, {"type": "text", "text": "We also define a black-box program $P$ as a function $(\\tau_{1},\\dots,\\tau_{m})\\rightarrow\\tau_{o}$ , where $\\tau_{1},\\dots,\\tau_{m}$ are the input types and $\\tau_{o}$ is the output type. For example, the structural input mapping for the hand-written formula task is ${\\tt L I S T}_{7}\\big({\\tt D I S C R E T E}\\big(\\{0,\\dots,9,+,-,\\times,\\dot{\\div}\\}\\big)\\big)$ ), and the structural output mapping is FLOAT. The mappings suggest that the program takes a list of length up to 7 as input, where each element is a digit or an arithmetic operator, and returns a floating point number. ", "page_idx": 3}, {"type": "text", "text": "There are two interpretations of a structural mapping: the set interpretation $\\operatorname{SET}(\\tau)$ represents a mapping with defined values, e.g., a digit with value 8; the tensor interpretation $\\mathrm{DIST}(\\tau)$ represents a mapping where each value is associated with a probability distribution, e.g., a digit that is 1 with probability 0.6 and 7 with probability 0.4. We use the set interpretation to represent structured program inputs that can be passed to a black-box program and the tensor interpretation to represent probability distributions for unstructured data and program outputs. These two interpretations are defined for the different structural mappings in Table 1. ", "page_idx": 3}, {"type": "table", "img_path": "QXQY58xU25/tmp/0b6806c2e779d7ccde66fe4b78e535072794bb4c12e502f2338d117d5ec335cc.jpg", "table_caption": ["Table 1: Set and tensor interpretations of different structural mappings. "], "table_footnote": [], "page_idx": 3}, {"type": "text", "text": "In order to represent the ground truth output as a distribution to be used in the loss computation, there needs to be a mechanism for transforming $\\operatorname{SET}(\\tau)$ mappings into $\\mathrm{DIST}(\\tau)$ mappings. For this purpose, we define a vectorize function $\\delta_{\\tau}:(\\mathrm{SET}(\\tau),2^{\\tau})\\rightarrow\\mathrm{DIST}(\\tau)$ for the different output mappings $\\tau$ in Table 2. When considering a datapoint $(x,y)$ during training, ISED samples many symbols and obtains a list of outputs $\\hat{y}$ . The vectorizer then takes the ground truth $y$ and the outputs $\\hat{y}$ as input and returns the equivalent distribution interpretation of $y$ . While $\\hat{y}$ is not used by $\\delta_{\\tau}$ in most cases, we include it as an argument so that FLOAT output mappings can be discretized, which is necessary for vectorization. For example, if the inputs to the vectorizer for the hand-written formula task are $y=2.0$ and $\\hat{y}=[1.0,3.5,2.\\bar{0},8.0]$ , then it would return $[0,0,1,0]$ . ", "page_idx": 3}, {"type": "text", "text": "", "page_idx": 4}, {"type": "table", "img_path": "QXQY58xU25/tmp/b578ede6a4d5ae4b7722e616184925cbcceb8a1a49e43cc4bf3ff035e25dfc09.jpg", "table_caption": ["Table 2: Vectorize and aggregate functions of different structural mappings. "], "table_footnote": [], "page_idx": 4}, {"type": "text", "text": "We also require a mechanism to aggregate the probabilities of sampled symbols that resulted in a particular output. With this aim, we define an aggregate function $\\bar{\\sigma_{\\tau}}:(\\bar{\\mathrm{SET}}(\\tau),\\mathrm{DIST}(\\tau))\\rightarrow\\mathbb{R}$ for different input mappings $\\tau$ in Table 2. ISED aggregates probabilities either by taking their minimum or their product, and we denote both operations by $\\otimes$ . The aggregator takes as input sampled symbols $\\hat{r}$ and neural predictions $\\hat{p}$ from which $\\hat{r}$ was sampled. It gathers values in $\\hat{p}$ at each index in $\\hat{r}$ and returns the result of $\\otimes$ applied to these values. For example, suppose we use min as the aggregator $\\otimes$ for the hand-written formula task. Then if $\\otimes$ takes $\\hat{r}=[1,+,1]$ and $\\hat{p}$ as inputs where $\\hat{p}[0][1]=0.1$ , $\\hat{p}[1][+]=0.05$ , and $\\hat{p}[2][1]=0.1$ , it would return 0.05. ", "page_idx": 4}, {"type": "text", "text": "3.3 Algorithm ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "We now formally present the ISED algorithm. For a given task, there is a black-box program $P$ , taking $m$ inputs, that operates on structured data. Let $\\tau_{1},...,\\tau_{m}$ be the mappings for these inputs and $\\tau_{o}$ the mapping for the program\u2019s output. We write $P$ as a function from its input mappings to its output mapping: $P:{\\bar{(\\tau_{1},...,\\tau_{m})}}\\rightarrow{\\bar{\\tau_{o}}}$ . For each unstructured input $i$ to the program, there is a neural model $M_{\\theta_{i}}^{i}:x_{i}\\rightarrow\\mathrm{DIST}(\\tau_{i})$ . $S$ is a sampling strategy (e.g., categorical sampling) that samples symbols using the outputs of a neural model, and $k$ is the number of samples to take for each training example. There is also a loss function $\\mathcal{L}$ whose first and second arguments are the predicted and ground truth values respectively. We present the pseudocode of the algorithm in Algorithm 1 and describe its steps with the hand-written formula task: ", "page_idx": 4}, {"type": "text", "text": "Infer. The training pipeline starts with an example from the dataset, $(x,y)=([\\div,\\dot{+},\\dot{2}],3.0)$ , and uses a CNN to predict these images, as shown on lines 3-4. ISED initializes $\\hat{p}=M_{\\theta}(x)$ . ", "page_idx": 4}, {"type": "text", "text": "Sample. ISED samples $\\hat{r}$ from $\\hat{p}$ for $k$ iterations using sampling strategy $S$ . For each sample $j$ , the algorithm initializes $\\hat{r}_{j}$ to be the sampled symbols, as shown on lines 6-9. To continue our example, suppose ISED initializes $\\hat{r}_{j}=[7,+,2]$ for sample $j$ . The next step is to execute the program on $\\hat{r}_{j}$ , as shown on line 10, which in this example means setting $\\hat{y}_{j}=P\\bar{(r}_{j})=9.0$ . ", "page_idx": 4}, {"type": "text", "text": "Estimate. In order to compute the prediction value to use in the loss function, ISED must consider each output $y_{l}$ in the output mapping and accumulate the aggregated probabilities for all sampled symbols that resulted in the output $y_{l}$ . We specify $\\otimes$ as the min function, and $\\oplus$ as the max function in this example. Note that ISED requires that $\\otimes$ and $\\oplus$ represent either min and max or mult and add respectively. We refer to these two options as the min-max and add-mult semirings. We define an accumulate function $\\omega$ that takes as input an element of the output mapping $y_{l}$ , sampled outputs $\\hat{y}$ , sampled symbols $\\hat{r}$ , and predicted input distributions $\\hat{p}$ . The accumulator performs the $\\oplus$ operation on aggregated probabilities for elements of $\\hat{y}$ that are equal to $y_{l}$ and is defined as follows: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\omega(y_{l},\\hat{y},\\hat{r},\\hat{p})=\\oplus_{j=1}^{k}\\mathbf{1}_{\\hat{y}_{j}=y_{l}}\\sigma_{\\tau_{o}}(\\hat{r}_{j},\\hat{p}_{j})\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Continuing our example, suppose, among the samples, there are two symbolic combinations $([7,+,2]$ and $[3,*,3],$ ) that resulted in the output 9.0. Let us say that these sets of symbols had probabilities [0.3, 0.8, 0.8] and $[0.1,0.1,0.1]$ , respectively. Then the result of the probability aggregation for $y_{l}=9.0$ would be $\\dot{\\omega}(9.0,\\hat{y},\\hat{r},\\hat{\\bar{p}})=\\bar{\\mathfrak{m a x}}(\\mathtt{m i n}([0.3,0.8,0.8]),\\mathtt{m i n}([0.1,\\bar{0}.1,0.1]))\\overset{\\cdot}{=}\\bar{0}.3$ . ", "page_idx": 4}, {"type": "text", "text": "Require: $P$ is the black-box program $\\left(\\tau_{1},\\ldots,\\tau_{m}\\right)\\rightarrow\\tau_{o},$ $M_{\\theta_{i}}^{i}$ the neural model $x_{i}\\to\\mathrm{DIST}(\\tau_{i})$ for   \neach $\\tau_{i}$ , $S$ the sampling strategy, $k$ the sample count, $\\mathcal{L}$ the loss function, and $\\mathcal{D}$ the dataset.   \n1: procedure TRAIN   \n2: for $((x_{1},\\hdots x_{m}),y)\\in\\mathcal{D}$ do   \n3: for $i\\in1\\ldots m$ do   \n4: $\\hat{p}[i]\\leftarrow M_{\\theta_{i}}^{i}(x_{i})$ \u25b7Infer   \n5: end for   \n6: for $j\\in{1\\dots k}$ do   \n7: for $i\\in1\\ldots m$ do   \n8: Sample $\\hat{r}_{j}[i]$ from $\\hat{p}[i]$ using $S$ \u25b7Sample   \n9: end for   \n10: $\\hat{y}_{j}\\gets P(\\hat{r}_{j})$   \n11: end for   \n12: w\u02c6 \u2190normalize([\u03c9(yl, y\u02c6, r\u02c6, p\u02c6) for $y_{l}\\in\\tau_{o}$ (or yl \u2208y\u02c6)]) \u25b7Estimate   \n13: w \u2190\u03b4(y, y\u02c6)   \n14: $l\\gets\\mathcal{L}(\\hat{w},w)$   \n15: Compute $\\frac{\\partial l}{\\partial\\theta}$ by performing back-propagation on $l$   \n16: Optimize \u03b8 based on \u2202\u2202\u03b8l \u25b7Descend   \n17: end for   \n18: end procedure ", "page_idx": 5}, {"type": "text", "text": "ISED then sets $\\tilde{w}=[\\omega(y_{l},\\hat{y},\\hat{r},\\hat{p})$ for $y_{l}\\in\\tau_{o}]$ in the case where $\\tau_{o}$ is not FLOAT. When $\\tau_{o}$ is FLOAT, as for hand-written formula, it only considers $y_{l}\\in\\hat{y}$ . Next, it performs $L_{2}$ normalization over each element in $\\tilde{w}$ and sets $\\hat{w}$ to this result. To initialize the ground truth vector, it sets $w=\\delta(y,\\hat{y})$ . ISED then initializes l = L( w\u02c6, w) and computes\u2202\u2202\u03b8li for each input $i$ . These steps are shown on lines 12-15. In our running example, since 9.0 is an incorrect output, the probability of the first symbol being equal to 7 (instead of the correct answer 1) will be penalized while the probabilities for predicting other symbols are unchanged. ", "page_idx": 5}, {"type": "text", "text": "Descend. The last step is shown on line 16, where the algorithm optimizes $\\theta_{i}$ for each input $i$ based on\u2202\u03b8i $\\frac{\\partial l}{\\partial\\theta_{i}}$ using a stochastic optimizer (e.g., Adam optimizer). This completes the training pipeline for one example, and the algorithm returns all final $\\theta_{i}$ after iterating through the entire dataset. ", "page_idx": 5}, {"type": "text", "text": "4 Evaluation ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "In this section, we evaluate ISED and aim to answer the following research questions: ", "page_idx": 5}, {"type": "text", "text": "RQ1: How does ISED compare to state-of-the-art neurosymbolic, REINFORCE-based, and gradient estimation baselines in terms of accuracy? ", "page_idx": 5}, {"type": "text", "text": "RQ2: What is the sample efficiency of ISED when compared to REINFORCE-based algorithms? RQ3: How data-efficient is ISED compared to neural gradient estimation methods? ", "page_idx": 5}, {"type": "text", "text": "4.1 Benchmark Tasks: NeuroGPT, NeuroPython, and Neurosymbolic ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "We first introduce two new neural program learning benchmarks which both contain a program component that can make a call to GPT-4. We call such models neuroGPT programs. ", "page_idx": 5}, {"type": "text", "text": "Leaf Classification. In this task, we use a dataset, which we call LEAF-ID, containing leaf images of 11 different plant species [4], containing 330 training samples and 110 testing samples. We define custom DISCRETE types MARGIN, SHAPE, TEXTURE. With this, we define LEAF-TRAITS $=$ TUPLE(MARGIN, SHAPE, TEXTURE) and LEAF-OUTPUT to be the DISCRETE set of 11 plant species in the dataset. Neural program solutions either prompt GPT-4 (GPT leaf) or use a decision tree (DT leaf). ", "page_idx": 5}, {"type": "text", "text": "Scene Recognition. We use a dataset containing scene images from 9 different room types [16], consisting of 830 training examples and 92 testing examples. We define custom types OBJECTS and SCENES to be DISCRETE set of 45 objects and 9 room types, respectively. We freeze the parameters of YOLOv8 and only optimize the custom neural network. The neural program solution prompts GPT-4 to classify the scene. ", "page_idx": 5}, {"type": "table", "img_path": "QXQY58xU25/tmp/8af4b3f68f72d09c166776c3261c7358d1d5063f592d05a0e85bffdf6b231e53.jpg", "table_caption": ["Table 3: Performance on selected benchmarks. \"TO\" means time-out, and \"N/A\" means the task could not be programmed in the framework. Methods are divided (from top to bottom) by neurosymbolic, black-box gradient estimation, and REINFORCE-based. "], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "We also consider several tasks from the neurosymbolic literature, including hand-written formula (HWF) evaluation and Sudoku solving. While the solutions to many of these tasks are usually presented as a logic program in neurosymbolic learning frameworks, neural program solutions can take the form of Python programs. We call such models neuroPython programs. ", "page_idx": 6}, {"type": "text", "text": "MNIST-R. MNIST-R [13, 14] contains 11 tasks operating on inputs of images of handwritten digits from the MNIST dataset [11]. This synthetic test suite includes tasks performing arithmetic $\\mathrm{(sum_{2}}$ , $\\mathrm{{Sum}_{3}}$ , $\\mathrm{sum}_{4}$ , $\\mathrm{\\mult_{2}}$ , $\\mod_{2}$ , add-mod-3, add-sub), comparison (less-than, equal), counting (count-3-or4), and negation (not-3-or-4) over the digits depicted in the images. Each task dataset has a training set of 5K samples and a testing set of 500 samples. ", "page_idx": 6}, {"type": "text", "text": "HWF. The goal of the HWF task is to classify images of handwritten digits and arithmetic operators and evaluate the formula [12]. The dataset contains 10K formulas of length 1-7, with 1K length 1 formulas, 1K length 3 formulas, 2K length 5 formulas, and 6K length 7 formulas. ", "page_idx": 6}, {"type": "text", "text": "Visual Sudoku. The goal of this task is to solve an incomplete $9\\mathrm{x9}$ Sudoku, where the problem board is given as MNIST digits. We follow the experimental setting of NASR [5], including their pre-trained MNIST digit recognition models and sudoku solvers. We use the SatNet dataset consisting of 9K training samples and 500 test samples [25]. ", "page_idx": 6}, {"type": "text", "text": "4.2 Evaluation Setup and Baselines ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "All of our experiments were conducted on a machine with two 20-core Intel Xeon CPUs, one NVIDIA RTX 2080 Ti GPU, and 755 GB RAM. Unless otherwise noted, the sample count, i.e., the number of calls to the program $P$ per training example, is fixed at 100 for all relevant methods. For additional details on experimental setup, see Appendix B. We apply a timeout of 10 seconds per testing sample, and report the average accuracy and 1-sigma standard deviation obtained from 10 randomized runs. ", "page_idx": 6}, {"type": "text", "text": "We pick as baselines neurosymbolic methods DeepProbLog (DPL) [14] and Scallop [13], A-NeSI [24] which performs neural approximation of the gradients, and sampling-based gradient approximation methods REINFORCE [26], IndeCateR [21], and NASR [5]. IndeCateR achieves provably lower variance than REINFORCE by using a specialized sampling method (Appendix A), and NASR is a variant specialized for efficient finetuning by using a single sample and a custom reward function. We also use purely neural baselines and CLIP [19] for GPT leaf and scene. CLIP is a multimodal model that supports zero-shot image classification by simply providing names of the output categories. ", "page_idx": 6}, {"type": "text", "text": "4.3 RQ1: Performance and Accuracy ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "To answer RQ1, we evaluate ISED\u2019s accuracy against those of the baselines. ISED matches, and in many cases surpasses, the accuracy of neurosymbolic and gradient estimation baselines. We highlight the results for $\\mathrm{sum}_{n}$ from MNIST-R and other benchmarks in Table 3. Tables 7-10 in Appendix C contain results for the remaining MNIST-R tasks, including standard deviations for all tasks. ISED is the top performer on 8 out of the 16 total tasks. ", "page_idx": 6}, {"type": "table", "img_path": "QXQY58xU25/tmp/8776bc4ccbf7c685511798668603c6dcac1f6b15186f7f0ff720a7e0c8195474.jpg", "table_caption": ["Table 4: Performance comparisons for $\\mathrm{sum}_{8}$ , $\\mathrm{sum}_{12}$ , and $\\mathrm{sum}_{16}$ with different sample counts $k$ . "], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "", "page_idx": 7}, {"type": "text", "text": "On the GPT leaf and scene tasks, ISED outperforms the purely neural baseline by $3.82\\%$ and $31.42\\%$ respectively, and zero-shot CLIP by $59.\\bar{8}0\\%$ and $17.\\bar{5}0\\%$ . For many tasks, A-NeSI is the nonneurosymbolic method that comes closest to ISED, sometimes outperforming our method. However, A-NeSI achieves significantly lower performance than ISED on tasks involving complex programs, namely HWF and sudoku. This is likely due to the difficulty of training a neural model to estimate the output of $P$ and its gradient when $P$ is complex. ISED also outperforms REINFORCE on all but 3 tasks due to the REINFORCE learning signal being weaker for tasks where $P$ involves multiple inputs. NASR outperforms ISED only on sudoku by $2.46\\%$ due to NASR being well-suited for fine-tuning as it restricts its algorithm to use a single sample. IndeCateR achieves similar performance compared to ISED on most tasks but achieves significantly lower accuracy on the scene classification task, which has a large input space with maximum 10 objects each with 47 possible values in each scene, demonstrating that IndeCateR is less sample-efficient than ISED. We elaborate more on this point in RQ2. ", "page_idx": 7}, {"type": "text", "text": "ISED outperforms the neurosymbolic methods on 9 out of 14 tasks that can be written in logic programming languages. Despite treating $P$ as a black-box, ISED even outperforms Scallop on HWF by $\\bar{0}.69\\%$ and comes within $\\bar{1}.16\\%$ of NGS, a specialized neurosymbolic learning framework that uses abductive reasoning [12]. Furthermore, DPL timed out on 4 tasks, and Scallop timed out on 1 (sudoku). These results demonstrate that even for tasks that can be written in a logic programming language, treating the program as a black-box can often yield optimal results. ", "page_idx": 7}, {"type": "text", "text": "4.4 RQ2: Sample Efficiency ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "To answer RQ2, we evaluate the sample efficiency of ISED against REINFORCE, IndeCateR, and IndeCateR $^{+}$ on adding MNIST digits. IndeCateR $^{+}$ [21] is a variant of IndeCateR with a sampling method and loss computation customized for higher dimensional setting such as the addition of 16 MNIST digits. We vary the size of the input and output space $\\mathrm{{\\dot{sum}}_{8}}$ , $\\mathrm{sum}_{12}$ , $\\mathrm{sum}_{16}$ ) of $P$ as well as the sample count, and report the average accuracy and standard deviation obtained from 5 randomized runs (Tables 4, 11-13). ", "page_idx": 7}, {"type": "text", "text": "For a lower number of samples, ISED outperforms all other methods on the three tasks, outperforming IndeCateR by over $80\\%$ on $\\mathrm{sum}_{8}$ and $\\mathrm{{sum}_{12}}$ . The experimental findings support the conceptual difference of REINFORCE-based methods providing a weak learning signal compared to ISED (Section 3.1). While ISED achieves accuracy similar to the top performer for $\\mathrm{sum}_{8}$ and $\\mathrm{{sum}_{12}}$ with a high sample count, it comes second on $\\mathrm{sum}_{16}$ with IndeCateR $^{+}$ beating ISED by $75.39\\%$ . This suggests our approach is limited in scaling to high-dimensional inputs to $P$ , and motivates exploring better sampling techniques, which is the core difference between IndeCateR and IndeCateR $^{+}$ . ", "page_idx": 7}, {"type": "text", "text": "4.5 RQ3: Data Efficiency ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "We now examine how ISED compares to state-of-the-art baselines in terms of data efficiency. We compare ISED and A-NeSI in terms of training time and accuracy on $\\mathrm{sum_{3}}$ and $\\mathrm{sum_{4}}$ . We choose these tasks for evaluation because A-NeSI has been shown to scale well to multi-digit addition tasks [24]. Furthermore, these tasks come from the MNIST-R suite in which we use 5K training samples, which is less than what A-NeSI would have used in its evaluation (20K training samples for $\\mathrm{sum_{3}}$ and 15K for $\\mathrm{sum}_{4}$ ). We plot the average test accuracy and standard deviation vs. training time (over 10 runs) in Figures 3 and 4, where each point represents the result of 1 epoch. ", "page_idx": 7}, {"type": "image", "img_path": "QXQY58xU25/tmp/4d6765439160b7397550b2fa93e72eb65d71aa02f507ef1daa92964a7ef63d7d.jpg", "img_caption": ["Figure 3: Accuracy vs. Time for $\\mathrm{sum_{3}}$ . "], "img_footnote": [], "page_idx": 8}, {"type": "image", "img_path": "QXQY58xU25/tmp/9d29a3d06eb03c3490cbb0cb46003168a19a45c679b6b3ba69e023d0cf8218ab.jpg", "img_caption": ["Figure 4: Accuracy vs. Time for $\\mathrm{sum}_{4}$ . "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "While ISED and A-NeSI learn at about the same rate for $\\mathrm{{sum}_{3}}$ after about 5 minutes of training, ISED learns at a much faster rate for the first 5 minutes, reaching an accuracy of $88.22\\%$ after just 2 epochs (Fig. 3). The difference between ISED and A-NeSI is more pronounced for $\\mathrm{sum}_{4}$ , with ISED reaching an accuracy of $94.10\\%$ after just 10 epochs while A-NeSI reaches $49.51\\%$ accuracy at the end of its 23rd epoch (Fig. 4). These results demonstrate that with limited training data, ISED is able to learn more quickly than A-NeSI, even for simple tasks. This result is likely due to A-NeSI training 2 additional neural models in its learning pipeline compared to ISED, with A-NeSI training a prior as well as a model to estimate the program output and gradient. ", "page_idx": 8}, {"type": "text", "text": "5 Limitations and Future Work ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "The main limitation of ISED is the difficulty of scaling with the dimensionality of the space of inputs to the program $P$ . There are interesting future directions in adapting and expanding ISED for high dimensionality. Specifically, improvements to the sampling strategy could help adapt ISED to a complex space of inputs. Techniques can be borrowed from the field of Bayesian optimization where such large spaces have traditionally been studied. Furthermore, there is merit to systematically combining white-box and black-box methods. ISED is especially useful when logic programs fail to encode reasoning components. Therefore, we believe that ISED can be used as an underlying engine for a new neurosymbolic language that blends the accessibility of black-box with the performance of white-box methods. ", "page_idx": 8}, {"type": "text", "text": "6 Related Work ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "Neurosymbolic programming frameworks. These frameworks provide a general mechanism to define white-box neurosymbolic programs. DeepProbLog [14] and Scallop [13] abstract away gradient calculations behind a rule-based language. Others specialize in targeted applications, such as NeurASP [28] for answer set programming, or NeuralLog [3] for phrase alignment in NLP. ISED is similar in that it seeks to make classes of neurosymbolic programs easier to write and access; however, it diverges by offering an interface not bound by any specific domain or language syntax. ", "page_idx": 8}, {"type": "text", "text": "RL and sampling-based neurosymbolic frameworks. ISED incorporates concepts found in the RL algorithm REINFORCE [26] such as the sampling of actions according to the current policy distribution, similar to NASR [5], and IndeCateR [21]. Other work has proposed a semantic loss function for neurosymbolic learning which measures how well neural network outputs match a given constraint [27]. While this technique resembles ISED in that it samples symbols from their predicted distributions to derive the loss, it relies on symbolic knowledge in the form of a constraint in Boolean logic, whereas ISED allows the program component to be any black-box program. ", "page_idx": 8}, {"type": "text", "text": "Specialized neurosymbolic methods. The majority of the neurosymbolic learning literature pertains to point solutions for specific use cases [7, 25]. In the HWF example, NGS [12] and several of its variants leverage a hand-defined syntax defining the inherent structure within mathematical expressions. Similarly, DiffSort [18] leverages the symbolic properties of sorting to produce differentiable sorting networks. Other point solutions address broader problem setups, such as NS-CL [15] which provides a framework for visual question answering by learning symbolic representations in text and images. For reading comprehension, the NeRd [3] framework converts NL questions into executable programs over symbolic information extracted from text. ISED aligns with all of these point solutions by aiming to solve problems that have thus far required technically specific solutions in order to access the advantages of neurosymbolic learning, but it takes an opposite and easier approach by forgoing significant specializations and instead leverages existing solutions as black-boxes. ", "page_idx": 8}, {"type": "text", "text": "", "page_idx": 9}, {"type": "text", "text": "Differentiable programming and non-differentiable optimization. Longstanding libraries in deep learning have grown to great popularity for their ability to abstract away automatic differentiation behind easy-to-use interfaces. PyTorch [17] is able to do so by keeping track of a dynamic computational graph. Similarly, JAX [1] leverages functional programming to abstract automatic differentiation. ISED follows the style of these frameworks by offering an interface to abstract away gradient calculations for algorithms used in deep learning, but ISED improves upon them by allowing systematic compatibility of non-differentiable functions. ", "page_idx": 9}, {"type": "text", "text": "7 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We proposed ISED, a data- and sample-efficient algorithm for learning neural programs. Unlike existing general neurosymbolic frameworks which require differentiable logic programs, ISED is compatible with Python programs and API calls to GPT, and it employs a sampling-based technique to learn neural model parameters using forward evaluation. We showed that for neuroGPT, neuroPython, and neurosymbolic benchmarks, ISED achieves better accuracy than end-to-end neural models and similar accuracy compared to neurosymbolic frameworks. ISED also often achieves superior accuracy on complex programs compared to REINFORCE-based and gradient estimation baselines. Furthermore, ISED learns in a more data- and sample-efficient manner compared to these baselines. ", "page_idx": 9}, {"type": "text", "text": "8 Acknowledgements ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We thank the anonymous reviewers for useful feedback. This research was supported by ARPA-H grant D24AC00253-00, NSF award CCF 2313010, and by a gift from AWS AI to ASSET (Penn Engineering Center on Trustworthy AI). ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] James Bradbury, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary, Dougal Maclaurin, George Necula, Adam Paszke, Jake VanderPlas, Skye Wanderman-Milne, and Qiao Zhang. JAX: composable transformations of Python+NumPy programs, 2018.   \n[2] Swarat Chaudhuri, Kevin Ellis, Oleksandr Polozov, Rishabh Singh, Armando Solar-Lezama, Yisong Yue, et al. Neurosymbolic programming. Foundations and Trends in Programming Languages, 7(3):158\u2013243, 2021.   \n[3] Zeming Chen, Qiyue Gao, and Lawrence S. Moss. NeuralLog: Natural language inference with joint neural and logical reasoning. In Proceedings of \\*SEM 2021: The Tenth Joint Conference on Lexical and Computational Semantics, pages 78\u201388, 2021.   \n[4] Siddharth Singh Chouhan, Uday Pratap Singh, Ajay Kaul, and Sanjeev Jain. A data repository of leaf images: Practice towards plant conservation with plant pathology. In 2019 4th International Conference on Information Systems and Computer Networks (ISCON), pages 700\u2013707, 2019.   \n[5] Cristina Cornelio, Jan Stuehmer, Shell Xu Hu, and Timothy Hospedales. Learning where and when to reason in neuro-symbolic inference. In International Conference on Learning Representations, 2023.   \n[6] Wang-Zhou Dai, Qiuling Xu, Yang Yu, and Zhi-Hua Zhou. Bridging machine learning and logical reasoning by abductive learning. In Proceedings of the 33rd International Conference on Neural Information Processing Systems, 2019.   \n[7] Rajdeep Dutta, Qincheng Wang, Ankur Singh, Dhruv Kumarjiguda, Li Xiaoli, and Senthilnath Jayavelu. S-reinforce: A neuro-symbolic policy gradient approach for interpretable reinforcement learning. arXiv preprint arXiv:2305.07367, 2023.   \n[8] Jiani Huang, Ziyang Li, Binghong Chen, Karan Samel, Mayur Naik, Le Song, and Xujie Si. Scallop: From probabilistic deductive databases to scalable differentiable reasoning. In Proceedings of the 35th International Conference on Neural Information Processing Systems, pages 25134\u201325145, 2021.   \n[9] Paul Shekonya Kanda, Kewen Xia, and Olanrewaju Hazzan Sanusi. A deep learning-based recognition technique for plant leaf classification. IEEE Access, 9:162590\u2013162613, 2021.   \n[10] Angelika Kimmig, Guy Van den Broeck, and Luc De Raedt. Algebraic model counting. CoRR, 2012.   \n[11] Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11):2278\u20132324, 1998.   \n[12] Qing Li, Siyuan Siyuan Huang, Yining Hong, Yixin Chen, Ying Nian Wu, and Song-Chun Zhu. Closed loop neural-symbolic learning via integrating neural perception, grammar parsing, and symbolic reasoning. In Proceedings of the 37th International Conference on Machine Learning, page 5884\u20135894, 2020.   \n[13] Ziyang Li, Jiani Huang, and Mayur Naik. Scallop: A language for neurosymbolic programming. In ACM International Conference on Programming Language Design and Implementation, page 1463\u20131487, 2023.   \n[14] Robin Manhaeve, Sebastijan Dumancic, Angelika Kimmig, Thomas Demeester, and Luc De Raedt. Deepproblog: Neural probabilistic logic programming. In Proceedings of the 32nd International Conference on Neural Information Processing Systems, page 3753\u20133763, 2018.   \n[15] Jiayuan Mao, Chuang Gan, Pushmeet Kohli, Joshua B. Tenenbaum, and Jiajun Wu. The neurosymbolic concept learner: Interpreting scenes, words, and sentences from natural supervision. In International Conference on Learning Representations, 2019.   \n[16] Lukas Murmann, Michael Gharbi, Miika Aittala, and Fredo Durand. A multi-illumination dataset of indoor object appearance. In 2019 IEEE International Conference on Computer Vision (ICCV), Oct 2019.   \n[17] Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, Alban Desmaison, Andreas Kopf, Edward Yang, Zachary DeVito, Martin Raison, Alykhan Tejani, Sasank Chilamkurthy, Benoit Steiner, Lu Fang, Junjie Bai, and Soumith Chintala. Pytorch: An imperative style, high-performance deep learning library. In Proceedings of the 33rd International Conference on Neural Information Processing Systems, page 8026\u20138037, 2019.   \n[18] Felix Petersen, Christian Borgelt, Hilde Kuehne, and Oliver Deussen. Differentiable sorting networks for scalable sorting and ranking supervision. In Proceedings of the 38th International Conference on Machine Learning, 2021.   \n[19] Alec Radford, Jong Wook Kim, Chris Hallacy, Aditya Ramesh, Gabriel Goh, Sandhini Agarwal, Girish Sastry, Amanda Askell, Pamela Mishkin, Jack Clark, Gretchen Krueger, and Ilya Sutskever. Learning transferable visual models from natural language supervision, 2021.   \n[20] Joseph Redmon, Santosh Divvala, Ross Girshick, and Ali Farhadi. You only look once: Unified, real-time object detection. In 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), pages 779\u2013788, 2016.   \n[21] Lennert De Smet, Emanuele Sansone, and Pedro Zuidberg Dos Martires. Differentiable sampling of categorical distributions using the catlog-derivative trick. In Proceedings of the 37th International Conference on Neural Information Processing Systems, 2023.   \n[22] Dagher R. Talhouk S.N., Fabian M. Landscape plant database, 2015.   \n[23] Efthymia Tsamoura, Timothy Hospedales, and Loizos Michael. Neural-symbolic integration: A compositional perspective. In AAAI Conference on Artificial Intelligence, 2020.   \n[24] Emile van Krieken, Thiviyan Thanapalasingam, Jakub M. Tomczak, Frank van Harmelen, and Annette ten Teije. A-nesi: A scalable approximate method for probabilistic neurosymbolic inference. In Proceedings of the 37th International Conference on Neural Information Processing Systems, 2023.   \n[25] Po-Wei Wang, Priya Donti, Bryan Wilder, and Zico Kolter. Satnet: Bridging deep learning and logical reasoning using a differentiable satisfiability solver. In Proceedings of the 36th International Conference on Machine Learning, pages 6545\u20136554, 2019.   \n[26] Ronald J. Williams. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine Learning, 8(3\u20134):229\u2013256, 1992.   \n[27] Jingyi Xu, Zilu Zhang, Tal Friedman, Yitao Liang, and Guy Van den Broeck. A semantic loss function for deep learning with symbolic knowledge. In Proceedings of the 35th International Conference on Machine Learning, pages 5502\u20135511, 2018.   \n[28] Zhun Yang, Adam Ishay, and Joohyung Lee. Neurasp: Embracing neural networks into answer set programming. In Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, pages 1755\u20131762, 2020.   \n[29] Delu Zeng, Minyu Liao, Mohammad Tavakolian, Yulan Guo, Bolei Zhou, Dewen Hu, Matti Pietik\u00e4inen, and Li Liu. Deep learning for scene classification: A survey, 2021. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "A Explanation of Differences Between ISED and Baseline Methods ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "We explain the differences between ISED and prior techniques using the simple example of $\\mathrm{{Sum}_{2}}$ , where digits are restricted to be between 0-2. Suppose that we are training a neural network $M_{\\theta}$ for this task, and we are considering the symbol-output sample where the ground truth symbols are 1 and 2, i.e., $r_{1}=1,r_{2}=2$ , and the ground truth output is $y=3$ . Suppose that the predicted distributions from $M_{\\theta}$ for $r_{1}$ and $r_{2}$ are [0.1, 0.6, 0.3] and $[0.2,0.1,0.7]$ respectively. We now explain how different methods perform their loss computations. ", "page_idx": 12}, {"type": "text", "text": "A.1 ISED ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "Suppose ISED is initialized with a sample count of 3, and the sampled symbol-output pairs are $(({\\bar{1,2}}),3)$ , $((1,0),1)$ , and $((2,1),3)$ . We use the add-mult semiring in this example. ISED can be thought of as differentiating through the following summary logic program: ", "page_idx": 12}, {"type": "equation", "text": "$$\n\\begin{array}{l}{r_{1}=1\\wedge r_{2}=2\\to y=3}\\\\ {r_{1}=1\\wedge r_{2}=0\\to y=1}\\\\ {r_{1}=2\\wedge r_{2}=1\\to y=3}\\end{array}\n$$", "text_format": "latex", "page_idx": 12}, {"type": "text", "text": "As a result, the final vector calculated for the loss function before normalization would be ", "page_idx": 12}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left[\\begin{array}{c}{0.0}\\\\ {0.6*0.2}\\\\ {0.0}\\\\ {0.6*0.7+0.3*0.1}\\\\ {0.0}\\end{array}\\right]}\\end{array}\n$$", "text_format": "latex", "page_idx": 12}, {"type": "text", "text": "where each value corresponds to the probability of the given output (possible outputs are in the range 0-4). Note that if there are duplicate samples, ISED includes the duplicate probabilities in its aggregation. In our implementation, we would perform normalization on this vector and then pass it into the binary cross-entropy loss function, with the ground truth vector being: ", "page_idx": 12}, {"type": "text", "text": "We would then minimize this loss and update $M_{\\theta}$ accordingly. ", "page_idx": 12}, {"type": "text", "text": "If we use the min-max semiring instead, $^*$ is replaced by min and $^+$ by max in the final vector calculation, resulting in ", "page_idx": 12}, {"type": "text", "text": "A.2 REINFORCE ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "Suppose REINFORCE is also initialized with a sample count of 3, and it samples the same symboloutput pairs. The final reward is computed by element-wise multiplication of the log probability of each sample with its reward value and taking the mean, as follows: ", "page_idx": 12}, {"type": "equation", "text": "$$\n\\frac{1}{3}*\\left[\\stackrel{\\log(0.6)}{\\log(0.6)}+\\log(0.7)\\right]*\\left[\\stackrel{1.07}{0.0}\\right]\n$$", "text_format": "latex", "page_idx": 12}, {"type": "text", "text": "and the goal is to optimize $M_{\\theta}$ to maximize this reward. While this approach resembles ISED\u2019s loss computation for the add-mult semiring, it does not involve the mult step. As it rewards possible values instead of possible combinations, the final reward would have been the same when (1,1) and (2,2) were the correct samples, instead of (1,2) and (2,1). Hence, the learning signal is weaker compared to ISED when there is more than one input to $P$ . ", "page_idx": 12}, {"type": "text", "text": "A.3 IndeCateR and NASR ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "IndeCateR is an extension of the REINFORCE estimator that is unbiased with a provably lower variance. It assumes and exploits the factoring of the underlying multivariate distribution into independent categorical variables by summing out one dimension while keeping a sample for other dimensions fixed. For each sample drawn, IndeCateR systematically creates additional samples that differ on a single entry by enumerating all possible values for each variable. NASR targets efficient finetuning by setting the sample count to one and customizing the reward function. ", "page_idx": 13}, {"type": "text", "text": "The loss computation for IndeCateR and NASR are identical to that of REINFORCE, also providing weak signals with fewer samples. Furthermore, both set the reward to 0 for samples leading to incorrect predictions, effectively ignoring them, unlike ISED which penalizes such symbols. Since only the correct symbol contribute to the final reward, the signal is sparser than ISED, making it sample-inefficient. ", "page_idx": 13}, {"type": "text", "text": "A.4 A-NeSI ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "A-NeSI trains two additional neural networks: a prediction model $Q_{\\theta^{\\prime}}$ as a surrogate for $P$ , and a prior model $R_{\\alpha}$ for learning the parameters $\\alpha$ for the Dirichlet distribution $D_{\\alpha}$ . ", "page_idx": 13}, {"type": "text", "text": "Suppose A-NeSI is also initialized with a sample count of 3. At each training step, A-NeSI first updates $\\alpha$ using $\\hat{y}\\,=\\,M_{\\theta}(x)$ . Next, it samples a single symbol from each of the 3 distributions sampled from $D_{\\alpha}$ , and uses the sampled symbol-output pair and the standard cross entropy loss to update $Q_{\\theta^{\\prime}}$ . Then, A-NeSI optimizes $M_{\\theta}$ by minimizing the loss ${\\mathcal{L}}(Q_{\\theta^{\\prime}}(M_{\\theta}(r_{1},r_{2})))$ using the prediction model instead of $P$ . ", "page_idx": 13}, {"type": "text", "text": "A.5 DeepProbLog ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "DeepProbLog (DPL) enumerates all possible proofs for each output and aggregates probabilities accordingly. For example, the proofs for $y=1$ include $r_{1}=0,r_{2}=1$ and $r_{1}=1,r_{2}=0$ . Thus, the probability of this output is $0.6*0.2+0.1*0.1$ . The final vector calculated would be ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left[0.1*0.2\\right.}\\\\ {\\left.0.6*0.2+0.1*0.1\\right.}\\\\ {0.1*0.7+0.6*0.1+0.3*0.2}\\\\ {\\left.0.6*0.7+0.3*0.1\\right.}\\\\ {\\left.0.3*0.7\\right.}\\end{array}\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "and we would pass this vector into some loss function (e.g., cross-entropy), with the same ground truth vector that ISED would use. DPL would then minimize this loss and update $M_{\\theta}$ accordingly. ", "page_idx": 13}, {"type": "text", "text": "A.6 Scallop ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Suppose Scallop is configured to use the diff-top-1-proofs semiring. This means that for each possible output, Scallop will use the proof of that output with the highest probability. For instance, the most likely proof for $y=1$ is $r_{1}=1$ and $r_{2}=0$ , and the probability of the output $y=1$ is $0.6*0.2$ . The final vector calculated would be ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left[0.1*0.2\\right]}\\\\ {0.6*0.2}\\\\ {0.1*0.7}\\\\ {0.6*0.7}\\\\ {0.3*0.7}\\end{array}\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "and we would pass this vector into some loss function (e.g., binary-cross-entropy), with the same ground truth vector that ISED would use. Scallop would then minimize this loss and update $M_{\\theta}$ accordingly. This probability estimation would change depending on the choice of semiring (e.g., diff-top- $\\mathtt{k}$ -proofs for a different value of $k$ ). ", "page_idx": 13}, {"type": "text", "text": "B Evaluation Setup ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "For tasks with the MNIST dataset as unstructured data, we employ LeNet [11], a 2-layer CNN-based model, except for $\\mathrm{sum}_{8}$ , $\\mathrm{{sum}_{12}}$ , and $\\mathrm{sum}_{16}$ tasks where we choose a smaller 2-layer CNN used by ", "page_idx": 13}, {"type": "text", "text": "IndeCateR [21]. For HWF, we also use a 2-layer CNN-based model. For leaf classification tasks, images are scaled down and passed to a simple CNN-based network with 4 convolutional layers. For the scene recognition, we use YOLOv8 and a 3-layer convolutional network for neural program methods, 7-layer CNN for the purely neural solution, and CLIP with ViT-B/32. For all tasks included in RQ1, other than sudoku, we remove the final softmax function at the end of each network when evaluating IndeCateR since its sampling procedure yields optimal results without the softmax. We also do that same with REINFORCE if it results in higher accuracy. Since sudoku uses a pretrained CNN, we use the same CNN across all methods, including IndeCateR and REINFORCE. ", "page_idx": 14}, {"type": "text", "text": "We use the Adam optimizer with the best learning rate among $\\{1{\\mathrm{e}}{-}3,5{\\mathrm{e}}{-}4,1{\\mathrm{e}}{-}4\\}$ . We train for maximum 100 epochs, but stop early if the training saturates. For MNIST-R tasks, we used learning rate 1e\u22124 and trained ISED for 10 epochs, REINFORCE and IndeCateR for 50 epochs, and A-NeSI and NASR for 100 epochs. We trained ISED for 30 epochs, A-NeSI for 100 epochs, and the rest for 50 epochs for HWF and Leaf Classification with learning rate 1e\u22124. For the Scene Recognition task, we trained A-NeSI and the purely neural baseline 50 epochs and the rest 100 epochs with learning rate 5e\u22124. For tasks $\\mathrm{sum}_{8}$ to $\\mathrm{sum}_{16}$ we trained ISED for 50 epochs and the rest for 100 epochs with learning rate 1e\u22123. For Visual Sudoku, we follow the setting in NASR [5] and train for 10 epochs with learning rate 1e\u22125. ", "page_idx": 14}, {"type": "text", "text": "We configure ISED to use the min-max semiring for HWF and the add-mult semiring for all other tasks. We use categorical sampling and binary cross-entropy loss for ISED. ", "page_idx": 14}, {"type": "text", "text": "B.1 Neural-GPT Experiment Prompts ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "For leaf classification and scene recognition, the neural-GPT experiments, we used the up-to-date version of GPT-4, gpt-4-1106-preview and gpt-4o respectively, with the parameter top-p set to 1e\u22128. We present the prompts used for the experiments in Tables 5 and 6. ", "page_idx": 14}, {"type": "table", "img_path": "QXQY58xU25/tmp/a03aa83b651df8737f6e9f104935d9cb2f80e73c396d0461928d85dda6dcb693.jpg", "table_caption": ["Table 5: GPT-4 prompt for the leaf classification task. "], "table_footnote": [], "page_idx": 14}, {"type": "table", "img_path": "QXQY58xU25/tmp/5d480ce0a442d171f63b83cededb9ff6d14356e9ee11c583b471c61915d2f4ea.jpg", "table_caption": ["Table 6: GPT-4 prompt for the scene recognition task. "], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "We use MARGIN $=$ {entire, dentate, lobed, serrate, serrulate, undulate}, SHAPE $=$ {elliptical, lanceolate, obovate, oblong, ovate}, TEXTURE $=$ {glossy, leathery, smooth, medium}, and PLANT NAME $\\in$ {Alstonia Scholaris, Citrus limon, Jatropha curcas, Mangifera indica, Ocimum basilicum, Platanus orientalis, Pongamia Pinnata, Psidium guajava, Punica granatum, Syzygium cumini, Terminalia Arjuna}. ", "page_idx": 14}, {"type": "text", "text": "Furthermore, SCENES $=$ {bathroom, bedroom, dining room, living room, kitchen, lab, office, home lobby, basement} and DETECTED OBJECTS is a list of maximum length 10 with duplicates. ", "page_idx": 14}, {"type": "text", "text": "C Full Performance Summary ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "We report the accuracy of all benchmarks with 1-sigma standard deviation in Tables 7, 8, 9, and 10. We further provide the performance comparison with varying sample counts with 1-sigma standard deviation in Tables 11, 12, and 13. ", "page_idx": 14}, {"type": "table", "img_path": "QXQY58xU25/tmp/3ea899aa7aed41a96a320c15a38f645f987a8ed7ebf325def0cc6af331a36695.jpg", "table_caption": ["Table 7: Performance comparison for DT leaf, GPT leaf, scene, and sudoku. "], "table_footnote": [], "page_idx": 15}, {"type": "table", "img_path": "QXQY58xU25/tmp/6c5d2cc45ffc053958b4a9a442b898391c51699d595c48cd8d1f38d58c163868.jpg", "table_caption": ["Table 8: Performance comparison for HWF, $\\mathrm{sum_{2}}$ , $\\mathrm{sum_{3}}$ , and $\\mathrm{sum_{4}}$ . "], "table_footnote": [], "page_idx": 15}, {"type": "table", "img_path": "QXQY58xU25/tmp/5ae2e159da97f58eebffe2fb5f9371d1e049ce5e2139bb1b4cd1cdcc7f053818.jpg", "table_caption": ["Table 9: Performance comparison for $\\mathrm{\\mult_{2}}$ , $\\mathrm{mod_{2}}$ , less-than, and add-mod-3. "], "table_footnote": [], "page_idx": 15}, {"type": "table", "img_path": "QXQY58xU25/tmp/d4fa24626fca679e5e551b0539ab1e3c026d078c551a5d2ad7601770f4990cf1.jpg", "table_caption": ["Table 10: Performance comparison for add-sub, equal, not-3-or-4, and count-3-4. "], "table_footnote": [], "page_idx": 15}, {"type": "table", "img_path": "QXQY58xU25/tmp/2a1f3b01be452c2f5602b6a44637a2d4248311e589aa2d990ef5c574647cd49f.jpg", "table_caption": ["Table 11: Performance comparison for $\\mathrm{sum}_{8}$ with different sample counts $k$ . "], "table_footnote": [], "page_idx": 16}, {"type": "table", "img_path": "QXQY58xU25/tmp/94013b08185dd689a1c14e6115e34e799393167671ff979502e8eb23565fb579.jpg", "table_caption": ["Table 12: Performance comparison for $\\mathrm{{sum}_{12}}$ with different sample counts $k$ . "], "table_footnote": [], "page_idx": 16}, {"type": "table", "img_path": "QXQY58xU25/tmp/e078f7f3772d00ac8dad4aa05ad9ed0b0c2ec69d0a2ca17eef5c03bdc686151e.jpg", "table_caption": ["Table 13: Performance comparison for $\\mathrm{sum_{16}}$ with different sample counts $k$ . "], "table_footnote": [], "page_idx": 16}, {"type": "text", "text": "D License Information ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "For implementing the baselines, we adapted the code from the official repositories of DeepProblog [14] (Apache 2.0), Scallop [8] (MIT), A-NeSI [24] (MIT), NASR [5] (MIT), and IndeCateR [21] (Apache 2.0). Additionally, our benchmarks use Multi-illumination dataset [16] (CC BY 4.0), HWF dataset (CC BY-NC-SA 3.0) from NGS [12], a subset of the leaf database [4] (CC BY 4.0), YOLOv8 (AGPL-3.0) and CLIP (MIT). ", "page_idx": 16}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 17}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 17}, {"type": "text", "text": "Justification: The abstract and introduction claim that our proposed algorithm (ISED) achieves similar, and often superior accuracy, compared to state-of-the-art neurosymbolic learning, REINFORCE-based, and black-box gradient estimation frameworks, but in a more data- and sample-efficient manner. We provide evidence for these claims in our evaluation in Sections 4.3, 4.4, and 4.5. ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 17}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] ", "page_idx": 17}, {"type": "text", "text": "Justification: We have a separate section on Limitations (Section 5), and show limitation in scaling to high dimensional inputs with experimental results in RQ2 (Section 4.4). ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 17}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 18}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 18}, {"type": "text", "text": "Justification: Our paper does not include any theoretical results. Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 18}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 18}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 18}, {"type": "text", "text": "Justification: We release code for all baselines and ISED to reproduce the results reported in the paper. The hyperparameters used for experiments are summarized in Appendix B. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 18}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: We are releasing data and code, along with the instructions for reproducing all results. We include directions for downloading datasets and setting up the environment. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 19}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: We provide information on data splits in Section 4.1 and provide the rest of the experimental details in Appendix B. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 19}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: All results are accompanied by standard deviation with clearly stated factors of variability. While some tables are presented without standard deviations (Tables 3 and 4), 1-sigma standard deviation is provided for these results in Tables 7-13 in Appendix C. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 19}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 20}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: We provide details of the compute used in Section 4.2. We also specify the number of runs and epochs for each task (Appendix B) and training time for selected benchmarks (Section 4.5). ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 20}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: We have reviewed the Code of Ethics and and followed them whenever relevant. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 20}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 20}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 20}, {"type": "text", "text": "Justification: We propose a new framework for learning neural networks in presence of black-box components and there is no societal impact to be pointed out. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 21}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 21}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 21}, {"type": "text", "text": "Justification: We do not release new data or models, hence the work poses no such risks. Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 21}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: For datasets, code, and pretrained models used, we cited the original paper and provided the license information in Appendix D. We stated the versions of GPT-4 and YOLO in Appendix B. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets. \u2022 The authors should cite the original paper that produced the code package or dataset. \u2022 The authors should state which version of the asset is used and, if possible, include a URL. ", "page_idx": 21}, {"type": "text", "text": "\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 22}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: The paper releases code for the proposed learning algorithm, which is well documented with license and training information. The limitations are mentioned in the paper (Sections 4.4 and 5). ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 22}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: This paper did not involve any crowdsourcing or research with human subjects. Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 22}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "page_idx": 22}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: This paper did not involve any crowdsourcing or research with human subjects. Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 23}]