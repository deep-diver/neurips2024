[{"type": "text", "text": "Neural Network Reparametrization for Accelerated Optimization in Molecular Simulations ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Nima Dehmamy Csaba Both Jeet Mohapatra Subhro Das IBM Research Northeastern University MIT CSAIL IBM Research Nima.Dehmamy@ibm.com both.c@northeastern.edu jeetmo@mit.edu subhro.das@ibm.com ", "page_idx": 0}, {"type": "text", "text": "Tommi Jaakkola MIT CSAIL tommi@csail.mit.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "We propose a novel approach to molecular simulations using neural network reparametrization, which offers a flexible alternative to traditional coarse-graining methods. Unlike conventional techniques that strictly reduce degrees of freedom, the complexity of the system can be adjusted in our model, sometimes increasing it to simplify the optimization process. Our approach also maintains continuous access to fine-grained modes and eliminates the need for force-matching, enhancing both the efficiency and accuracy of energy minimization. Importantly, our framework allows for the use of potentially arbitrary neural networks (e.g., Graph Neural Networks (GNN)) to perform the reparametrization, incorporating CG modes as needed. In fact, our experiments using very weak molecular forces (Lennard-Jones potential) the GNN-based model is the sole model to find the correct configuration. Similarly, in protein-folding scenarios, our GNN-based CG method consistently outperforms traditional optimization methods. It not only recovers the target structures more accurately but also achieves faster convergence to the deepest energy states. This work demonstrates significant advancements in molecular simulations by optimizing energy minimization and convergence speeds, offering a new, efficient framework for simulating complex molecular systems. 1 ", "page_idx": 0}, {"type": "text", "text": "Scientific simulations, particularly in molecular dynamics (MD), face fundamental challenges in finding optimal configurations. The energy landscapes of these systems are characterized by numerous saddle points and local minima, making it difficult for traditional optimization methods to discover the most stable states. This complexity stems from the interplay between different scales of interactions, from strong covalent bonds to weak van der Waals forces, leading to slow convergence in gradientbased methods and often suboptimal results. For instance, in protein folding, the strong peptide bonds create steep energy barriers while weak hydrophobic interactions guide the overall folding process, creating a hierarchy of energy scales that is challenging to optimize simultaneously. ", "page_idx": 0}, {"type": "text", "text": "To address these challenges, coarse-graining (CG) methods have emerged as a popular approach, reducing computational complexity by decreasing the number of degrees of freedom (DOF) and clustering them into collective modes. While these methods have shown success (Pak & Voth, 2018; Hollingsworth & Dror, 2018), they face significant limitations. Traditional CG approaches require cumbersome procedures such as back-mapping (returning to the original DOF) and force-matching (finding the forces experienced by CG modes) (Jin et al., 2022), which can limit their efficiency and scalability. Moreover, the strict reduction of DOF in conventional CG can sometimes oversimplify the system, losing important fine-grained details necessary for accurate energy minimization. ", "page_idx": 0}, {"type": "text", "text": "In this paper, we introduce an innovative alternative that overcomes these limitations through neural reparametrization. Instead of strictly reducing DOF as in conventional CG, our approach leverages an overparametrized neural ansatz to represent fine-grained (FG) modes as functions of CG modes. This reparametrization concept, similar to techniques such as Deep Image Priors (Ulyanov et al., 2018), enables the neural network to dynamically represent the FG system while maintaining continuous access to FG modes and eliminating the need for force-matching. The overparametrization provides additional flexibility in navigating the energy landscape - while the physical system has $n\\times d$ degrees of freedom ( $\\ln$ particles in $d$ dimensions), our neural representation can use a higher-dimensional latent space to find paths around energy barriers that might be difficult to traverse in the original space. ", "page_idx": 1}, {"type": "text", "text": "A key innovation in our approach is the incorporation of Graph Neural Networks (GNN) with a structure informed by \u2018slow modes\u2019\u2013inherently stable collective modes identified through spectral analysis of the system\u2019s dynamics. We show that these modes arise naturally from the structure of physical Hessians, which are Laplacian matrices over particle indices for a broad class of potential energies. By focusing on these slow modes, which typically cause convergence bottlenecks in traditional optimization, we can significantly accelerate the learning process. The GNN architecture allows us to safely increase learning rates without stability issues, resulting in both faster dynamics progression and the discovery of lower energy states compared to direct optimization methods. ", "page_idx": 1}, {"type": "text", "text": "The effectiveness of our approach is demonstrated through experiments on both synthetic systems and real molecular structures. In particular, for protein folding with weak Lennard-Jones interactions, where traditional methods often struggle with the shallow energy landscape, our GNN-based model consistently finds deeper energy minima. This success can be attributed to two key factors: the ability of the overparametrized representation to explore the energy landscape more effectively, and the incorporation of physically meaningful slow modes into the neural architecture, which helps guide the optimization toward stable configurations. ", "page_idx": 1}, {"type": "text", "text": "The main contributions of this work are: ", "page_idx": 1}, {"type": "text", "text": "1. CG via reparametrization: A new paradigm that circumvents traditional challenges like force-matching and back-mapping.   \n2. Robust slow modes: Effective identification and utilization of stable modes across various systems.   \n3. MD simulations: Demonstrated improvements in efficiency and depth of energy exploration in protein dynamics.   \n4. Overparametrization benefits: Evidence that an overparametrized framework can outperform traditional DOF reduction in terms of convergence speed and energy minimization.   \n5. Data-free optimization: Our method modifies the optimization landscape without the need for training data, enhancing its applicability and efficiency. ", "page_idx": 1}, {"type": "text", "text": "1 Background ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Traditional optimization in physics-based models, like (MD), faces unique challenges due to the shallow nature of these models, where physical DOF are the trainable weights. Additionally, the interactions occur at multiple scales, from strong covalent bonds to weak van der Waals forces, leading to slow convergence in gradient-based methods. ", "page_idx": 1}, {"type": "text", "text": "To address these challenges, conventional strategies include preconditioning with methods like adaptive gradient (Duchi et al., 2011; Kingma & Ba, 2014) or quasi-Newton (Fletcher, 2013), and CG, which simplifies the system by truncating DOF to focus on collective modes. However, both approaches have limitations: preconditioning methods struggle with cost and inefficacy due to nondiagonal Hessians in physics problems, and CG can be restrictive and require intensive back-mapping and force-matching steps (Jin et al., 2022). ", "page_idx": 1}, {"type": "text", "text": "In contrast, our approach utilizes neural network reparametrization to dynamically adjust system complexity, which may involve overparametrization. This method allows for flexible system representation, which can simplify the optimization process. It can help avoid local minima and accelerates convergence by exploring the configuration space more efficiently. ", "page_idx": 1}, {"type": "text", "text": "Neural Reparametrization in Practice Our neural reparametrization approach is not limited to reducing DOF but can also increase them when beneficial, offering an adaptive solution to the specific needs of a simulation. This flexibility is crucial for addressing the hierarchy of interactions in molecular systems, where different forces operate at vastly different scales. ", "page_idx": 2}, {"type": "text", "text": "Implementation and Comparison to CG While CG methods focus on predefined collective modes and often involve laborious optimization steps like force-matching and back-mapping, our neural reparametrization approach defines modes based on the spectrum of a canonical Hessian, directly incorporating these into the neural network\u2019s architecture. This not only bypasses the need for traditional CG steps but also enhances the adaptability and speed of the optimization process. ", "page_idx": 2}, {"type": "text", "text": "Advantages Over Traditional Methods Our method diverges from traditional data-driven ML approaches that require extensive datasets, which are often unavailable or costly to produce in molecular and material design. By not relying on training data, our approach provides a robust framework for tackling complex optimization problems, from molecular dynamics to protein folding, with improved efficiency and without the constraints of data availability. ", "page_idx": 2}, {"type": "text", "text": "1.1 Traditional Coarse-graining ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Let $X\\in{\\mathcal{X}}\\simeq\\mathbb{R}^{n\\times d}$ represent the degrees of freedom (DOF), such as particle positions or bond angles, and let $\\mathcal{L}:\\mathcal{X}\\rightarrow\\mathbb{R}$ denote the energy or potential function. The objective is to simulate the dynamics of the system or to find high-likelihood configurations $X^{*}$ that represent deep local minima of $\\mathcal{L}$ . Given that $n$ is typically large and $\\mathcal{L}$ is a steep non-convex function, computations can be slow. Traditional coarse-graining (CG) maps $X$ to a reduced space of CG variables, $\\mathcal{Z}\\simeq\\mathbb{R}^{k\\times d}$ , where $k\\ll n$ . Implementing dynamics using CG modes requires determining the inter-mode forces (\u201cforce-matching\u201d) and how to revert to $\\mathcal{X}$ (\u201cback-mapping\u201d). ", "page_idx": 2}, {"type": "text", "text": "Force-matching. The fine-grained (FG) energy function, $\\mathcal{L}_{F G}:\\mathcal{X}\\rightarrow\\mathbb{R}$ , needs an approximate potential $\\mathcal{L}_{C G}:\\mathcal{Z}\\to\\mathbb{R}$ such that for $X\\in\\mathcal{X}$ , ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathsf{C G}\\colon\\;\\;\\phi:\\mathcal{X}\\to\\mathcal{Z},\\quad\\mathcal{L}_{C G}(\\phi(X))\\approx\\mathcal{L}_{F G}(X).}\\end{array}\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "The process of finding $\\mathcal{L}_{C G}$ is called force-matching, traditionally solved analytically but increasingly with machine learning for enhanced accuracy Jin et al. (2022); Majewski et al. (2023). ", "page_idx": 2}, {"type": "text", "text": "Back-mapping. The map $\\mathcal{Z}\\sim\\mathbb{R}^{k\\times d}$ is not unique, often resulting in multiple possible $X$ for a given $Z$ . Back-mapping typically involves sampling or optimization to find physically plausible $X$ configurations, avoiding scenarios like overlapping atoms or high energies. This can be complex when many $X$ map to the same $Z$ , with current methods ranging from geometric reconstruction Lombardi et al. (2016) to refinement with molecular dynamics Badaczewska-Dawid et al. (2020); Roel-Touris & Bonvin (2020) and data-driven approaches Yang & G\u00f3mez-Bombarelli (2023); Wang et al. (2022). ", "page_idx": 2}, {"type": "text", "text": "1.2 Neural Reparametrization as an Alternative to Coarse-graining ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Instead of traditional CG, which reduces DOF through a mapping to a reduced space, our approach reparametrizes the DOF $X$ as a function of CG-like modes. This reparametrization, given by $\\bar{X^{}}=\\rho(Z)$ , where $\\rho:\\mathcal{Z}\\rightarrow\\mathcal{X}$ , offers a flexible, reversible mapping that inherently includes beneftis such as direct access to fine-grained modes and elimination of force-matching and back-mapping needs: ", "page_idx": 2}, {"type": "equation", "text": "$X=\\rho(Z),\\quad\\rho:\\mathcal{Z}\\rightarrow\\mathcal{X}$ ", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "Flexible parametrization: Leveraging neural overparametrization and architecture design. ", "page_idx": 2}, {"type": "text", "text": "2. Direct access to fine-grained modes: $X=\\rho(Z)$ avoids the need for back-mapping. ", "page_idx": 2}, {"type": "text", "text": "3. Simplified energy computation: The energy for CG-like modes is $\\mathcal{L}_{C G}(Z)=\\mathcal{L}(\\rho(Z))$ . ", "page_idx": 2}, {"type": "text", "text": "While this method can be computationally intensive as ${\\mathcal{L}}_{C G}(Z)$ is computed using $X$ , the efficiency gains in optimization speed and depth of energy minimization can offset the costs. ", "page_idx": 2}, {"type": "image", "img_path": "FwxOHl0BEl/tmp/f203f7ad7f299d778987811a3fadf98c33e758da8b90dad85fad8e52d0ab0090.jpg", "img_caption": ["Figure 1: Overview of the neural reparametrization method. Top: Architectures used for reparametrization. In linear reparametrization, $X\\ =\\ Z^{T}\\Psi_{\\mathrm{slow}}$ . In the GNN case, we use the slow modes to construct a graph with adjacency $A=\\Psi_{\\mathrm{slow}}\\Psi_{\\mathrm{slow}}^{T}$ and use it in GCN layers to obtain $X=\\operatorname{gnn}(Z)$ . Left: Flowchart showing the key steps of the method. Right: Detailed algorithm for implementation. "], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "Neural Architectures for Reparametrization The reparametrization function $\\rho$ can range from simple linear projections to complex neural networks. Initially, we employ a linear projection onto identified slow modes: ", "page_idx": 3}, {"type": "equation", "text": "$$\nX=\\rho(Z)=Z^{T}\\Psi_{\\mathrm{\\bfSlow}}\\equiv\\sum_{i\\in\\mathrm{\\bfSlow}}Z_{i}^{T}\\psi_{i}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "More generally, $\\rho$ may be a deep neural network (DNN), similar to the approach taken in prior work suggesting neural priors (e.g. Deep Image Priors Ulyanov et al. (2018)). ", "page_idx": 3}, {"type": "text", "text": "Graph Neural Networks (GNN) for Dynamic Reparametrization: Extending beyond linear models, we explore the use of GNNs, inspired by recent advancements in graph-based optimizations Both et al. (2023). Here, the GNN reparametrizes node states and was shown to find both lower energy states and exhibit faster convergence. Our idea is to use a \u201cHessian backbone\u201d as a graph, which acts as a weighted graph adjacency matrix for a GNN. In our experiments, we observe this GNN to have significant advantages over the direct as well as linear reparametrization equation 3. The details of our GNN architecture are discussed in Section 3. Next, we derive the properties of the slow modes for a large class of energy functions important in molecular systems. ", "page_idx": 3}, {"type": "text", "text": "1.3 The role of the Hessian ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "The success of optimization in molecular systems is fundamentally limited by the disparity in evolution rates along different modes of the system. Near any configuration $X$ , the dynamics of gradient-based optimization can be understood through the eigendecomposition of the Hessian $\\mathbf{\\bar{\\boldsymbol{H}}}=\\nabla\\nabla\\mathcal{L}$ . The eigenvectors of $\\pmb{H}$ define the natural modes of the system, with their eigenvalues determining how quickly these modes evolve under gradient descent. Modes with large eigenvalues (fast modes) evolve rapidly but constrain the learning rate to ensure stability, while modes with eigenvalues close to zero (slow modes) evolve orders of magnitude more slowly, leading to extremely slow convergence, particularly near saddle points. ", "page_idx": 3}, {"type": "text", "text": "", "page_idx": 4}, {"type": "text", "text": "This disparity presents a fundamental challenge: To maintain numerical stability, the learning rate must be small enough to handle the fastest modes, but this makes the slow modes evolve at a glacial pace. Traditional approaches like adaptive gradient methods attempt to address this by approximating a diagonal preconditioner, but they struggle with the strongly coupled nature of physical systems where the Hessian is far from diagonal. While conventional coarse-graining partially addresses this by eliminating fast modes, it introduces other challenges such as force-matching and back-mapping. ", "page_idx": 4}, {"type": "text", "text": "Our approach takes a different perspective: instead of eliminating modes, we seek to identify and directly incorporate slow modes into our optimization process. However, this raises two key challenges. First, as the system evolves, the Hessian changes, potentially altering which modes are slow. Second, even if we can identify slow modes, we need a way to modify the optimization to preferentially explore these directions. The next section addresses the first challenge by proving that slow modes of physical Hessians are remarkably robust, arising from fundamental symmetries of the underlying interactions. We then show how these robust slow modes can be effectively utilized through neural reparametrization. ", "page_idx": 4}, {"type": "text", "text": "2 Properties of Physical Hessians ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "We will now show that the Hessian of potential energies important in physics and molecular systems enjoy certain properties that lead to the robustness of slow modes. In short, if we find a stable backbone for Hessians of different configurations $X$ , then the slow modes of the Hessian at $X$ are close to the slow modes derived from the backbone. ", "page_idx": 4}, {"type": "text", "text": "Invariant potentials. In systems of interacting particles in physics, leading interactions are often pairwise and involve relative features, $\\pmb{r}_{i j}\\equiv X_{i}-X_{j}$ (distance vector, relative angle, etc). These interactions are invariant under global symmetries, such as Euclidean symmetries (translation and rotation) or Lorentz symmetry (relativistic particles). These symmetries maintain the invariance of certain norms, $v^{2}=\\|\\pmb{v}\\|_{\\eta}\\equiv\\pmb{\\dot{v}}^{T}\\eta\\pmb{v}$ , where $\\eta$ may be the Euclidean metric $\\eta=\\mathrm{diag}(1,1,1)$ or the Minkowski metric $\\eta=\\mathrm{diag}(-1,1,1,1)$ . For example, the Euclidean norm ${\\pmb v}^{T}{\\pmb v}$ in $d$ dimensions is invariant under rotations ${\\pmb v}\\rightarrow g{\\pmb v}$ , where $g\\in S O(d)$ . ", "page_idx": 4}, {"type": "text", "text": "Energy function structure. Let $r$ denote the matrix of distances with $r_{i j}=\\|\\pmb{r}_{i j}\\|_{\\eta}$ . Any function of $r_{i j}$ is invariant under symmetries that keep $\\|\\cdot\\|_{\\eta}$ invariant. Assuming additivity, the energy function can be written as: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\mathcal{L}(X)=\\sum_{i j}f_{i j}(r_{i j})\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $f_{i j}(z)=f_{j i}(z)$ . For example, the Coulomb potential between particles $i$ and $j$ with charges $q_{i}$ and $q_{j}$ respectively, is given by $f_{i j}(z)=k q_{i}q_{j}/z\\quad$ . The Lennard-Jones potential $f_{i j}(z)=A_{i j}/z^{1}2\\;-$ $B_{i j}/z^{6}$ in molecular systems is also of this form. ", "page_idx": 4}, {"type": "text", "text": "2.1 Hessian of invariant potentials ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "The Hessian of potentials of the form equation 4 has the special property that it is the graph Laplacian of a weighted graph which depends on $X$ , as we show now (see appendix E for details). This will play a crucial role in our argument about the robustness of the slow modes. ", "page_idx": 4}, {"type": "text", "text": "Hessian as a graph Laplacian. Recall the Laplacian of an undirected graph with adjacency matrix $A$ is defined as ${\\bar{L}}\\,=\\,\\operatorname{Lap}(A)\\,=\\,D\\,-\\,A$ , where $D$ is the degree matrix with elements $\\begin{array}{r}{D_{i j}=\\delta_{i j}\\sum_{k}A_{i k}}\\end{array}$ . The components of Laplacian can also be written as $\\begin{array}{r}{L_{i j}=\\sum_{k}A_{i k}\\big(\\delta_{i j}-\\delta_{j k}\\big)}\\end{array}$ . We show that the Hessian of $\\mathcal{L}$ in equation 4 is a Laplacian. Let $\\partial_{i}\\equiv\\partial{\\bar{/}}\\partial X_{i}$ and let $\\hat{r}=\\eta r/r$ be the dual unit vector of $\\pmb{r}$ . First, observe that $\\partial_{i}r_{j k}\\overset{\\cdot}{=}\\hat{r}_{j k}(\\delta_{i j}-\\delta_{i k})$ where $\\hat{r}_{j k}$ is the unit vector of $\\pmb{r}_{j k}$ and $\\delta_{i j}$ is the Kronecker delta (1 if $i=j$ , 0 otherwise). Let ${\\mathrm{Hes}}[g]$ denote the Hessian of a function $g$ . We find that (app. E) ", "page_idx": 4}, {"type": "text", "text": "", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathrm{Hes}[\\mathcal{L}](X)_{i j}=\\partial_{i}\\partial_{j}\\mathcal{L}(X)=\\sum_{k}(\\delta_{i j}-\\delta_{j k})\\pmb{H}_{i k}(X)=\\mathrm{Lap}(\\pmb{H})_{i j}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $H_{i k}(X)=\\operatorname{Hes}[f_{i k}](r_{i k})$ . Note that $\\pmb{H}$ has four indices, with components $\\displaystyle H_{i j\\,.}^{\\mu\\nu}$ , having two particle indices $i,j$ and two spatial indices $\\mu,\\nu$ . Thus, for every pair of spatial indices $\\mu,\\nu$ , the Hessian $H^{\\mu\\nu}$ is a Laplacian over particle indices. The Hessian being Laplacian has an important effect on its null eigenvectors. To show this we make use of the incidence matrix. ", "page_idx": 5}, {"type": "text", "text": "We are interested in the eigenvalues and eigenvectors of $\\mathbf{H}$ , as these characterize the slow and fast modes of the system. First, given a weighted adjacency matrix $A$ of a graph, let $\\hat{A}$ and $\\hat{L}$ be the \u201cunweighted\u201d adjacency and Laplacian matrices, where $\\hat{A}_{i j}=1$ if $A_{i j}\\neq0$ and zero otherwise. It follows that the null spaces of $L$ and $\\hat{L}$ are shared: ", "page_idx": 5}, {"type": "text", "text": "Theorem 2.1 (Null Space of the Laplacian). Let $\\mathbf{Null}[M]$ denote the null space of a symmetric real matrix $M$ . The null space of the unweighted Laplacian $\\bar{\\hat{L}}$ is contained within the null space of the weighted Laplacian $L$ , i.e., $\\mathbf{Null}[\\hat{L}]\\subseteq\\mathbf{\\hat{Null}}[L]$ . ", "page_idx": 5}, {"type": "text", "text": "Sketch of proof. For any vector, $\\pmb{v}\\in\\mathbb{R}^{n}$ , $\\begin{array}{r}{\\pmb{v}^{T}\\mathrm{Lap}(\\boldsymbol{A})\\pmb{v}=\\sum_{i j}A_{i j}(v_{i}-v_{j})^{2}}\\end{array}$ . Since $\\hat{A}_{i j}=0$ yields $A_{i j}=0$ , but not necessarily vice versa, null vectors of $\\mathbf{Null}[\\hat{L}]\\subseteq\\mathbf{Null}[L]$ . See appendix for full proof. \u53e3 ", "page_idx": 5}, {"type": "text", "text": "Definition 2.1 (Slow manifold). Let $L$ be a graph Laplacian (undirected, weighted or unweighted), with spectral expansion $\\begin{array}{r}{L\\,=\\,\\sum_{i=1}^{n}\\lambda_{i}\\psi_{i}\\psi_{i}^{\\overline{{T}}}}\\end{array}$ . Let $\\varepsilon\\ll\\,1$ and $\\lambda_{\\operatorname*{max}}\\,=\\,\\operatorname*{max}\\{\\lambda_{i}\\}$ be the largest eigenvalue of $L$ . We define the slow manifold as ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathbf{Slow}_{\\varepsilon}[L]=\\operatorname{Span}\\bigl\\{\\psi_{i}\\bigl||\\lambda_{i}|<\\varepsilon^{2}\\lambda_{\\operatorname*{max}}\\bigr\\}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "Theorem 2.2 (Slow modes of weighted Laplacians). Let $A$ be the adjacency matrix of a weighted graph and $\\hat{A}$ be its unweighted counterpart. Let $L=\\operatorname{Lap}(A)$ and $\\hat{L}=\\mathrm{Lap}(\\hat{A})$ . Then $\\operatorname{Slow}_{\\varepsilon}[L]$ overlaps with $\\operatorname{Slow}_{\\varepsilon}[\\hat{L}]$ up to $O(\\varepsilon^{2})$ corrections from the rest of the modes. ", "page_idx": 5}, {"type": "text", "text": "The sketch of the proof relies on relating the spectra of the weighted and unweighted Laplacians using the incidence matrix $C$ , as $\\begin{array}{r}{L=\\frac{1}{2}C W C^{T}}\\end{array}$ and $\\hat{L}=\\frac{1}{2}C C^{T}$ . For a random configuration $X$ the edge weights $W$ will be random, as they arising from derivatives of $f_{i j}(r_{i j})$ in equation 20 (unless $f_{i j}$ is quadratic which makes $W$ constant). Then, using the assumption of randomness on the weights $W$ , we can show the slow modes of $L$ are perturbations of order $\\varepsilon^{2}$ on slow modes of $\\mathcal{\\hat{L}}$ . See Appendix $\\mathrm{D}$ for proof. ", "page_idx": 5}, {"type": "text", "text": "Implications for Coarse-Graining. The identification of slow modes in the Hessian is crucial for coarse-graining, as these modes capture the essential dynamics of the system at larger scales. By focusing on these slow modes, we can develop reduced models that retain the key physical properties while being computationally more efficient. ", "page_idx": 5}, {"type": "text", "text": "Coarse-Graining via Slow Modes. The identification of slow modes in the Hessian enables an effective coarse-graining approach, where fast dynamics are averaged out, retaining only the slow, relevant dynamics. This method is particularly advantageous in reducing computational complexity while preserving critical structural information. ", "page_idx": 5}, {"type": "text", "text": "2.2 Hessian Backbone and Robust Slow Modes ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "The slow modes of the Hessian $\\operatorname{Hes}[\\mathcal{L}](X)\\ =\\ \\operatorname{Lap}(H(X))$ can dynamically change during optimization. To ensure the robustness of these modes, we need a proxy for the unweighted adjacency matrix $\\hat{A}\\equiv\\mathbf{H}$ . To this end, we aggregate Hessians from perturbed configurations Samp $\\begin{array}{r}{\\dot{\\bf e s}(X)=\\{X^{\\prime}=X+\\delta X\\}}\\end{array}$ : ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathbf{H}_{i j}=\\sum_{X^{\\prime}\\in\\mathbf{Sample}(X)}\\|H_{i j}(X^{\\prime})\\|^{2}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "image", "img_path": "FwxOHl0BEl/tmp/1cb7d970c9ec5f4e1d62a0506c5e4bbc0ebf25c445a7d786f2f04158d19bf16e.jpg", "img_caption": [], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "Figure 2: Synthetic loop experiments. Example runs of the synthetic loop experiments with $n=400$ nodes. On the left $(\\mathtt{B o n d+L J})$ , the potential is the sum of a quadratic bond potential $E_{b o n d}$ and a weak LJ (12,6) $E_{L J}$ . The bonds form a line graph $A_{b o n d}$ connecting node $i$ to $i+1$ , and a 10 weaker $A_{l o o p}$ connecting node $i$ to $i+10$ via the LJ potential. To the right (Pure LJ) where the interactions are all LJ, but with a coupling matrix $A=A_{b o n d}+0.1A_{l o o p}$ . In Bond $+\\mathrm{LJ}$ , GD already finds good energies and the configuration is reasonably close to a loop, though flattened. Both linear CG reparametrization (CG Rep) and GNN also find a good layout. The pure LJ case is much more tricky. But in most runs, GD almost gets the layout, but some nodes remain far away. The CG Rep fails to bring all the pieces together. Only GNN succeeds in finding the correct layout. ", "page_idx": 6}, {"type": "image", "img_path": "FwxOHl0BEl/tmp/524b34a519c9c1da426ddd35c76a136763b9858f2f4da883cb85167850736f69.jpg", "img_caption": [], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "Figure 3: Synthetic loop folding $(n=1000)$ . Lower means better for both energy and time. In Bond $+\\mathrm{LJ}$ (left), a quadratic potential $\\textstyle\\sum_{i}(r_{i i+1}-1)^{2}$ attracts nodes $i$ and $i+1$ . A weak LJ potential attracts nodes $i$ and $i+10$ to form l oops. In LJ loop (right) both the backbone $i,i+1$ and the $10\\mathrm{x}$ weaker loop are LJ. Orange crosses denote the baseline GD, green is GNN and blue is CG. The dots are different hyperparameter settings (LR, Nr. CG modes, stopping criteria, etc.) with error bars over 5 runs. In Bond $+\\mathrm{LJ}$ , CG yields slightly better energies but takes longer, while GNN can converge faster to GD energies. In pure LJ, using CG and GNN can yield significantly better energies. ", "page_idx": 6}, {"type": "text", "text": "This aggregation helps identify consistently significant components across configurations, aiding in the extraction of reliable slow modes that remain effective over extended periods of optimization. In equation 7, $i,j\\in\\mathbb{Z}_{n}$ are the particle indices and the Frobenius norm $\\begin{array}{r}{\\|H_{i j}\\|^{2}=\\dot{\\sum}_{\\mu,\\nu}(H_{i j}^{\\mu\\nu})^{2}}\\end{array}$ sums over the feature indices (note that $X_{i}^{\\mu}$ has a particle index $i$ and a feature index $\\mu\\in\\{1,\\ldots d\\})$ . Then, we extract the slow modes of the backbone, by doing a spectral expansion $\\begin{array}{r}{{\\bf H}=\\sum_{i}\\lambda_{i}\\psi_{i}\\psi_{i}^{T}}\\end{array}$ and picking $\\psi_{i}$ with $|\\lambda_{i}|<\\varepsilon^{2}\\operatorname*{max}_{j}[\\lambda_{j}]$ , for some small $\\varepsilon<1$ . The intuition behind equation 7 is to identify the components in the sampled Hessians which have consistently high magnitudes. If we had taken a simple mean we could get very small values, because the components can fluctuate randomly. Also, if we had taken the variance instead of the norm, we would get zero for quadratic $\\mathcal{L}$ , where $H$ is constant and has no variance. As we discussed above, the slow modes of the backbone $\\mathbf{H}$ approximate the slow modes of sampled $H(X^{\\prime})$ up to $O(\\varepsilon^{2})$ errors. ", "page_idx": 6}, {"type": "text", "text": "3 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We apply our method to protein folding using classical MD forces. ", "page_idx": 6}, {"type": "text", "text": "Settings: We use gradient descent to minimize ${\\mathcal{L}}(X)$ . All experiments (both CG and baseline) use the Adam optimizer with a learning rate $10^{-2}$ and early stopping with $|\\delta\\mathcal{L}|=10^{-6}$ tolerance and 5 steps patience. We ran each experiment four times. ", "page_idx": 6}, {"type": "text", "text": "Baseline: we use gradient descent (GD) with Adam optimizer on the MD energy as baseline. ", "page_idx": 6}, {"type": "image", "img_path": "FwxOHl0BEl/tmp/d39ec2496b761a81fe9a27be4e47c60be580915388614eb753a7ce5285521aa7.jpg", "img_caption": ["Figure 4: Protein folding simulations Figure (a) shows the energy improvement factor (FG energy / GNN energy) in the function of the speedup factor (FG time / GNN time) for the six selected proteins marked with different colors (c). In all cases, the GNN parameterization leads to speed improvement while it converges higher energy. (b) However, the higher energy in some cases, 2JOF and 1UNC proteins, results in a slightly lower RMSD value, which measures how close the final layout is to the PDB layout. The data points are averaged over ten simulations per protein. "], "img_footnote": [], "page_idx": 7}, {"type": "image", "img_path": "FwxOHl0BEl/tmp/0fb9aa8b0c8fae77f84a6fa0444522464273b767758cadf7b8cf29604d5d25f3.jpg", "img_caption": ["Figure 5: 2JOF (Trp-Cage) protein folding. Figure (a) shows the RMSD value evolution of the 2JOF protein as it goes from an unfolded to a folded stage. At every step, we calculated the RMSD of the current layout compared to the PDB layout. We ran the OpenMM simulations at $298K$ temperature with 2fs timestep for 800000 steps, while the GNN and GD simulations were performed for 400000 steps with various hidden dimensions (10, 100, 300, 500). The black curves show the stochastic nature of protein folding using OpenMM. (b) The first figure shows the PDB (red) and unfolded (blue) layout; the second one is the GNN 500 final layout (blue), while the third is one of the OpenMM layouts, corresponding to the black curve. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "CG model: We use four different choices for the fraction of the eigenvectors to use in CG equation 3: $3\\times(\\#\\mathrm{AminoAcids})$ , $30\\%$ , $50\\%$ , and $70\\%$ . We use a two stage process. First, we use CG as in equation 3 $X=\\rho(Z)=Z^{T}\\Psi_{\\mathrm{\\bfSlow}}$ and minimize $\\mathcal{L}_{C G}(Z)=\\mathcal{L}(\\rho(Z))$ over $Z$ . After convergence to $X_{0}=\\rho(Z_{0})$ , we add $\\delta X$ to $X_{0}$ and optimize the fine-grained $\\delta X$ , starting with $\\delta X=0$ . ", "page_idx": 7}, {"type": "text", "text": "GNN model: We use a GNN consisting of a graph convolution (GCN) layer with self-loops and one node-wise MLP layer, projecting the GNN output to 3D to get particle positions. The GCN takes $Z_{h_{0}}\\in\\mathbb{R}^{n\\times h_{0}}$ as input, with $h_{0}>3$ and has weights $W_{G}\\in\\mathbb{R}^{\\tilde{h_{0}}\\times\\tilde{h_{1}}}$ . Then, GCN output gets a Tanh activation and is passed to the MLP layer to yield $X$ . The CG parameters in this case are $Z_{h},W_{G}$ and the weights and biases of the MLP. ", "page_idx": 7}, {"type": "text", "text": "Synthetic coil: We use quadratic and LJ potentials to make synthetic systems whose minimum energy state should be a coil (looping every 10 nodes), inspired by MD potentials. Figure 3 shows many experiments using GD, CG, and GNN. In the quadratic Bond+LJ case, GNN yields a good ", "page_idx": 7}, {"type": "image", "img_path": "FwxOHl0BEl/tmp/4ee1400daa546afe4ddba52b80df50487f7dcb7b6606aebe401cc456b13c993c.jpg", "img_caption": [], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "Figure 6: Learning rate and initialization in protein folding for pdb 2JOF: We conducted a sweep of the learning rate to see how robust the advantage of GNN over direct GD is. In a and b we show the energy achieved by GD and GNN vs the number of iterations and wallclock time. GNN1 and GNN2 use one and two GCN layers, respectively. We used early stopping which generally stopped the runs after $3{-}5\\mathrm{k}$ steps. The grey star shows the OpenMM results after 5k steps, which has a worse (higher) energy than our GD and GNN runs, but it takes a fraction of the time (it has many efficiency tricks that our code doesn\u2019t have). The dashed line shows the energy achieved by OpenMM after 10k steps. As we see, some of our GNN models reach energies close to the 10k steps of openMM in a fraction of the steps. All experiments show the best energy among three runs. c shows the effect of initialization on the GD runs. We do find the protein converges to significantly different conformations based on the init. ", "page_idx": 8}, {"type": "text", "text": "speedup, while CG yields better energies. The benefti of CG and GNN become more apparent in the harder pure LJ problem, where GD fails to find good energies, while CG finds much deeper energies, followed by GNN (Fig. 2). ", "page_idx": 8}, {"type": "text", "text": "Protein folding with classical MD: We implement a simplified force-field with implicit solvent (i.e. water molecules are not modeled and appear as hydrogen-bonding and hydrophobicity terms; app. A). In protein folding our energy function consists of five potential energies: bond length $E_{b o n d}$ , bond angles $E_{a n g l e}$ , van der Waals $E_{v d W}$ , hydrophobic $E_{h p}$ and hydrogen bonding $E_{H}$ Ceci et al. (2007). Figure 7 shows an example of these coupling matrices for the Enkephalin (1PLW) protein. To evaluate the effect of our CG model, we run experiments on four small proteins: Chignolin (5AWL), Trp-Cage (2JOF), Cyclotide (2MGO) and Enkephalin (1PLW). ", "page_idx": 8}, {"type": "text", "text": "Protein Folding with Classical MD Using AMBER Force Field In the updated simulation approach, we incorporate the AMBER force field, known for its accurate representation of molecular interactions, particularly in proteins. This force field is implemented using the parameters from OpenMM Eastman et al. (2017), and it comprehensively models the following interactions: ", "page_idx": 8}, {"type": "text", "text": "\u2022 Bond lengths $E_{b o n d}$ and bond angles $E_{a n g l e}$   \n\u2022 Torsional angles $E_{t o r s i o n}$   \n\u2022 Non-bonded interactions including van der Waals $E_{v d W}$ and electrostatic $E_{e l e c}$ forces ", "page_idx": 8}, {"type": "text", "text": "We utilize the functional forms and parameters specified in the AMBER force field: ", "page_idx": 8}, {"type": "equation", "text": "$$\n\\begin{array}{c c l}{{}}&{{E_{b o n d}=\\displaystyle\\sum_{b o n d s}k_{b o n d}(r-r_{0})^{2}}}&{{~~~~~~}}\\\\ {{}}&{{E_{t o r s i o n}=\\displaystyle\\sum_{t o r s i o n s}V_{n}\\left[1+\\cos(n\\omega-\\gamma)\\right]}}&{{~~~~~E_{v d W}=\\sum_{i<j}\\frac{A_{i j}}{r_{i j}^{12}}-\\frac{B_{i j}}{r_{i j}^{6}}}}\\\\ {{}}&{{}}&{{E_{e l e c}=\\sum_{i<j}\\frac{q_{i}q_{j}}{4\\pi\\epsilon_{0}\\epsilon_{r}r_{i j}}}}\\end{array}\\ }\\\\ {{}}&{{{}}}&{{E_{e l e c}=\\sum_{i<j}\\frac{A_{i j}}{4\\pi\\epsilon_{0}\\epsilon_{r}r_{i j}}}}\\end{array}\n$$", "text_format": "latex", "page_idx": 8}, {"type": "text", "text": "Here, $r$ and $\\theta$ represent the bond lengths and angles, respectively, with $r_{0}$ and $\\theta_{0}$ as their equilibrium values. The torsional term $E_{t o r s i o n}$ includes a sum over all torsion angles $\\omega$ , with periodicity $n$ , ", "page_idx": 8}, {"type": "text", "text": "amplitude $V_{n}$ , and phase $\\gamma$ . The Lennard-Jones potential in $E_{v d W}$ is characterized by parameters $A_{i j}$ and $B_{i j}$ , and $E_{e l e c}$ is calculated using the Coulombic potential with partial charges $q_{i},\\,q_{j}$ and the relative permittivity $\\epsilon_{r}$ . ", "page_idx": 9}, {"type": "text", "text": "In this simulation, we exclude the modeling of solvent effects entirely, focusing solely on the protein in vacuum. This approach simplifies the computational model while emphasizing the direct interactions within the protein. ", "page_idx": 9}, {"type": "text", "text": "The overall energy of the system is then given by: ", "page_idx": 9}, {"type": "equation", "text": "$$\n\\mathcal{L}(X)=E_{b o n d}+E_{a n g l e}+E_{t o r s i o n}+E_{v d W}+E_{e l e c}\n$$", "text_format": "latex", "page_idx": 9}, {"type": "text", "text": "Figure 7 shows the interaction matrices for the Enkephalin (1PLW) protein. Our framework has been extended to efficiently compute these energies and gradients, facilitating the simulation of protein folding dynamics in our coarse-grained model. We test our model on several small proteins including Chignolin (5AWL), Trp-Cage (2JOF), Cyclotide (2MGO), and Enkephalin (1PLW) to evaluate the effectiveness of our approach. ", "page_idx": 9}, {"type": "text", "text": "Protein results: Denoting the final energy and run time of the GNN model by $E_{G N N}$ and $t_{G N N}$ , and baseline by $E_{0}$ and $t_{0}$ , we compute the energy improvement factor $\\delta\\hat{E}=E_{0}/E_{G N N}$ and speedup factor $\\delta\\hat{t}=t_{0}/t_{G N N}$ , to plot different proteins together. Figure 4a shows the mean of $\\delta\\hat{E}$ vs $\\delta\\hat{t}$ over the 10 runs for GNN the model with hidden dimensions 300 (error bars are 1 STD). Overall, we find that all GNN models outperform the baseline in terms of run time and, eventually, also with energy improvement. To measure the folding quality, we use RMSD, comparing the final layouts to the PDB structure. ", "page_idx": 9}, {"type": "text", "text": "Figure 5 shows the RMSD value evolution using different methods. While, in most cases, OpenMM reaches a deeper RMSD value, our models could serve as a good initializer for accelerating molecular dynamics. To evaluate the robustness of these results, we ran sweeps over the learning rate, varied the number of GNN layers (one or two layers), and varied the initialization. ", "page_idx": 9}, {"type": "text", "text": "Figure 6 shows the results of these tests for the protein 2JOF. We used early stopping for switching from CG to FG in our GNN models and GD, resulting in 3-5k iteration steps. Compared with $5\\mathrm{k}$ steps of OpenMM simulations, both our GNN models and GD with Adam reach significantly deeper energies with fewer steps (a), with the lowest energies being all GNN. However, OpenMM takes less wall-clock time (b). Nevertheless, the depth of the energies achieved by GNN at $3{-}5\\mathrm{k}$ steps is close to 10k steps with OpenMM. More efficient implementations of our GNN may further improve these results. ", "page_idx": 9}, {"type": "text", "text": "4 Discussion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We showed preliminary evidence that CG through reparametrization can yield some improvements over non-CG baseline in protein folding, both in terms of run time as well as energy. This method has the advantage that it does not require force-matching or back-mapping. However, more experiments are needed to compare it against traditional CG methods. In fact, using ML to learn force-matching might provide further advantage by removing the need to evaluate $\\bar{\\mathcal{L}}_{C G}(Z)=\\mathcal{L}(X)$ via the finegrained modes $X$ . Also, while our canonical slow modes are derived for physical Hessians, the reparametrization approach to CG is general and could be applied to other ML problems. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgment ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "JM was partly supported by a grant from the MIT-IBM Watson AI Lab. CB\u2019s work was done partly during his internship at the MIT-IBM Watson AI Lab. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "Aleksandra E Badaczewska-Dawid, Andrzej Kolinski, and Sebastian Kmiecik. Computational reconstruction of atomistic protein structures from coarse-grained models. Computational and structural biotechnology journal, 18:162\u2013176, 2020. ", "page_idx": 9}, {"type": "text", "text": "G Ceci, A Mucherino, M D\u2019Apuzzo, Daniela Di Serafino, S Costantini, A Facchiano, and G Colonna. Computational methods for protein fold prediction: an ab-initio topological approach. Data Mining in Biomedicine, pp. 391\u2013429, 2007. ", "page_idx": 10}, {"type": "text", "text": "John Duchi, Elad Hazan, and Yoram Singer. Adaptive subgradient methods for online learning and stochastic optimization. Journal of machine learning research, 12(7), 2011. ", "page_idx": 10}, {"type": "text", "text": "Peter Eastman, Jason Swails, John D Chodera, Robert T McGibbon, Yutong Zhao, Kyle A Beauchamp, Lee-Ping Wang, Andrew C Simmonett, Matthew P Harrigan, Chaya D Stern, et al. Openmm 7: Rapid development of high performance algorithms for molecular dynamics. PLoS computational biology, 13(7):e1005659, 2017. ", "page_idx": 10}, {"type": "text", "text": "Roger Fletcher. Practical methods of optimization. John Wiley & Sons, 2013.   \nVineet Gupta, Tomer Koren, and Yoram Singer. Shampoo: Preconditioned stochastic tensor optimization. In International Conference on Machine Learning, pp. 1842\u20131850. PMLR, 2018.   \nScott A Hollingsworth and Ron O Dror. Molecular dynamics simulation for all. Neuron, 99(6): 1129\u20131143, 2018.   \nJaehyeok Jin, Alexander J Pak, Aleksander EP Durumeric, Timothy D Loose, and Gregory A Voth. Bottom-up coarse-graining: Principles and perspectives. Journal of Chemical Theory and Computation, 18(10):5759\u20135791, 2022.   \nDiederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.   \nGreg Landrum, Paolo Tosco, Brian Kelley, sriniker, gedeck, NadineSchneider, Riccardo Vianello, Ric, Andrew Dalke, Brian Cole, AlexanderSavelyev, Matt Swain, Samo Turk, Dan N, Alain Vaucher, Eisuke Kawashima, Maciej W\u00f3jcikowski, Daniel Probst, guillaume godin, David Cosgrove, Axel Pahl, JP, Francois Berenger, strets123, JLVarjo, Noel O\u2019Boyle, Patrick Fuller, Jan Holst Jensen, Gianluca Sforna, and DoliathGavid. rdkit/rdkit: 2020_03_1 (q1 2020) release, March 2020. URL https://doi.org/10.5281/zenodo.3732262.   \nLeandro E Lombardi, Marcelo A Mart\u00ed, and Luciana Capece. Cg2aa: backmapping protein coarsegrained structures. Bioinformatics, 32(8):1235\u20131237, 2016.   \nMaciej Majewski, Adri\u00e0 P\u00e9rez, Philipp Th\u00f6lke, Stefan Doerr, Nicholas E Charron, Toni Giorgino, Brooke E Husic, Cecilia Clementi, Frank No\u00e9, and Gianni De Fabritiis. Machine learning coarsegrained potentials of protein thermodynamics. Nature Communications, 14(1):5739, 2023.   \nJames Martens and Roger Grosse. Optimizing neural networks with kronecker-factored approximate curvature. In International conference on machine learning, pp. 2408\u20132417. PMLR, 2015.   \nAlexander J Pak and Gregory A Voth. Advances in coarse-grained modeling of macromolecular complexes. Current opinion in structural biology, 52:119\u2013126, 2018.   \nJorge Roel-Touris and Alexandre MJJ Bonvin. Coarse-grained (hybrid) integrative modeling of biomolecular interactions. Computational and structural biotechnology journal, 18:1182\u20131190, 2020.   \nDmitry Ulyanov, Andrea Vedaldi, and Victor Lempitsky. Deep image prior. In Proceedings of the IEEE conference on computer vision and pattern recognition, pp. 9446\u20139454, 2018.   \nWujie Wang, Minkai Xu, Chen Cai, Benjamin Kurt Miller, Tess Smidt, Yusu Wang, Jian Tang, and Rafael G\u00f3mez-Bombarelli. Generative coarse-graining of molecular conformations. arXiv preprint arXiv:2201.12176, 2022.   \nSoojung Yang and Rafael G\u00f3mez-Bombarelli. Chemically transferable generative backmapping of ", "page_idx": 10}, {"type": "text", "text": "coarse-grained proteins. arXiv preprint arXiv:2303.01569, 2023. ", "page_idx": 10}, {"type": "text", "text": "A Protein folding with classical MD ", "text_level": 1, "page_idx": 11}, {"type": "text", "text": "In protein folding our energy function consists of five potential energies for: bond length $E_{b o n d}$ , bond angles $E_{a n g l e}$ , Van der Waals $E_{v d W}$ , hydrophobic $E_{h p}$ and hydrogen bonding $E_{H}$ Ceci et al. (2007). Note that we are ignoring the solvent (e.g. water) and writing using potentials, or force fields. To calculate the force field, we use distance, $r$ , and angle-based, $\\Theta$ , potentials. For each amino acid, we use the rdkit Landrum et al. (2020) package to acquire bond length, $r_{0}$ , and bond angle, $\\theta_{0}$ (every triplet of atoms defining the bond), information that we use to define quadratic energies $E_{b o n d}$ and $E_{a n g l e}$ . We use Lennard-Jones (LJ) potentials, $V_{p,q}(r)=r^{-p}-r^{-q}$ , to approximate $E_{v d W}$ between all pairs of atoms, $E_{H}$ between atoms prone to form a hydrogen bond (certain $H$ and $O$ , in our case), $E_{h p}$ between atoms in hydrophobic residues, yielding ", "page_idx": 11}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\lefteqn{\\mathcal{L}(\\boldsymbol{X})=E_{b o n d}+E_{a n g l e}+E_{v d W}+E_{H}+E_{h p}}}\\\\ &{=k_{b o n d}(r-r_{0})^{2}+k_{a n g l e}(\\theta-\\theta_{0})^{2}}\\\\ &{\\qquad+\\,\\epsilon_{v d W}V_{12,6}\\left(\\frac{r}{\\sigma_{v d W}}\\right)+\\epsilon_{H}V_{6,4}\\left(\\frac{r}{\\sigma_{H}}\\right)+\\epsilon_{h p}V_{6,4}\\left(\\frac{r}{\\sigma_{h p}}\\right)}\\end{array}\n$$", "text_format": "latex", "page_idx": 11}, {"type": "text", "text": "Here the coupling matrix $[\\sigma_{v d W}]_{i j}=a_{i}+a_{j}$ where $a_{i}$ is the vdW radius of atom $i$ . For atoms which form H-bonds, $[\\sigma_{H}]_{i j}=(b_{i}\\cdot b_{j})1.5\\mathring\\mathrm{A}$ (hydrogen bonding radius) with $b_{i}=1$ if $i$ forms an H-bond, and $b_{i}=0$ otherwise. $[\\sigma_{h p}]_{i j}=c_{i}+c_{j}$ where $c_{i}=2\\mathring\\mathrm{A}$ if atom $i$ is in a hydrophobic residue and $c_{i}=0$ otherwise. ", "page_idx": 11}, {"type": "text", "text": "We note that our choices for $\\epsilon_{H}$ $H,\\epsilon_{v d W},\\epsilon_{h p}$ and $k_{b o n d},k_{a n g l e}$ , can be a source of error. Additionally, we \u201csoftened\u201d the LJ potential to $V_{p,q}=\\bar{1}/(r^{p}+\\zeta)-1/(\\bar{r}^{q}+\\zeta)$ with $\\zeta=0.65$ , which is large and significantly reduces the penalty for overlapping atoms and may reduce accuracy. ", "page_idx": 11}, {"type": "text", "text": "B Additional Figures ", "text_level": 1, "page_idx": 11}, {"type": "image", "img_path": "FwxOHl0BEl/tmp/1295f3aae17cde1840fc6f2bda23cf2971befcccb67088f5b23644e029723973.jpg", "img_caption": [], "img_footnote": [], "page_idx": 11}, {"type": "text", "text": "Figure 7: Enkephalin (1PLW). a) The peptide chain is built by stacking amino acids on each other using the peptide bond length from the literature, $1.32\\,\\mathring\\mathrm{A}$ . b) Van der Waals, hydrogen bond, and hydrophobic interaction matrix, that we use in the energy optimization. ", "page_idx": 11}, {"type": "text", "text": "C Energy minimization ", "text_level": 1, "page_idx": 11}, {"type": "text", "text": "Let $X\\in{\\mathcal{X}}\\simeq\\mathbb{R}^{n\\times d}$ be a set of degrees of freedom (e.g. particle positions, bond angles, etc.) and let $\\mathcal{L}:\\mathcal{X}\\rightarrow\\mathbb{R}$ be the energy (loss) function. We are interested in finding configurations $X^{*}$ which are local minima of $\\mathcal{L}$ . We can find such $X^{*}$ using a gradient descent (GD), or its continuous variant, gradient flow (GF) ", "page_idx": 11}, {"type": "equation", "text": "$$\n\\frac{d X}{d t}=-\\varepsilon\\pmb{\\nabla}\\mathcal{L}(X)\n$$", "text_format": "latex", "page_idx": 11}, {"type": "text", "text": "where $\\varepsilon$ is the matrix of learning rates (LR). In simple GD where $\\varepsilon=c I$ is a single constant times identity, GD evolves at different rates in different directions, with some being much slower than others. At a given $X$ , these \u201cslow modes\u201d are the eigenvectors of the Hessian $\\boldsymbol{H}(\\boldsymbol{X})=\\nabla\\nabla\\mathcal{L}(\\boldsymbol{X})$ with eigenvalues closest to zero, as we review below. We will first define fast and slow modes in the simple quadratic case and then generalize them to non-convex cases in the next section. ", "page_idx": 11}, {"type": "image", "img_path": "FwxOHl0BEl/tmp/df46fecb74c52f40dad227f23553f2093a3ee52688d01d5950286fba43980d5e.jpg", "img_caption": ["Figure 8: Comparison of performance of CG Hessian versus baseline MD. Point sizes correspond to the number of CG modes used. "], "img_footnote": [], "page_idx": 12}, {"type": "text", "text": "Fast and slow modes for quadratic Loss. Consider the case where ${\\mathcal{L}}(X)={\\textstyle{\\frac{1}{2}}}\\operatorname{Tr}\\{X^{T}H X\\}$ . Here $\\pmb{H}$ is a Hermitian matrix and the Hessian of $\\mathcal{L}$ , with a spectral expansion given by $H\\overset{\\cdot}{=}$ $\\textstyle\\sum_{i}\\lambda_{i}\\psi_{i}\\psi_{i}^{T}$ , $\\lambda_{i}\\in\\mathbb{R}$ and $\\psi_{i}\\,\\in\\,\\mathbb{R}^{n}$ . In this basis we have $\\begin{array}{r}{X(t)\\stackrel{}{=}\\sum_{i}c_{i}(\\bar{t})\\psi_{i}}\\end{array}$ with $c_{i}:\\mathbb{R}^{}\\rightarrow\\mathbb{R}^{d}$ . Projecting equation 13 onto one of the eigenmodes we get ", "page_idx": 12}, {"type": "equation", "text": "$$\n{\\frac{d c_{i}}{d t}}={\\boldsymbol{\\psi}}^{T}{\\frac{d X}{d t}}=-\\varepsilon\\lambda_{i}{\\boldsymbol{\\psi}}^{T}X=-\\varepsilon\\lambda_{i}c_{i}\n$$", "text_format": "latex", "page_idx": 12}, {"type": "text", "text": "where we assumed $d\\psi_{i}/d t=0$ . From equation 14 we see that the decay/growth rate along mode $\\psi_{i}$ is $\\left|\\varepsilon\\lambda_{i}\\right|$ . Hence, modes with $\\lambda_{i}$ close to zero are the \u201cslow modes\u201d, evolving very slowly, and large $|\\lambda_{i}|$ defines the \u201cfast modes\u201d. Since $c_{i}(t)=c_{i}(0)\\exp[-t/\\tau_{i}]$ with time scale $\\tau_{i}=1/(\\varepsilon\\lambda_{i})$ , the fast modes evolve exponentially faster than slow modes. This disparity in the rates results in slow convergence, because the fast modes force us to choose smaller $\\varepsilon$ to avoid numerical instabilities. Two potential ways to fix the issue with disparity in time scales are: 1) make rates isotropic (second-order methods and adaptive gradients); 2) mode truncation or compression (CG). We will briefly review the former here. ", "page_idx": 12}, {"type": "text", "text": "Adaptive gradient and second-order methods. Newton\u2019s method uses $\\varepsilon\\,=\\,\\eta H(X)^{-1}$ which makes GD isotropic along all modes, but it is expensive $(O((3n)^{3})$ in our case). Quasi-Newton methods, e.g. BFGS Fletcher (2013), approximate $\\dot{H}^{-1}$ iteratively, but are generally also slow. Another, Kmionrge mefaf ic&i eBnta  a(p2p0r1o4a)c hw ihsi cahd aapptpivreo xgirmadaitee $H$ mbeyt $\\sqrt{g_{t}g_{t}^{T}+\\eta}$ wAhdearGe $\\begin{array}{r}{g_{t}=\\sum_{i=1}^{k}\\gamma^{i}\\nabla\\mathcal{L}(X(t-i))}\\end{array}$ ims some discounted average over past gradients and $\\eta$ a small constant. Fo r efficiency, in practice we only use the diagonal part of this matrix to approximate $H^{-1}$ . As we will see in experiments, this approximation, while being far superior to GD with constant LR, is still very slow for MD tasks. ", "page_idx": 12}, {"type": "text", "text": "Most second-order methods are designed to work for generic problem and don\u2019t make strong assumptions about the spectrum of the Hessian. Recent second-order methods such as K-FAC Martens & Grosse (2015) and Shampoo Gupta et al. (2018) work with block diagonal approximations of the Hessian (or the Fisher information matrix), which usually emerges in deep learning models due to model architecture. Instead, we will exploit the spectral properties of the Hessian in physics problems. Fast and slow modes generally arise in physics due to vastly different strengths in forces (e.g. weak van der Waals vs strong chemical bonds). ", "page_idx": 12}, {"type": "image", "img_path": "FwxOHl0BEl/tmp/e0f697853eceb2105e09af09cc3ef5e184108468f7ba8a4e1ddb4ef746792b0f.jpg", "img_caption": ["Figure 9: The folded structures of the 2JOF protein by using the CG and baseline method. The numbers in front of the rows are the numbers of eigenvectors used in the CG reparametrization. Dashed frames show the minimum energy embedding in each case, while the thick line frame highlights the absolute minimum layout. "], "img_footnote": [], "page_idx": 13}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "C.1 Generalized fast and slow modes ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "The notion of fast and slow modes is helpful for the analysis of any time slice of the dynamics during which the Hessian is not changing dramatically. Consider a configuration $X(t)$ and let $\\delta t$ be a small time interval. We are looking for modes which are almost stationary over $\\delta t$ . To identify these modes, we can for instance find perturbations $\\delta X$ which would have almost zero dynamics. concretely we find the dynamics of $X+\\delta X$ as ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\frac{d}{d t}(X+\\delta X)=-\\varepsilon\\nabla\\mathcal{L}(X+\\delta X)\\approx-\\varepsilon\\nabla\\mathcal{L}(X)-\\varepsilon H\\delta X+O(\\delta X)^{2}\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "meaning, a small $\\delta X$ adds $\\varepsilon H\\delta X$ to the dynamics. ", "page_idx": 13}, {"type": "text", "text": "Thus if $\\delta X$ is a zero mode of the Hessian, $H\\delta X\\,=\\,0$ , it won\u2019t change the dynamics of $X$ . To define slow modes, we can slightly relax this and look for normalized modes $\\psi=\\delta X/\\|\\delta X\\|$ whose associated time scale is much longer than a desired time scale $\\delta t$ ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\tau=|\\varepsilon\\psi^{T}H\\psi|=|\\varepsilon\\lambda|\\gg\\delta t\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "which just means that we need to find the approximate zero modes of the Hessian $H(X)$ . ", "page_idx": 13}, {"type": "text", "text": "CG by projecting to the slow manifold. Because the dynamics of the modes above is very slow over $\\delta t$ , we can safely increase the time scale and run their dynamics over much longer periods $\\Delta t\\gg\\delta t$ . The essence of our algorithm is to ignore fast modes and project and evolve the system on the \u201cslow manifold\u201d spanned by the slow modes of the Hessian. However, the main challenge is how to deal with the fact that the Hessian is not constant and depends on the configuration $X$ . We address this point next. We show that for a large class of physical potentials one can find a reliable set of approximate slow modes. ", "page_idx": 13}, {"type": "text", "text": "D Properties of Physical Hessians ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Invariant potentials. In systems of interacting particles in physics, most of the leading interactions are pairwise and involve relative features, $\\pmb{r}_{i j}\\,\\equiv\\,X_{i}\\,-\\,X_{j}$ (distance vector, relative angle, etc). Moreover, they are often invariant under certain global symmetries, such as Euclidean symmetries (translation and rotation) or Lorentz symmetry (relativistic particles). These symmetries keep some 2-norm of vectors, $v^{2}\\;=\\;\\|v\\|_{\\eta}\\;\\stackrel{.}{=}\\;v^{T}\\eta\\dot{v}$ invariant. Here $\\eta$ may be the Euclidean metric $\\eta=\\mathrm{diag}(1,1,1)$ or the Minkowski metric $\\eta=\\mathrm{diag}(-1,1,1,1)$ for relativistic problems, etc. For example, the Euclidean norm ${\\pmb v}^{T}{\\pmb v}$ in $d$ dimensions is invariant under rotations $\\pmb{v}\\rightarrow\\pmb{g}\\pmb{v}$ , where $g\\in S O(d)$ , and the Minkowski norm is invariant under the Lorentz group $S O(1,d-1)$ . ", "page_idx": 14}, {"type": "text", "text": "Let $r$ denote the matrix of distances with $r_{i j}\\,=\\,\\|r_{i j}\\|_{\\eta}$ . Any function of $r_{i j}$ is invariant under symmetries that keep $\\|\\cdot\\|_{\\eta}$ invariant. A general invariant energy function can combine $r_{i j}$ for different $i,j$ in arbitrary ways. Usually in physical systems each pair contributes an additive term in to the total energy. Assuming additivity, the energy has a form ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathcal{L}(X)=\\sum_{i j}f_{i j}(r_{i j})\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "where $f_{i j}(z)=f_{j i}(z)$ (symmetric under $i\\leftrightarrow j$ ). For example, when particle $i$ has electric charge $q_{i}$ , the Coulomb potential between $i,j$ can be written as in equation 17 using $f_{i j}(z)=k q_{i}q_{j}\\bar{/}z$ . Similarly, weak van der Waals (vdW) forces in molecular systems, which are modeled as LennardJones potential, are also of the form in equation 17 with ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathrm{van\\;der\\;Waals:}\\quad\\ f_{i j}(r_{i j})=V_{p,q}\\left({\\frac{r_{i j}}{\\sigma_{i j}}}\\right),\\quad V_{p,q}(r)={\\frac{1}{r^{p}}}-{\\frac{1}{r^{q}}}.\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "Here $\\sigma_{i j}=a_{i}+a_{j}$ , where $a_{i}$ is the vdW radius of particle $i$ , and vdW uses $p=12,q=6$ . Next, we show that the Hessian of equation 17 has an important property which aids in finding its slow modes. ", "page_idx": 14}, {"type": "text", "text": "D.1 Hessian of invariant potentials ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "The Hessian of potentials of the form equation 17 has the special property that it is the graph Laplacian of a weighted graph which depends on $X$ , as we show now (see appendix E for details). This will play a crucial role in our argument about canonical slow modes. ", "page_idx": 14}, {"type": "text", "text": "Hessian as a graph Laplacian. Let $\\partial_{i}\\equiv\\partial/\\partial X_{i}$ and let $\\hat{r}=\\eta r/r$ be the dual unit vector of $\\pmb{r}$ . First, observe that $\\partial_{i}r_{j k}=\\hat{r}_{j k}\\big(\\delta_{i j}-\\delta_{i k}\\big)$ where $\\hat{r}_{j k}$ is the unit vector of $\\pmb{r}_{j k}$ and $\\delta_{i j}$ is the Kronecker delta (1 if $i=j$ , 0 otherwise). Let ${\\mathrm{Hes}}[g]$ denote the Hessian of a function $g$ . We find that (app. E) ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathrm{Hes}[\\mathcal{L}](X)_{i j}=\\partial_{i}\\partial_{j}\\mathcal{L}(X)=\\sum_{k}(\\delta_{i j}-\\delta_{j k})\\pmb{H}_{i k}(X)\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "where $H_{i k}(X)=\\operatorname{Hes}[f_{i k}](r_{i k})$ and given by ", "page_idx": 14}, {"type": "equation", "text": "$$\nH_{i k}(X)=\\left[\\left(f_{i k}^{\\prime\\prime}(v)-\\frac{f_{i k}^{\\prime}(v)}{v}\\right)\\hat{v}\\otimes\\hat{v}+\\frac{f_{i k}^{\\prime}(v)}{v}\\eta\\right]_{v=r_{i k}}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "Note that $\\pmb{H}$ has four indices, with components $H_{i j}^{\\mu\\nu}$ , having two particle indices $i,j$ and two spatial indices $\\mu,\\nu$ . Recall the Laplacian of an undirected graph with adjacency matrix $A$ is defined as $L\\,=\\,\\mathrm{Lap}(A)\\,=\\,D\\,-\\,A$ , where $D$ is the degree matrix with elements $\\begin{array}{r}{\\dot{D}_{i j}\\,=\\,\\delta_{i j}\\sum_{k}A_{i k}}\\end{array}$ . The components of Laplacian can also be written as $\\begin{array}{r}{L_{i j}=\\sum_{k}A_{i k}\\big(\\delta_{i j}-\\delta_{j k}\\big)}\\end{array}$ . Thus, we see that the Hessian of $\\mathcal{L}$ is indeed the Laplacian of $\\pmb{H}$ ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathrm{Hes}[\\mathcal{L}](X)_{i j}=\\sum_{k}(\\delta_{i j}-\\delta_{j k})\\pmb{H}_{i k}=\\mathrm{Lap}(\\pmb{H})_{i j}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "where for every pair of spatial indices the Hessian is a Laplacian over particle indices. The Hessian being Laplacian has an important effect on its null eigenvectors. To show this we make use of the incidence matrix. ", "page_idx": 14}, {"type": "text", "text": "D.2 Canonical backbone for the Hessian ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "As the Hessian depends on $X$ , it is not clear whether slow modes found at a given $X$ would be applicable to other $X$ . We need some guarantee that a set of modes exist which are approximately slow modes for the Hessian at a range of different $X$ . We could use multiple perturbed configurations $X+\\delta X$ with random $\\delta X\\sim\\mathcal{N}(0,\\mathbf{\\bar{}{}}T)$ to get an ensemble of Hessians $\\bar{\\mathcal{H}}=\\bar{\\left\\{H(X+\\delta X)\\right\\}}$ and find the overlap of the slow modes of the Hessians in $\\mathcal{H}$ . However, this is expensive, roughly $\\scriptstyle{\\hat{O}}(m k n^{2})$ for $m=|\\mathcal{H}|$ and $k$ slow modes. We cannot recompute the Hessian slow modes often. We also want a method which is more efficient than quasi-Newton methods such as BFGS. Our solution is to find a backbone for the sampled Hessians whose slow modes are guaranteed to be approximate slow modes of the actual Hessians. The key observation is that the Hessian in equation 21 is a Laplacian of a weighted graph. We show that the slow modes of weighted Laplacians overlap significantly with their unweighted counterparts. ", "page_idx": 15}, {"type": "text", "text": "We want to extract a set of slow modes from the sampled Hessians $H(X^{\\prime})$ . We then compute a backbone from these Hessians of the form ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{H}_{i j}=\\sum_{X^{\\prime}\\in\\mathbf{Sample}(X)}\\|H_{i j}(X^{\\prime})\\|^{2}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Here $i,j\\in\\mathbb{Z}_{n}$ are the particle indices and the Frobenius norm $\\begin{array}{r}{\\|H_{i j}\\|^{2}=\\sum_{\\mu,\\nu}(H_{i j}^{\\mu\\nu})^{2}}\\end{array}$ sums over the feature indices (note that $X_{i}^{\\mu}$ has a particle index $i$ and a feature index $\\mu\\in\\{1,\\ldots d\\})$ ). Then, we extract the slow modes of the backbone, by doing a spectral expansion $\\begin{array}{r}{{\\bf H}=\\sum_{i}\\lambda_{i}\\psi_{i}\\psi_{i}^{T}}\\end{array}$ and picking $\\psi_{i}$ with $|\\lambda_{i}|<\\varepsilon^{2}\\operatorname*{max}_{j}[\\lambda_{j}].$ , for some small $\\varepsilon<1$ . ", "page_idx": 15}, {"type": "text", "text": "The intuition behind equation 22 is to identify the components in the sampled Hessians which have consistently high magnitudes. If we had taken a simple mean we could get very small values, because the components can fluctuate randomly. Also, if we had taken the variance instead of the norm, we would get zero for quadratic $\\mathcal{L}$ , where $H$ is constant and has no variance. However, these intuitions do not show that there would be any connection between the modes of the backbone $\\mathbf{H}$ and the actual Hessians $H(X^{\\prime})$ . Importantly, entries in $H(X^{\\prime})$ have signs, which affects the spectrum, whereas all entries in $\\mathbf{H}$ are positive. So why should the spectra of $H$ and $\\mathbf{H}$ be related? This is where the structure of $\\mathcal{L}$ comes into play. Indeed, as we show below, for many physical $\\mathcal{L}$ , the slow modes of the backbone $\\mathbf{H}$ approximate the slow modes of sampled $H(X^{\\prime})$ up to $\\operatorname{\\bar{O}}(\\varepsilon^{2})$ errors. ", "page_idx": 15}, {"type": "text", "text": "Definition D.1 (weighted graph). Let $\\hat{\\mathcal{G}}=(\\nu,\\mathcal{E})$ be a graph with vertices $\\mathcal{V}=\\mathbb{Z}_{n}$ , edges $\\mathcal{E}\\subseteq\\mathcal{V}\\times\\mathcal{V}$ Let $\\hat{A}\\in\\mathbb{R}^{n\\times n}$ denote the adjacency matrix $\\hat{A}_{i j}\\,=\\,1\\;i f\\,(i,j)\\,\\in\\,\\mathcal{E}$ and 0 otherwise. We denote a weighted graph as $\\mathcal{G}=(\\mathcal{V},\\mathcal{E},\\mathcal{W})$ where $\\mathcal{W}:\\mathcal{E}\\to\\mathbb{R}$ are the weights of the edges. Let $A$ denote the adjacency matrix of $\\mathcal{G}$ , where $A_{i j}=\\mathcal{W}(i,j)$ or zero $i f(i,j)\\notin\\mathcal{E}$ . The Laplacian $L=\\operatorname{Lap}(A)$ of an undirected weighted graph is defined analogous to the unweighted graph as $L=D-A$ with degree matrix elements $\\begin{array}{r}{D_{i j}=\\bar{\\delta}_{i k}\\sum_{k}\\bar{A}_{i k}}\\end{array}$ . ", "page_idx": 15}, {"type": "text", "text": "Definition D.2 (Slow manifold). Let $L$ be a graph Laplacian (undirected, weighted or unweighted), with spectral expansion $\\begin{array}{r}{L\\,=\\,\\sum_{i=1}^{n}\\lambda_{i}\\psi_{i}\\psi_{i}^{\\tilde{T}}}\\end{array}$ . Let $\\varepsilon\\ll\\,1$ and $\\lambda_{\\operatorname*{max}}\\,=\\,\\operatorname*{max}\\{\\lambda_{i}\\}$ be the largest eigenvalue of $L$ . We define the slow manifold as ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{Slow}_{\\varepsilon}[L]=\\mathrm{Span}\\bigl\\{\\psi_{i}\\bigl||\\lambda_{i}|<\\varepsilon^{2}\\lambda_{\\mathrm{max}}\\bigr\\}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Theorem D.1 (Slow modes of weighted Laplacians). Let $A$ be the adjacency matrix of a weighted graph and $\\hat{A}$ be its unweighted counterpart. Let $L=\\operatorname{Lap}(A)$ and $\\hat{L}=\\mathrm{Lap}(\\hat{A})$ . Then $\\operatorname{Slow}_{\\varepsilon}[L]$ overlaps with $\\operatorname{Slow}_{\\varepsilon}[\\hat{L}]$ up to $O(\\varepsilon^{2})$ corrections from the rest of the modes. ", "page_idx": 15}, {"type": "text", "text": "To prove this we will make use of the incidence matrix representation of the Laplacian. ", "page_idx": 15}, {"type": "text", "text": "Definition D.3 (Incidence matrix). Given a weighted graph $\\mathcal{G}=(\\mathcal{V},\\mathcal{E},\\mathcal{W})$ , define its incidence matrix as $C:\\mathcal{V}\\times\\mathcal{E}\\to\\{\\pm1\\},$ , where for any edge $e=(i\\to j)\\in\\mathcal{E}$ , $C_{i,e}=-1$ and $C_{j,e}=1$ , and zero for other components. ", "page_idx": 15}, {"type": "text", "text": "Lemma D.2 (Laplacian in terms of the incidence matrix). Let $w=\\mathrm{vec}(\\mathcal{W}(\\mathcal{E}))$ be the vector of all weights indexed in the same order as the columns of $C$ , with $w_{e}=A_{i j}$ , for $\\boldsymbol{e}=(i,j)$ and let $W$ be a diagonal matrix with w on its diagonal. Then, the Laplacian $L=\\operatorname{Lap}(A)$ can be written as $\\begin{array}{r}{L=\\frac12C\\dot{\\boldsymbol{W}}C^{T}}\\end{array}$ (proof in app. E.1). ", "page_idx": 15}, {"type": "text", "text": "Because $\\mathcal{G}$ and $\\hat{\\mathcal G}$ share the same vertices and edges, their incidence matrix $C$ is the same. From Lemma D.2, $\\begin{array}{r}{L=\\frac{1}{2}C W C^{T}}\\end{array}$ and $\\begin{array}{r}{\\hat{L}\\,=\\,\\frac{1}{2}C C^{T}}\\end{array}$ as $\\hat{\\mathcal G}$ is unweighted. Using SVD, $C=U S V^{T}$ and defining $R=U S/\\sqrt{2}$ and $Q=V^{T}W V$ , we have ", "page_idx": 15}, {"type": "text", "text": "", "page_idx": 16}, {"type": "equation", "text": "$$\n\\hat{L}=R R^{T}\\qquad\\qquad\\qquad\\qquad L=R Q R^{T}.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Note that for a random configuration $X$ the edge weights $W$ will be random, as they arising from derivatives of $f_{i j}(r_{i j})$ in equation 20 (unless $f_{i j}$ is quadratic which makes $W$ constant). Therefore, we will assume $Q$ has a uniform Gaussian distribution. Assuming $W$ is also Gaussian, the spectrum of such a $Q\\;=\\;V^{T}W V$ is somewhere between the distribution of $W$ (for sparse graphs with $|\\mathcal{E}|\\sim O(|\\mathcal{V}|))$ and a Wigner Semi-circle (for dense graphs with $|\\mathcal{E}|\\sim O(|\\mathcal{V}|^{2}))$ . See appendix E.2 for more discussion. We also assume $Q$ has no particular block structure and that the spectrum of any diagonal block of $Q$ should also follows a distribution similar to all of $Q$ . ", "page_idx": 16}, {"type": "text", "text": "Slow subspace. We now sketch the proof for Theorem D.1. For details, refer to appendix E.4. From the SVD, $\\bar{\\boldsymbol{C}}=\\boldsymbol{U}\\boldsymbol{S}\\boldsymbol{V}^{T}$ , the slow subspace is ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{Slow}_{\\varepsilon}[\\hat{L}]=\\left\\{i\\big|S_{i i}<\\varepsilon\\operatorname*{max}[S]\\right\\}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Normalize $\\hat{S}=S/\\operatorname*{max}[S]$ and make them all positive (e.g. absorb their sign into $U$ ). For some $\\varepsilon<1$ sort the SV such that $\\hat{S}=\\mathrm{diag}(S_{\\varepsilon},S_{1})$ where the diagonal matrices $S_{\\varepsilon}\\,<\\,\\varepsilon$ and $S_{1}\\,\\geq\\,\\varepsilon$ . Now, the problem of finding $\\operatorname{Slow}_{\\varepsilon}[L]$ becomes finding eigenvectors of the matrix $\\hat{M}=\\hat{S}Q\\hat{S}^{T}$ with eigenvalues $O(\\varepsilon^{2})$ . Using $S_{\\varepsilon}\\sim O(\\varepsilon)$ and $S_{1}\\sim O(1)$ , we can pull factors of $\\varepsilon$ out from $\\hat{M}$ and write it as ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\hat{M}=M_{0}+\\hat{\\varepsilon}\\delta M,\\qquad\\qquad M_{0}=\\left(\\hat{\\varepsilon}^{2}\\hat{A}}&{0\\right),\\qquad\\qquad\\delta M=\\left(\\hat{\\theta}\\quad\\hat{B}\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where $\\hat{\\varepsilon}^{2}\\equiv\\varepsilon^{2}\\sqrt{n_{A}/n_{C}}$ is rescaled so that the random matrices $\\hat{A}\\in\\mathbb{R}^{n_{A}\\times n_{A}}$ and $C\\in\\mathbb{R}^{n_{C}\\times n_{C}}$ have a similar range of eigenvalues. Next, using a perturbative ansatz for eigenvectors $\\psi^{\\prime}=\\psi+\\hat{\\varepsilon}\\delta\\psi$ and eigenvalues $\\lambda^{\\prime}=\\lambda+\\hat{\\varepsilon}\\delta\\lambda$ , we solve $\\hat{M}\\bar{\\psi^{\\prime}}=\\bar{\\lambda^{\\prime}}\\psi^{\\prime}$ up to $O(\\hat{\\varepsilon}^{2})$ corrections. ", "page_idx": 16}, {"type": "text", "text": "To find slow modes for $L$ we start from $\\psi\\in\\operatorname{Slow}_{\\varepsilon}[\\hat{L}]$ . Specifically, we start with an eigenvector $\\psi_{A}$ of $\\hat{A}$ and concatenate it with zeros to get $\\psi=(\\psi_{A},0)$ . We have $M_{0}\\psi=\\lambda\\psi$ with $\\lambda=\\hat{\\varepsilon}^{2}\\lambda_{A}$ . Using first-order perturbation theory, we find the corrections $\\delta\\lambda$ to the eigenvalues and eigenvectors to be ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\delta\\lambda=\\psi^{T}\\delta M\\psi=0,\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\delta\\psi=-(M_{0}-\\lambda)^{-1}\\delta M\\psi=\\left(\\!\\!\\!\\begin{array}{c}{{0}}\\\\ {{(C-\\lambda)^{-1}\\hat{B}^{T}\\psi_{A}}}\\end{array}\\!\\!\\!\\right).\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Putting all together we find the slow eigenvector $\\psi^{\\prime}=\\psi+\\hat{\\varepsilon}\\delta\\psi$ up to order $O(\\varepsilon^{2})$ to be ", "page_idx": 16}, {"type": "equation", "text": "$$\n{\\bf S l o w}_{\\varepsilon}[L]\\ni\\psi^{\\prime}=\\left(\\hat{\\varepsilon}(C-\\hat{\\varepsilon}^{2}\\lambda_{A})^{-1}\\hat{B}^{T}\\psi_{A}\\right),\\qquad\\hat{M}\\psi^{\\prime}=\\hat{\\varepsilon}^{2}\\lambda\\psi^{\\prime}+O(\\hat{\\varepsilon}^{2})=O(\\hat{\\varepsilon}^{2}).\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "meaning to first order in $\\hat{\\varepsilon}$ the corrections to eigenvalues of slow modes vanishes. This is desired because the slow mode eigenvalues are $O(\\hat{\\varepsilon}^{2})$ . We also observe that slow modes of $L$ are mostly confined to $\\operatorname{Slow}_{\\varepsilon}[\\hat{L}]$ and only get $O(\\varepsilon)$ contributions from the fast subspace of $\\hat{L}$ . ", "page_idx": 16}, {"type": "text", "text": "As a side, it follows that all weighted graphs share the null space of the unweighted Laplacian. ", "page_idx": 16}, {"type": "text", "text": "Proposition D.3 (Shared null space). Let $\\mathbf{Null}[M]=\\mathrm{Span}\\{v|v\\in\\mathbb{R}^{n},M v=0\\}$ denote the null space of a matrix $M\\in\\mathbb{R}^{n\\times n}$ . The null space of the Laplacian $\\hat{L}$ (unweighted) is contained in the null space of Laplacian $L$ (weighted), meaning $\\mathbf{Null}[\\hat{L}]\\subseteq\\mathbf{Null}[L]$ . ", "page_idx": 16}, {"type": "text", "text": "Lemma D.4. $\\mathbf{Null}[{\\hat{L}}]=\\mathbf{Null}[R^{T}]$ ", "text_level": 1, "page_idx": 16}, {"type": "equation", "text": "$$\n\\forall v\\in\\mathbf{Null}[\\hat{L}],0=v^{T}\\hat{L}v=\\Vert\\mathbb{R}^{T}v\\Vert^{2}\\mathrm{~and~}\\forall v\\in\\mathbf{Null}[R^{T}],\\hat{L}v=R R^{T}v=0.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "equation", "text": "$$\n,\\;L v=R Q R^{T}v=0\\;\\mathrm{hence},\\,\\mathbf{Null}[\\hat{L}]\\subseteq\\mathbf{Null}[L].\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Note that $\\mathbf{Null}[\\hat{L}]$ and $\\subseteq\\mathbf{Null}[L]$ are not necessarily the same because weights can be zero, which could make the null space of the weighted graph larger than the unweighted one. Next, we present our method for coarse-graining using a set of canonical slow modes. ", "page_idx": 16}, {"type": "text", "text": "E Invariant additive dyadic potentials ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "We want to Compute the Hessian of equation 17, $\\begin{array}{r}{\\mathcal{L}(\\boldsymbol{X})=\\sum_{i j}\\bigl(r_{i j}\\bigr)}\\end{array}$ . Let $\\hat{r}=\\eta\\pmb{r}/r$ be the dual unit vector of $\\pmb{r}$ . First, note that ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{l}{{\\displaystyle\\partial_{i}r_{j k}\\equiv\\frac{\\partial r_{j k}}{\\partial X_{i}}=\\partial_{i}\\sqrt{\\|X_{j}-X_{k}\\|_{\\eta}}}}\\\\ {{\\displaystyle~~~~~~~=\\eta\\frac{r_{j k}}{r_{j k}}(\\delta_{i j}-\\delta_{i k})=\\hat{r}_{j k}(\\delta_{i j}-\\delta_{i k})}}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Then the gradient becomes ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\partial_{i}\\mathcal{L}(X)=\\displaystyle\\sum_{j,k}f_{j k}^{\\prime}(r_{j k})\\frac{\\partial r_{j k}}{\\partial x_{i}}}\\\\ &{\\qquad\\qquad=\\displaystyle\\sum_{j,k}f_{j k}^{\\prime}(r_{j k})\\eta\\hat{r}_{j k}(\\delta_{i j}-\\delta_{i k})}\\\\ &{\\qquad\\qquad=2\\displaystyle\\sum_{j}f_{i j}^{\\prime}(r_{i j})\\eta\\hat{r}_{i j}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "where we used $\\hat{r}_{j k}=-\\hat{r}_{k j}$ to show both terms in $(\\delta_{i j}\\mathrm{~-~}\\delta_{i k})$ yield the same output. Finally, the Hessian becomes ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{H(X)_{i j}=\\partial_{\\nu}\\mathcal{L}(X)=2\\partial_{\\nu}\\sum_{\\stackrel{k}{=}\\kappa}\\tilde{f}_{i}(r_{k i})\\tilde{r}_{k i}}&{}\\\\ {=2\\sum_{k}\\tilde{f}_{i k}^{\\kappa}(r_{k i})\\partial_{\\nu}\\kappa\\,\\tilde{\\rho}_{k i}+\\tilde{f}_{k i}(r_{k i})\\tilde{\\rho}_{k i}\\tilde{\\rho}_{k i}}\\\\ &{=2\\sum_{k}\\left[\\left(\\tilde{\\rho}_{k i}-\\tilde{\\rho}_{k i}\\right)\\tilde{r}_{k i}^{\\kappa}(r_{k i})\\tilde{r}_{k i}\\tilde{\\rho}_{k i}\\tilde{r}_{k i}}\\\\ &{\\qquad+\\tilde{f}_{k i}^{\\kappa}(r_{k i})\\left(\\eta\\frac{\\tilde{\\rho}_{k i}-\\tilde{\\rho}_{k j}}{r_{k i}}-\\frac{\\tilde{r}_{k i}}{r_{k i}^{\\kappa}}\\partial_{\\nu}r_{k i}\\right)\\right]}\\\\ &{=2\\sum_{k}\\tilde{\\rho}_{i k}-\\delta_{j k}\\left[\\int_{r_{k}}^{\\tilde{\\rho}_{k}}(r_{k i})\\tilde{r}_{k i}\\otimes\\tilde{r}_{k i}+\\tilde{f}_{k i}^{\\kappa}(r_{k i})\\left(\\frac{\\eta}{r_{k i}}-\\frac{\\tilde{r}_{k i}}{r_{k i}^{\\kappa}}\\otimes\\tilde{r}_{k i}\\right)\\right]}\\\\ &{=2\\sum_{k}\\left[\\tilde{f}_{i k}^{\\kappa}(r_{k i})\\tilde{\\rho}\\otimes\\tilde{\\phi}+\\frac{\\tilde{f}_{k i}^{\\kappa}(r_{k i})}{r_{k i}^{\\kappa}}(\\eta-\\tilde{\\rho}_{k i})\\right]_{\\kappa,\\eta}(\\delta_{j}-\\delta_{j k})}\\\\ &{=2\\sum_{k}\\left[\\left(\\tilde{f}_{j k}^{\\kappa}(r_{k i})-\\frac{\\tilde{f}_{j k}^{\\kappa}(r_{k j})}{r_{k i}}\\right)\\delta\\otimes\\tilde{\\phi}+\\frac{\\tilde{f}_{k}^{\\kappa}(r_{k i})}{r_{k i}^{\\kappa}}\\tilde{\\rho}_{k i}\\right]_{\\kappa,\\eta}(\\delta_{j}-\\delta_{j k})}\\\\ &{\\geq\\sum_{k}\\tilde{\\mu}_{i k}(\\boldsymbol{\\alpha})(\\delta_{j}-\\delta_{j k})=\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "This is because the components of Laplacian can be be written ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{l}{{\\displaystyle{\\cal L}_{i j}=\\mathrm{Lap}(A)_{i j}=(D-A)_{i j}}}\\\\ {{\\displaystyle\\qquad=\\delta_{i j}\\sum_{k}A_{i k}-A_{i j}=\\sum_{k}A_{i k}(\\delta_{i j}-\\delta_{j k})}}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "E.1 Incidence matrix ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "The Laplacian $L=D-A$ of an undirected graph with adjacency $A$ can be written as $L=C W C^{T}/2$ using the incidence matrix $C$ and the edge weights $W$ . This can be shown as follows ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{[C W C^{T}]_{i j}=\\underset{\\epsilon}{\\sum}C_{i}^{\\epsilon}W_{\\epsilon}C_{j}^{\\epsilon}}\\\\ {=\\underset{k,l}{\\sum}C_{i}^{(k-l)}\\mathrm{~}A_{k l}C_{j}^{(k-l-1)}}\\\\ {=\\underset{k,l}{\\sum}(\\delta_{i l}-\\delta_{i k})A_{k l}(\\delta_{j l}-\\delta_{j k})}\\\\ {=\\underset{k,l}{\\sum}(\\delta_{i l}\\delta_{j l}-\\delta_{i k}\\delta_{j l}-\\delta_{i l}\\delta_{j k}+\\delta_{i k}\\delta_{j k})A_{k l}}\\\\ {=\\underset{k,l}{\\sum}(\\delta_{i l}\\delta_{j l}-\\delta_{i k}\\delta_{j l})A_{k l}}\\\\ {=2\\underset{k,l}{\\sum}\\delta_{i j}A_{k j}-2A_{i j}=2(D-A)_{i j}=2L_{i j}}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where we assumed $A_{k l}=A_{l k}$ (undirected graph). ", "page_idx": 18}, {"type": "text", "text": "So the same derivation of the backbone also holds for this case. The idea is that using the incidence matrix $C$ and edge weights $W$ (as a diagonal matrix), any Laplacian $L$ can be decomposed as $L=C W C^{T}$ . Then, doing SVD $\\dot{C}=U S\\bar{V}^{T}$ we have ", "page_idx": 18}, {"type": "equation", "text": "$$\nL=U S V^{T}W V S^{T}U^{T}=U M U^{T}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Where the matrix $M=S V^{T}W V S^{T}$ has an interesting property, namely that its null space includes the null space of the unweighted Laplacian $L_{0}=C C^{T}$ . To see this note that $L_{0}=U S\\dot{S}^{T}S^{T}$ , which means columns $U_{i}$ are the eigenvectors of $L_{0}$ with eigenvalues $S_{i}^{2}$ . The null eigenspace of $L_{0}$ are the $U_{i}$ for which $S_{i}=0$ . This subspace will also be a null subspace for $L$ , because that block is also zero in $M$ , because $\\begin{array}{r}{M_{i j}=\\sum_{c}S_{i}\\bar{V}_{i k}W_{k k}V_{j k}S_{j}}\\end{array}$ . So, whenever $S_{i}=0$ or $S_{j}=0$ , $M_{i j}\\,=\\,0$ , meaning that whole block in $M$ is zero and $M U_{i}=0$ ( write it better). ", "page_idx": 18}, {"type": "text", "text": "Example: power law. Let $f(r)=r^{p}$ . We have $f^{\\prime}=p r^{p-1}$ and $f^{\\prime\\prime}=p(p-1)r^{p-2}$ , yielding the Hessian ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{l}{{\\displaystyle{\\cal H}=\\nabla\\nabla f(r)=r^{p-2}\\left[\\left(p^{2}-2p\\right)\\hat{r}\\otimes\\hat{r}+p\\eta\\right]}}\\\\ {{\\mathrm{}}}\\\\ {{\\displaystyle B_{i k}=A_{i k}r_{i k}^{p-2}\\left[\\left(p^{2}-2p\\right)\\hat{r}_{i k}\\otimes\\hat{r}_{i k}+p\\eta\\right]}}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Example: Lennard-Jones. This potential has the form ", "page_idx": 18}, {"type": "equation", "text": "$$\nf(r)=4\\varepsilon\\left[\\left({\\frac{\\sigma}{r}}\\right)^{p}-\\left({\\frac{\\sigma}{r}}\\right)^{q}\\right]\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where for classic van-der Waals potential $p=2q=12$ . The Hessian for this potential is given by ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\pmb{H}(r)=\\nabla\\nabla f(r)=\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{p+2}\\left[\\left(p^{2}+2p\\right)\\hat{r}\\otimes\\hat{r}-p\\eta\\right]-\\left(\\frac{\\sigma}{r}\\right)^{q+2}\\left[\\left(q^{2}+2q\\right)\\hat{r}\\otimes\\hat{r}-q\\eta\\right]\\right]\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "and $B_{i k}=A_{i k}H(r_{i k})$ ", "page_idx": 18}, {"type": "text", "text": "E.2 Structure and spectrum of of $Q=V^{T}W V$ ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "To consider only the relevant subspace of SVD, we have $U,S\\in\\mathbb{R}^{n\\times n}$ , and $V\\in\\mathbb{R}^{m\\times n}$ , with $n=|\\gamma|$ and $m=|\\mathcal{E}|$ . For a connected undirected graph $m\\geq2(n-1)$ and $V$ is full rank $(V^{T}V={\\dot{I}}_{n})$ ). Note the edge weights $W$ come from the forces $f_{i j}(r_{i j})$ in equation 20, which for an arbitrary $X$ will be random. Assuming a Gaussian distribution $\\overrightharpoon{W_{e e}}\\sim\\tilde{\\mathcal{N}}(0,\\sigma)$ for all edges $e$ , the matrix $Q$ will also have random Gaussian entries. When $m\\,=\\,n$ , $V$ defines the eigenbasis of $Q$ and $W_{e e}$ are the eigenvalues of $Q$ . Similarly, in sparse graphs, where $m\\sim O(n)$ , $V$ is approximately the eigenbasis and the spectrum of $Q$ should have a distribution similar to $W_{e e}$ . For dense graphs, where $m\\\"\\sim O(n^{2})$ , every entry of $Q$ will involve a weighted sum over multiple $W_{e e}$ . Then, from central limit theorem, entries of $Q$ will asymptotically have a Gaussian distribution. From random matrix theory, we know that such $Q$ will have a spectrum which follows the Wigner-semi-circle law. In both cases (sparse and dense graphs) the spectrum of $Q$ has a finite variance and sits somewhere between a Gaussian and a semi-circle. ", "page_idx": 18}, {"type": "text", "text": "", "page_idx": 19}, {"type": "text", "text": "E.3 Generalization to nonzero but small SV ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "We want to know how much the slow modes of weighted and unweighted graphs to overlaps. With the spectral expansion $\\begin{array}{r}{\\hat{L}=\\sum_{i}\\lambda_{i}\\psi_{i}\\psi_{i}^{T}}\\end{array}$ Define the slow subspace as in equation 23 ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\mathbf{Slow}_{\\varepsilon}[\\hat{L}]=\\mathrm{Span}\\big\\{\\psi_{i}\\big||\\lambda_{i}|<\\varepsilon^{2}\\lambda_{\\mathrm{max}}(\\hat{L})\\big\\}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "where $\\lambda_{\\operatorname*{max}}(\\hat{L})=\\operatorname*{max}\\{\\lambda_{i}\\}=\\operatorname*{max}_{\\psi}[\\psi^{T}L\\psi/\\|\\psi\\|^{2}]$ is the largest eigenvalue of $L$ and $\\varepsilon\\ll1$ . In terms of the singular values (SV) of the incidence matrix $C=U S V^{T}$ , the slow subspace becomes ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\mathbf{Slow}_{\\varepsilon}[\\hat{L}]=\\left\\{i\\big|S_{i i}<\\varepsilon\\operatorname*{max}[S]\\right\\}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "We will show that the slow modes in weighted $L=C W C^{T}$ are perturbations to the slow modes of $\\hat{L}$ . Define ", "page_idx": 19}, {"type": "equation", "text": "$$\nM=S V^{T}W V S^{T}=S Q S^{T}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Normalize $\\hat{S}=S/\\operatorname*{max}[S]$ . Break the space down to the slow and fast subspaces, based on whether $\\hat{S}_{i i}<\\varepsilon$ or not. First, since $L$ is positive semi-definite, we can make all $S_{i i}\\geq0$ . Let $\\hat{S}=S/\\operatorname*{max}S$ We sort the dimensions in $\\hat{S}$ to have the small SVs appear first. Denote the block in $\\hat{S}$ where $S_{i i}<\\varepsilon$ by $S_{\\varepsilon}$ . We have ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\hat{S}^{2}=\\left(\\!\\!\\begin{array}{c c}{{S_{\\varepsilon}^{2}}}&{{0}}\\\\ {{0}}&{{S_{1}^{2}}}\\end{array}\\!\\!\\right)<\\left(\\!\\!\\begin{array}{c c}{{\\varepsilon^{2}}}&{{0}}\\\\ {{0}}&{{1}}\\end{array}\\!\\!\\right)\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "We know the null space of $\\hat{L}$ , where $S_{i i}=0$ , is shared with $L$ . First, we remove the null space from $L$ and $\\hat{L}$ , calling the remainder $L_{0}$ and $\\hat{L}_{0}$ and the remaining $\\mathrm{SVs}\\;\\hat{S}$ . Then in this remainder subspace we need to find parts which are $O(\\varepsilon)$ . We sort the dimensions in $\\hat{S}$ to have the small SVs appear first. We denote the block in $\\hat{S}$ where $S_{i i}^{2}<\\varepsilon\\operatorname*{max}[S^{2}]$ by $S_{\\varepsilon}$ . We have ", "page_idx": 19}, {"type": "equation", "text": "$$\nM=\\operatorname*{max}[S]^{2}\\hat{S}Q\\hat{S}^{T}=\\left(\\!\\!\\begin{array}{l l}{S_{\\varepsilon}Q_{\\varepsilon\\varepsilon}S_{\\varepsilon}}&{S_{\\varepsilon}Q_{\\varepsilon1}S_{1}}\\\\ {S_{1}Q_{\\varepsilon1}^{T}S_{\\varepsilon}}&{S_{1}Q_{11}S_{1}}\\end{array}\\!\\!\\right)=\\left(\\!\\!\\begin{array}{c c}{M_{\\varepsilon\\varepsilon}}&{M_{\\varepsilon1}}\\\\ {M_{\\varepsilon1}^{T}}&{M_{11}}\\end{array}\\!\\!\\right)\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Because $S_{\\varepsilon}$ is $O(\\varepsilon)$ and $S_{1}$ is $O(1)$ , we will factor out the factors of $\\varepsilon$ from blocks in $M$ and write ", "page_idx": 19}, {"type": "equation", "text": "$$\nM=\\operatorname*{max}[S]^{2}\\left({\\varepsilon}^{2}A\\quad{\\varepsilon}B\\right)\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Here $A$ and $C$ are random matrices built from their corresponding blocks in $Q$ and sandwiched between $S_{\\varepsilon}/\\varepsilon$ (for $A$ ), and $S_{1}$ (for $C$ ), which have $O(1)$ values. The spectrum of $Q$ has a distribution between a Gaussian with mean zero and a Wigner semi-circle, also centered around zero. We expect spectra of $A$ and $C$ to be similar to $Q$ . Denote the spectral expansion of $Q$ as ", "page_idx": 19}, {"type": "equation", "text": "$$\nQ=\\Psi\\Lambda\\Psi^{T},\\qquad\\qquad\\qquad\\Lambda=\\mathrm{diag}(\\lambda_{i})_{i=1}^{n},\\qquad\\qquad\\qquad\\Psi=[\\psi_{i}]_{i=1}^{n}.\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "This is because when $Q_{i j}\\sim\\mathcal{N}(0,\\sigma)$ we have (ignoring Bessel\u2019s correction for $k\\gg1$ ). ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\sigma^{2}=\\mathrm{Var}(Q_{i j})\\approx\\frac{1}{n}\\|Q\\|^{2}=\\frac{1}{n}\\sum_{i}\\lambda_{i}^{2}=\\mathrm{Var}(\\Lambda)\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "where we assumed ${\\mathrm{Tr}}\\{Q\\}/n\\approx{\\mathrm{mean}}(Q)=0$ . Since a block $Q_{k}$ of size $k$ is $k^{2}$ entries sampled from the same distribution as $Q$ , we expect ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\frac{\\|Q_{k}\\|^{2}}{k^{2}}\\approx\\frac{\\|Q_{l}\\|^{2}}{l^{2}}\\quad\\Rightarrow\\frac{1}{k}{\\mathrm{Var}}(Q_{k})\\approx\\frac{1}{l}{\\mathrm{Var}}(Q_{l})\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Thus, rescaling $A\\in\\mathbb{R}^{n_{A}\\times n_{A}}$ and $C\\in\\mathbb{R}^{n_{C}\\times n_{C}}$ we get ", "page_idx": 19}, {"type": "equation", "text": "$$\n{\\hat{A}}={\\frac{A}{\\sqrt{n_{A}}}},\\quad{\\hat{C}}={\\frac{C}{\\sqrt{n_{C}}}},\\quad\\operatorname{Var}({\\hat{A}})\\approx\\operatorname{Var}({\\hat{C}})\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "E.4 Approximate slow modes of $L$ ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "If $M$ did not have the off-diagonal blocks $B$ , then $\\operatorname{Slow}_{\\varepsilon}[L]$ and $\\operatorname{Slow}_{\\varepsilon}[\\hat{L}]$ would coincide, as the $S_{\\varepsilon}$ block and the $S_{1}$ block would not mix when $B=0$ . Define $M_{0}$ as the block matrix of $M$ with $B=0$ . ", "page_idx": 20}, {"type": "equation", "text": "$$\nM_{0}\\equiv{\\binom{\\varepsilon^{2}A}{0}}\\quad{\\binom{0}{C}}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Using spectral expansions ", "page_idx": 20}, {"type": "equation", "text": "$$\nA=\\Psi_{A}\\Lambda_{A}\\Psi_{A}^{T},\\quad C=\\Psi_{C}\\Lambda_{C}\\Psi_{C}^{T}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "the eigenvectors of $M_{0}$ consist of ", "page_idx": 20}, {"type": "equation", "text": "$$\nM_{0}\\left(\\!\\!\\begin{array}{c}{{\\psi_{A i}}}\\\\ {{0}}\\end{array}\\!\\!\\right)=\\varepsilon^{2}\\lambda_{A i}\\left(\\!\\!\\begin{array}{c}{{\\psi_{A i}}}\\\\ {{0}}\\end{array}\\!\\!\\right),\\qquad\\qquad\\qquad M_{0}\\left(\\!\\!\\begin{array}{c}{{0}}\\\\ {{\\psi_{C i}}}\\end{array}\\!\\!\\right)=\\lambda_{C i}\\left(\\!\\!\\begin{array}{c}{{0}}\\\\ {{\\psi_{C i}}}\\end{array}\\!\\!\\right).\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Since we are looking for slow modes, we must also consider the magnitudes of $\\lambda_{A i}$ and $\\lambda_{C i}$ . Since $A$ and $C$ entries are random samples from $Q$ , we expect them to have a semi-circle or Gaussian distribution similar to $Q$ . Thus, we can use the variances of eigenvalues of $A$ and $C$ as a proxy for the how the magnitudes of $\\lambda_{A i}$ and $\\lambda_{C i}$ compare. From equation 48 we have ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\frac{1}{n_{A}}\\mathbb{E}[\\Lambda_{A}^{2}]\\approx\\frac{1}{n_{A}}\\mathrm{Var}(A)\\approx\\frac{1}{n_{C}}\\mathbb{E}[\\Lambda_{C}^{2}]\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Based on this we define a rescaled $\\hat{\\varepsilon}$ such that $\\varepsilon^{2}\\lambda_{A i}$ still has a smaller magnitude than $\\lambda_{C i}$ on average, meaning we want ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\varepsilon^{4}\\mathbb{E}[\\Lambda_{A}^{2}]<\\mathbb{E}[\\Lambda_{C}^{2}]\\qquad\\Rightarrow\\qquad\\varepsilon^{4}n_{A}<n_{C}\\qquad\\Rightarrow\\qquad\\hat{\\varepsilon}^{2}\\equiv\\varepsilon^{2}\\sqrt{\\frac{n_{A}}{n_{C}}}<1\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "We choose $\\varepsilon$ such that the condition in equation 53 is satisfied. We can express $M$ in terms of $\\hat{\\varepsilon}$ by rescaling $A$ and $B$ to $\\hat{\\varepsilon}^{2}\\hat{A}=\\varepsilon^{2}A$ and $\\hat{\\varepsilon}\\hat{B}=\\varepsilon B$ . Now eigenvalues of $\\hat{A}$ have the same variance as eigenvalues of $C$ . For brevity, denote $\\hat{M}=\\operatorname*{max}[S]^{2}M$ . We have ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\hat{M}=\\left({\\hat{\\varepsilon}}^{2}\\hat{A}\\;\\;\\;\\hat{\\varepsilon}\\hat{B}\\right).\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "To find how slow modes of $\\hat{M}=S Q S^{T}/\\operatorname*{max}[S]^{2}$ differ from slow modes of $S S^{T}$ , we break $\\hat{M}$ into a block diagonal part and an $O(\\hat{\\varepsilon})$ off-diagonal perturbation ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\hat{M}=M_{0}+\\hat{\\varepsilon}\\delta M,\\qquad\\qquad M_{0}=\\left({\\hat{\\varepsilon}}^{2}\\hat{A}\\quad0\\right)\\qquad\\qquad\\delta M=\\left({0\\atop\\hat{B}^{T}}\\quad\\hat{B}\\right).\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "As in equation 51, eigenvectors of $A=\\sqrt{n_{C}/n_{A}}\\hat{A}$ and $C$ are eigenvectors of $M_{0}$ . Now we want to find eigenvectors of $\\hat{M}$ with small $O(\\varepsilon^{2})$ eigenvalues up to order $\\hat{\\varepsilon}$ corrections by treating $\\delta M$ as a perturbation. ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{(M_{0}+\\hat{\\varepsilon}\\delta M)(\\psi+\\hat{\\varepsilon}\\delta\\psi)=(\\lambda+\\hat{\\varepsilon}\\delta\\lambda)(\\psi+\\hat{\\varepsilon}\\delta\\psi)}&{}\\\\ {M_{0}\\psi+\\hat{\\varepsilon}(\\delta M\\psi+M_{0}\\delta\\psi)+O(\\hat{\\varepsilon}^{2})=\\lambda\\psi+\\hat{\\varepsilon}(\\delta\\lambda\\psi+\\lambda\\delta\\psi)+O(\\hat{\\varepsilon}^{2})}&{}\\\\ {\\Rightarrow\\delta M\\psi+M_{0}\\delta\\psi=\\delta\\lambda\\psi+\\lambda\\delta\\psi\\,}&{}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "We only need the components of $\\delta\\psi$ orthogonal to $\\psi$ , so we can assume $\\delta\\psi^{T}\\psi=0$ . From this we have ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\delta\\lambda=\\psi^{T}\\delta M\\psi+\\psi^{T}M_{0}\\delta\\psi=\\psi^{T}\\delta M\\psi,\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "where we used $\\psi^{T}M_{0}\\delta\\psi=\\lambda\\psi^{T}\\delta\\psi=0$ . Plugging equation 57 into equation 56 we can solve for $\\delta\\psi$ by inverting the matrices ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{(M_{0}-\\lambda)\\delta\\psi=(\\delta\\lambda-\\delta M)\\psi}\\\\ &{\\qquad\\quad\\Rightarrow\\delta\\psi=(M_{0}-\\lambda+i\\eta)^{-1}(\\delta\\lambda-\\delta M)\\psi}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "where we added a small $\\eta$ to make the matrix $M_{0}-\\lambda$ invertible, as $\\lambda$ is one of its eigenvalues. ", "page_idx": 21}, {"type": "text", "text": "To find slow modes, we start from slow modes of $M_{0}$ which are in the $A$ subspace. Let $\\psi_{A}$ be an eigenvector of $A$ with $\\hat{A}\\psi_{A}=\\lambda_{A}\\psi_{A}$ . Concatenating $\\psi_{A}$ with zeros in the $C$ subspace we have ", "page_idx": 21}, {"type": "equation", "text": "$$\n\\psi=\\binom{\\psi_{A}}{0}\\,,\\qquad\\qquad\\qquad\\qquad M_{0}\\psi=\\hat{\\varepsilon}^{2}\\lambda_{A}\\psi.\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "Using this $\\psi$ to compute $\\delta\\lambda$ in equation 57 we have ", "page_idx": 21}, {"type": "equation", "text": "$$\n\\delta\\lambda=\\psi^{T}\\delta M\\psi=\\left(\\psi_{A}^{T}\\quad0\\right)\\left(\\hat{\\cal B}^{T}\\psi_{A}\\right)=0\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "meaning to first order in $\\hat{\\varepsilon}$ the corrections to eigenvalues of slow modes vanishes. This is desired because the slow mode eigenvalues are $O(\\hat{\\varepsilon}^{2})$ and we find that with this $\\psi$ ansatz the corrections it will get are also at least $\\bar{O(\\hat{\\varepsilon}^{2})}$ . Next, we compute the corrections $\\delta\\psi$ to the eigenvectors. Plugging $\\psi$ into equation 58 with $\\lambda=\\hat{\\varepsilon}^{2}\\lambda_{A}$ and $\\delta\\lambda=0$ we have ", "page_idx": 21}, {"type": "equation", "text": "$$\n\\begin{array}{c}{{(M_{0}-\\lambda+i\\eta)^{-1}=\\left((\\hat{\\varepsilon}^{2}\\hat{A}-\\lambda+i\\eta)^{-1}\\begin{array}{c}{{0}}\\\\ {{(C-\\lambda)^{-1}}}\\end{array}\\right)}}\\\\ {{\\delta\\psi=-(M_{0}-\\lambda+i\\eta)^{-1}\\delta M\\psi}}\\\\ {{=\\binom{0}{(C-\\lambda)^{-1}\\hat{B}^{T}\\psi_{A}}}}\\end{array}\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "where we dropped $i\\eta$ in the lower block because $\\hat{\\varepsilon}^{2}\\lambda_{A}$ is unlikely to be also an eigenvalue of $C$ , as $A$ and $C$ are random matrices. ", "page_idx": 21}, {"type": "text", "text": "Using the relation $\\hat{\\varepsilon}\\hat{B}\\,=\\,\\varepsilon B$ with the original $\\varepsilon$ and putting all together we find the eigenvector $\\psi^{\\prime}={\\bar{\\psi}}+{\\hat{\\varepsilon}}\\delta\\psi$ up to order $O(\\varepsilon^{2})$ to be ", "page_idx": 21}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\hat{\\psi}^{\\prime}=\\binom{\\psi_{A}}{\\hat{\\varepsilon}(C-\\hat{\\varepsilon}^{2}\\lambda_{A})^{-1}\\hat{B}^{T}}}\\\\ {\\hat{M}\\psi^{\\prime}=\\hat{\\varepsilon}^{2}\\lambda\\psi^{\\prime}+O(\\hat{\\varepsilon}^{2})=O(\\hat{\\varepsilon}^{2})}\\end{array}\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "The checklist is designed to encourage best practices for responsible machine learning research, addressing issues of reproducibility, transparency, research ethics, and societal impact. Do not remove the checklist: The papers not including the checklist will be desk rejected. The checklist should follow the references and follow the (optional) supplemental material. The checklist does NOT count towards the page limit. ", "page_idx": 22}, {"type": "text", "text": "Please read the checklist guidelines carefully for information on how to answer these questions. For each question in the checklist: ", "page_idx": 22}, {"type": "text", "text": "\u2022 You should answer [Yes] , [No] , or [NA] .   \n\u2022 [NA] means either that the question is Not Applicable for that particular paper or the relevant information is Not Available.   \n\u2022 Please provide a short (1\u20132 sentence) justification right after your answer (even for NA). ", "page_idx": 22}, {"type": "text", "text": "The checklist answers are an integral part of your paper submission. They are visible to the reviewers, area chairs, senior area chairs, and ethics reviewers. You will be asked to also include it (after eventual revisions) with the final version of your paper, and its final version will be published with the paper. ", "page_idx": 22}, {"type": "text", "text": "The reviewers of your paper will be asked to use the checklist as one of the factors in their evaluation. While \"[Yes] \" is generally preferable to \"[No] \", it is perfectly acceptable to answer \"[No] \" provided a proper justification is given (e.g., \"error bars are not reported because it would be too computationally expensive\" or \"we were unable to find the license for the dataset we used\"). In general, answering \"[No] \" or \"[NA] \" is not grounds for rejection. While the questions are phrased in a binary way, we acknowledge that the true answer is often more nuanced, so please just use your best judgment and write a justification to elaborate. All supporting evidence can appear either in the main paper or the supplemental material, provided in appendix. If you answer [Yes] to a question, in the justification please point to the section(s) where related material for the question can be found. ", "page_idx": 22}, {"type": "text", "text": "IMPORTANT, please: ", "page_idx": 22}, {"type": "text", "text": "\u2022 Delete this instruction block, but keep the section heading \u201cNeurIPS paper checklist\", \u2022 Keep the checklist subsection headings, questions/answers and guidelines below. \u2022 Do not modify the questions and only use the provided macros for your answers. ", "page_idx": 22}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Justification: [TODO] ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 22}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: [TODO] ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 23}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: [TODO] ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 23}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: Most experiments are uploaded in supplemental. Rest will be provided upon request. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: \u2022 The answer NA means that the paper does not include experiments. ", "page_idx": 23}, {"type": "text", "text": "\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 24}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Justification: Most code in supplement. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). ", "page_idx": 24}, {"type": "text", "text": "\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 25}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: in code and text. Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 25}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: In most cases, multiple runs and their statistics are provided in figures and text. Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 25}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 25}, {"type": "text", "text": "Answer: [TODO] ", "page_idx": 25}, {"type": "text", "text": "Justification: [TODO] ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage. ", "page_idx": 25}, {"type": "text", "text": "\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 26}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: [TODO] ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 26}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: [TODO] ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 26}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] Justification: [TODO] ", "page_idx": 26}, {"type": "text", "text": "", "page_idx": 26}, {"type": "text", "text": "Guidelines: \u2022 The answer NA means that the paper poses no such risks. ", "page_idx": 26}, {"type": "text", "text": "\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 27}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 27}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 27}, {"type": "text", "text": "Justification: [TODO] ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 27}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 27}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 27}, {"type": "text", "text": "Justification: [TODO] ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 27}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 27}, {"type": "text", "text": "Answer: [NA] Justification: [TODO] ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 28}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] Justification: [TODO] ", "page_idx": 28}, {"type": "text", "text": "Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 28}]