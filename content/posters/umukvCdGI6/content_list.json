[{"type": "text", "text": "DOFEN: Deep Oblivious Forest ENsemble ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Kuan-Yu Chen Ping-Han Chiang Hsin-Rung Chou Sinopac Holdings Sinopac Holdings Sinopac Holdings lavamore@sinopac.com u10000129@gmail.com sherry.chou@sinopac.com ", "page_idx": 0}, {"type": "text", "text": "Chih-Sheng Chen Sinopac Holdings sheng77@sinopac.com ", "page_idx": 0}, {"type": "text", "text": "Darby Tien-Hao Chang Sinopac Holdings National Cheng Kung University darby@sinopac.com ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Deep Neural Networks (DNNs) have revolutionized artificial intelligence, achieving impressive results on diverse data types, including images, videos, and texts. However, DNNs still lag behind Gradient Boosting Decision Trees (GBDT) on tabular data, a format extensively utilized across various domains. This paper introduces DOFEN, which stands for Deep Oblivious Forest ENsemble. DOFEN is a novel DNN architecture inspired by oblivious decision trees and achieves on-off sparse selection of columns. DOFEN surpasses other DNNs on tabular data, achieving state-of-the-art performance on the well-recognized benchmark: Tabular Benchmark [1], which includes 73 total datasets spanning a wide array of domains. The code of DOFEN is available at: https: //github.com/Sinopac-Digital-Technology-Division/DOFEN. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Tree-based models, including RandomForest [2], Extra Trees [3], and Gradient Boosting Decision Tree (GBDT) frameworks such as XGBoost [4], LightGBM [5], and CatBoost [6], are widely recognized for their simplicity, efficiency, and remarkable performance with tabular data. This has inspired numerous studies investigating the integration of tree-based algorithms with deep neural networks (DNNs), leading to tree-inspired DNNs such as Deep Forest [7], NODE [8], and TabNet [9]. In another line of tabular DNN research, novel DNN architectures such as SAINT [10], FT-Transformer [11], and Trompt [12] have been proposed. These novel architectures, which are essentially attention-based, demonstrate better performance compared with tree-inspired DNNs but require significantly more time and space. While these tabular DNNs have shown promising performance in specific contexts, recent surveys and benchmarks generally indicate that they do not surpass the performance of GBDTs on tabular data [1, 11, 13\u201315]. ", "page_idx": 0}, {"type": "text", "text": "Hence, we begin by questioning what\u2019s missing in existing tabular DNNs and identify one key difference: in tree-based models, only a limited number of features are used in the construction of each tree. This concept of \"sparse selection of columns\" not only increases feature diversity but also helps mitigate overftiting in tree-based models [2\u20136]. However, existing tabular DNNs are unable to achieve a sparse selection. For example, attention-based models [10\u201312] use the softmax operation to aggregate column information, resulting in a \"dense selection\" across columns. Some tree-inspired DNNs [8, 9] have utilized methods like entmax and sparsemax [16, 17] to enhance sparsity, but they can still only achieve near-sparse effects. Therefore, we opt to develop a new approach to achieve this characteristic. ", "page_idx": 0}, {"type": "image", "img_path": "umukvCdGI6/tmp/a71219c26b40d5511100132e8f3dd0d1ff6d74fe6c56ae2a6233523f78cafe0a.jpg", "img_caption": ["Figure 1: Evaluation results on the Tabular Benchmark. The model names are sorted by their performances at the end of the random search of hyperparameters. The result are averaged over various datasets included in each benchmark respectively, detailed number of datasets of each benchmark is provided in Appendix B.1 "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "For deep learning models, the biggest challenge is that generating a sparse matrix for on-off column selection is non-differentiable. In this study, we propose a novel two-step process to work around this issue: (1) enumerating as many sparse selections of columns as possible, and (2) weighting the importance of these sparse selections, making the weights differentiable and trainable by a DNN model. We name this new tree-inspired DNN DOFEN, an abbreviation for Deep Oblivious Forest ENsemble, and further demonstrate how DOFEN implements these two steps below: ", "page_idx": 1}, {"type": "text", "text": "1. Condition Generation and rODT Construction. In DOFEN, the step of enumerating sparse selections is further divided into two parts. The first part generates conditions, each involving exactly one column and corresponding to a decision rule of a tree node, as described in Section 3.2.1. The second part combines conditions using a shuffle-then-reshape procedure, detailed in Section 3.2.2. Each resultant combination of conditions can be seen as a differentiable counterpart to the Oblivious Decision Tree (ODT) [18], referred to as a relaxed ODT (rODT) in the context. Consequently, all the combinations collectively form a pool of rODTs. ", "page_idx": 1}, {"type": "text", "text": "2. Two-level rODT Ensemble. To ensure that the weighting of a limited number of rODTs can achieve good predictive performance, the previous step requires a sufficiently large pool. However, assembling all the rODTs in the pool into a single giant forest tends to cause overfitting, as shown in Appendix F.1 and Figure 9. Thus, DOFEN implements the step of importance weighting using a two-level ensemble procedure. The first level involves ensembling only a randomly selected subset of the rODT pool to form individual rODT forests, which is similar to applying dropout [19] to the rODT pool. The second level treats each rODT forest as a weak learner and aggregates them into a forest ensemble. This level is designed to enhance performance and stability, similar to standard ensemble learning. Both level of ensemble is detailed in Algorithm 1 of Section 3.2.3. ", "page_idx": 1}, {"type": "text", "text": "To evaluate DOFEN comprehensively and objectively, we have chosen a recent and well-recognized benchmark: the Tabular Benchmark [1]. This benchmark addresses the issue of inconsistent dataset selection, which is prevalent in deep learning research on tabular data. It includes a variety of regression and classification datasets with standardized feature processing for consistency. Additionally, we have conducted detailed analyses focusing on the distinct features of DOFEN, thereby offering insights into its functionalities. In summary, our research makes two key contributions: ", "page_idx": 1}, {"type": "text", "text": "1. Innovative Neural Network Architecture. The DOFEN model is fundamentally inspired by ODTs and incorporates an innovative two-step process to achieve on-off sparse selection of columns. This unique approach enhances performance beyond that of current tree-inspired DNNs and offers differentiability compared to conventional tree-based models. ", "page_idx": 1}, {"type": "text", "text": "2. State-of-the-Art Performance. The DOFEN model exhibits outstanding performance, surpassing that of other neural network models and competing closely with GBDTs on the Tabular Benchmark. This achievement underscores its robustness and versatility across various tasks, as illustrated in Figure 1. ", "page_idx": 1}, {"type": "text", "text": "2 Related Work ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this section, we start by exploring ODT and detail our rationale for selecting ODT as the foundational element in our study. We then systematically categorize deep tabular neural networks into two distinct streams: tree-inspired DNN architectures and novel DNN architectures. Through comparing DOFEN with these established models, our goal is to highlight its unique contributions and position it within the broad landscape of deep tabular network research. ", "page_idx": 2}, {"type": "text", "text": "Oblivious Decision Tree. The ODT is a variant of the traditional decision tree algorithm [20], which makes a series of feature-based decisions along its root-to-leaf path to deliver a prediction. In the context, a feature-based decision rule, e.g. age $>18$ , is called a condition. The traditional decision tree algorithm [18] chooses different conditions on different nodes, while in ODT, all nodes at the same level apply the same condition, resulting in a more uniform decision-making process. This uniformity allows for streamlined and vectorized decision-making, thus enhancing computational efficiency, while it also comes at the cost of capacity [8]. However, studies have shown that ensembles of ODTs can achieve remarkable performance with sufficient capacity [6, 8]. In this research, we integrate ODTs as the foundational element in the DOFEN model and capitalize on the strengths of ODTs while mitigating their limitations through ensemble strategies and deep learning techniques. ", "page_idx": 2}, {"type": "text", "text": "Tree-inspired DNN Architectures. Integrating decision tree (DT) algorithms with DNNs has become prominent for handling tabular data. Pioneering works like Deep Forest [7], NODE [8], TabNet [9], GradTree [21] and GRANDE [22] have each introduced unique methodologies. ", "page_idx": 2}, {"type": "text", "text": "Deep Forest adapts the random forest algorithm and incorporates multi-grained feature scanning to leverage the representation learning capabilities of DNNs. TabNet models the sequential decisionmaking process of traditional decision trees using a DNN, featuring a distinct encoder-decoder architecture that enables self-supervised learning. GradTree recognizes the importance of hard, axisaligned splits for tabular data and uses a straight-through operator to handle the non-differentiable nature of decision trees, allowing for the end-to-end training of decision trees. NODE and GRANDE share a similar observation and high-level structure to DOFEN, in that they ensemble multiple treelike deep learning base models. NODE uses ODT as a base predictor and employs a DenseNet-like multi-layer ensemble to boost performance. GRANDE, a successor to GradTree, uses DT as a base predictor and introduces advanced instance-wise weighting for ensembling each base model\u2019s prediction. ", "page_idx": 2}, {"type": "text", "text": "However, DOFEN distinguishes itself from NODE and GRANDE through its unique architectural design. First, DOFEN employs a different approach to transform tree-based models into neural networks. Unlike NODE and GRANDE, which explicitly learn the decision paths (i.e., selecting features and thresholds for each node) and the leaf node values of a tree, DOFEN randomly selects features to form rODTs and uses a neural network to measure how well a sample aligns with the decision rule. Additionally, the leaf node value of an rODT is replaced with an embedding vector for further ensembling. Second, DOFEN introduces a novel two-level ensemble process to enhance model performance and stability. Unlike NODE and GRANDE, which simply perform a weighted sum on base model predictions, DOFEN first constructs multiple rODT forests by randomly aggregating selected rODT embeddings and then applies bagging on the predictions of these rODT forests. ", "page_idx": 2}, {"type": "text", "text": "Novel DNN Architectures. Beyond merging decision tree algorithms with DNNs, significant progress has been made in developing novel architectures for tabular data. Notable among these are TabTransformer [23], FT-Transformer [11], SAINT [10], TabPFN [24], and Trompt [12]. These models primarily leverage the transformer architecture [25], utilizing self-attention mechanisms to capture complex feature relationships. ", "page_idx": 2}, {"type": "text", "text": "TabTransformer applies transformer blocks specifically to numerical features, while FT-Transformer extends this approach to both numerical and categorical features. SAINT enhances the model further by applying self-attention both column-wise and sample-wise, increasing its capacity. TabPFN, a variant of the Prior Fitted Network (PFN) [26], is particularly effective with smaller datasets. Trompt introduces an innovative approach by incorporating prompt learning techniques from natural language processing [27], aiming to extract deeper insights from the tabular data\u2019s columnar structure. ", "page_idx": 2}, {"type": "text", "text": "These models have demonstrated impressive performance across various studies and benchmarks. As a result, we choose them as our baselines to offer a comprehensive evaluation for deep learning models on tabular data. ", "page_idx": 2}, {"type": "text", "text": "3 DOFEN: Deep Oblivious Forest Ensemble ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "In this section, we begin with discussion about how DOFEN relax an ODT to be differentiable in Section 3.1, and elaborate on the details of the overall architecture design in Section 3.2. In the following figures and equations, three sub-networks\u2014composites of fundamental neural network layers such as linear layers, layer normalization, and dropout\u2014are simplified into symbols $\\Delta_{1}$ , $\\Delta_{2}$ , and $\\Delta_{3}$ for readability. The detailed configurations of these sub-networks can be found in Appendix A.2. ", "page_idx": 3}, {"type": "text", "text": "3.1 ODT Relaxation ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "An ODT operates on an input vector $\\vec{x}$ , where $\\vec{x}\\in\\mathbb R^{N_{\\mathrm{col}}}$ and $N_{\\mathrm{col}}$ is the number of columns in a tabular dataset, as described in Equation (1). Although these columns can be either numerical or categorical, we focus on real numbers in Equations (2) and (3) to simplify the notations. ", "page_idx": 3}, {"type": "equation", "text": "$$\n{\\vec{x}}=(x_{i}\\mid i=1,2,...\\,,N_{\\mathrm{col}}),x_{i}\\in\\mathbb{R}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Fundamentally, an ODT of depth $d$ is a decision table consisting of $d$ entries [28], as depicted in Equation (2). Here, $I_{j}$ indicates the index of a selected column, and $x_{I_{j}}$ denotes its column value at depth $j$ . The corresponding threshold is denoted by $b_{j}$ , and $H$ denotes the Heaviside function. In practice, the choice of $x_{I_{j}}$ is decided by a predefined criterion, e.g., entropy or Gini impurity. It is possible for a raw column to be selected multiple times at different depths, each with a varying threshold. ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\operatorname{ODT}(\\vec{x})=\\{H(x_{I_{j}}-b_{j})\\},\\ \\vec{x}\\ \\xrightarrow[]{\\mathrm{decided\\,by\\,entropy,Gini\\,impurity,\\,etc.}}\\{(x_{I_{j}},b_{j})\\},}\\\\ {I_{j}\\in\\ \\{1,2,\\ldots,N_{\\mathrm{col}}\\},\\ b_{j}\\in\\mathbb{R},\\ j=(1,2,\\ldots,d)\\ \\qquad\\qquad}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Equation (2) involves non-differentiable calculations, including the Heaviside function and the predefined criterion. Consequently, the key to integrating an ODT within a neural network model lies in making the following operations differentiable: selecting columns, deciding thresholds, and modeling $H$ . ", "page_idx": 3}, {"type": "text", "text": "To address these challenges, DOFEN proposes a method to relax an ODT, as shown in Equation (3). In DOFEN, the columns of an ODT at different depths are selected randomly. The thresholds and the Heaviside function for column $I_{j}$ are replaced with a sub-network $\\Delta_{1I_{j}}$ , which employs the sigmoid activation function to create soft conditions. To avoid confusion, we introduce a new term, relaxed ODT (rODT), in this context. This term distinguishes between the original ODT and the relaxed version proposed in this study, which can be integrated to neural networks. ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r l r}&{}&{\\mathrm{rODT}(\\vec{x})=\\{\\Delta_{1I_{j}}(x_{I_{j}})\\},\\;\\vec{x}\\;\\xrightarrow[]{\\mathrm{randomly\\;select}}\\{x_{I_{j}}\\},}\\\\ &{}&{I_{j}\\in\\;\\{1,2,...\\,,N_{\\mathrm{col}}\\},\\;j=(1,2,...\\,,d)\\quad\\quad}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "3.2 DOFEN Model ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "3.2.1 Condition Generation ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "This module transforms input vector $\\vec{x}$ into multiple soft conditions for subsequent modules. The raw input in tabular data comprises a combination of numerical and categorical columns. In this study, a soft condition is defined as a scalar indicating how well a column adheres to a decision rule. ", "page_idx": 3}, {"type": "text", "text": "This transformation process creates a matrix $\\mathbf{M}$ , as shown in Equation (4), where $N_{\\mathrm{cond}}$ is a hyperparameter denoting the number of conditions we aim to generate for each column. Notably, each column $x_{i}$ is processed by individual sub-network $\\Delta_{1i}$ in this context, where $i\\in\\left\\lbrace1,\\dots,N_{\\mathrm{col}}\\right\\rbrace$ . This design is derived from the original ODT, where each condition involves only a single column. The sub-network $\\Delta_{1}$ is an embedding layer for a categorical column or a linear layer for a numerical column. Further details of $\\Delta_{1}$ can be found in Appendix A.2. As depicted in Figure 2a, three instances of $\\Delta_{1}$ generate four conditions for each column, resulting in a $3\\times4$ matrix. ", "page_idx": 3}, {"type": "image", "img_path": "umukvCdGI6/tmp/b766f018d6897ad1c7ff13edd9c9954fb64a7e9357898c31d582c3841d5f08f5.jpg", "img_caption": [], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "Figure 2: (a) Condition Generation: For each column $x_{i}$ , $N_{\\mathrm{cond}}$ conditions are generated through an individual sub-network $\\Delta_{1i}$ . The aggregate of the conditions of all columns is denoted by the matrix M. (b) Relaxed ODT Construction: The condition matrix $\\mathbf{M}$ is shuffled (i.e. permutation with $\\pi$ ) and reshape into $\\mathbf{O}$ , representing $N_{\\mathrm{rODT}}$ rODTs each with depth $d$ . (c) Forest Construction: To compute the weights $w_{i}$ , an individual sub-networks $\\Delta_{2i}$ is applied to each rODT. In addition, each $w_{i}$ is paired with a learnable embedding vector $\\mathbf{e}_{i}$ . The aggregate of all weights and their corresponding embedding vectors are denoted as $\\vec{w}$ and $\\mathbf{E}$ , respectively. ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\mathbf{H}=\\left[\\begin{array}{c c c}{m_{11}}&{\\hdots}&{m_{1N_{\\mathrm{col}}}}\\\\ {\\vdots}&{\\ddots}&{\\vdots}\\\\ {m_{N_{\\mathrm{coul}}}}&{\\hdots}&{m_{N_{\\mathrm{coul}}N_{\\mathrm{col}}}}\\end{array}\\right]\\in\\mathbb{R}^{N_{\\mathrm{coul}}\\times N_{\\mathrm{col}}},(m_{i1},\\hdots,m_{i N_{\\mathrm{coul}}})=\\Delta_{1i}(x_{i}),i=(1,2,\\hdots,N_{\\mathrm{col}})\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "3.2.2 Relaxed ODT Construction ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "This module constructs multiple rODTs. Unlike traditional ODT, which selects columns and their corresponding thresholds based on predefined criteria, DOFEN randomly selects $d$ elements from the $N_{\\mathrm{cond}}\\times N_{\\mathrm{col}}$ conditions in matrix $\\mathbf{M}$ without replacement to build an rODT with depth $d$ . In our implementation, $\\mathbf{M}$ is shuffled and reshaped into a matrix $\\mathbf{O}$ with dimensions $N_{\\mathrm{roDT}}\\times d$ , as shown in Equation (5). Here, we use $\\pi$ to represent a bijective function that maps the index of each element in $\\mathbf{M}$ to a unique position in $\\mathbf{O}$ (i.e. permutation). The whole process is also illustrated in Figure 2b. ", "page_idx": 4}, {"type": "text", "text": "Specifically, $N_{r o D T}=N_{c o n d}N_{c o l}/d$ . To guarantee that $N_{r O D T}$ is an integer, we introduce an intermediate parameter, $m$ , which ensures that $N_{c o n d}$ is always a multiple of $d$ by formulating $N_{c o n d}=m d$ . In practice, we use $m$ to adjust $N_{c o n d}$ instead of directly changing $N_{c o n d}$ . ", "page_idx": 4}, {"type": "text", "text": "On the other hand, note that each row in $\\mathbf{O}$ represents an rODT, which is crucial for subsequent operations. To ensure this consistency and the stability during training, the permutation is done only once during model construction and the configuration is then maintained throughout. ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\mathbf{O}=\\left[\\begin{array}{c c c c}{o_{11}}&{\\cdot\\cdot\\cdot}&{o_{1d}}\\\\ {\\vdots}&{\\cdot\\cdot}&{\\vdots}\\\\ {o_{N_{\\mathrm{ronr}}1}}&{\\cdot\\cdot\\cdot}&{o_{N_{\\mathrm{ronr}}d}}\\end{array}\\right]\\in\\mathbb{R}^{N_{\\mathrm{ronr}}\\times d},\n$$", "text_format": "latex", "page_idx": 4}, {"type": "equation", "text": "$$\n\\left\\{o_{j k}\\mid j=\\left\\lceil{\\frac{\\pi(n)}{d}}\\right\\rceil,k=\\pi(n){\\bmod{d}},n=u\\times N_{\\mathrm{col}}+v\\right\\}=\\{m_{u v}\\}\\subset\\mathbf{M},\n$$", "text_format": "latex", "page_idx": 4}, {"type": "image", "img_path": "umukvCdGI6/tmp/8961c5d2d6389e9edb73d4fde6e46f16f5e6fa2befed71685d7ab674454a85b4.jpg", "img_caption": ["Figure 3: (a) Forest Construction: First, $N_{\\mathrm{estimator}}$ pairs of $(w_{i},\\vec{e_{i}})$ are randomly sampled to form $\\vec{w}^{\\prime}$ and $\\mathbf{E}^{\\prime}$ . Secondly, $\\vec{w}^{\\prime}$ is transformed through a softmax function, and is used for computing the weighted sum of $\\mathbf{E}^{\\prime}$ to form forest embedding $\\bar{f}$ . (b) Forest Ensemble: a shared-weight sub-network $\\Delta_{3}$ is employed to make a prediction $\\hat{y}$ for each embedding. The final prediction is the average of all $\\hat{y}$ values, and the total loss is the sum of their individual losses. "], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "3.2.3 Two-level Relaxed ODT Ensemble ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "This module integrates rODTs to construct forests and then assembles multiple forests to conduct a final prediction. ", "page_idx": 5}, {"type": "text", "text": "Forest Construction. To construct an rODT forest using the generated rODTs, DOFEN introduces a sub-network and a standalone embedding vector for each rODT, denoted as $\\Delta_{2i}$ and $\\vec{e_{i}}$ respectively, where $i\\in\\{1,\\dots,N_{\\mathrm{roDT}}\\}$ . The role of $\\Delta_{2i}$ is to evaluate how well a sample aligns with the conditions of an rODT, producing a weight scalar $w_{i}$ , as shown in Equation (6) and Figure $2c$ . ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\vec{w}=\\left(\\begin{array}{c}{\\Delta_{21}\\big(\\big(o_{11},\\dots,o_{1d}\\big)\\big)}\\\\ {\\qquad\\qquad\\qquad\\vdots}\\\\ {\\qquad\\qquad\\big(o_{N_{\\mathrm{ronr}}}(\\big(o_{N_{\\mathrm{ronr}1}},\\dots,o_{N_{\\mathrm{ronr}d}})\\big)\\big)}\\end{array}\\right)=\\big(w_{1},\\dots,w_{N_{\\mathrm{ronr}}}\\big)\\in\\mathbb{R}^{N_{\\mathrm{ronr}}}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "The embedding vector $\\vec{e_{i}}$ represents the tree information and is independent of the samples. The embedding vectors are combined into a matrix $\\mathbf{E}$ , as depicted in Equation (7), where $N_{\\mathrm{hidden}}$ represents the size of the hidden dimension. Importantly, each tree embedding vector is directly linked to the specific conditions of its corresponding rODT. It is crucial to keep this association consistent throughout each training session to effectively train the tree embedding vectors. ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathbf{E}=\\left[\\begin{array}{c}{\\vec{e}_{1}}\\\\ {\\vdots}\\\\ {\\vec{e}_{N_{\\mathrm{ropr}}}}\\end{array}\\right]\\in\\mathbb{R}^{N_{\\mathrm{ropr}}\\times N_{\\mathrm{hiden}}},\\mathrm{where~}\\vec{e}_{i}\\in\\mathbb{R}^{N_{\\mathrm{hiden}}},i=(1,2,\\dots,N_{\\mathrm{ropr}})\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "To further construct an rODT forest, $N_{\\mathrm{estimator}}$ of paired weights and embeddings are sampled from $\\vec{w}$ and $\\mathbf{E}$ . This process is graphically represented in Figure 3a and described in line 3 to 7 of the pseudo-code for the two-level ensemble (Algorithm 1). The weights are processed through a softmax function and the weighted sum of embeddings forms the embedding vector $\\vec{f}$ for an rODT forest. The magnitude of these softmaxed weights indicate the importance of the selected rODTs for making predictions. Noted that this process is repeated $N_{\\mathrm{forest}}$ times to form $N_{\\mathrm{forest}}$ instances of rODT forests. ", "page_idx": 5}, {"type": "text", "text": "Forest Ensemble. To make a prediction, DOFEN applies a shared sub-network $\\Delta_{3}$ to the embedding of each rODT forest to make individual predictions. The predictions are then averaged for a bagging ", "page_idx": 5}, {"type": "image", "img_path": "umukvCdGI6/tmp/e54482da2588d4fff4cdd6ef04e113a3065b23a3be44a12460f7f67d78e97253.jpg", "img_caption": ["Algorithm 1: Two-level Relaxed ODT Ensemble "], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "ensemble. The process is detailed in line 1, 8, 10, and 12 in Algorithm 1 and is illustrated in Figure 3b.   \nNotice that the output $\\hat{y}_{i}$ is a scalar for regression tasks and a vector for classification tasks. ", "page_idx": 6}, {"type": "text", "text": "During training, DOFEN updates the model parameters by aggregating the loss from each prediction, as shown in line 9 in Algorithm 1. The loss function $\\mathcal{L}$ is cross-entropy for classification tasks and mean squared error for regression tasks. ", "page_idx": 6}, {"type": "text", "text": "Notably, the sampling of weight-embedding pairs allows resampling in each forward pass without disrupting the training. In fact, the two-level rODT ensemble essentially implements a form of bootstrap aggregating (i.e. bagging) of trees. Conventional tree-based models like random forest bootstrap samples to generate a variety of trees, which are then combined to form a forest. In DOFEN, the $\\vec{w}$ and $\\mathbf{E}$ represent a tree pool. From this pool, trees are sampled with replacement to create diverse tree sets, or forests, represented by $\\vec{w}^{\\prime}$ and $\\mathbf{E^{\\prime}}$ . These forests are then integrated to make the final prediction. The design of this tree bagging method enables the construction of varied base models (in this case, forests rather than individual trees) within a single training session, which is particularly suited to deep learning contexts. Although the randomization may seem chaotic, experiments shows that this approach contributes to the model\u2019s stability and generalizability, which is discussed in detail in Section 4.3.1 and Appendix F.1. ", "page_idx": 6}, {"type": "text", "text": "4 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "This section presents a comprehensive analysis of our experimental results, organized as follows: The Tabular Benchmark and the baseline models are first introduced in Section 4.1. In Section 4.2, we evaluate DOFEN on the medium-sized Tabular Benchmark, while leaving the results for large-sized benchmark in Appendix G.1. Section 4.3 delves into DOFEN to elucidate the underlying mechanics that drive its performance. Additionally, we discuss DOFEN\u2019s computational efficiency in Appendices C.1 to C.3, analyze DOFEN\u2019s scalability in Appendix D, and show DOFEN\u2019s interpretability in Appendix E. ", "page_idx": 6}, {"type": "text", "text": "4.1 Tabular Benchmark Setup ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Datasets. We strictly follow the protocols of the Tabular Benchmark as detailed in its official implementation1. This includes dataset splits, preprocessing methods, hyperparameter search guidelines, and evaluation metrics. For full details, please refer to the original paper [1]. The Tabular Benchmark categorized datasets into classification and regression, with features being either exclusively numerical or a combination of numerical and categorical (heterogeneous). These datasets are further classified according to their sample size: medium-sized or large-sized. The dataset counts from Tabular Benchmark are provided in Appendix B.1, and the detailed datasets used in Tabular Benchmark are provided in Appendix B.3. ", "page_idx": 6}, {"type": "image", "img_path": "umukvCdGI6/tmp/2335359099ddc6d7a72cd19c1decd80e312725b741d0673043cc24b34d4fca49.jpg", "img_caption": ["Figure 4: Results on medium-sized classification and regression datasets. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "", "page_idx": 7}, {"type": "text", "text": "Model Selection. For model comparison, Tabular Benchmark includes four tree-based models: RandomForest, GradientBoostingTree [29], HGBT [30], and XGBoost; two generic DNN models: MLP and ResNet [11]; and two tabular DNN models: SAINT and FT-Transformer. To ensure a comprehensive comparison, we also included two additional tree-based models: LightGBM and CatBoost, and three tabular DNN models: NODE, Trompt, and GRANDE. LightGBM and CatBoost are selected due to their widespread use across various domains. NODE and GRANDE both share similar motivation and high-level structure with DOFEN, while Trompt represents the current stateof-the-art tabular DNNs when following the origin protocols of the Tabular Benchmark. The default hyperparameter configuration of DOFEN and hyperparameter search space of different models are presented in Appendices A.1 and H.2, and the list of some missing model baselines from Tabular Benchmark is provided in Appendix B.2. ", "page_idx": 7}, {"type": "text", "text": "4.2 Performance Evaluation ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "We analyze the results of medium-sized benchmark on classification and regression tasks separately. The evaluation metrics adhere to the Tabular Benchmark protocols, which use accuracy for classification datasets and the R-squared score for regression datasets. We discuss the overall performance in this section and provide comprehensive results for each dataset in Appendix G.2. ", "page_idx": 7}, {"type": "text", "text": "Classification. In Figure 4a, the models can be roughly categorized into three groups: (1) tree-based models and three tabular DNN models: DOFEN, Trompt and GRANDE, (2) three other tabular DNN models, and (3) the two generic DNN models. Prior to DOFEN, Trompt was the sole DNN model comparable to tree-based models. DOFEN not only matches but also surpasses the performance of most tree-based models, establishing a new benchmark for DNN models in tabular data. In Figure 4b, DOFEN and Trompt are again the only two DNN models grouped with tree-based models, yet they are positioned at the bottom of this group. ", "page_idx": 7}, {"type": "text", "text": "Regression. In Figure 4c, XGBoost stands out as a distinct category. Meanwhile, CatBoost and DOFEN represent a second level of performance. Notably, XGBoost and DOFEN demonstrate a significant improvement during the hyperparameter optimization, whereas CatBoost maintains strong performance consistently. In Figure 4d, XGBoost and CatBoost continue to hold the top two positions. DOFEN, ending up in sixth place, is overtaken by GradientBoostingTree as well as HGBT, and is comparable with FT-Transformer towards the end of the hyperparameter search process. ", "page_idx": 7}, {"type": "text", "text": "The analysis of Figure 4 allows us to draw several conclusions. When compared to DNN models, DOFEN consistently either ranks first or shares the top positions. Additionally, DOFEN exhibits strong competitiveness against tree-based models. In datasets with numerical features, it consistently places within the top three. However, in the context of heterogeneous features, DOFEN\u2019s performance is moderate, typically falling in the middle or lower tiers in comparison with tree-based models. This challenge in managing heterogeneous features is a prevalent issue among all DNN models, highlighting an area for potential improvement in future tabular DNN models. ", "page_idx": 7}, {"type": "table", "img_path": "umukvCdGI6/tmp/47accfb198414dc8d9b9b79c8f0d7362ba0fee1515f11dbf7da6714204b7527a.jpg", "table_caption": ["Table 1: Mean $(\\mu)$ and standard deviation $(\\sigma)$ of DOFEN\u2019s performance with 15 random seeds on 4 datasets from different tasks. "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "4.3 Additional Analysis ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "This section is dedicated to a deeper exploration of the DOFEN model. Randomness plays an important role in DOFEN, as both the condition selection of an rODT and rODT selection of a forest involve random processes. A straightforward concern is the stability of DOFEN, which is examined in Section 4.3.1. Moreover, given that the conditions are randomly selected, we investigate whether this randomness leads to redundant trees in Section 4.3.2. In addition to randomness, another distinct feature of DOFEN is the introduction of a higher-level ensemble that combines multiple forests, instead of merely assembling trees into a forest. Appendix F.1 discusses the impact of removing this higher-level ensemble on DOFEN. ", "page_idx": 8}, {"type": "text", "text": "All experiments in this section are conducted using the default hyperparameters and medium-sized datasets from the Tabular Benchmark. For evaluation metrics, accuracy is used for classification datasets, while the R-squared score for regression datasets. Except for the cases evaluated on individual datasets, the results represent the averaged metrics across the corresponding datasets. ", "page_idx": 8}, {"type": "text", "text": "4.3.1 Model Stability ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "DOFEN incorporates randomness at two steps: firstly, in the selection of conditions as shown in Equation (5) for rODT construction, and secondly, in the sampling of rODTs as shown in line 3 of Algorithm 1 for a two-level rODT ensemble. This section explores how randomness affects the stability of DOFEN. ", "page_idx": 8}, {"type": "text", "text": "We start by analyzing the variation in performance of four datasets, where DOFEN ranks first, as shown in Table 1. The standard deviations are even negligible when $N_{\\mathrm{forest}}=1$ (about $0.1\\%$ to $1\\%$ to mean), except for the delays-zurich dataset. Moreover, with increased $N_{\\mathrm{forest}}$ , the standard deviations become even smaller (about $0.01\\%$ to $0.1\\%$ to mean). These results suggest that the stability of DOFEN is not an issue in most cases $(N_{f o r e s t}\\,>\\,10)$ , and using the default setting of DOFEN $(N_{f o r e s t}=100)$ ) ensures both adequate performance and stability for most datasets. Furthermore, the performance improves as the $N_{\\mathrm{forest}}$ increases, indicating that the tree bagging of DOFEN not only mitigates instability but also enhances the model\u2019s generalizability. ", "page_idx": 8}, {"type": "text", "text": "In addition to analyzing the intrinsic instability, we also replace the steps involving randomness with deterministic alternatives to assess the impact of the randomness on DOFEN from a different perspective. For the selection of conditions, we utilize CatBoost to choose columns based on a predefined criterion. The detailed results, presented in Appendix F.3, reveal that the predefined criterion perform only slightly better than the shuffle-then-reshape process. Considering the differentiability and the potential for end-to-end training, random selection of conditions remains a viable and promising option. For sampling rODTs, we implement a sliding window technique to lock in the selected trees for each forest. The results are detailed in Appendix F.4, which suggests that our straightforward approach is comparable to a more sophisticated approach. ", "page_idx": 8}, {"type": "image", "img_path": "umukvCdGI6/tmp/29bd23479221e903c930605a0444739c7200f279144fc7c73f009011cc8c4a9a.jpg", "img_caption": ["(a) Relaxed ODTs with large weight variation. ", "Figure 5: In the covertype dataset, Figure 5a shows that the average weights of true positives differ significantly from those of true negatives. Conversely, Figure 5b reveals a contrasting result for rODTs with small weight variation. "], "img_footnote": [], "page_idx": 9}, {"type": "image", "img_path": "umukvCdGI6/tmp/2c47e62c0343775bc9ecc0301a52558ae606a9b3afac0a7736e9cfce7315c5a2.jpg", "img_caption": ["(b) Relaxed ODTs with small weight variation. "], "img_footnote": [], "page_idx": 9}, {"type": "text", "text": "4.3.2 Weights of Individual Relaxed ODT ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In DOFEN, an rODT is assigned a weight to predict a sample, as shown in Equation (6). In this section, we analyze a binary classification dataset (covertype) to observe the variation in the weights assigned to individual rODTs, as shown in Figure 5. ", "page_idx": 9}, {"type": "text", "text": "Figure 5a shows that, for most rODTs ranked in the top 25 according to their standard deviations of weights, there is a significant difference between the average weights of true positives and those of true negatives. Conversely, Figure 5b shows an opposite trend for rODTs with the smallest standard deviations of weights. These trends are also observed in another dataset, as shown in Appendix F.5. These observations imply that rODTs with larger standard deviations of weights is more crucial role in classifying samples. ", "page_idx": 9}, {"type": "text", "text": "In addition, we come up with an idea to examine the performance change after pruning weights with small standard deviations and their corresponding embeddings, since they are not sensitive to samples with different label. The results are provided in Appendix F.6 and suggest that the variation serves as a reliable indicator of the importance of rODTs. Moreover, pruning the less important rODTs not only enhances the model\u2019s efficiency but also its performance. ", "page_idx": 9}, {"type": "text", "text": "5 Limitation and Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "Limitation. Although DOFEN shows promising results, it still contains two weaknesses. First, the inference time of DOFEN is relatively long compared to other DNN models, as shown in Appendix C.1. However, Appendix C.1 also shows that DOFEN possesses the fewest floating point operations (FLOPs). This inconsistency between inference time and FLOPs is mainly caused by the group convolution operation for calculating weights for each rODT (Appendix C.2), which can be improved in the future implementation of DOFEN. Second, the randomization steps involved in DOFEN result in a slower convergence speed, meaning that DOFEN requires more training steps to reach optimal performance. This is reflected in the relatively larger number of training epochs needed for DOFEN. Therefore, the workaround strategy of differentiable sparse selection proposed in this study is merely a starting point, demonstrating its potential. Finding more efficient strategies will be the future work. ", "page_idx": 9}, {"type": "text", "text": "Conclusion. In this work, we proposed DOFEN, a novel tree-inspired DNN for tabular data that achieves on-off sparse selections of columns. DOFEN first constructs sufficiently large number of rODTs and randomly ensembles these rODTs into multiple rODT forests to make prediction. DOFEN was evaluated on the Tabular Benchmark, achieving state-of-the-art results compared to DNN-based models and proving competitive with tree-based ones. Furthermore, we showed that the randomization steps involved in DOFEN do not compromise stability but do yield redundant rODTs. Nevertheless, redundant rODTs can be efficiently removed through our pruning method. In summary, based on DOFEN\u2019s outstanding performance, it has the potential to serve as the backbone model for tabular data across various scenarios, including self- and semi-supervised learning, as well as multi-modal training. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[1] Grinsztajn, L.; Oyallon, E.; Varoquaux, G. Why do tree-based models still outperform deep learning on typical tabular data? Advances in Neural Information Processing Systems 2022, 35, 507\u2013520.   \n[2] Breiman, L. Random forests. Machine learning 2001, 45, 5\u201332.   \n[3] Geurts, P.; Ernst, D.; Wehenkel, L. Extremely randomized trees. Machine learning 2006, 63, 3\u201342.   \n[4] Chen, T.; Guestrin, C. Xgboost: A scalable tree boosting system. Proceedings of the 22nd acm sigkdd international conference on knowledge discovery and data mining. 2016; pp 785\u2013794.   \n[5] Ke, G.; Meng, Q.; Finley, T.; Wang, T.; Chen, W.; Ma, W.; Ye, Q.; Liu, T.-Y. Lightgbm: A highly efficient gradient boosting decision tree. Advances in neural information processing systems 2017, 30.   \n[6] Prokhorenkova, L.; Gusev, G.; Vorobev, A.; Dorogush, A. V.; Gulin, A. CatBoost: unbiased boosting with categorical features. Advances in neural information processing systems 2018, 31.   \n[7] Zhou, Z.-H.; Feng, J. Deep forest. National science review 2019, 6, 74\u201386.   \n[8] Popov, S.; Morozov, S.; Babenko, A. Neural oblivious decision ensembles for deep learning on tabular data. arXiv preprint arXiv:1909.06312 2019,   \n[9] Arik, S. \u00d6.; Pfister, T. Tabnet: Attentive interpretable tabular learning. Proceedings of the AAAI conference on artificial intelligence. 2021; pp 6679\u20136687.   \n[10] Somepalli, G.; Goldblum, M.; Schwarzschild, A.; Bruss, C. B.; Goldstein, T. Saint: Improved neural networks for tabular data via row attention and contrastive pre-training. arXiv preprint arXiv:2106.01342 2021,   \n[11] Gorishniy, Y.; Rubachev, I.; Khrulkov, V.; Babenko, A. Revisiting deep learning models for tabular data. Advances in Neural Information Processing Systems 2021, 34, 18932\u201318943.   \n[12] Chen, K.-Y.; Chiang, P.-H.; Chou, H.-R.; Chen, T.-W.; Chang, T.-H. Trompt: Towards a Better Deep Neural Network for Tabular Data. arXiv preprint arXiv:2305.18446 2023,   \n[13] Shwartz-Ziv, R.; Armon, A. Tabular data: Deep learning is not all you need. Information Fusion 2022, 81, 84\u201390.   \n[14] Borisov, V.; Leemann, T.; Se\u00dfler, K.; Haug, J.; Pawelczyk, M.; Kasneci, G. Deep neural networks and tabular data: A survey. IEEE Transactions on Neural Networks and Learning Systems 2022,   \n[15] McElfresh, D.; Khandagale, S.; Valverde, J.; Ramakrishnan, G.; Goldblum, M.; White, C.; others When Do Neural Nets Outperform Boosted Trees on Tabular Data? arXiv preprint arXiv:2305.02997 2023,   \n[16] Peters, B.; Niculae, V.; Martins, A. F. Sparse Sequence-to-Sequence Models. Proc. ACL. 2019.   \n[17] Martins, A.; Astudillo, R. From softmax to sparsemax: A sparse model of attention and multi-label classification. International conference on machine learning. 2016; pp 1614\u20131623.   \n[18] Kohavi, R. Bottom-up induction of oblivious read-once decision graphs. European Conference on Machine Learning. 1994; pp 154\u2013169.   \n[19] Srivastava, N.; Hinton, G.; Krizhevsky, A.; Sutskever, I.; Salakhutdinov, R. Dropout: a simple way to prevent neural networks from overfitting. The journal of machine learning research 2014, 15, 1929\u20131958.   \n[20] Quinlan, J. R. Induction of decision trees. Machine learning 1986, 1, 81\u2013106.   \n[21] Marton, S.; L\u00fcdtke, S.; Bartelt, C.; Stuckenschmidt, H. GradTree: Learning axis-aligned decision trees with gradient descent. Proceedings of the AAAI Conference on Artificial Intelligence. 2024; pp 14323\u201314331.   \n[22] Marton, S.; L\u00fcdtke, S.; Bartelt, C.; Stuckenschmidt, H. GRANDE: Gradient-Based Decision Tree Ensembles for Tabular Data. The Twelfth International Conference on Learning Representations. 2024.   \n[23] Huang, X.; Khetan, A.; Cvitkovic, M.; Karnin, Z. Tabtransformer: Tabular data modeling using contextual embeddings. arXiv preprint arXiv:2012.06678 2020,   \n[24] Hollmann, N.; M\u00fcller, S.; Eggensperger, K.; Hutter, F. Tabpfn: A transformer that solves small tabular classification problems in a second. arXiv preprint arXiv:2207.01848 2022,   \n[25] Vaswani, A.; Shazeer, N.; Parmar, N.; Uszkoreit, J.; Jones, L.; Gomez, A. N.; Kaiser, \u0141.; Polosukhin, I. Attention is all you need. Advances in neural information processing systems 2017, 30.   \n[26] M\u00fcller, S.; Hollmann, N.; Arango, S. P.; Grabocka, J.; Hutter, F. Transformers can do bayesian inference. arXiv preprint arXiv:2112.10510 2021,   \n[27] Radford, A.; Narasimhan, K.; Salimans, T.; Sutskever, I.; others Improving language understanding by generative pre-training. 2018,   \n[28] Lou, Y.; Obukhov, M. Bdt: Gradient boosted decision tables for high accuracy and scoring efficiency. Proceedings of the 23rd ACM SIGKDD international conference on knowledge discovery and data mining. 2017; pp 1893\u20131901.   \n[29] Friedman, J. H. Stochastic gradient boosting. Computational statistics & data analysis 2002, 38, 367\u2013378.   \n[30] Pedregosa, F. et al. Scikit-learn: Machine Learning in Python. Journal of Machine Learning Research 2011, 12, 2825\u20132830.   \n[31] Paszke, A.; Gross, S.; Massa, F.; Lerer, A.; Bradbury, J.; Chanan, G.; Killeen, T.; Lin, Z.; Gimelshein, N.; Antiga, L.; others Pytorch: An imperative style, high-performance deep learning library. Advances in neural information processing systems 2019, 32.   \n[32] Loshchilov, I.; Hutter, F. Decoupled weight decay regularization. arXiv preprint arXiv:1711.05101 2017,   \n[33] fvcore library. https://github.com/facebookresearch/fvcore/.   \n[34] Averagemn LGBM with hyperopt tuning. 2019; https://www.kaggle.com/code/donkeys/ lgbm-with-hyperopt-tuning/notebook, [Online; accessed 5-January-2023].   \n[35] Bahmani, M. Understanding LightGBM Parameters (and How to Tune Them). 2022; https: //neptune.ai/blog/lightgbm-parameters-guide, [Online; accessed 5-January-2023].   \n[36] Vanschoren, J.; van Rijn, J. N.; Bischl, B.; Torgo, L. OpenML: Networked Science in Machine Learning. SIGKDD Explorations 2013, 15, 49\u201360. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "Appendix ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "Table of Contents ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "A More DOFEN Settings 14 ", "page_idx": 12}, {"type": "text", "text": "A.1 Default Hyperparameters Settings for DOFEN 14   \nA.2 Detailed Model Configurations. . . . 14   \nA.3 Actual $N_{\\mathrm{estimator}}$ for each Dataset . . 14 ", "page_idx": 12}, {"type": "text", "text": "B More Tabular Benchmark Settings 16 ", "page_idx": 12}, {"type": "text", "text": "B.1 Dataset Counts . 16   \nB.2 Missing Model Baselines . . 16   \nB.3 Mappings of OpenML Task ID and Dataset Name 16 ", "page_idx": 12}, {"type": "text", "text": "C Computational Efficiency Analysis 18 ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "C.1 Computational Efficiency Analysis 18   \nC.2 Long Inference Time of DOFEN 19   \nC.3 Training Time of DOFEN . 20 ", "page_idx": 12}, {"type": "text", "text": "D Scalability of DOFEN 21 ", "page_idx": 12}, {"type": "text", "text": "E Interpretability of DOFEN 22 ", "page_idx": 12}, {"type": "text", "text": "F More Analysis 23 ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "F.1 Sampling in Relaxed ODT Forest Ensemble 23   \nF.2 Seed Ensemble . 24   \nF.3 An Alternative Strategy for Condition Selection . 25   \nF.4 An Alternative Strategy for Weight Selection . . 25   \nF.5 More Experiments for Section 4.3.2 (Activated rODT for Different Classes) . 26   \nF.6 Pruning of Relaxed ODT . 26 ", "page_idx": 12}, {"type": "text", "text": "G More Evaluation Results on Tabular Benchmark 27 ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "G.1 Performance Evaluation on Large-sized Benchmark 27   \nG.2 Detailed Evaluation Results . 28   \nH.1 Hardware Used 44   \nH.2 Hyperparameter Search Space . 44 ", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "A More DOFEN Settings ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "A.1 Default Hyperparameters Settings for DOFEN ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "In this section, we describe the hyperparameters used in our DOFEN model, along with their default values, as shown in Table 2. All notations used here have been previously introduced in Section 3, except for dropout_rate. The dropout_rate is applied in dropout layers, and its usage is detailed in Appendix A.2. ", "page_idx": 13}, {"type": "text", "text": "The calculated $N_{\\mathrm{estimator}}$ for each dataset can be found in Appendix A.3. Additionally, the hyperparameter search spaces for both the DOFEN model and all baseline models are detailed in Appendix H.2. ", "page_idx": 13}, {"type": "text", "text": "DOFEN is implemented in Pytorch [31]. For hyperparameters used in model optimization (e.g. optimizer, learning rate, weight decay, etc.), all experiments share the same settings. Specifically, DOFEN uses AdamW optimizer [32] with 1e\u22123 learning rate and no weight decay. The batch size is set to 256, and DOFEN is trained for 500 epochs without using learning rate scheduling or early stopping. ", "page_idx": 13}, {"type": "table", "img_path": "umukvCdGI6/tmp/0e6b27a6b2dff349ceaf1937b93dce0508f8411a8713198275bf452db371c007.jpg", "table_caption": ["Table 2: The default hyperparameters of DOFEN. "], "table_footnote": ["1 depth of a rODT an intermediate parameter to ensure that $N_{\\mathrm{rODT}}$ is an integer "], "page_idx": 13}, {"type": "text", "text": "A.2 Detailed Model Configurations. ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "In this appendix, we elucidate the specific configurations of the neural network layer composites, denoted as $\\Delta_{1},\\Delta_{2}$ , and $\\Delta_{3}$ in the main paper. ", "page_idx": 13}, {"type": "text", "text": "1. $\\Delta_{1}$ - Generate conditions for each column: $\\Delta_{1}$ is designed to generate conditions for both numerical and categorical data columns, as detailed in Figure 6. For categorical columns in particular, we employ embedding layers. These layers are utilized to transform categorical features into a format that the neural network can effectively process.   \n2. $\\Delta_{2}$ and $\\Delta_{3}$ - Derive weights and make predictions: The layers represented by $\\Delta_{2}$ and $\\Delta_{3}$ are responsible for generating weights based on the combination of conditions and making predictions, respectively. The relevant structures and processes are illustrated in Figure 7 and Figure 8. ", "page_idx": 13}, {"type": "text", "text": "3. Key Parameters: ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "\u2022 num_categories: This parameter represents the number of distinct categories in a given categorical column.   \n\u2022 drop_rate: This hyperparameter defines the extent of dropout operations applied within the network. ", "page_idx": 13}, {"type": "text", "text": "A.3 Actual $N_{\\mathbf{estimator}}$ for each Dataset ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "The $N_{\\mathrm{estimator}}$ is calculated through a pre-defined formula as shown in Table 2. In this section, we provide the calculated $N_{\\mathrm{estimator}}$ for each dataset in Table 3 when using default hyperparameters. Datasets are represented by their OpenML ID as described in Appendix B.3. ", "page_idx": 13}, {"type": "image", "img_path": "umukvCdGI6/tmp/27e8742070532d1bb991b63fcb8b180770e71e437f87ce56e4e97fa01c0b7765.jpg", "img_caption": [], "img_footnote": [], "page_idx": 14}, {"type": "text", "text": "Figure 6: Detailed network layer composite for $\\Delta_{1}$ . ", "page_idx": 14}, {"type": "image", "img_path": "umukvCdGI6/tmp/2b450b35e719795b3becb8d10c323340f512bf4cca6d6da73e32bc6c6de4e2d3.jpg", "img_caption": ["Figure 7: Detailed network layer composite for $\\Delta_{2}$ . "], "img_footnote": [], "page_idx": 14}, {"type": "image", "img_path": "umukvCdGI6/tmp/c42c4da5366869f636e304f9c4776000b22d1d8dbdb4831d5933aaa81200ebf9.jpg", "img_caption": ["Figure 8: Detailed network layer composite for $\\Delta_{3}$ . "], "img_footnote": [], "page_idx": 14}, {"type": "table", "img_path": "umukvCdGI6/tmp/d9c55b6d90e5d6d7023651aa71c2032a484cb06de74df9ceeeed789caa9e07d5.jpg", "table_caption": ["Table 3: $N_{\\mathrm{estimator}}$ for each dataset, as long as their $N_{\\mathrm{col}}$ and $N_{\\mathrm{rODT}}$ "], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "B More Tabular Benchmark Settings ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "B.1 Dataset Counts ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "In this section, we provide the dataset counts for each task for your reference, as presented in Table 4. ", "page_idx": 15}, {"type": "table", "img_path": "umukvCdGI6/tmp/64879d5a38bdd17a6a6aa85c6baa269a7e9f91d5abbf86b9dfbc8515626c1691.jpg", "table_caption": ["Table 4: Dataset counts for each task. "], "table_footnote": [], "page_idx": 15}, {"type": "text", "text": "B.2 Missing Model Baselines ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "We found that two baselines, MLP and HGBT, are absent from the evaluation results in the large-sized classification task because they are missing from the official repository. Furthermore, MLP, HGBT, and RandomForest are not included in the large-sized regression task for the same reason. ", "page_idx": 15}, {"type": "text", "text": "B.3 Mappings of OpenML Task ID and Dataset Name ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "In this section, we introduce the mappings between OpenML Task IDs and elaborate on how to download the corresponding datasets using these IDs. ", "page_idx": 15}, {"type": "text", "text": "The mappings are provided in Tables 5 to 8. To access the datasets, please follow the links below, which direct you to the OpenML website for each type of dataset. You can then search using the OpenML ID. ", "page_idx": 15}, {"type": "text", "text": "\u2022 Classification datasets with numerical features only: https://www.openml.org/search?type $=$ benchmark&study_type $=$ task&id=337   \n\u2022 Classification datasets with heterogeneous features: https://www.openml.org/search?type $=$ benchmark&study_type $=$ task&id=334   \n\u2022 Regression datasets with numerical features only: https://www.openml.org/search?type $=$ benchmark&study_type $=$ task&id=336 https://www.openml.org/search?type $=$ benchmark&study_type $=$ task&id=297 (only for task ID 361091)   \n\u2022 Regression datasets with heterogeneous features: https://www.openml.org/search?type $:=$ benchmark&study_type $=$ task&id=335 https://www.openml.org/search?type $=$ benchmark&study_type $=$ task&id=299 (only for task ID 361095) ", "page_idx": 15}, {"type": "table", "img_path": "umukvCdGI6/tmp/0eb81dd55e01cac22869831d54bda1271bd9f0d87ea7f68fd6de71b8a8b7d267.jpg", "table_caption": [], "table_footnote": [], "page_idx": 16}, {"type": "text", "text": "Table 6: OpenML Task ID mappings for classification datasets with heterogeneous features. ", "page_idx": 16}, {"type": "table", "img_path": "umukvCdGI6/tmp/bfeba301afa91284222e17fa29fbf02faa41cb6c273c753b9643b46ed24027f6.jpg", "table_caption": [], "table_footnote": [], "page_idx": 16}, {"type": "text", "text": "Table 7: OpenML Task ID mappings for regression datasets with numerical features only. ", "page_idx": 16}, {"type": "table", "img_path": "umukvCdGI6/tmp/30786cf5442ad50600f539d50a8f12c4b6ba177777e9aa8644fc977955c1b80f.jpg", "table_caption": [], "table_footnote": [], "page_idx": 16}, {"type": "table", "img_path": "umukvCdGI6/tmp/29e90a94143c637dead9461788b699599d69f355c5d8042698b7b65a928ff791.jpg", "table_caption": ["Table 8: OpenML Task ID mappings for regression datasets with heterogeneous features. "], "table_footnote": [], "page_idx": 17}, {"type": "text", "text": "C Computational Efficiency Analysis ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "C.1 Computational Efficiency Analysis ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "To discuss the computational efficiency, we analyzed the average floating point operations (FLOPs) [33], parameter sizes, and inference time of DOFEN and other baseline models. Our analyses covered both the default and optimal hyperparameter settings, where the optimal hyperparameter delivers the best performance for each model on each dataset. The experiments involving DNN-based models were performed using an NVIDIA GeForce RTX 2080 Ti, while those for the GBDT-based models utilized an AMD EPYC 7742 64-core Processor with 16 threads. ", "page_idx": 17}, {"type": "text", "text": "We begin with the comparison between DNN-based and GBDT-based models. This comparison primarily focuses on inference time, as FLOPs and parameter sizes are applicable for evaluating the efficiency of DNN-based models but cannot be applied to GBDTs. Additionally, inference times under the optimal parameters are provided only when those parameters are available. As shown in Tables Table 9 to Table 12, the inference times for all DNN-based models are slower than those for GBDT-based models. This is expected due to the inherent differences between the two types of models. ", "page_idx": 17}, {"type": "text", "text": "When compared to other DNN baselines, DOFEN achieves the highest performance, the lowest FLOPs, and the smallest parameter sizes but exhibits the relatively long inference time among all the DNN-based models. This inconsistency between FLOPs and inference time suggests that there is still room for implementation improvements in DOFEN. Hence, we conduct additional experiments to analyze which part of the DOFEN model is the computational bottleneck, as discussed in Appendix C.2, showing that the bottleneck of DOFEN arises from using group operations when constructing rODTs. Although this does not affect DOFEN\u2019s article, improvements can be made during future open-source releases. ", "page_idx": 17}, {"type": "table", "img_path": "umukvCdGI6/tmp/419d9d05d84702d9f96333cacddc2b4f3d49be4a5f8466ca870417ba4ddf97a8.jpg", "table_caption": ["Table 9: Computational efficiency analysis of default hyperparameters on medium-sized classification datasets. "], "table_footnote": [], "page_idx": 18}, {"type": "table", "img_path": "umukvCdGI6/tmp/74ddad0595a1efc88e12b6d895e68088221a9c68e0d2f27e981876236d639bbe.jpg", "table_caption": ["Table 10: Computational efficiency analysis of optimal hyperparameters on medium-sized classification datasets. "], "table_footnote": ["\\* The evaluation results are obtained from the Trompt paper without the corresponding optimal hyperparameters. Thus, the inference time under the optimal hyperparameters is unavailable. "], "page_idx": 18}, {"type": "table", "img_path": "umukvCdGI6/tmp/e505835126e0c09f0ad2e46ba6888eebf87f164a99e692394763415384f72ad7.jpg", "table_caption": ["Table 11: Computational efficiency analysis of default hyperparameters on medium-sized regression datasets. "], "table_footnote": [], "page_idx": 18}, {"type": "table", "img_path": "umukvCdGI6/tmp/935bada42b6d44af0335a4dd5217f26309159925f2b3b2527c9764a72319260f.jpg", "table_caption": ["Table 12: Computational efficiency analysis of optimal hyperparameters on medium-sized regression datasets. "], "table_footnote": ["\\* The evaluation results are obtained from the Trompt paper without the corresponding optimal hyperparameters. Thus, the inference time under the optimal hyperparameters is unavailable. "], "page_idx": 18}, {"type": "text", "text": "C.2 Long Inference Time of DOFEN ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "To find out the computation bottleneck of DOFEN, we analyzed the inference time of each DOFEN module in proportion, as shown in Table 13 and Table 14, which is averaged across 59 medium-sized datasets with default hyperparameters. Table A1 shows that the Forest Construction module consumes the most inference time. In Table A2, more detailed operations reveal that the sub-module $\\Delta_{2}$ in the Forest Construction module, which generates weights for each rODT, has the longest inference time. ", "page_idx": 18}, {"type": "text", "text": "", "page_idx": 19}, {"type": "text", "text": "The sub-module $\\Delta_{2}$ is designed with multiple MLP and normalization layers, implemented using group convolution and group normalization to parallelize scoring for each rODT. However, the efficiency of group convolution in PyTorch has been problematic and remains unresolved. Specifically, the operation efficiency decreases as the number of groups increases, sometimes making it slower than separate convolutions in CUDA streams (see PyTorch issues 18631, 70954, 73764). The sub-module $\\Delta_{1}$ also uses group convolution to parallelize condition generation across different numerical columns, resulting in slower inference times compared to other operations, though less significant than $\\Delta_{2}$ due to fewer groups being used. ", "page_idx": 19}, {"type": "text", "text": "However, we mainly focus on the concept and model structure in this paper, acknowledging that model implementation can be further optimized. For example, attention operations are originally slow due to quadratic complexity, and many recent works have successfully accelerated the speed of attention operations and reduced their memory usage. Hence, we believe there will be better implementations of these group operations with much greater efficiency in the future. ", "page_idx": 19}, {"type": "table", "img_path": "umukvCdGI6/tmp/36653347ccddae9c7c4fa03f9fbaf2e90f411b2df3a096c6d408108950ffa7db.jpg", "table_caption": ["Table 13: Average inference time proportion of each DOFEN module across 59 medium-sized datasets. "], "table_footnote": [], "page_idx": 19}, {"type": "table", "img_path": "umukvCdGI6/tmp/dc431d309b8c209867b8cd03964842992d2ec14f3d1fd6422e9149ccee07a3c3.jpg", "table_caption": ["Table 14: Average inference time proportion of each DOFEN operation across 59 medium-sized datasets. "], "table_footnote": [], "page_idx": 19}, {"type": "text", "text": "C.3 Training Time of DOFEN ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "To know more about how the slow inference time will affect the training time of DOFEN, we also conducted an experiment to compare the training time of DOFEN with other deep learning methods included in our paper (i.e. Trompt, FT Transformer, and NODE). We measured the training time on medium-sized datasets using both default and optimal hyperparameter settings, where the optimal hyperparameters refers to the settings that deliver the best performance for each model on each dataset. ", "page_idx": 19}, {"type": "text", "text": "This experiment was conducted using a single NVIDIA Tesla V100 GPU. During model training, we carefully ensured that no other computational processes were running concurrently to enable a fair comparison. Additionally, we excluded datasets that would cause OOM (Out of Memory) issues during training, resulting in the selection of 50 out of 59 medium-sized datasets. ", "page_idx": 19}, {"type": "text", "text": "The average training time across datasets for each model is provided in Table A7. The results show that the training time for DOFEN is relatively long, approximately twice as long as Trompt when using optimal hyperparameters. This extended training time may be due to the inefficient group operations involved in DOFEN, which consume about $80\\%$ of the computation time during the forward pass. For more details, please refer to Appendix C.2. Therefore, improving the efficiency of group operations could reduce both the training and inference time of DOFEN. ", "page_idx": 19}, {"type": "text", "text": "", "page_idx": 20}, {"type": "table", "img_path": "umukvCdGI6/tmp/f068c27690856a32fe62e5ce6009fb28faa185daad29a5dfd10ecdfad37afaa2.jpg", "table_caption": ["Table 15: Average training time of different methods using default and optimal hyperparameter settings on 50 medium-sized datasets. Numbers are in Seconds, with lower values indicating faster training speed. "], "table_footnote": [], "page_idx": 20}, {"type": "text", "text": "D Scalability of DOFEN ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "To discuss the scalability of DOFEN, we have conducted experiments to investigate its performance given changes in hyperparameters $m$ , $d$ , and the number of MLP layers (num_layers). In detail, changes in $m$ and $d$ affect the number of conditions $(N_{\\mathrm{cond}})$ , while alterations in $m$ impact both the total number of rODTs $(N_{\\mathrm{rODT}})$ and the number of rODTs within an rODT forest $(N_{\\mathrm{estimator}})$ . For further details on these parameters, please refer to Table 2. The num_layers hyperparameter, newly introduced, refers to the number of MLP layers in neural networks $\\Delta_{1},\\,\\Delta_{2}$ , and $\\Delta_{3}$ . A detailed introduction to $\\Delta_{1},\\Delta_{2}$ , and $\\Delta_{3}$ can be found in Appendix A.2. ", "page_idx": 20}, {"type": "text", "text": "Due to limited computational resources, we only conducted this experiment on datasets that would not cause out-of-memory (OOM) issues on our machine across all hyperparameter settings. This selection resulted in 51 out of 59 medium-sized datasets and 10 out of 14 large-sized datasets. ", "page_idx": 20}, {"type": "text", "text": "Based on Table 16 to Table 21, we observed that larger values of $m$ and $d$ enhance DOFEN\u2019s performance. Notably, improvements are more significant with large-sized datasets than with mediumsized datasets, likely because larger datasets benefti more from increased model capacity. In contrast, Table 20 reveals that an increase in num_layers generally results in poorer performance. This could be attributed to the substantial growth in parameter size and FLOPs, compared to adjustments in the $m$ and $d$ , potentially leading to overfitting. ", "page_idx": 20}, {"type": "table", "img_path": "umukvCdGI6/tmp/ea27a0470a1b71578a1b7ec98f16a4d5db00927b1af2ee790b3cf3b940ef7b4a.jpg", "table_caption": ["Table 16: Analysis of performance and efficiency across varied settings of $m$ on medium-sized datasets. "], "table_footnote": [], "page_idx": 20}, {"type": "table", "img_path": "umukvCdGI6/tmp/687072afb092360b74c4bd8785d26cc462fc8d1b034b93ef962788b4466fc9ce.jpg", "table_caption": ["Table 17: Analysis of performance and efficiency across varied settings of $m$ on large-sized datasets. "], "table_footnote": [], "page_idx": 20}, {"type": "table", "img_path": "umukvCdGI6/tmp/cbddb71f641c191b9f564b4af2eadd0d3ffb64211b6209bc6d8a9dba717e0807.jpg", "table_caption": ["Table 18: Analysis of performance and efficiency across varied settings of $d$ on medium-sized datasets. "], "table_footnote": [], "page_idx": 21}, {"type": "table", "img_path": "umukvCdGI6/tmp/97115da6f5a7c038c83fc092d80be83d7882a94c811c5f1790fdad2e54f9e6d7.jpg", "table_caption": ["Table 19: Analysis of performance and efficiency across varied settings of $d$ on large-sized datasets. "], "table_footnote": [], "page_idx": 21}, {"type": "table", "img_path": "umukvCdGI6/tmp/c149e9e1d521a28781a5c173433a3e4993e48eee0eabbc1ed57c26eb0df5997f.jpg", "table_caption": ["Table 20: Analysis of performance and efficiency across varied settings of num_layers on mediumsized datasets. "], "table_footnote": [], "page_idx": 21}, {"type": "table", "img_path": "umukvCdGI6/tmp/9e027c01f48ccdbebe002dd96567f3c2896e1e5429bf7caf690629bc9b000318.jpg", "table_caption": ["Table 21: Analysis of performance and efficiency across varied settings of num_layers on largesized datasets. "], "table_footnote": [], "page_idx": 21}, {"type": "text", "text": "E Interpretability of DOFEN ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "This section aims to demonstrate the interpretability of DOFEN. Specifically, we adopt a feature importance metric akin to the \"split\" or \"weight\" importance used in LightGBM and XGBoost, which counts how often a feature is used in the model. ", "page_idx": 21}, {"type": "text", "text": "To calculate DOFEN\u2019s feature importance of a specific sample, let $\\mathbf{F}\\in\\mathbb{R}^{N_{\\mathrm{rODT}}\\times N_{\\mathrm{col}}}$ be a matrix of feature occurrences across different rODTs. We then use the output of sub-module $\\Delta_{2}$ , a vector $\\vec{w}\\in\\mathbb{R}^{N_{\\mathrm{roDT}}}$ (Equation (6)), to represent the importance across all rODTs for each sample, as this weight $\\vec{w}$ is used for constructing rODT forest to perform prediction in DOFEN model. A softmax operation is further applied to the vector $\\vec{w}$ to ensure the importance sums to 1 (also done in line 6 of Algorithm 1). Finally, we perform a weighted sum between the feature occurrences and the importance of each rODT, resulting in a single vector $\\vec{t}\\,\\in\\,\\mathbb{R}^{N_{\\mathrm{col}}}$ representing DOFEN\u2019s feature importance for a specific sample. To calculate DOFEN\u2019s overall feature importance of a dataset, we simply average the feature importance of all samples in training dataset. ", "page_idx": 21}, {"type": "text", "text": "", "page_idx": 22}, {"type": "text", "text": "We tested the reliability of DOFEN\u2019s feature importance on three real-world datasets: the mushroom dataset, the red wine quality dataset, and the white wine quality dataset, following the experimental design used by Trompt. The results of these three datasets are shown in Tables 22 to 24, respectively. The results indicate that the top-3 important features identified by DOFEN align closely with those selected by other tree-based models, with only minor ranking differences. This demonstrates DOFEN\u2019s ability to reliably identify key features while maintaining interpretability despite its deep learning architecture. This further indicates that DOFEN may contain similar decision-making process as tree-based model does, as it is a tree-inspired deep neural network. ", "page_idx": 22}, {"type": "table", "img_path": "umukvCdGI6/tmp/9b08def5d466d5c3c66c39013b299d752965eb26bcdde91c5609605d01c60e68.jpg", "table_caption": ["Table 22: Top 3 Feature importance of DOFEN on mushroom dataset. "], "table_footnote": [], "page_idx": 22}, {"type": "table", "img_path": "umukvCdGI6/tmp/eef90c9256aeafa94d00b77e011cc6887a886fea497db8e036ce85f0ec3089d3.jpg", "table_caption": ["Table 23: Feature importance of DOFEN on red wine dataset. "], "table_footnote": [], "page_idx": 22}, {"type": "table", "img_path": "umukvCdGI6/tmp/ea2d6a850535df24edd765d483f6fd915dba1903f2f10b80b75dcd273e8bd66d.jpg", "table_caption": ["Table 24: Feature importance of DOFEN on white wine dataset. "], "table_footnote": [], "page_idx": 22}, {"type": "text", "text": "F More Analysis ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "F.1 Sampling in Relaxed ODT Forest Ensemble ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "The forest ensemble in DOFEN is a level higher than common tree-based models. This section attempts to explore its impact on model performance by ablating this higher-level ensemble. The experiment involves using all the constructed rODTs from Equation (5) to form a single forest, without the sampling of weights and embeddings as described in line 6 in Algorithm 1. In practice, we directly apply a softmax function to the weight vector $\\vec{w}$ and calculate the weighted sum of corresponding embeddings E. As a result, there is only one prediction for each sample, unlike $N_{\\mathrm{forest}}$ predictions as in Algorithm 1. ", "page_idx": 22}, {"type": "text", "text": "", "page_idx": 23}, {"type": "text", "text": "From the results in Table 25, it can be seen that with the ensemble of forests, the performance of DOFEN is improved across all datasets, independent of the types of tasks and features. The average improvement in classification datasets has reached 0.0363 in accuracy, while in regression datasets has reached 0.3367 in the R-squared score. ", "page_idx": 23}, {"type": "text", "text": "To further investigate the drastic drop in performance without using sampling in forest ensembles, we analyze performance at various training checkpoints. As shown in Figure 9, when sampling is not used in forest ensembles, training performance is significantly better compared to testing performance, and testing performance decreases with increasing training epochs, indicating an overfitting issue. Conversely, with an ensemble of multiple forests, both training and testing performance improve concurrently, thus mitigating the overfitting issue. ", "page_idx": 23}, {"type": "text", "text": "Based on the performance improvements from introducing a forest ensemble, we have applied an extra level of ensemble that combines multiple DOFEN models. However, the enhancement in performance is negligible. The detailed results can be found in Appendix F.2. ", "page_idx": 23}, {"type": "table", "img_path": "umukvCdGI6/tmp/3fd23f3830fbd521559c790a4b1be92a6935240c6c22f471bee9b6116790621f.jpg", "table_caption": ["Table 25: Comparing DOFEN with and without sampling in forest ensemble "], "table_footnote": [], "page_idx": 23}, {"type": "image", "img_path": "umukvCdGI6/tmp/1767a24ceae0dd6af31d0cd64100a36023dfb5bf034ef840e908be867b8f6d5c.jpg", "img_caption": ["Figure 9: Overfitting arises when not using sampling in the forest ensemble, affecting both (a) classification and (b) regression tasks. \"Train\" refers to training performance, and \"Test\" refers to testing performance. \"w/\" indicates the use of sampling to construct multiple forests, while \"w/o\" indicates the use of all constructed rODTs to form a single forest. "], "img_footnote": [], "page_idx": 23}, {"type": "text", "text": "F.2 Seed Ensemble ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "In this section, we explore the results of applying an additional layer of bagging ensemble to the DOFEN model, a technique we denote as the seed ensemble. Specifically, we infer the trained DOFEN model using 15 different random seeds. This results in 15 distinct predictions due to the random sampling procedure conducted in the rODT Forest Construction module. Building upon these predictions, we average the 15 different predictions to create another layer of bagging ensemble, which we then present as the final prediction. This experiment is conducted on a medium-sized tabular benchmark. As shown in Table 26, this seed ensemble approach further enhances the performance of the DOFEN model, even with a small $N_{\\mathrm{forest}}$ . The results further suggest that the DOFEN model can easily benefit from ensemble strategies, thanks to the random sampling procedure. ", "page_idx": 23}, {"type": "table", "img_path": "umukvCdGI6/tmp/c876a5de6e1fdd7f4eb117bacb6373a2aba954552446893b90b75f578ba4f434.jpg", "table_caption": ["Table 26: Comparing evaluation performance with and without seed ensemble at varying $N_{\\mathrm{forest}}$ "], "table_footnote": [], "page_idx": 24}, {"type": "text", "text": "F.3 An Alternative Strategy for Condition Selection ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "In the rODT Construction module, we implement a shuffle-then-reshape procedure to construct rODTs as outlined in Equation (5). The shuffle of matrix M serves as a straightforward approach to delivering a diverse set of condition combinations for subsequent segmentation. In this section, we aim to experiment with an alternative strategy for selecting columns to construct rODTs, which we adopt the column selection strategy used by CatBoost to form the rODTs in our DOFEN model, we denote this approach as \u2019Catboost-Init\u2019. Specifically, we begin by selecting a machine learning algorithm that also employs ODT as the base element, namely, CatBoost. Subsequently, we train the CatBoost model and use the columns it identifies post-training to construct our rODTs. In the context of experimental configurations, to ensure a fair comparision, it is crucial to equate the capacity of CatBoost model with the default settings of DOFEN. To achieve this, we set the depth and number of boosting iterations of Catboost as the depth of an rODT $(d)$ and the total number of rODT $(N_{\\mathrm{rODT}})$ in DOFEN, respectively. The CatBoost trained based on these configurations is denoted as \u2019CatBoost\\*\u2019 in the context. ", "page_idx": 24}, {"type": "text", "text": "The results are presented in Table 27. As can be seen, the \u2019Catboost-Init\u2019 approach achieves performance comparable to the \u2019CatBoost\\*\u2019 approach and generally outperforms the default shuffle approach. This indicates that designing a more sophisticated approach for rODT construction indeed contributes to better performance. However, adopting a selection strategy from a tree-based model results in a two-stage modeling process, which contradicts our goal of designing an end-to-end differentiable DNN model. This intriguing insight leads us to consider a more innovative end-to-end condition selection approach, which we will explore in future work. ", "page_idx": 24}, {"type": "table", "img_path": "umukvCdGI6/tmp/6d2fa3c8c3e1ae77be1505b84621a80aa018d6d7b4f69c64b33824249892a278.jpg", "table_caption": ["Table 27: Comparing the column selection strategy of DOFEN. "], "table_footnote": [], "page_idx": 24}, {"type": "text", "text": "F.4 An Alternative Strategy for Weight Selection ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "In the Two-level rODT Ensemble module, our default method involves random sampling of weights. We contrast this approach with an alternative weight selection strategy, denoted as sliding window selection. The method creates $N_{\\mathrm{forest}}$ windows, each containing $N_{\\mathrm{estimator}}$ weights. These windows are then evenly distributed across $N_{\\mathrm{rODT}}$ weights. Within each window, the weights are collectively treated as a rODT forest. As shown in Table 28, our results indicate that random sampling yields better performance compared to the sliding window selection. This finding substantiates that the random sampling approach already works well compared to a sophisticated alternative. Investigating a more advanced and effective approach is worth considering in future work. ", "page_idx": 24}, {"type": "table", "img_path": "umukvCdGI6/tmp/917c8e5669859e4fd30d436400a9e5e1475cb473bf2f120f4088f1595f954f28.jpg", "table_caption": ["Table 28: The comparison of random sampling and sliding window selection of weights. "], "table_footnote": [], "page_idx": 24}, {"type": "text", "text": "F.5 More Experiments for Section 4.3.2 (Activated rODT for Different Classes) ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "In this section, we aim to test whether the findings presented in Section 4.3.2 can be replicated on another dataset. Consequently, we have chosen another binary classification dataset (compass-twoyears) and repeated the experiment using the same settings. The experimental results are depicted in Figure 10. As shown in Figure 10a, weights with higher standard deviation exhibit distinct distributions between true positive and true negative samples. Conversely, Figure 10b illustrates an opposite trend. Overall, conducting the experiment on another dataset further validates our findings. ", "page_idx": 25}, {"type": "image", "img_path": "umukvCdGI6/tmp/180737c26b1e0d998a67a4d6695fe52d23c5e645ed09f392c0ac966724b5d20a.jpg", "img_caption": ["(a) Relaxed ODTs with large weight variation. "], "img_footnote": [], "page_idx": 25}, {"type": "image", "img_path": "umukvCdGI6/tmp/610f59263b18a65c33cb6708c9de45f3f9e65f6bd982d2847026f25bd307b0cf.jpg", "img_caption": ["(b) Relaxed ODTs with small weight variation. "], "img_footnote": [], "page_idx": 25}, {"type": "text", "text": "Figure 10: In the compass dataset, the weights $w_{i}$ of rODT are sorted based on the standard deviation calculated across true positive (TP) and true negative (TN) samples in the testing data. Figure 10a shows that the weights of TP samples differ significantly from those of TN samples when the standard deviation of the weights is higher. Conversely, Figure 10b reveals contrasting results for weights with a lower standard deviation. ", "page_idx": 25}, {"type": "text", "text": "F.6 Pruning of Relaxed ODT ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Following Section 4.3.2, in this section, we aim to examine the performance change after pruning weights with small standard deviations and their corresponding embeddings. ", "page_idx": 25}, {"type": "text", "text": "Table 29 shows the performance under different pruning ratios. The column labeled \u2019by dataset\u2019 indicates that we tailored the pruning ratio for each dataset based on its validation data. As shown in Table 29, pruning these rODTs does not negatively affect performance. In fact, a minor degree of pruning can actually enhance performance, with the optimal pruning ratio being 0.02 for classification datasets and 0.1 for regression datasets. Notice that the \u2019by dataset\u2019 approach is better suited to real-world scenarios, even though it does not always yield the best performance. ", "page_idx": 25}, {"type": "table", "img_path": "umukvCdGI6/tmp/61966fef18f468812f70e84a326a85e4be84e477e7aa5f8928e652148f2623c7.jpg", "table_caption": ["Table 29: Pruning of rODT with varying ratio. Weights $w_{i}$ with lower standard deviation are pruned. "], "table_footnote": [], "page_idx": 25}, {"type": "text", "text": "We then investigate the outcomes when weights with higher standard deviations are pruned. Consequently, we sort the weights and prune them from the higher end. The results, presented in Table 30, show that the performance in both classification and regression tasks monotonically drops as the prune ratio increases. This finding suggests that the standard deviation of weights is a good indicator of their importance in making predictions. It further validates why pruning weights with lower standard deviation does not harm performance and, in some cases, even helps. ", "page_idx": 25}, {"type": "table", "img_path": "umukvCdGI6/tmp/a6e072722bc13cff9e6655ca27d39e3e686f3c5aa4f24f076823a083eabb9277.jpg", "table_caption": ["Table 30: rODT pruning with varying ratio. Weights $w_{i}$ with higher standard deviation are pruned. "], "table_footnote": [], "page_idx": 25}, {"type": "text", "text": "In addition, we discuss another, potentially more straightforward, pruning approach. Specifically, we prune the weights $w_{i}$ based on their average value across samples. Similar to the experiments that use standard deviation as the metric for pruning, this time we sort the weights by their average. We then attempt to prune the weights from both the top and bottom ends. The results are provided in Table 31 and Table 32, suggesting that the value of weights is not an effective indicator for pruning. Although there is some improvement in performance at a low ratio, this approach generally diminishes performance with larger ratios, regardless of whether the weights are pruned from the higher or lower end. ", "page_idx": 26}, {"type": "table", "img_path": "umukvCdGI6/tmp/72f98edd99b503f9c1f2e8ad382e965dc2c7ae048eb3a045967f5a623bdbd62e.jpg", "table_caption": ["Table 31: rODT pruning with varying ratio. Weights $w_{i}$ with lower average value are pruned. "], "table_footnote": [], "page_idx": 26}, {"type": "table", "img_path": "umukvCdGI6/tmp/4ce8b243f6da33d4178bcfa54decbc1b3cb2b99372022ff8fdb11c4de81d9a9a.jpg", "table_caption": ["Table 32: rODT pruning with varying ratio. Weights $w_{i}$ with higher average value are pruned. "], "table_footnote": [], "page_idx": 26}, {"type": "text", "text": "G More Evaluation Results on Tabular Benchmark ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "G.1 Performance Evaluation on Large-sized Benchmark ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "This section discusses the evaluation results on large-sized classification and regression tasks. Overall, the results demonstrate a similar trend as the medium-sized tabular benchmark. Notably, DOEFN achieves the top ranks in both tasks with numerical features. ", "page_idx": 26}, {"type": "image", "img_path": "umukvCdGI6/tmp/cc81626703c911b9aad2b103fbd7b2ffa84f7cffdba9d10090ce14bed7dc9625.jpg", "img_caption": ["Figure 11: Results on large-sized classification datasets. "], "img_footnote": [], "page_idx": 26}, {"type": "text", "text": "Classification. In Figure 11a, DOFEN even surpasses CatBoost to become the top performer. Conversely, in Figure 11b, CatBoost clearly outperforms other models. FT-Transformer, Trompt and DOFEN are the best-performing tabular DNN models, though they rank in the middle among all models. As a result, with the current development of tabular DNN models, their performance in processing numerical features is already on par with or even surpass that of tree-based models, and they are more advantageous for large-sized datasets. However, DOFEN and other DNN models are still less efficient in handling heterogeneous features. ", "page_idx": 26}, {"type": "image", "img_path": "umukvCdGI6/tmp/9995d80c2a1513b3b2d26940c90212a9dd3ff7387e88e651e2e9b1afb13b146f.jpg", "img_caption": ["Figure 12: Results on large-sized regression datasets. "], "img_footnote": [], "page_idx": 27}, {"type": "text", "text": "Regression. In Figure 12a, the leading models remain DOFEN, XGBoost, and CatBoost. DOFEN\u2019s proficiency in handling numerical features, further enhanced by the increased data volume, enables it to secure the top position once again. In Figure 12b, DOFEN and Trompt barely maintain their positions within the leading group, yet they still stand out from the other DNN models. ", "page_idx": 27}, {"type": "text", "text": "G.2 Detailed Evaluation Results ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "In the main paper, we have discussed the overall performance of DOFEN. To simplify tables, we map dataset names with their OpenML ID, as described in Appendix B.3. The evaluation results of each task are organized in Table 33. Please refer to the detailed figures and tables for each task of your interest. The evaluation metrics are accuracy for classification tasks and $\\mathrm{R^{2}}$ score for regression tasks, consistent with our main paper. Furthermore, we calculate the mean and standard deviation of ranks across datasets to provide the rank for each model in the tables. ", "page_idx": 27}, {"type": "table", "img_path": "umukvCdGI6/tmp/5b0bf81af01393d6c506b89c02cb94b8a1fc94fb26421772e8f66eeb8abb9ee7.jpg", "table_caption": ["Table 33: Tables and figures for each task. "], "table_footnote": [], "page_idx": 27}, {"type": "image", "img_path": "umukvCdGI6/tmp/036730added0e2792b0e34f91f5231673648bf65ee4bfea409ad98d85508de7d.jpg", "img_caption": ["Figure 13: Results on each medium-sized classification datasets with only numerical features. "], "img_footnote": [], "page_idx": 28}, {"type": "image", "img_path": "umukvCdGI6/tmp/afeea8b0a4d5b0c289788b7ee01988bf2b13c473b17688c85834c19ec8ea42f0.jpg", "img_caption": ["Figure 14: Results on each medium-sized classification datasets with heterogeneous features. "], "img_footnote": [], "page_idx": 29}, {"type": "image", "img_path": "umukvCdGI6/tmp/80da1299fd59c0ee1c9910ad5c520bb48b37332a9ad85088bc6334f1effd4e87.jpg", "img_caption": ["Figure 15: Results on each medium-sized regression datasets with numerical features. "], "img_footnote": [], "page_idx": 30}, {"type": "image", "img_path": "umukvCdGI6/tmp/66edc98ac9e6f137077f52ecfdd4d08b0074026b2dd04da58e9686bdd8f1c5d2.jpg", "img_caption": [], "img_footnote": [], "page_idx": 31}, {"type": "image", "img_path": "umukvCdGI6/tmp/5361ce1b33fb11045d9bfc04ad3e2995a5fff66c4ea42245b0246e1971d5787c.jpg", "img_caption": ["Figure 16: Results on each medium-sized regression datasets with heterogeneous features. "], "img_footnote": [], "page_idx": 31}, {"type": "image", "img_path": "umukvCdGI6/tmp/8d79575bb6b9eed1acfa001ad2971aa5d39c19ade587d701a04a38886683c0ea.jpg", "img_caption": ["Figure 17: Results on each large-sized classification datasets with only numerical features. "], "img_footnote": [], "page_idx": 32}, {"type": "image", "img_path": "umukvCdGI6/tmp/c801428ede24a2774ecb5e53560c166965fdf84c9356e235581e37f11581b7ec.jpg", "img_caption": ["Figure 18: Results on each large-sized classification datasets with heterogeneous features. "], "img_footnote": [], "page_idx": 32}, {"type": "image", "img_path": "umukvCdGI6/tmp/e902bee63745cbad4a9809e2188a4c1c897ac77d4639ed7e07eda53ff2781ba8.jpg", "img_caption": ["Figure 19: Results on each large-sized regression datasets with numerical features. "], "img_footnote": [], "page_idx": 32}, {"type": "image", "img_path": "umukvCdGI6/tmp/8b2272c5b27febc2aaac9f9ce391275b22c30496113355dcd4c5d08a1f78f019.jpg", "img_caption": ["Figure 20: Results on each large-sized regression datasets with heterogeneous features. "], "img_footnote": [], "page_idx": 33}, {"type": "table", "img_path": "umukvCdGI6/tmp/71187310da2de0d57a5d50f0bda9f7098f7531f1ebb9d2d8f2d95414902bdd2a.jpg", "table_caption": ["Table 34: The performance of medium-sized classification task (numerical features only) (1). "], "table_footnote": [], "page_idx": 33}, {"type": "table", "img_path": "umukvCdGI6/tmp/7c23956cdcfeea986ecc0603969413d034301ee3c3439fbe38fbc77c28c185cf.jpg", "table_caption": ["Table 35: The performance of medium-sized classification task (numerical features only) (2). "], "table_footnote": [], "page_idx": 34}, {"type": "table", "img_path": "umukvCdGI6/tmp/4842a6d9a629e24ef62228ac68b7d5220d8227fc57de295bb5f0fe216ea2fcf6.jpg", "table_caption": ["Table 36: The performance of medium-sized classification task (heterogeneous features). "], "table_footnote": [], "page_idx": 35}, {"type": "table", "img_path": "umukvCdGI6/tmp/8686a29a1f747401620f7166e958279c44907a7580b18a2d8407657481e9573f.jpg", "table_caption": ["Table 37: The performance of medium-sized regression task (numerical features only) (1). "], "table_footnote": [], "page_idx": 36}, {"type": "table", "img_path": "umukvCdGI6/tmp/cd64e35abc5fd105ac602c37bd197986970d7fe15bcae1c3cc9435e2c19e4974.jpg", "table_caption": ["Table 38: The performance of medium-sized regression task (numerical features only) (2). "], "table_footnote": [], "page_idx": 37}, {"type": "table", "img_path": "umukvCdGI6/tmp/af08b8f7e808df9f2870906d9a59455d1120f6f1c46cc0ef8c58f3c7745a7cb9.jpg", "table_caption": ["Table 39: The performance of medium-sized regression task (heterogeneous features) (1). "], "table_footnote": [], "page_idx": 38}, {"type": "table", "img_path": "umukvCdGI6/tmp/d1de6b201af68a3c3bd4d5ea7f4a3d8a82a45233d76057b811f9cdfd0d5f8e72.jpg", "table_caption": ["Table 40: The performance of medium-sized regression task (heterogeneous features) (2). "], "table_footnote": [], "page_idx": 39}, {"type": "table", "img_path": "umukvCdGI6/tmp/98907b92d49b22ba4a12d233e27ba95f5158efd1394c36a7a7cb77afe7ba2037.jpg", "table_caption": ["Table 41: The performance of large-sized classification task (numerical features only). "], "table_footnote": [], "page_idx": 40}, {"type": "table", "img_path": "umukvCdGI6/tmp/05b2c460153be2fcd8c079e0ed8b08f680d873eb1081777c4439635a533aae49.jpg", "table_caption": ["Table 42: The performance of large-sized classification task (heterogeneous features). "], "table_footnote": [], "page_idx": 41}, {"type": "table", "img_path": "umukvCdGI6/tmp/888554150483511e4a2e19bfa9db07757cc002ee7ad28aa742924e173b568686.jpg", "table_caption": ["Table 43: The performance of large-sized regression task (numerical features only). "], "table_footnote": [], "page_idx": 42}, {"type": "table", "img_path": "umukvCdGI6/tmp/abc5fa61eda552e62f098aa4fa3e6fdcf82bae8cc3e4e155214fa5812eed1714.jpg", "table_caption": ["Table 44: The performance of large-sized regression task (heterogeneous features). "], "table_footnote": [], "page_idx": 43}, {"type": "text", "text": "H More Experiment Settings ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "H.1 Hardware Used ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "The following hardware configuration was used for all of our experiments. The hardware selection was based on availability, with neural networks consistently run on GPUs and tree-based models executed on CPUs. ", "page_idx": 43}, {"type": "text", "text": "GPUs: NVIDIA GeForce RTX 2080 Ti, NVIDIA DGX1, NVIDIA A100 ", "page_idx": 43}, {"type": "text", "text": "CPUs: Intel(R) Xeon(R) Silver 4210 CPU, Intel(R) Xeon(R) CPU E5-2698 v4, AMD EPYC605 7742 64-core Processor ", "page_idx": 43}, {"type": "text", "text": "H.2 Hyperparameter Search Space ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "This section details the hyperparameter search space adopted for each model, as referenced in various tables (Tables 45 to 56). We have employed search spaces consistent with those presented in the Tabular Benchmark [1] for models including XGBoost, GradientBoostingTree, RandomForest, FT-Transformer, SAINT, ResNet, and MLP. ", "page_idx": 43}, {"type": "text", "text": "Additionally, we have defined specific search spaces for newer baselines such as CatBoost, LightGBM, Trompt, NODE, and GRANDE. For CatBoost, our search space aligns with the parameters specified by the FT-Transformer study [11]. In the case of LightGBM, we have derived the search space based on recommendations from field practitioners, as cited in [34, 35]. For NODE, our approach follows the guidelines provided in TabZilla [15]. For GRANDE, we follow the settings provided in the notebook example from the official github of GRANDE. ", "page_idx": 43}, {"type": "table", "img_path": "umukvCdGI6/tmp/951520be6156a09286380cf1a91ab769015bcbfa0a377650a09262a5f77fb598.jpg", "table_caption": ["Table 46: Hyperparameter search space of XGBoost. "], "table_footnote": [], "page_idx": 44}, {"type": "table", "img_path": "umukvCdGI6/tmp/ebd24c831b2afdd9faf8e603e5fa73c248e29b81e5dd1f3a18cc36f3d2b2203f.jpg", "table_caption": ["Table 47: Hyperparameter search space of CatBoost. "], "table_footnote": [], "page_idx": 44}, {"type": "text", "text": "In the context of our model, DOFEN, we have focused our search on the number of $m$ and $d$ , which relate to the varied number of $N_{\\mathrm{cond}}$ and the conditions per rODT. Additionally, we have explored the drop_rate parameter to fine-tune the degree of regularization in our model. It is important to note that the overall search space for DOFEN is relatively compact when compared to the other baseline models while achieve competitive performance. ", "page_idx": 44}, {"type": "table", "img_path": "umukvCdGI6/tmp/0c10195485d21cac08198137da20196c466cb118f5112a96edcf0c9641f6d608.jpg", "table_caption": ["Table 45: Hyperparameter search space of DOFEN. "], "table_footnote": [], "page_idx": 44}, {"type": "table", "img_path": "umukvCdGI6/tmp/bd7c6a123b90e4d0a464e213975e92ae360e7667b6e7da0f1a9240dbfcbf2646.jpg", "table_caption": ["Table 48: Hyperparameter search space of LightGBM "], "table_footnote": [], "page_idx": 44}, {"type": "table", "img_path": "umukvCdGI6/tmp/0f8122fac37bb1839db23be1141eca054d6ff7a4b11579d0bbcf5f42acd40aa1.jpg", "table_caption": [], "table_footnote": [], "page_idx": 45}, {"type": "table", "img_path": "umukvCdGI6/tmp/a30ceefe938cc3b0f476572e2bbc21622b82c35bbe812f36b935e5ad211b7d19.jpg", "table_caption": ["Table 50: Hyperparameter search space of RandomForest. "], "table_footnote": [], "page_idx": 45}, {"type": "table", "img_path": "umukvCdGI6/tmp/da26bb96ee9f152aacbad536218cc80c472c85cc638d35c67a3efcbcde105371.jpg", "table_caption": ["Table 51: Hyperparameter search space of NODE. "], "table_footnote": [], "page_idx": 45}, {"type": "table", "img_path": "umukvCdGI6/tmp/90be5bf34cb8dc05a1bba4066542e1cc176848b8771a1a41d62be5ca4d69a110.jpg", "table_caption": ["Table 52: Hyperparameter search space of Trompt. "], "table_footnote": [], "page_idx": 45}, {"type": "table", "img_path": "umukvCdGI6/tmp/f1f345af420cea661ec8ad0554775d403a5e5c089baf577da2ccef86f0d1c6b5.jpg", "table_caption": ["Table 53: Hyperparameter search space of FT-Transformer. "], "table_footnote": [], "page_idx": 45}, {"type": "table", "img_path": "umukvCdGI6/tmp/416fa742fcde83d91d1bbabd2a2bb7e6f8f812eafd669e4fdeed1abce7e0b5e4.jpg", "table_caption": [], "table_footnote": [], "page_idx": 46}, {"type": "table", "img_path": "umukvCdGI6/tmp/9d16d44c5dbbc93465cd506b49a8ec1fd74379b075c5760e00139912c63b6174.jpg", "table_caption": ["Table 55: Hyperparameter search space of ResNet. "], "table_footnote": [], "page_idx": 46}, {"type": "table", "img_path": "umukvCdGI6/tmp/f17ca8af2f0a8c60c20e4292412b58c0e09ebab8cb0a535560eef21c895d3916.jpg", "table_caption": ["Table 56: Hyperparameter search space of MLP. "], "table_footnote": [], "page_idx": 46}, {"type": "table", "img_path": "umukvCdGI6/tmp/0a52c0f1879fb1b3f65eb6d814605da3658b3dc0ea077a0d0684174ce720cad5.jpg", "table_caption": ["Table 57: Hyperparameter search space of GRANDE. "], "table_footnote": [], "page_idx": 46}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 47}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 47}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 47}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 47}, {"type": "text", "text": "Justification: We have verified our idea using experiments as shown in Section 4. The results not only reveal the state-of-the-art performance of DOFEN among deep neural networks on tabular data but also demonstrate the nuance of its architecture design, which echos the contribution and scope we mentioned in the abstract and introduction. ", "page_idx": 47}, {"type": "text", "text": "Guidelines: ", "page_idx": 47}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 47}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 47}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 47}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 47}, {"type": "text", "text": "Justification: See Section 5 for limitations. ", "page_idx": 47}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 47}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 47}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 47}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 47}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 48}, {"type": "text", "text": "Justification: This paper focuses on model architecture design and empirical evaluations based on hypotheses, without making theoretical assumptions or providing proofs. ", "page_idx": 48}, {"type": "text", "text": "Guidelines: ", "page_idx": 48}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 48}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 48}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 48}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 48}, {"type": "text", "text": "Justification: See Section 3.2 and Appendix A.2 for model implementation details, Appendices A.1 and H.2 for hyperparameter settings, and Section 4.1 and Appendices B.1 to B.3 for dataset settings. ", "page_idx": 48}, {"type": "text", "text": "Guidelines: ", "page_idx": 48}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 48}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 49}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 49}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 49}, {"type": "text", "text": "Justification: The code will be published in the future; currently, we provide an anonymous version in the supplemental material. For datasets, we use an open-source benchmark and strictly follow its official implementation as described in Section 4.1. ", "page_idx": 49}, {"type": "text", "text": "Guidelines: ", "page_idx": 49}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 49}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 49}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 49}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 49}, {"type": "text", "text": "Justification: For dataset settings, see Section 4.1 and Appendices B.1 to B.3. For detailed hyperparameter settings, see Appendices A.1 and H.2. ", "page_idx": 49}, {"type": "text", "text": "Guidelines: ", "page_idx": 49}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 49}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 49}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 49}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 49}, {"type": "text", "text": "Justification: For tables in Appendix G.2, we calculate the mean and standard deviation of ranks across datasets to provide the rank for each model with their confidence interval. ", "page_idx": 49}, {"type": "text", "text": "Guidelines: ", "page_idx": 49}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 49}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 50}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 50}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 50}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 50}, {"type": "text", "text": "Justification: See Appendix H.1 for hardware settings and Appendix C.1 for the FLOPs and inference time of different models. ", "page_idx": 50}, {"type": "text", "text": "Guidelines: ", "page_idx": 50}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 50}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 50}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 50}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 50}, {"type": "text", "text": "Justification: The research conducted in our paper conforms, in every respect, with the NeurIPS Code of Ethics. ", "page_idx": 50}, {"type": "text", "text": "Guidelines: ", "page_idx": 50}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 50}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 50}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 50}, {"type": "text", "text": "Answer: [No] ", "page_idx": 50}, {"type": "text", "text": "Justification: This paper proposes a novel DNN model, with experiments focusing on performance comparisons with other existing DNN and tree-based models, as well as exploring the mechanisms behind this novel method. We acknowledge that the introduction of new model structures can have both positive and negative societal impacts (e.g. fairness considerations); however, these aspects are not the primary scope or focus of this paper. ", "page_idx": 50}, {"type": "text", "text": "Guidelines: ", "page_idx": 51}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 51}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 51}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 51}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 51}, {"type": "text", "text": "Justification: This paper poses no such risks. ", "page_idx": 51}, {"type": "text", "text": "Guidelines: ", "page_idx": 51}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 51}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 51}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 51}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 51}, {"type": "text", "text": "Justification: The public assets accessed in this paper include models and datasets. We have clearly cited each of them and strictly followed their terms of use. For all public models, please refer to their respective websites for the license information. Regarding the Tabular Benchmark, all datasets used are publicly available from OpenML [36] under the CC-BY 4.0 license. Please refer to Appendix B.3 for detailed information on the datasets used. ", "page_idx": 51}, {"type": "text", "text": "Guidelines: ", "page_idx": 51}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 51}, {"type": "text", "text": "", "page_idx": 52}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 52}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 52}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 52}, {"type": "text", "text": "Justification: The source code for this paper will be published under the Apache License 2.0 in the future. During the reviewing process, a minimal workable example of DOFEN is provided in the supplementary material, along with a simple README explaining how to execute the code. ", "page_idx": 52}, {"type": "text", "text": "Guidelines: ", "page_idx": 52}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 52}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 52}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 52}, {"type": "text", "text": "Answer: [NA] ", "text_level": 1, "page_idx": 52}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 52}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 52}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "page_idx": 52}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 52}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 52}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 53}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 53}]