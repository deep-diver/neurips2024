[{"type": "text", "text": "Detecting Bugs with Substantial Monetary Consequences by LLM and Rule-based Reasoning ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Brian Zhang University of Texas at Austin Austin, TX 78705 bz5346@utexas.edu ", "page_idx": 0}, {"type": "text", "text": "Zhuo Zhang   \nPurdue University   \nWest Lafayette, IN 47906   \nzhan3299@purdue.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Financial transactions are increasingly being handled by automated programs called smart contracts. However, one challenge in the adaptation of smart contracts is the presence of vulnerabilities, which can cause significant monetary loss. In 2024, $\\mathbb{S}247.88\\;\\mathrm{M}$ was lost in 20 smart contract exploits. According to a recent study, accounting bugs (i.e., incorrect implementations of domain-specific financial models) are the most prevalent type of vulnerability, and are one of the most difficult to find, requiring substantial human efforts. While Large Language Models (LLMs) have shown promise in identifying these bugs, they often suffer from lack of generalization of vulnerability types, hallucinations, and problems with representing smart contracts in limited token context space. This paper proposes a hybrid system combining LLMs and rule-based reasoning to detect accounting error vulnerabilities in smart contracts. In particular, it utilizes the understanding capabilities of LLMs to annotate the financial meaning of variables in smart contracts, and employs rule-based reasoning to propagate the information throughout a contract\u2019s logic and to validate potential vulnerabilities. To remedy hallucinations, we propose a feedback loop where validation is performed by providing the reasoning trace of vulnerabilities to the LLM for iterative self-reflection. We achieve $75.6\\%$ accuracy on the labelling of financial meanings against human annotations. Furthermore, we achieve a recall of $90.5\\%$ from running on 23 real-world smart contract projects containing 21 accounting error vulnerabilities. Finally, we apply the automated technique on 8 recent projects, finding 4 known and 2 unknown bugs. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Blockchains are public, append-only ledgers that record data in a secure manner and provide a foundation for many financial applications. Two such applications are tokens and smart contracts. Tokens are cryptocurrencies (e.g., Bitcoin Nakamoto [2008], WETH WETH [2024]). Smart contracts are programs that perform a service once deployed to the blockchain, typically financial in nature. Example services include banking, marketplaces, and loaning. With the digitization of finance, smart contracts have seen increasing usage for financial transactions. For example, the Ethereum blockchain has over 40 million smart contracts deployed Bitkan [2024]. Smart contracts are implemented in a Java-like language known as Solidity [2023] They are similar to traditional software applications in that they are composed of functions, and not all functions can be invoked (due to function modifiers). Entry functions are those that can be directly invoked by users, which are defined as any entities (e.g., humans) interacting with the smart contract. ", "page_idx": 0}, {"type": "text", "text": "Our work focuses on one challenge in smart contracts, namely their vulnerability to accounting bugs. As defined by Zhang et al. [2023], accounting bugs are incorrect implementations of domain-specific business models. According to the study, accounting bugs are the most popular type of bug, as well as one of the most difficult for humans to identify. Furthermore, they cause significant damage if exploited. In 2024, more than $\\mathbb{S}50\\;\\mathbf{M}$ dollars in damages DefiLlama [2024] were caused by 8 $38\\mathrm{th}$ Conference on Neural Information Processing Systems (NeurIPS 2024). ", "page_idx": 0}, {"type": "text", "text": "accounting bugs so far. There are many existing vulnerability detection techniques for smart contracts, including fuzzers W\u00fcstholz and Christakis [2020]; Choi et al. [2021] , program analysis Wang et al. [2019]; Huang et al. [2022] , verification Jiao et al. [2020]; Tan et al. [2022] , and symbolic execution Consensys [2024]; Bose et al. [2022]. However, we find that most cannot handle accounting bugs. Recently, Zhang [2024] proposed a program analysis based technique that relies on a type system. In particular, it relies on manual annotation of initial types of variables, which include the currency unit, scaling factor, and correspondence to some functionality in a bank. With such knowledge, it performs type checking to detect accounting bugs. However, the annotation is extensive, in many cases requiring deep understanding of the code and even external documentation. Hence, there is a need to develop an automated technique for detecting accounting bugs in smart contracts. ", "page_idx": 1}, {"type": "text", "text": "According to Zhang et al. [2023], the reason that accounting bugs are difficult to identify is due to the necessity to first understand the complex business logic of smart contracts. We hypothesize that LLMs like GPT can be used to perform the analysis, citing their capability to easily comprehend code. For example, Sun et al. [2024] propose an LLM based technique that performs analysis of smart contracts, through utilizing context from past vulnerabilities as well as techniques such as Chain-of-thought (COT) to improve the reasoning capability of the LLM. However, the approach does not focus on accounting bugs, and the analysis is function-level as opposed to flie-level. Furthermore, a significant concern with LLM-based techniques is the generation of hallucinations. Hence, a naive approach focused on detecting accounting bugs providing high-level descriptions and few-shot examples of accounting bugs does not suffice, due to the observations that: ", "page_idx": 1}, {"type": "text", "text": "Challenge 1: The code of smart contracts provided for analysis is often too large or too costly to fit in the limited token context space. While it is possible to filter non-relevant functions (i.e., functions which cannot be invoked by the public), the remaining code usually retains the same issues. Furthermore, reducing the scope of the analysis to function-level can miss accounting bugs that spread across multiple functions or even files. ", "page_idx": 1}, {"type": "text", "text": "Challenge 2: Most warnings produced by the method are often hallucinations from the model, and there is no existing technique to validate the warnings without human analysis. ", "page_idx": 1}, {"type": "text", "text": "While the naive approach fails, we are able to develop 4 key insights. First, the task of detecting accounting bugs can be split into two subtasks: assigning financial meanings to variables and checking the correctness of operations. For example, there is an accounting bug in the operation $Z=X+Y$ , where X has a financial meaning of a balance (i.e., an amount of some currency) and Y has a financial meaning of price (i.e., an exchange rate between two currencies), the reasoning being that such an operation does not result in meaningful output, hence is a violation of all business models. Second, LLMs such as GPT can easily assign financial meanings to variables through semantic analysis. However, prompting LLMs to annotate all variables is infeasible due to monetary cost and risks of misclassifications due to hallucinations. Hence our third insight: rule-based reasoning allows for propagation of financial meaning, efficient checking of operation correctness, and function-level analysis with file-level scope. Rule-based systems Hayes-Roth [1985] are an approach to artificial intelligence that operates on a set of predefined rules. In our context, inferences rule are utilized for the propagation, taking advantage of the deterministic results of financial meaning operations. Furthermore, the rules substantially reduce the workload on LLMs to only annotating entry variables (i.e., parameters of entry functions and global variables), as all other variables can be assigned financial meanings from the propagation. Finally, inference rules can be enhanced to enable propagation through function invocations, reducing the analysis to function-level while maintaining file-level scope for detection. Fourth, while hallucinations are still an issue, a reasoning trace can be prompted to the LLM to detect hallucinations in annotations. Furthermore, the trace can be integrated with an iterative feedback loop to automatically remedy hallucinations. ", "page_idx": 1}, {"type": "text", "text": "Based on the insights, we develop ABAUDITOR , a hybrid LLM and rule-based reasoning system to automatically detect accounting errors. It utilises the understanding capabilities of LLM (specifically, GPT 3.5-turbo OpenAI [2024]) to provide financial meaning annotations for entry variables and rule-based reasoning to propagate meanings to other variables and to discover potential vulnerabilities. Furthermore, our technique reduces hallucinations by implementing an iterative feedback loop where reasoning traces of potential bugs are provided to the LLM for self-reflection. In sum, we make the following contributions. ", "page_idx": 1}, {"type": "text", "text": "\u2022 We abstract detecting accounting bugs into two subtasks: identifying financial meanings of variables with LLM, and checking correctness of operations with rule-based reasoning. ", "page_idx": 1}, {"type": "text", "text": "1 contract MagicLpAggregator {   \n2 function getPairPrice () public returns (int256) {   \n3 baseReserve $=$ baseCurrency . totalSupply ();   \n4 quoteReserve $=$ quoteCurrency . totalSupply () \\* priceOfBaseInQuote ();   \n5 totalShareSupply $=$ totalShareSupply ();   \n6 return (( baseReserve $^+$ quoteReserve ) / totalShareSupply );   \n7 }} ", "page_idx": 2}, {"type": "text", "text": "Figure 1: Buggy Code from Abracadabra MIMSwap Abracadabra [2024] \u2022 We develop a method to detect hallucinations in GPT via generating a reasoning trace and prompting it back to GPT for self-reflection. \u2022 We implement a prototype ABAUDITOR based on Slither Feist et al. [2019] using the GPT-3.5 turbo model as our LLM. We evaluate on 34 real contracts from Zhang et al. [2023] that have 40 reported accounting bugs. Among these bugs, we find that 19 of them belong to categories such as pure math errors (i.e., the $>$ operation is swapped with $<$ ) hence fall out of scope. Our method detects 19 of the remaining in-scope bugs (i.e., $90.5\\%$ recall). Furthermore, we achieve $75.6\\%$ accuracy in financial meaning annotations by our system versus by humans. We also measure the results without our reasoning trace-based hallucination reduction, and find that the trace reduces the false positive rate by $54.5\\%$ . Furthermore, we run our system on 8 new smart contract projects, finding 6 out of 7 accounting bugs, two of which are zero-day (i.e. not discovered before) vulnerabilities. ", "page_idx": 2}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "2 Motivation ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "We demonstrate the effectiveness of our hybrid system with the following real-world example. ", "page_idx": 2}, {"type": "text", "text": "In January 2024, the smart contract project Abracadabra MIMSwap Mutual [2024] was exploited for $\\mathbb{S}6.5\\,\\mathrm{M}$ dollars. The loss was due to an attack known as a flash loan attack, which is when a malicious actor takes advantage of a vulnerability to control a currency\u2019s price and make profit. Typically the attack begins via a large loan which is used to skew the price through the vulnerability. The attacker then makes a profit based on the skewed price (by trading the exploited currency), and pays off the loan right after. Flash loan attacks have caused $\\mathbb{S}33.35\\;\\mathrm{M}$ in damages in 2024 alone DefiLlama [2024]. The developers fixed the vulnerability in their new version, and posted the code as a bug bounty on Code4rena in March. Code4rena [2024] is a prestigious vendor for smart contract auditing competitions. However, the new implementation was also vulnerable to the aforementioned attack. The vulnerability was an accounting bug, and was only found by two security researchers, among hundreds. Figure 1 shows code for the function that contains the accounting bug. The function is written in Solidity, and has been simplified for demonstrative purposes. The code was taken from the released Code4rena bug report after publication, and the vulnerability has already been fixed. ", "page_idx": 2}, {"type": "text", "text": "In Figure 1, getPairPrice() is a function in the file MagicLpAggregator.sol. The file implements an exchange of three cryptocurrencies: the base token, the quote token, and the share token. In the exchange, users can trade base tokens with quote tokens, or vice versa. Intuitively, the functionality is analogous to an ATM. The share token represents a share of the total base and quote token in the exchange. It acts similar to real-world stocks, where instead of a company, ownership is designated to the amounts of base and quote tokens in the exchange. Users can buy or sell the share token by paying or receiving amounts of both the base and quote token, respectively. The function getPairPrice() is used to calculate the price of the share token, in units of the base token. ", "page_idx": 2}, {"type": "text", "text": "In the getPairPrice() function, the price of the share token is calculated as follows. The total amount of base tokens is calculated on line 3 via the function call baseCurrency.totalSupply(). The total amount of quote tokens is calculated on line 4 via the function call quoteCurrency.totalSupply(). It is then converted to an equivalent amount of base tokens by multiplying the price of base tokens. The function calls baseCurrency.totalSupply() and quoteCurrency.totalSupply() return the exact amount of each token owned by the smart contract. Then, the amount of available share tokens (totalShareSupply) is obtained on line 5. Finally, the share token price is calculated by adding the total amount of base currency, baseReserve, with the total amount of converted quote currency, quoteReserve, and dividing by the totalShareSupply. ", "page_idx": 2}, {"type": "text", "text": "The accounting bug is due to using baseReserve and quoteReserve to compute the share token price. Specifically, it is due to the function calls baseCurrency.totalSupply() and quoteCurrency.totalSupply(), which directly return the amounts of base and quote currencies owned by the smart contract. A malicious actor can initiate a flash loan attack by taking a large loan of the base or quote currency and paying it to the smart contract. This results in the amount of base or quote currency to be inflated, and when calling the function getPairPrice(), a grossly incorrect share price is returned. The malicious actor can take advantage of the price to make profit. ", "page_idx": 3}, {"type": "text", "text": "When our technique is run on the smart contract, it identifies the vulnerability with no false positives. It can determine that the variables baseReserve, quoteReserve, and totalPairSupply all represent reserves in the smart contract, and that the return value of the function priceOfBaseInQuote() represents a price. Reserve is defined as an amount of currency that is owned by the smart contract. Price is defined as the exchange rate of one currency to another. Furthermore, it is able to determine that the addition operation on line 6, (baseReserve $^+$ quoteReserve), also has a financial meaning of reserve. Intuitively, the result of the operation is considered a reserve because it represents the aggregation of two reserve values, thereby maintaining its definition. Our system reports an error for the division operation on line 6, where the code attempts to produce a price by the division of two reserves, following a rule that disallows any division of two reserves. Such divisions are problematic due to being a potential vulnerability for flash loan attacks, as demonstrated above. A better alternative would be to obtain the price by querying offchain authorities, which are trusted services that process data such as prices off the blockchain. ", "page_idx": 3}, {"type": "text", "text": "3 Design ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "A na\u00efve approach of directly prompting the LLM does not work ( Appendix A). The under-performance of the naive approach leads to our proposal of ABAUDITOR. Figure 2 shows the architecture of ABAUDITOR. The blue blocks represent actions taken by the system, while the grey blocks ", "page_idx": 3}, {"type": "image", "img_path": "hB5NkiET32/tmp/c642a3045873765f94e1444f31a619eeeb90e01a347e6b668b73570ccf23d328.jpg", "img_caption": ["Figure 2: Architecture of Our System "], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "represent the intermediate and final results produced by the system. ABAUDITOR takes as input a singular smart contract file or an entire directory with many such files. First, ABAUDITOR extracts the control flow graph (CFG) of the targeted smart contracts and converts the individual operations to static single assignment (SSA) Cytron et al. [1986], a specific intermediate representation whose details are not needed to understand our paper. From the extracted CFG, entry functions are identified. Recall entry functions are those that are accessible to all users. These are done using APIs from an existing analysis framework Slither Feist et al. [2019]. Once all entry functions are identified, the next step involves identifying and annotating the financial meanings of their parameters as well as global variables. This is discussed in more detail in Section 3.1. After the initial labeling, propagation of financial meanings and verification of the correctness of all operations is done through rule-based reasoning. This is discussed in more detail in Section 3.2. At this step, a list of potential vulnerabilities is generated and validated as either a hallucination or a real bug. The validation process is discussed in more detail in Section 3.3 ", "page_idx": 3}, {"type": "text", "text": "We demonstrate each step of our technique with an example found in Figure 3, which shows a bug. The code contains two functions: tswap() and applyFee(). tswap() is a public function (i.e., it can be invoked by all users) which performs a swap of tAmount of one currency to another. During the swap, a fee is applied. Function applyFee() is an internal function used to calculate the remaining amount after fee is applied in the exchange. The accounting bug is that ", "page_idx": 3}, {"type": "image", "img_path": "hB5NkiET32/tmp/c1e74924ba10fd9486c69f30cbd010e6879b09dc73e41c5087b7408a4186c9ef.jpg", "img_caption": ["Figure 3: Demo smart contract with accounting bug "], "img_footnote": [], "page_idx": 3}, {"type": "image", "img_path": "hB5NkiET32/tmp/46f0a837edd2ac996375b6ea20306bfc09ac5d7d86da243408d786435617f270.jpg", "img_caption": ["Figure 4: Subset of Rule-Based Inference Rules "], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "the remaining amount is less than intended. Particularly, this is because fee is applied to it twice, one instance on line 5 in applyFee(), and the other on line 12. ", "page_idx": 4}, {"type": "text", "text": "3.1 Initial Annotation by LLM ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "For every entry function parameter and global variable, GPT performs initial annotation of their financial meaning. In our implementation, we define 6 possible choices for initial financial meanings, which are: raw balance, net rate, interest rate, debt, price, and reserve. Raw balance is defined as an amount of currency that is strictly owned by a user. Net rate is defined as the percentage left after applying a fee. In the blockchain economy, many smart contracts deduct a fee from users to earn profit. Net rate is the amount left after the fee, (e.g., if $10\\%$ fee was deducted, net rate is $90\\%$ ). Interest rate represents the percentage charged on borrowed or lent funds. Debt refers to the amount of borrowed funds owed by a user. Price represents the exchange rate from one currency to another. Reserve denotes the pool of funds strictly owned by the smart contract. These latter two financial meanings were depicted in Figure 1 in the motivation section. We restrict the choices of initial annotations to these 6 types as they are sufficient for commonly seen business models, although it is very easy to expand the system. ", "page_idx": 4}, {"type": "text", "text": "GPT is prompted with high-level definitions of each financial meaning, as well as few-shot examples of real-world instances. To fti the few-shot examples as well as to account for the potential size of the entry function, each financial meaning is formatted in its own prompt. To perform the annotation for an entry function parameter, the name of the parameter and the code of the entry function are provided to the prompt. To perform the annotation for a global variable, a similar prompt is crafted for every function it appears in, and the final assignment is done via the first financial meaning to appear 3 times, or a majority vote. An example can be found in Appendix B and Appendix C. ", "page_idx": 4}, {"type": "text", "text": "3.2 Rule-based Reasoning ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "We describe the inference rules used in reasoning. The rules are invariants (i.e. properties held across different business models) that we have manually summarized. Th invariants are summarized from a study of many business models and their variants Zhang et al. [2023]. A subset of these rules is included in Figure 4. There are in total 119 such rules. Within the table, $y:\\tau$ represents variable $y$ having the financial meaning of $\\tau$ . The statement $x:=\\ldots:\\tau$ represents that $\\tau$ is the resulting financial meaning from the statement that will be propagated to $x$ . ", "page_idx": 4}, {"type": "text", "text": "Rule $R_{1}$ specifies that when a variable $y_{1}$ with the meaning rawbal, or raw balance, is added to a variable $y_{2}$ which is also a raw balance variable, the result $x$ is a raw balance. Rule $R_{2}$ is similar for reserve. Rule $R_{3}$ specifies when a variable $y_{1}$ is subtracted from a variable $y_{2}$ , and both have financial meanings of raw balance, the result is still a raw balance. Rule $R_{4}$ specifies when a variable $y_{1}$ is subtracted from a variable $y_{2}$ , and both have financial meanings of net balance, the result is still a net balance. Net balance is defined as an amount of currency owned by a user that has already had a fee applied. Rule $R_{5}$ specifies when a raw balance variable $y_{1}$ is multiplied by a net rate $y_{2}$ , the result is a net balance. The operation represents collecting a fee from a user. Rule $R_{6}$ specifies when a reserve variable $y_{1}$ is multiplied by a net rate $y_{2}$ , the result is an error. The operation is deducting a fee from the smart contract, which is counterintuitive. Rule $R_{7}$ specifies when a net balance variable $y_{1}$ is multiplied by a net rate $y_{2}$ , the result is an error. The operation represents collecting fee twice from a user, which should not be allowed. Rule $R_{8}$ specifies when a raw balance variable is divided by a raw balance, the result is a price. Rule $R_{9}$ specifies when a reserve variable $y_{1}$ is divided by another reserve variable $y_{2}$ , the result is an error. ", "page_idx": 4}, {"type": "image", "img_path": "hB5NkiET32/tmp/13f72ffccfb1910fe44ce87b56f37e1f30467ef7d0eb535771dbc701adfd37f7.jpg", "img_caption": ["Figure 5: Reasoning Trace Prompt and Response from Hallucination "], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "", "page_idx": 5}, {"type": "text", "text": "The overall process of ABAUDITOR is the following. Given a smart contract, it traverses the statements in the function invocation order and the control flow graph order. It prompts the LLM to assign the initial annotation when encountering a global variable or an entry function parameter that has not been prompted before. Otherwise, it invokes the inference engine that follows the aforementioned rules to propagate financial meanings and identify potential bugs. For each step of propagation, the system records its source. This is for later construction of reasoning traces. For example, _tAmount on line 5 in Figure 3 has its origin from _tAmount on line 3, whose origin is in turn tAmount on line 11, whose origin is line 7 by the LLM. The algorithm and an example of the whole process can be found in Appendix D. ", "page_idx": 5}, {"type": "text", "text": "3.3 Iterative Validation of Accounting Bugs and Application of Remedy ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "At this point, our algorithm has produced a list of statements containing potential accounting bugs. However, some of the bugs are produced from mislabelled initial annotations (i.e., due to GPT hallucinations), while others are true accounting bugs. In this subsection, we discuss how we detect hallucinations by providing a reasoning trace for GPT to perform self-reflection. We also explain how this approach can be integrated into an iterative feedback loop to automatically correct hallucinations and re-run the analysis, thereby improving the accuracy of bug detection. ", "page_idx": 5}, {"type": "text", "text": "For an accounting bug report regarding some buggy statement, its reasoning trace contains the list of operations involved in the propagation of financial meanings from the initial LLM annotations to the operands in the buggy statement. For each operation, the source statement and the rule applied in propagation are included. At the end, the explanation of why the system considers this a bug is also appended. It provides a comprehensive context on which the LLM performs self-reflection. We then compose a self-reflection prompt to the LLM, providing the trace, the definitions of all financial meanings, together with a subset of related reasoning rules in natural language, and ask the LLM to consider if other initial annotations are possible for the involved entry/global variables. If so, the system continues with the new annotations. If the bug disappears with the new annotations, we consider it a false positive caused by hallucination. The procedure is iterative. If the LLM considers there are no other annotations, and the bug still persists, we consider the bug real and include it in the final report. The trace construction algorithm is presented in Appendix E. ", "page_idx": 5}, {"type": "text", "text": "Example. An example of a reasoning trace can be found in Figure 5. It was generated from an accounting bug produced by mislabeled inital annotations (due to hallucinations). We have reduced its content for sake of space, and only include necessary details for discussion. Here we discuss the content of the reasoning trace as well as how GPT responds to it. As mentioned previously, the definitions of all financial meanings are provided in the trace. Specifically, they can be found in the yellow box labeled with \"1\". The green box labeled with $\"2\"$ contains the set of relevant rules. We have selected two such rules (R1: raw balance $\\times$ net rate $=$ net balance [a raw balance variable multiplied by a net rate results in a net balance] and R2: reserve $\\times$ net rate $=$ Error). Finally, we provide the list of related operations to the reported accounting bug in the blue box labeled with $\"3\"$ . We go over the included operations as follows. In the first operation, we provide that the variable tAmount located in function tswap() was initially annotated by GPT as a reserve. In the second operation, we provide that tAmount in tswap() is propagated to parameter _tAmount in function applyFee(), and hence the latter also has the financial meaning of reserve. The third line begins a chain of related operations depicting how variable _netRate in function applyFee() is eventually assigned the financial meaning of net rate, however, we exclude them here for the sake of space. In the fourth operation in the figure, we provide the erroneous operation of _tAmount $^*$ _netRate on line 5 in applyFee(), and explain how it is an accounting bug due to the rule R2. In particular, _tAmount was assigned the meaning of reserve while _netRate was assigned the meaning of net rate, and the result of their multiplication is an error, as defined by R2. ", "page_idx": 5}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "The response from GPT can be found in the orange box labelled with \"4\". In particular, the response details how the entry variable tAmount should have been classified as a raw balance. It supports this claim by referencing that if _tAmount (which had its meaning directly propagated from tAmount) was classified as such, the fourth operation would succeed according to R1. Since GPT reports that a reclassification should be made, the initial annotations are updated (i.e., tAmount is classified to raw balance), and the rule-based reasoning algorithm is rerun. Although the annotations are now correct, the rerun still produces a potential accounting bug in line 12. We note that this accounting bug is a true bug, as discussed in Section 3.2. The system reports it accurately, and the LLM does not flag any mislabeling. For more details, refer to Appendix F. ", "page_idx": 6}, {"type": "text", "text": "4 Evaluation ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We implement our technique on the Slither [13] framework. We chose GPT-3.5 turbo for our LLM.   \nIn this section, we conduct experiments to determine the effectiveness and efficiency of the technique.   \nWe aim to answer the following research questions.   \n\u2022 Research Question 1: What is the effectiveness of our approach?   \n\u2022 Research Question 2: What is the distribution of financial meanings assigned by the LLM? (Appendix G)   \n\u2022 Research Question 3: What is the efficiency of the approach?   \n\u2022 Research Question 4: What is the effect of fine-tuning and providing few-shot examples in our system?   \n\u2022 Research Question 5: Can a less powerful model than GPT-3.5 be used in the approach? (Appendix H)   \n\u2022 Research Question 6: How sensitive is the LLM annotation to variable names? (Appendix I) ", "page_idx": 6}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "4.1 Experimental Setup ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Benchmark. We utilize the dataset provided by Zhang et al. [2023], which contains 513 smart contract bugs across 113 smart contract projects. 72 are categorized as accounting bugs. We preclude 15 of them as they cannot be loaded by Slither or miss code. We further exclude 6 projects due to reasons such as code obfuscation. The list of remaining projects can be found in Table 1.While a project may have many files, we only run ABAUDITOR on those with accounting bugs. We further analyze 8 new smart contract projects containing accounting bugs collected from the most recent Code4rena bug reports. The list can be found in Appendix Table 4. ", "page_idx": 6}, {"type": "text", "text": "Baseline. For our baseline, we ran our rule-based reasoning algorithm using annotations provided by humans on the main dataset. Specifically, we performed manual annotation of financial meanings on every file containing accounting bugs in the benchmark. In each project, we only annotate the entry variables, leveraging the propagation ability of our rule-based reasoning. We find that such effort is substantial, sometimes requiring significant time and attention to detail. We also run our benchmark with two recent tools, namely GPTScan ( Sun et al. [2023]) and ItyFuzz ( Shou et al. [2023]). We do not run with older tools, since according to Zhang et al. [2023] published in 2023, accounting bugs were beyond existing tools at the time. ", "page_idx": 6}, {"type": "table", "img_path": "hB5NkiET32/tmp/5343e54486627b79b059a5f8266d9d26cbbf883467d8afe33a3feb70873366d5.jpg", "table_caption": ["Table 1: Accuracy of Initial Financial Type Labelling "], "table_footnote": ["The experiments are conducted on a machine with AMD Ryzen $3975\\mathrm{x}$ and 512GB RAM, "], "page_idx": 7}, {"type": "text", "text": "4.2 Research Question 1: Effectiveness of approach ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "We ran our system and the baseline technique on the benchmark. We manually inspect all results reported by both methods and categorize them as true positives (TP) or false positives (FP). We also compared the annotations produced by the LLM (i.e., from our system) with the human annotations. We collected the number of invocations of the reasoning trace feedback loop , the number of tokens passed to GPT, the number of total functions analyzed, the run time , and the number of GPT requests. The manual evaluation involved two researchers. Two independently categorized the results and provided annotations while an external judge resolved any inconsistencies. ", "page_idx": 7}, {"type": "text", "text": "The results can be found in Table 1. The name of the smart contract project can be found in the leftmost column. The column labelled \"Baseline\" shows the total human annotations for each project. The column labelled \"Ours\" shows the number of correct annotations by GPT. The column labelled \"Iters\" shows the number of times the iterative feedback loop was invoked. The following three headers contain the results from running the baseline (labelled \"Baseline\"), our technique with the feedback loop (labelled \"Ours\"), and our technique without it (labelled \"No Rem.\"). For each header, the column labeled with \"TP\" contains the number of true positive bugs. The column labeled with \"FP\" contains the number of false positive reports. Accounting bugs that are out of the scope of our system can be found in the column labeled with \"NIS\" or Not-in-Scope. Such accounting bugs belong to other categories such as pure-math-errors (i.e., a \u2019>\u2019 sign is swapped with a $\\acute{\\mathbf{\\theta}}$ sign). The following data are unique to our system. The number of tokens prompted can be found in the column labeled with \"Tokens\". The number of function analyzed can be found in the column labeled with \"Func.\". The run time per project can be found in the column labeled with \"Time\". The number of requests set can be found in the column labeled with \"Req.\". ", "page_idx": 7}, {"type": "text", "text": "Observations. Both our system and our baseline were run on 23 smart contract projects, containing 40 accounting errors. In regards to the effectiveness, our system reports $19\\;\\mathrm{TP}$ and 10 FP, while the baseline reports $19\\ \\mathrm{TP}$ and 7 FP. While both techniques are unable to detect 21 of the total accounting errors, we find that 19 of them are beyond scope. Hence, the recalls of both our system and our baseline are $19/(40\u201319)=90.5\\%$ . In regards to labelling, our technique can correctly annotate ", "page_idx": 7}, {"type": "table", "img_path": "hB5NkiET32/tmp/6cd2dba3fdeb0f56a6353505885f4b11e6444ce384e442784d06b7077babb74d.jpg", "table_caption": ["Table 2: Results of GPTScan "], "table_footnote": [], "page_idx": 8}, {"type": "table", "img_path": "hB5NkiET32/tmp/0a9edca52a6504d176125744550a3bbf1df6fe962c530faaabd8d2ac9b07280e.jpg", "table_caption": ["Table 3: Results Using Fine-tuned GPTs "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "62 out of the 82 human annotations performed in the baseline, achieving an accuracy of $62/82=$ $75.6\\%$ . We find that most misclassifications were due to hallucinations in the initial annotation not resulting in accounting bug warnings. As a result, our feedback loop was not run, hence leaving the misclassifications as is. Also observe that using the reasoning traces reduces the number of FPs from 22 to 10, denoting a $54.5\\%$ reduction, without losing any TPs. In most cases, fixing these hallucination requires less than 3 iterations. ", "page_idx": 8}, {"type": "text", "text": "False Positives. We manually inspect the false positives produced by the system. We find that of the 7 FP common to both our full system and our baseline, the most common issue is the path-insensitive nature of our rule-based reasoning. For example, our rules are unable to deal with the scenario where a variable can potentially have two financial meanings due to an if conditional. Such scenarios require path-sensitive analysis such as symbolic execution, or enhancing with expressive reasoning methods such as Symbolic Finite Automata (SFA), which can model symbolic transitions between states to model stateful behaviors of business models. Of the 3 FP unique to our full technique, we find that the reason is due to hallucinations in the initial annotation. Particularly, when performing the hallucination remedy procedure, GPT fails to recognize or fails to fix the hallucination. Solving this problem requires improving upon the reasoning trace generation. We will leave resolving both to our future work. ", "page_idx": 8}, {"type": "text", "text": "Further experiments. To further test the effectiveness of our technique, we run our system on 8 very recent real world smart contracts released in 2024 containing accounting bugs. We do not perform any human annotation, and run our system directly, allowing GPT to perform annotation on all of the entry variables. Our technique can detect 6 of the 7 accounting bugs that are in scope, including 2 zero-day bugs. We have made reports on the zero-day bugs and submitted them to the developers. Our system reports 6 FPs. We argue that this demonstrates the effectiveness of our system even in latest projects. Details can be found in Appendix J. ", "page_idx": 8}, {"type": "text", "text": "4.3 Research Question 3: What is the efficiency of the technique? ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "To evaluate the efficiency of the system, we measure the cost of evaluation on the main dataset. Regarding the monetary cost of the system, each project requires an average of 110645 tokens to run. Using the API pricing of the GPT3.5-Turbo model, we find that the average cost to run one such project is $1106\\bar{4}5*\\mathbb{9}\\bar{0}.5/1000000=\\mathbb{9}0.05$ . Regarding the time to run the system, we find that each project requires an average of 115.19 seconds to run, or approximately 2 minutes. ", "page_idx": 8}, {"type": "text", "text": "4.4 Research Question 4: What is the effect of fine-tuning and providing few-shot examples in our system? ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We examined the impact of fine-tuning GPT-3.5 and providing few-shot examples for our system to identify accounting bugs. We also studied the benefits of using a fine-tuned GPT-4.o mini model instead of the GPT-3.5 turbo model. We used 50 fine-tuning examples covering all the supported financial types and those without financial meanings. Then, we evaluated our system with different settings, namely with and without fine-tuning, with and without few-shot examples in prompting.. ", "page_idx": 8}, {"type": "text", "text": "We include only one setting for GPT-4 due to the high cost of fine-tuning and using it. The results can be found in Table 3. In the table, the first column labelled \"Model\" shows the settings used for each experiment. The second column labeled \"True Pos.\" shows the true positive bugs detected during each experiment. The column labeled \"False Pos.\" lists the number of false positive warnings reported. The column labeled \"Iters.\" shows the total number of times that the reflection process was run. Finally, the column labeled \"Correct Annotations\" shows the total number of annotations that match the human-labeled annotations. ", "page_idx": 9}, {"type": "text", "text": "Observe that the experiment on row 5 with both fine-tuning and providing few-shot examples to the GPT 3.5 model improved annotation accuracy from $75.6\\%$ (62/82; the annotation accuracy of our system located on row 2) to $78\\%$ (64/82). Only fine-tuning with no few shots on row 4 performs worse than our default setting. No fine-tuning and no few shots, or simply using the GPT 3.5 model directly, on row 3 generates many more false positives and requires more calls of the reflection process. Using the fine-tuned GPT4.o model has the best performance in terms of a higher annotation accuracy of $86.6\\%$ (71/82) at the expense of higher fine-tuning and inference costs. Note that the annotation accuracy changes lead to changes of downstream bug finding. However, the influence may not be proportional because the financial types involved in the bugs are not evenly distributed. That is, the incorrect annotations lie in variables unrelated to the bugs. ", "page_idx": 9}, {"type": "text", "text": "5 Limitations (see Appendix K) ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "6 Related Work ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "Rule-based Systems and Rule-base reasoning. Rule-based systems are a long-established field in artificial intelligence. Early work such as Hayes-Roth [1985] and Golding and Rosenbloom [1991] derive rule-based systems as a way to modularize knowledge. Rules-based systems have been used to enhance LLMs, such as in generating business insights Vertsel and Rumiantsau [2024] and visual data processing Sharan et al. [2023]. In the context of analysis, rule-based reasoning can be particularly effective, such as in anomaly detection Preece et al. [1992], computer penetration detection Ilgun et al. [1995], and reverse engineering of code Alnusair et al. [2014]. ", "page_idx": 9}, {"type": "text", "text": "LLMs in Program Analysis The use of LLMs in program analysis has gained significant attention in recent years. LLMs leverage extensive datasets and sophisticated neural network architectures to understand and generate human-like text. They have seen usage in tasks such as code understanding Nam et al. [2024], testing Deng et al. [2023], and detecting vulnerabilities Cheshkov et al. [2023]. In relation to our work, LLMs such as GPT have even been used to detect vulnerabilities in smart contracts. Sun et al. [2024] evaluate the vulnerability reasoning capability of LLMs through prompting approaches such as Chain-of-Thought (CoT). Xia et al. [2024] utilize GPT to verify adherence of smart contracts to a set of standards known as the Ethereum Request for Comment (ERC). Sun et al. [2023] perform vulnerability detection via function-level abstraction. In comparison, our system focuses on the detection of accounting bugs in smart contracts. ", "page_idx": 9}, {"type": "text", "text": "Accounting Bugs in Smart Contracts. A recent technique was proposed in Zhang [2024] to detect accounting bugs using a type system. It relies on intensive manual annotations of initial variable types. A lot of human efforts are hence needed to apply it to a new contract. The technique has inspired our rule-based reasoning part. To some extent, it corresponds to the baseline presented in our evaluation section. In contrast, our technique proposes the novel integration between LLM annotation and rule-based reasoning, enabling automation. It also uses reasoning traces to reduce hallucinations. ", "page_idx": 9}, {"type": "text", "text": "7 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We develop a hybrid LLM and rule-based reasoning system for the detection of accounting bugs in smart contracts. We utilize the understanding capability of LLMs like GPT to perform annotation of financial meanings for variables. We further utilize rule-based reasoning to propagate financial meanings and check for the correctness of operations. We implement a remedy technique for hallucinations, which relies on the generation of reasoning traces. Our results achieve $75.6\\%$ accuracy in annotations against those performed by humans, and detects $90.5\\%$ of the accounting bugs. Furthermore, our system detects 2 zero-day accounting bugs, which have been reported to the developers. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "Abracadabra. 2024. Abracadabra Smart Contract. https://github.com/code-423n4/2024-03- abracadabra-money ", "page_idx": 10}, {"type": "text", "text": "Awny Alnusair, Tian Zhao, and Gongjun Yan. 2014. Rule-based detection of design patterns in program code. International Journal on Software Tools for Technology Transfer 16 (2014), 315\u2013 334. ", "page_idx": 10}, {"type": "text", "text": "Luca Beurer-Kellner, Mark Niklas M\u00fcller, Marc Fischer, and Martin Vechev. 2023. Prompt Sketching for Large Language Models. arXiv:2311.04954 [cs.CL] https://arxiv.org/abs/2311.04954 ", "page_idx": 10}, {"type": "text", "text": "Bitkan. 2024. Number of Smart Contracts. https://bitkan.com/learn/how-many-smartcontracts-on-ethereum-how-do-ethereum-smart-contracts-work-8989 ", "page_idx": 10}, {"type": "text", "text": "Priyanka Bose, Dipanjan Das, Yanju Chen, Yu Feng, Christopher Kruegel, and Giovanni Vigna. 2022. Sailfish: Vetting smart contract state-inconsistency bugs in seconds. In 2022 IEEE Symposium on Security and Privacy (SP). IEEE. ", "page_idx": 10}, {"type": "text", "text": "Anton Cheshkov, Pavel Zadorozhny, and Rodion Levichev. 2023. Evaluation of ChatGPT Model for Vulnerability Detection. arXiv:2304.07232 [cs.CR] ", "page_idx": 10}, {"type": "text", "text": "Jaeseung Choi, Doyeon Kim, Soomin Kim, Gustavo Grieco, Alex Groce, and Sang Kil Cha. 2021. SMARTIAN: Enhancing smart contract fuzzing with static and dynamic data-flow analyses. In ASE. IEEE. ", "page_idx": 10}, {"type": "text", "text": "Code4rena. 2024. Code4rena. https://code4rena.com ", "page_idx": 10}, {"type": "text", "text": "Consensys. 2024. Blockchain Technology Solutions. https://consensys.net/ ", "page_idx": 10}, {"type": "text", "text": "Ron Cytron, Andy Lowry, and F Kenneth Zadeck. 1986. Code motion of control structures in highlevel languages. In Proceedings of the 13th ACM SIGACT-SIGPLAN symposium on Principles of programming languages. 70\u201385. ", "page_idx": 10}, {"type": "text", "text": "DefiLlama. 2024. Defillama. https://defillama.com/hacks ", "page_idx": 10}, {"type": "text", "text": "Yinlin Deng, Chunqiu Steven Xia, Haoran Peng, Chenyuan Yang, and Lingming Zhang. 2023. Large Language Models are Zero-Shot Fuzzers: Fuzzing Deep-Learning Libraries via Large Language Models. arXiv:2212.14834 [cs.SE] ", "page_idx": 10}, {"type": "text", "text": "Josselin Feist, Gustavo Grieco, and Alex Groce. 2019. Slither: a static analysis framework for smart contracts. In WETSEB@ICSE. IEEE / ACM. ", "page_idx": 10}, {"type": "text", "text": "Andrew R Golding and Paul S Rosenbloom. 1991. Improving Rule-Based Systems Through CaseBased Reasoning.. In AAAI, Vol. 1. 22\u201327. ", "page_idx": 10}, {"type": "text", "text": "Frederick Hayes-Roth. 1985. Rule-based systems. Commun. ACM 28, 9 (sep 1985), 921\u2013932. https://doi.org/10.1145/4284.4286 ", "page_idx": 10}, {"type": "text", "text": "Jing Huang, Kuo Zhou, Ao Xiong, and Dongmeng Li. 2022. Smart contract vulnerability detection model based on multi-task learning. Sensors (2022). ", "page_idx": 10}, {"type": "text", "text": "Koral Ilgun, Richard A Kemmerer, and Phillip A Porras. 1995. State transition analysis: A rule-based intrusion detection approach. IEEE transactions on software engineering 21, 3 (1995), 181\u2013199. ", "page_idx": 10}, {"type": "text", "text": "Jiao Jiao, Shang-Wei Lin, and Jun Sun. 2020. A Generalized Formal Semantic Framework for Smart Contracts. Fundamental Approaches to Software Engineering 12076 (2020), 75 \u2013 96. ", "page_idx": 10}, {"type": "text", "text": "Neptune Mutual. 2024. Abracadabra Exploit. https://neptunemutual.com/blog/how-wasabracadabra-money-exploited/ ", "page_idx": 10}, {"type": "text", "text": "Satoshi Nakamoto. 2008. Bitcoin: A peer-to-peer electronic cash system. (2008). ", "page_idx": 10}, {"type": "text", "text": "Daye Nam, Andrew Macvean, Vincent Hellendoorn, Bogdan Vasilescu, and Brad Myers. 2024. Using an llm to help with code understanding. In Proceedings of the IEEE/ACM 46th International Conference on Software Engineering. 1\u201313. ", "page_idx": 10}, {"type": "text", "text": "OpenAI. 2024. OpenAI GPT 3.5-Turbo. https://platform.openai.com/docs/models/gpt3-5-turbo ", "page_idx": 11}, {"type": "text", "text": "Alun D Preece, Rajjan Shinghal, and Aida Batarekh. 1992. Principles and practice in verifying rule-based systems. The Knowledge Engineering Review 7, 2 (1992), 115\u2013141. ", "page_idx": 11}, {"type": "text", "text": "Akond Rahman, Chris Parnin, and Laurie Williams. 2019. The seven sins: Security smells in infrastructure as code scripts. In 2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE). IEEE, 164\u2013175. ", "page_idx": 11}, {"type": "text", "text": "SP Sharan, Francesco Pittaluga, Manmohan Chandraker, et al. 2023. Llm-assist: Enhancing closedloop planning with language-based reasoning. arXiv preprint arXiv:2401.00125 (2023). ", "page_idx": 11}, {"type": "text", "text": "Chaofan Shou, Jing Liu, Doudou Lu, and Koushik Sen. 2024. LLM4Fuzz: Guided Fuzzing of Smart Contracts with Large Language Models. arXiv preprint arXiv:2401.11108 (2024). ", "page_idx": 11}, {"type": "text", "text": "Chaofan Shou, Shangyin Tan, and Koushik Sen. 2023. ItyFuzz: Snapshot-Based Fuzzer for Smart Contract. arXiv:2306.17135 [cs.CR] https://arxiv.org/abs/2306.17135 ", "page_idx": 11}, {"type": "text", "text": "Solidity. 2023. Solidity. https://docs.soliditylang.org/en/v0.8.15/ ", "page_idx": 11}, {"type": "text", "text": "Yuqiang Sun, Daoyuan Wu, Yue Xue, Han Liu, Wei Ma, Lyuye Zhang, Miaolei Shi, and Yang Liu. 2024. LLM4Vuln: A Unified Evaluation Framework for Decoupling and Enhancing LLMs\u2019 Vulnerability Reasoning. arXiv preprint arXiv:2401.16185 (2024). ", "page_idx": 11}, {"type": "text", "text": "Yuqiang Sun, Daoyuan Wu, Yue Xue, Han Liu, Haijun Wang, Zhengzi Xu, Xiaofei Xie, and Yang Liu. 2023. When gpt meets program analysis: Towards intelligent detection of smart contract logic vulnerabilities in gptscan. arXiv preprint arXiv:2308.03314 (2023). ", "page_idx": 11}, {"type": "text", "text": "Bryan Tan, Benjamin Mariano, Shuvendu K Lahiri, Isil Dillig, and Yu Feng. 2022. SolType: refinement types for arithmetic overflow in solidity. Proceedings of the ACM on Programming Languages 6, POPL (2022), 1\u201329. ", "page_idx": 11}, {"type": "text", "text": "Aliaksei Vertsel and Mikhail Rumiantsau. 2024. Hybrid LLM/Rule-based Approaches to Business Insights Generation from Structured Data. arXiv preprint arXiv:2404.15604 (2024). ", "page_idx": 11}, {"type": "text", "text": "Shuai Wang, Chengyu Zhang, and Zhendong Su. 2019. Detecting nondeterministic payment bugs in Ethereum smart contracts. Proceedings of the ACM on Programming Languages 3, OOPSLA (2019). ", "page_idx": 11}, {"type": "text", "text": "WETH. 2024. WETH. https://weth.io/ ", "text_level": 1, "page_idx": 11}, {"type": "text", "text": "Valentin W\u00fcstholz and Maria Christakis. 2020. Harvey: a greybox fuzzer for smart contracts. In ESEC/SIGSOFT FSE. ACM, 1398\u20131409. ", "page_idx": 11}, {"type": "text", "text": "Shihao Xia, Shuai Shao, Mengting He, Tingting Yu, Linhai Song, and Yiying Zhang. 2024. AuditGPT: Auditing Smart Contracts with ChatGPT. arXiv preprint arXiv:2404.04306 (2024). ", "page_idx": 11}, {"type": "text", "text": "Brian Zhang. 2024. Towards Finding Accounting Errors in Smart Contracts. In Proceedings of the IEEE/ACM 46th International Conference on Software Engineering. 1\u201313. ", "page_idx": 11}, {"type": "text", "text": "Zhuo Zhang, Brian Zhang, Wen Xu, and Zhiqiang Lin. 2023. Demystifying Exploitable Bugs in Smart Contracts. 2023 IEEE/ACM 45th International Conference on Software Engineering (ICSE) (2023), 615\u2013627. ", "page_idx": 11}, {"type": "image", "img_path": "hB5NkiET32/tmp/09c724f9e931b607b65fc58269f1ca6f5f77b1095a7c88084d923f2d82876b09.jpg", "img_caption": ["Figure 6: Format for Naive Prompt "], "img_footnote": [], "page_idx": 12}, {"type": "image", "img_path": "hB5NkiET32/tmp/1943fc0ee70b463c2f0ea7a81ecf84bfcdbb982aea79dffa759a12427edd1d0e.jpg", "img_caption": ["Figure 7: Format for Initial Prompt for Raw Balance "], "img_footnote": [], "page_idx": 12}, {"type": "text", "text": "Supplementary Material ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "A A Naive Approach ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "A naive approach is to directly prompt the LLM with few-shot accounting bug examples and ask it to find new bugs of a similar nature. Figure 6 shows the format of the prompt used for the naive approach. Similar to existing works utilizing GPT to detect vulnerabilities in smart contracts Sun et al. [2024]; Shou et al. [2024], high-level descriptions and few-shot examples of accounting bugs are provided within the prompt. Specifically, the blue box labeled \"1\" contains the definition of accounting bugs, while the red box labeled \"2\" shows the few-shot examples. Each few shot example follows a two-part format: first, related code is provided, followed by the reason that it contains an accounting bug (i.e., what domain-specific property is violated in the code). The purple box labeled $\"3\"$ is where the code of a target smart contract is provided as input to the LLM. ", "page_idx": 12}, {"type": "text", "text": "However, this approach does not suffice to detect accounting bugs, due to the observations that: ", "page_idx": 12}, {"type": "text", "text": "Challenge 1: The code of smart contracts provided for analysis is often too large or too costly to fti in the limited token context space. While it is possible to fliter non-relevant functions (i.e., functions which cannot be invoked by the public), the remaining code usually still retains the same issues. Furthermore, reducing the scope of the analysis to function-level analysis can miss accounting bugs that spread across multiple functions or even files. ", "page_idx": 12}, {"type": "text", "text": "Challenge 2: Most warnings produced by the method are often hallucinations from the model, and there is no existing technique to validate the warnings without human analysis. ", "page_idx": 12}, {"type": "text", "text": "B Prompt for LLM to Annotate Variable with Finnancial Meanings ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Figure 7 demonstrates the prompt format for the financial meaning \"reserve\". The text in the blue box labelled with \"1\" contains the definition of a \"reserve\". The text in the red box labelled with \"2\" contains few-shot examples for a \"reserve\" variable. The text in the orange box labelled with \"3\" contains the prompt used to determine whether or not the new variable (tAmount) should be assigned a \"reserve\". ", "page_idx": 13}, {"type": "text", "text": "C Example of Initial LLM Annotation ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Example. Referring to the example provided in Figure 3, there is only one entry function, tswap(). tswap() contains two parameters: tAmount and price, which are introduced on line 7. There is also one global variable, netRate, which is defined on line 2. Only these 3 variables would be selected for initial annotation, and the correct annotations for the variables are \"raw balance\", \"price\", and \"net rate\", respectively. ", "page_idx": 13}, {"type": "text", "text": "D Rule-based Reasoning Algorithm and Example ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Data: $p\\leftarrow$ the list of all operations in the smart contract, ordered according to the CFG in SSA Result: nodeserror \u2190 ", "page_idx": 13}, {"type": "image", "img_path": "hB5NkiET32/tmp/d42b1fda183308afb6714570883d4f6565e2b3776490ffe52bd71526d547705d.jpg", "img_caption": ["Algorithm 1: Rule-based reasoning pseudocode "], "img_footnote": [], "page_idx": 13}, {"type": "text", "text": "We explain the usage of the rule set for analysis and propagation through the pseudocode presented in Algorithm 1. The pseudocode shows the Algorithm for both sections 3.1 and $3.2.p$ represents the list of operations in the smart contract in CFG order in SSA, and is provided as input. According to Figure 2, it is the first grey box. The output is a list of nodes that potentially contain accounting bugs. According to Figure 2, it is the second grey box. A node is defined as either an assignment $x=y$ or a computational operation $x=y_{1}\\,o p\\,y_{2}$ . In the pseudocode, node.dest represents the destination of the node (e.g., $x^{\\th}$ ), node.op represents the operation performed in a node (e.g., $+,-,=,\\ldots)$ , and node.operands represent the operands (e.g., $y_{1},y_{2})$ that appear in the node. For any variable $x$ , its financial meaning is denoted by $x.f i n$ and its parent node (i.e., the node that assigned its financial meaning) is denoted $x$ .definition. ", "page_idx": 13}, {"type": "text", "text": "The loop from lines 2-14 traverse $p$ in order, and for each node, performs the following operations. An inner loop from line 4-13 traverses each variable (dubbed $x$ ) that appears in the node. If variable $x$ is an entry function parameter or a global variable, the initial annotation discussed in 3.1 is performed (lines 5-7). Lines 9-10 show the propagation. The financial meaning of the variable $n o d e_{c u r}.d e s t$ , or the destination variable of the current node, is the result of rule-based inference given the operation of the node $(n o d e_{c u r}.o p)$ and its operands $(n o d e_{c u r}.o p e r a n d s)$ . If the operation is valid (i.e., the operation aligns with a rule in the rule set), the destination variable is assigned the resulting financial meaning of the operation. If there is no right operand (i.e., the node is an assignment), the financial meaning of the destination variable is assigned the financial meaning of the singular operand. If the operation is invalid (i.e., does not satisfy a rule), the node is added to the list of potential accounting bugs, $n o d e s_{e r r o r}\\$ . The definition of variable $n o d e_{c u r}.d e s t$ is assigned to $n o d e_{c u r}$ . ", "page_idx": 13}, {"type": "text", "text": "", "page_idx": 14}, {"type": "text", "text": "Example. We demonstrate how rule-based reasoning is used to propagate financial meaning as well as identify potential accounting bugs using the example in Figure 3. We use the initial annotations of variable tAmount $\\leftarrow$ reserve, price $\\leftarrow$ price, and netRate $\\leftarrow$ net rate to demonstrate how misclassified initial annotation (i.e., tAmount should be a raw balance) can lead to false postive reports. ", "page_idx": 14}, {"type": "text", "text": "We begin with the first operation in function tswap() of fRate $=$ getFeeRate() on line 6. Chaining the SSA nodes of the operation results in: fRate [in tswap()] $=$ getFeeRate() $=$ feeRate [in getFeeRate()] $=$ feeRate [Global]. Since all of the SSA nodes are assignments, the financial meaning of fRate in tswap() is simply that of global variable feeRate, which is fee rate (as assigned from the initial annotation. ", "page_idx": 14}, {"type": "text", "text": "Continuing to the second operation in function tswap() of net_tAmount $=$ applyFee(tAmount, fRate) on line 11, we find that there is an improper usage of financial meanings, hence resulting in a potential accounting bug. Specifically, the violation of the rule-based reasoning occurs in the operation _fAmount $=$ _tAmount $^*$ _netRate on line 5 within function applyFee(). In tswap(), function applyFee() is called with two parameters, tAmount (initially annotated as a reserve), and fRate (annotated as a net rate). Correspondingly, parameters _tAmount and _netRate defined on line 4 are assigned the financial meanings of reserve and net rate, respectively. However, the rule-based reasoning is violated on line 5 during the operation _tAmount $^*$ _netRate. This is because multiplying a reserve and a net rate is not allowed, as demonstrated by rule $R_{6}$ in Figure 4. Intuitively, the net rate should be applied on a user-owned balance (i.e., raw balance) in order for the smart contract to earn profit, yet this operation shows it being deducting from the smart contract\u2019s balance (i.e., reserve), instead. Hence, this node is added to the list of potential accounting bugs. ", "page_idx": 14}, {"type": "text", "text": "However, this accounting bug is present due to the misclassification of variable tAmount in the initial annotation. By simply replacing the misclassified financial meaning (i.e., reserve) with the correct one (i.e., raw balance), there will be no violation on line 5. Rule-based reasoning applied to the operation _tAmount $^*$ _netRate yields a valid computation of raw balance multiplied by net rate, as specified by $R_{5}$ in the rules, leading to the assignment of net balance to the variable _fAmount. Additionally, the true accounting bug in the operation net_tAmount $^*$ fRate on line 12 can be discovered via continuing the analysis. Variable net_tAmount on line 11 is assigned a net balance, as it is assigned to be _fAmount by the return statement on line 6. In the next operation, net_tAmount $^*$ fRate on line 11, there is an accounting bug due to the operation net balance \\* net rate. It is represented by $R_{7}$ in the rules. Intuitively, the fee has already been deducted from the users balance, as represented by the variable net_tAmount being a net balance, hence the operation on line 12 is applying the fee twice, which is not allowed. ", "page_idx": 14}, {"type": "text", "text": "E Reasoning Trace Construction Algorithm ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Data: $e\\gets$ an operation that results in an accounting error vulnerability in SSA Result: $n o d e s_{t r a c e}\\gets\\mathrm{\\bf{a}}$ list of operation in SSA that represent the trace ofe ", "page_idx": 14}, {"type": "image", "img_path": "hB5NkiET32/tmp/286729da73f7299f41f8a6441d4a429b07ddfbc8f0de1cfb4de3178d42e191d0.jpg", "img_caption": ["Algorithm 2: Trace generation pseudocode "], "img_footnote": [], "page_idx": 14}, {"type": "text", "text": "To obtain the list of related operations for the response trace, we develop a recursive algorithm that traverses through and tracks each node along with the nodes defining its operands. The pseudocode for the algorithm can be found in Algorithm 2 . The input $e$ is a node that potentially contains an accounting error. The output $n o d e s_{t r a c e}$ is a list of nodes in the reasoning trace of $e$ . ", "page_idx": 14}, {"type": "image", "img_path": "hB5NkiET32/tmp/81a4f5e7f0a46958fadc65af3290998963387468137837e2847f4b341da40a43.jpg", "img_caption": ["User: { You are given a reasoning trace of an accounting bug. Identify any possible mislabelings. ", "Figure 8: Reasoning Trace Prompt and Response for Valid Bug "], "img_footnote": [], "page_idx": 15}, {"type": "text", "text": "The loop from lines 3-8 contains the procedure applied to a worklist queue that initially contains $e$ First, the current node is popped into $n o d e_{c u r}$ . The node is added to $n o d e s_{t r a c e}$ . Then, for every variable $x$ in $n o d e_{c u r}$ .operands, the parent node $x$ .definition is added to the worklist. This process continues until the worklist is empty. ", "page_idx": 15}, {"type": "text", "text": "F LLM Reflection on a Real Bug Trace ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "The second reasoning trace in Figure 8 is generated for the accounting bug discovered by the correct initial annotations. While the majority of the content is shared with that in Figure 5 , the green box labeled with \"1\" representing inference rules contains the rule R3 net balance $\\times$ net rate $=$ Error instead of R2. In the trace, we note that there are more operations. First, with the relabelling of \"reserve\" to \"raw balance\", we find that the fourth operation is a success. The result is that the variable _fAmount in applyFee()is now categorized as a net balance. In the fifth operation, _fAmount is propagated to net_tAmount in function tswap() on line 11 due to the return statement. In the sixth operation, we provide the new erroneous operation of net_tAmount $^*$ fRate on line 12, and explain how it is an accounting bug due to the rule R3. In particular, net_tAmount was assigned the meaning of net balance while fRate was assigned the meaning of net rate, and the result of their multiplication is an error, as defined by R3. ", "page_idx": 15}, {"type": "text", "text": "The response from GPT can be found in the orange box labelled with \"4\". In particular, the response concludes that no reclassification should be performed. As evidence, it provides the success of operation 4 due to rule R1. As such, the accounting bug is considered real. ", "page_idx": 15}, {"type": "text", "text": "G Research Question 2: What is the distribution of financial meanings? ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Figure 9 shows the distribution of the 6 financial meanings in the human annotations performed in the first experiment. Notably, the largest category comprises raw balance variables. This outcome aligns with our expectations. An entry function, defined as one that any user can invoke, often serves as the entrance for users to interact with the smart contract\u2019s underlying business model. Hence it is natural that such functions have parameters representing raw balances or amounts of currency owned by users. All other financial meanings are less common in the sense that they are not usually controllable by users. ", "page_idx": 15}, {"type": "image", "img_path": "hB5NkiET32/tmp/6695ba762f66a87b2bf88ef6b55ec865f70289c3ca01c139626b87a46ccaab17.jpg", "img_caption": ["Figure 9: Distributions of financial types "], "img_footnote": [], "page_idx": 16}, {"type": "table", "img_path": "hB5NkiET32/tmp/01a2f7f48c22e83b8be7337aa25692c84a8650927c770657cad511dfc83e2156.jpg", "table_caption": ["Table 4: Results on New Projects "], "table_footnote": [], "page_idx": 16}, {"type": "text", "text": "H Research Question 5: Can a less powerful model than GPT-3.5 be used in the approach? ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "We replaced GPT-3.5 in our system with less powerful models such as CodeLlama-7B-instruct-bf and 13B-instruct-hf. CodeLlama-7B failed to produce formatted outputs in many cases such that our pipeline could not parse its results properly. Similar problems were observed in existing works such as Beurer-Kellner et al. [2023]. 13B performs better in this matter. However, it does not seem to understand the nuances of various financial meanings even with the few-shot examples. As such, it produced much worse annotation results than our default setting ${}^{41.9\\%}$ vs $75.6\\%$ ). This indicates the level of intelligence of the underlying LLM is quite important. ", "page_idx": 16}, {"type": "text", "text": "I Research Question 6: How sensitive is the LLM annotation to variable names? ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "We conducted an experiment in which we leveraged the Solidity compiler to rewrite variable names (to something as plain as v1, v2), without changing program semantics, to see how the annotation is affected. We kept the function names. We then reran our pipeline with the modified code. Our results showed that the annotation accuracy degraded from $75.6\\%$ to $31.7\\%$ . The true positives (TPs) degrade from 19 to 14, and the FPs increase from 9 to 21. It is not surprising because without proper variable names, it is extremely difficult even for humans to decide the financial meaning of an operation, e.g., a simple addition. Note that the substantial annotation degradation does not yield in a proportional loss in TPs. This is because for TPs, many incorrect annotations do not happen in the variables that are involved in the bugs. For FPs, the same operations (e.g., simple additions) are allowed for multiple financial types such that even though a variable is mis-annotated, and the system may not flag its operation as an error. ", "page_idx": 16}, {"type": "text", "text": "J Results on Eight New Smart Contracts ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "The results of running our system on the 8 new smart contracts can be found in Table 4. The name of the project can be found in the leftmost column. The number of true positive accounting errors can be found in the column labeled with \"TP\". The number of false positive accounting errors can be found in the column labeled with \"FP\". The number of false negative accounting errors can be found in the column labeled with \"FN\". The number of accounting errors belonging to other categories (i.e., pure math errors) can be found in the column labeled with \"NIS\" (Not-in-scope). ", "page_idx": 16}, {"type": "text", "text": "Out of the 8 accounting bugs in the new projects, the technique was able to detect 6. Furthermore, one of the undetected accounting errors is due to an incorrect integer value, hence belonging to the pure math category. Of the 6 accounting bugs, 2 are zero-day vulnerabilities, meaning that they were previously undiscovered. Our technique fails to catch 1 bug (FN) and reports 7 false positive bugs (FP). It analyzed a total of 10,097 additional functions. We find that the FN bug is due to the lack of modeling of a specific financial meaning (i.e., a reward rate, which represents the percentage of a loan that is earned as a reward for the loaner). We find that the FP bugs are due to similar reasons, where financial meanings are incorrectly assigned to variables which have financial meanings that are not modeled. We address both in the limitations section of our paper. ", "page_idx": 17}, {"type": "text", "text": "K Limitations ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "We note four main limitations: insufficient financial meaning coverage, inability to detect all hallucinations, inability to handle all accounting bugs, and inability to scale to other programming languages. The reason for the first is that we only model 6 financial meanings in our system. However, real-world smart contracts may contain more financial meanings. As such our technique may miss some accounting bugs. This can be improved by expanding the system to accommodate a wider range of financial meanings. The reason for the second is that we only apply the hallucination detection on potential accounting bugs. This can be improved by developing alternative methods to detecting hallucinations. The reason for the third is that our system cannot handle accounting bugs such as pure-math errors. To address this, a more comprehensive approach that combines rule-based reasoning with additional analysis techniques may be necessary to capture these types of errors effectively. For example, our rules could be extended to capture problematic smells, as demonstrated in Rahman et al. [2019]. The reason for the fourth is that Solidity is the most popular programming language for smart contracts, and our implementation currently only supports that. Our system is implemented inside of Slither, a Solidity analysis engine that generates intermediate representations (IR) of smart contracts and provides a rich set of APIs to manipulate the IRS. That said, it is possible to implement the rule checker at the source level (using just a parser), which would allow easy extension to other languages. We leave this to future work. ", "page_idx": 17}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 18}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 18}, {"type": "text", "text": "Justification: The claims made in the abstract and introduction match the results reported in 4. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 18}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 18}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Justification: The limitations of the work are provided in 5. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 18}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 18}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 18}, {"type": "text", "text": "Justification: Our work does not include theoretical results, all results have been achieved by our work. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 19}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: The design of our architecture can be found in 3. It contains the main algorithm, as well as pseudocode to help explain certain algorithms (i.e. for how the trace for our hallucination remedy is generated). ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 19}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: We have submitted our code, as well as instructions on how to set up our technique. Due to space limitations (the entire benchmark requires $>20$ GB), we only submit a subset of our benchmark. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 20}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Justification: Our work does not perform training, but we provide instructions on how to understand the test output. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 20}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 20}, {"type": "text", "text": "Answer: [No] ", "page_idx": 20}, {"type": "text", "text": "Justification: We did not perform studies of statistical significance in the experiments. Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 20}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 21}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: We provide the specifications of the computer resources to run experiments in 4. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 21}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: We have reviewed the NeurIPS Code of Ethics and determine that we conform with it. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 21}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: We discuss the dangers of accounting bugs in the real world in Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed. ", "page_idx": 21}, {"type": "text", "text": "\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 22}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: The paper poses no such risks. We do not release any new models nor data. Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 22}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: We have cited the original owners of assets in our paper. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 22}, {"type": "text", "text": "", "page_idx": 23}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: We have submitted our code, along with documentation on how to setup and run the code. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 23}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 23}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 23}, {"type": "text", "text": "Justification: We did not involve crowdsourcing, nor performed research with human subjects. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 23}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 23}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 23}, {"type": "text", "text": "Justification: We did not involve crowdsourcing, nor performed research with human subjects. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects. ", "page_idx": 23}, {"type": "text", "text": "\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 24}]