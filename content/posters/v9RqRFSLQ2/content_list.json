[{"type": "text", "text": "Learning from Uncertain Data: From Possible Worlds to Possible Models ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Jiongli Zhu1 Su Feng2 Boris Glavic3 Babak Salimi1 1University of California, San Diego 2Nanjing Tech University 3University of Illinois, Chicago ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "We introduce an efficient method for learning linear models from uncertain data, where uncertainty is represented as a set of possible variations in the data, leading to predictive multiplicity. Our approach leverages abstract interpretation and zonotopes, a type of convex polytope, to compactly represent these dataset variations, enabling the symbolic execution of gradient descent on all possible worlds simultaneously. We develop techniques to ensure that this process converges to a fixed point and derive closed-form solutions for this fixed point. Our method provides sound over-approximations of all possible optimal models and viable prediction ranges. We demonstrate the effectiveness of our approach through theoretical and empirical analysis, highlighting its potential to reason about model and prediction uncertainty due to data quality issues in training data. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "This paper addresses the challenges of learning from uncertain datasets by employing the framework of possible world semantics, a well-established concept in AI and database theory [59, 23, 41, 28]. In this approach, uncertainty in a dataset $_{D}$ is conceptualized through a collection of possible datasets $\\mathbf{\\bar{\\rho}}[D_{1},D_{2},\\ldots]$ , each representing a potential state of the real world, reflecting variations due to missing entries, errors, inconsistencies, and biases. Given this framework and a learning algorithm, our objective is to construct a set of models $\\left\\{f_{1},f_{2},\\ldots\\right\\}$ , where each model $f_{i}$ is trained on a corresponding potential dataset $D_{i}$ . This method, that we implement in a system called ZORRO (ZOnotope-based $R$ obustness Analysis for Regression with $o$ ver-approximations), allows for a thorough evaluation of how data uncertainties affect the robustness, reliability, and fairness of models in predictive modeling and statistical inference, particularly in scenarios where the ground truth is unidentifiable, necessitating consideration of all possible dataset variations. ", "page_idx": 0}, {"type": "text", "text": "While the framework of possible world semantics is essential for modeling dataset uncertainties, it poses significant challenges due to the potentially infinite number of scenarios each dataset might represent. Exploring every possibility and training a model for each is impractical. The concept of model multiplicity, which highlights situations where models with similar accuracy differ in individual predictions, has gained traction [7, 42], yet it primarily focuses on competing models without addressing the full range of dataset variations. Similarly, dataset multiplicity introduced in [47] recognizes data variations due to uncertainty but [47] only proposed a solution for linear models with label errors. Our approach expands these ideas by using possible world semantics to systematically manage uncertainty across all features and labels, thus creating a comprehensive framework for evaluating model robustness amid data uncertainties. ", "page_idx": 0}, {"type": "text", "text": "To address the challenges of learning from uncertain datasets, we employ the method of abstract interpretation [13]. Utilizing zonotopes\u2014a type of convex polytope well-suited for compactly representing high-dimensional data spaces [74, 4]\u2014we over-approximate the set of all possible dataset variations. This framework allows for the simultaneous symbolic execution of gradient descent across all possible datasets, compactly over-approximating all possible optimal model parameters as a zonotope. We demonstrate that for linear regression with $\\ell_{2}$ regularization (Ridge), our method admits a non-trivial closed-form solution. The zonotope representation of model parameters enables efficient inference, facilitating reasoning about the range of possible predictions or of specific parameters. ", "page_idx": 0}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "Contributions. The key contributions of this research are: ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "1. We introduce an abstract gradient descent algorithm for learning linear regression models from uncertain data. This method over-approximates data variations using zonotopes and symbolically executes gradient descent on all possible datasets concurrently. We define and prove the existence of a fixed point that soundly over-approximates all potential models.   \n2. Symbolic execution generates intractable polynomial zonotopes for gradients due to non-linear terms and monomial growth that is exponential in the number of iterations. We use linearization and order reduction to compactly over-approximate these polynomial zonotopes using linear zonotopes at each step, introducing an efficient version of abstract gradient descent.   \n3. The efficient version, however, does not guarantee a fixed point for arbitrary order reduction techniques. To address this, we develop advanced order reduction techniques that ensure fixed points and provide a non-trivial closed-form solution for these fixed points in ridge regression.   \n4. We implement our approach in a system called ZORRO and use it to evaluate the impact of data uncertainty on linear regression models. Our empirical results and analytical solutions validate the effectiveness of our approach, demonstrating its efficacy in computing prediction ranges and verifying robustness. ", "page_idx": 1}, {"type": "text", "text": "Related Work. Predictive multiplicity has shown that a single dataset can produce multiple optimally fitted models due to variations in training processes [8, 11, 44, 66, 69, 9, 15, 71, 42] or modifications to training parameters such as random seeds, data ordering, and hyperparameters. For predictive multiplicity due to missing data, Khosravi et al.[34] address the issue using a probabilistic method that computes expected predictions for all possible imputations. Our approach can be seen as an extreme case of multiple imputation [62, 61], where we consider all possible data variations rather than just a few plausible scenarios. Meyer et al. [47] recently introduced the concept of dataset multiplicity, using possible world semantics to model how uncertain, biased, or noisy training data can lead to predictive multiplicity. However, their focus is on uncertainty in training labels, and they use interval arithmetic for over-approximation of prediction intervals for linear regression. In contrast, our approach handles arbitrary uncertainty in features and labels during both training and testing using zonotope-based learning for over-approximation of prediction ranges and model parameters. We show that interval arithmetic fails to provide tight prediction ranges even for uncertainty in labels. ", "page_idx": 1}, {"type": "text", "text": "Our work is broadly related to robust model learning, which ensures robustness against data quality issues such as attacks [31, 76, 70, 60, 55, 52, 29]. Distributional robustness [6, 53, 65] studies model reliability against varying data distributions, while robust statistics [19, 18] examines model performance under outliers or data errors. Our approach provides exact provable robustness guarantees by exploring the entire range of models under extreme dataset variations, which is crucial for individual-level predictions and reasoning about the robustness of specific parameters. ", "page_idx": 1}, {"type": "text", "text": "Our work is also related to robustness certification, which certifies ML models\u2019 robustness against data perturbations and uncertainties [27, 68, 50]. These efforts mainly focus on test-time robustness, validating predictions for inputs in the vicinity of a test sample. In contrast, we address training-time robustness, considering the effects of possible datasets on training models. Closest to our approach is the work by Meyer et al. [46] for decision trees and Karlas et al. [33] for nearest neighbor classifiers. We use zonotopes to over-approximate prediction ranges for linear regression, generating robustness certificates. While zonotopes have been used for test-time robustness [49, 20, 22, 51], our work is the first to apply zonotopes for training-time robustness for an iterative learning algorithm. ", "page_idx": 1}, {"type": "text", "text": "Approaches for uncertainty quantification (UQ) aim to understand the range of outcomes a model may produce using Bayesian methods, ensembling, conformal prediction, and bootstrapping [54, 43, 35, 17, 16]. UQ focuses on epistemic and aleatoric uncertainty, stemming from insufficient data, noisy data, or uncertainty about the model parameters, and does not account for uncertainty due to systematic data quality issues, such as non-random data errors or missing values [25], which induce a multiplicity of possible datasets. In this case, UQ methods might underestimate the uncertainty as they rely on critical assumptions. Bayesian methods, for instance, require correctly specified priors to accurately model uncertainty, often failing under conditions with unknown or erroneous priors [73, 67, 72], while conformal prediction (CP) assumes data exchangeability\u2014a condition that breaks down when data errors are systematic [21, 75]. In contrast, our approach addresses this distinct challenge by computing sound over-approximations that guarantee complete coverage of potential predictions across all variations of the dataset. This sound coverage is essential in high-stakes settings such as evaluating the robustness of predictive models for medical use. ", "page_idx": 1}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "2 Notation, Problem Formulation and Background ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Denote a training dataset $D=(X,y)$ with $X=\\left[\\pmb{x}_{1}\\quad.\\~.\\quad\\pmb{x}_{n}\\right]^{T}\\in\\mathbb{R}^{n\\times d}$ as the matrix of features, and $\\pmb{{y}}=\\left[\\pmb{{y}}_{1}\\pmb{{\\psi}}_{1}\\pmb{{\\psi}}_{\\cdot}\\cdot\\cdot\\cdot\\mathbf{\\sigma}_{{y}_{n}}\\right]^{T}\\in\\mathbb{R}^{n}$ as the corresponding ground truth labels. Let $f(\\boldsymbol{x};\\boldsymbol{w})$ be a model parameterized by $\\pmb{w}\\in\\mathbb{R}^{p}$ that maps an input data point to a label. A learning algorithm $\\boldsymbol{\\mathcal{A}}$ maps a training dataset $_{D}$ to the parameters of the trained model, $\\pmb{w}^{*}=\\mathcal{A}(\\pmb{D})$ . Given a test dataset $\\mathbf{X}_{\\mathrm{test}}\\in\\mathbb{R}^{n\\times d}$ , for any test sample $\\textbf{\\em x}$ from $\\mathbf{X}_{\\mathrm{test}}$ , the function $f$ computes a prediction $\\hat{y}=f(x;w^{*})$ . ", "page_idx": 2}, {"type": "text", "text": "2.1 Learning Possible Models from Possible Worlds ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "We use possible world semantics to represent the uncertainty in a dataset $_{D}$ . ", "page_idx": 2}, {"type": "text", "text": "Definition 2.1 (Possible Datasets). Given an uncertain dataset $_{D}$ , the uncertainty in $_{D}$ can be represented by a set of possible datasets $D^{\\odot}$ : $\\pmb{{\\cal D}}^{\\odot}=\\{\\pmb{{\\cal D}}_{1},\\pmb{{\\cal D}}_{2},\\pmb{\\cdot}\\cdot\\cdot\\}$ . ", "page_idx": 2}, {"type": "text", "text": "Each dataset $D_{i}\\in D^{\\odot}$ is a \"possible world\", i.e., a hypothetical variation of the dataset $_{D}$ that could potentially exist in the real world based on our knowledge about the uncertainty in $_{D}$ . ", "page_idx": 2}, {"type": "text", "text": "Example 2.2. Consider an $e$ -commerce dataset $_{D}$ where some product price is missing, meaning the exact price is unknown. Using possible world semantics, we represent this uncertainty with a set of possible datasets $D^{\\odot}$ , each containing a possible clean price, which could be obtained from prices of the same items on the market. ", "page_idx": 2}, {"type": "text", "text": "In App. D, we discuss construction methods for common data quality issues. Our goal is to efficiently construct the set of all possible models from uncertain data and understand their behavior in making predictions. ", "page_idx": 2}, {"type": "text", "text": "Definition 2.3 (Possible Models and Prediction Range). Given a set of possible datasets $D^{\\odot}$ associated with an uncertain dataset $_{D}$ , the possible models, denoted $f^{\\odot}$ , are obtained by applying the learning algorithm $\\boldsymbol{\\mathcal{A}}$ to each training dataset $D_{i}$ within $D^{\\odot}$ to obtain the set of all possible optimal model parameters $w^{\\odot*}$ , i.e., ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\pmb{w}^{\\odot*}=\\{\\pmb{w}_{i}^{*}\\mid\\pmb{w}_{i}^{*}=\\mathcal{A}(\\pmb{D}_{i}),\\pmb{D}_{i}\\in\\pmb{D}^{\\odot}\\}\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "For a test data point $\\textbf{\\em x}$ , the viable prediction range $V(x)$ is defined as the interval between the least upper bound and the greatest lower bound of the outputs produced by all models in $f^{\\odot}$ , i.e., ", "page_idx": 2}, {"type": "equation", "text": "$$\nV(\\pmb{x})=\\left[\\operatorname*{inf}_{\\pmb{w}^{*}\\in\\pmb{w}^{\\odot}\\ast}f(\\pmb{x},\\pmb{w}^{*}),\\operatorname*{sup}_{\\pmb{w}^{*}\\in\\pmb{w}^{\\odot}\\ast}f(\\pmb{x},\\pmb{w}^{*})\\right]\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "This prediction range quantifies the minimum and maximum predictions that can be expected for $\\textbf{\\em x}$ , highlighting the variability in model outputs due to differences in the training data. Our framework supports uncertainty in training and test data. We discuss test data uncertainty in App. F.3. ", "page_idx": 2}, {"type": "text", "text": "2.2 Sound Approximation of Possible Models with Abstract Interpretation ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "The set of all possible datasets associated with uncertain data can be intractable. We use abstract interpretation [12] to over-approximate sets of elements of a concrete domain $\\mathbb{D}$ (the training data and model weights) with elements from an abstract domain $\\mathbb{D}^{\\sharp}$ . Specifically, we use the abstract domain of zonotopes, a type of convex polytope, to over-approximate the possible datasets $D^{\\odot}$ using a zonotope $D^{\\sharp}$ that has a compact symbolic representation. Instead of applying the learning algorithm $\\boldsymbol{\\mathcal{A}}$ to each possible dataset to compute all possible optimal model parameters $\\pmb{w}^{\\odot*}$ , we develop an abstract learning algorithm $\\mathcal{A}^{\\sharp}$ that operates directly on the abstract domain of zonotopes. Given $\\mathbf{D}^{\\sharp}$ , $\\mathcal{A}^{\\sharp}$ generates a zonotope $w^{\\sharp}={\\mathcal{A}}^{\\sharp}(\\mathbf{D}^{\\sharp})$ that over-approximates $\\pmb{w}^{\\odot*}$ (demonstrated in the graph on the right). Intuitively, this represents the symbolic execution of the learning algorithm across all possible datasets simultaneously. ", "page_idx": 2}, {"type": "text", "text": "", "page_idx": 2}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/c383cf113ed9888635e8c9d246168a2e0f81133fae80b7b44ab9bbd005e3aa38.jpg", "img_caption": [], "img_footnote": [], "page_idx": 2}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "Definition 2.4 (Abstract Domain). Let $\\mathbb{D}$ be a concrete domain. $A n$ abstract domain for $\\mathbb{D}$ is a set $\\mathbb{D}^{\\sharp}$ paired with two functions: ", "page_idx": 3}, {"type": "text", "text": "which satisfy the following condition for any subset $S\\subseteq\\mathbb{D}$ : $\\gamma\\left(\\alpha(S)\\right)\\supseteq S$ . Two abstract elements $d_{1}$ and $d_{2}$ are equivalent, written as $d_{1}\\simeq_{\\sharp}d_{2}$ , if $\\dot{\\gamma}\\left(d_{1}\\right)=\\gamma\\left(d_{2}\\right)$ . ", "page_idx": 3}, {"type": "text", "text": "Def. 2.4 ensures that the abstract element $\\alpha(S)$ associated with a set $S$ through application of the abstraction function $\\alpha$ encodes an over-approximation of $S$ . We will use an abstract element $\\mathbf{D}^{\\sharp}=\\alpha(\\mathbf{D}^{\\odot})$ to over-approximate the possible worlds of an uncertain training dataset $D^{\\odot}$ . We discuss abstraction functions $\\alpha$ for specific types of training data uncertainty in App. D. ", "page_idx": 3}, {"type": "text", "text": "Definition 2.5 (Abstract Transformer). Consider a function $F:\\mathbb{D}_{1}\\to\\mathbb{D}_{2}$ on concrete domains $\\mathbb{D}_{1}$ and $\\mathbb{D}_{2}$ . $A n$ abstract transformer $F^{\\sharp}:\\mathbb{D}_{1}{}^{\\sharp}\\rightarrow\\mathbb{D}_{2}{}^{\\sharp}$ over-approximates $F$ in the abstract domain: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\forall S\\in{\\mathcal{P}}(\\mathbb{D}):\\gamma\\left(F^{\\sharp}(\\alpha(S))\\right)\\supseteq F(S)\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "An abstract transformer is exact (does not loose precision) $\\begin{array}{r}{i f\\forall d\\in\\mathbb{D}^{\\sharp}:\\gamma\\left(F^{\\sharp}(d)\\right)=F(\\gamma\\left(d\\right)).}\\end{array}$ ", "page_idx": 3}, {"type": "text", "text": "Importantly, (exact) abstract transformers compose (see App. B.2, Prop. B.1) and, thus, we can construct an abstract transformer for complex functions from simpler parts. ", "page_idx": 3}, {"type": "text", "text": "To over-approximate the set of possible model parameters $\\pmb{w}^{\\odot*}$ , we will develop an abstract transformer $\\mathcal{A}^{\\sharp}$ for the learning algorithm $\\boldsymbol{\\mathcal{A}}$ to get $\\gamma^{\\prime}(A^{\\sharp}({\\bf D}^{\\sharp}))\\supseteq w^{\\odot*}$ . ", "page_idx": 3}, {"type": "text", "text": "Symbolic Abstract Domains and Zonotopes. We consider a symbolic abstract domain $\\Psi$ of vectors and matrices (marked with $.^{\\sharp}$ ) with elements that are polynomials $\\psi$ over variables $\\mathcal{E}=\\{\\epsilon_{i}\\}$ . The concretization of a polynomial $\\psi$ is the result of evaluating $\\psi$ on all assignments $e:\\mathcal{E}\\to[-1,1]$ , encoded as vectors $[-1,1]^{|\\,\\varepsilon\\,|}{\\,:\\,}\\gamma\\left(\\psi\\right)=\\left\\{\\psi(e)\\;|\\;e\\in[-1,1]^{|\\,\\varepsilon\\,|}\\right\\}$ . We lift concretization to vectors and matrices through point-wise application. Such an object $z^{\\sharp}$ is typically referred to as a polynomial zonotope or zonotope if all symbolic expressions are linear (see App. C.2). The concretization of $z^{\\sharp}$ is: $\\gamma\\left(z^{\\sharp}\\right)=\\left\\{z^{\\sharp}(e)\\mid e\\in[-1,1]^{|\\,\\varepsilon\\,|}\\right\\}$ . ", "page_idx": 3}, {"type": "text", "text": "3 Exact Abstract Transformers for Learning Linear Models ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Given an uncertain training dataset $D^{\\odot}$ , we aim to over-approximate the set of possible optimal linear models $\\pmb{w}^{\\odot*}=\\{\\pmb{w}_{1}^{*},\\pmb{w}_{2}^{*},\\cdot\\cdot\\cdot\\}$ , where $\\pmb{w}_{i}^{*}\\in\\mathbb{R}^{p}$ represents the optimal parameters of a linear model trained on $D_{i}\\in D^{\\odot}$ . These optimal parameters are the fixed point of the sequence $\\{w_{i}^{k}\\}_{k=0}^{\\infty}$ generated by: wik+1 = \u03a6(wik ) where the operator \u03a6 : Rp \u2192Rp captures one step of gradient descent, i.e., $\\Phi(\\pmb{w})=\\pmb{w}-\\eta\\nabla L(\\pmb{w})$ , for a learning rate $\\eta$ and a loss function $L(w)$ [57]. ", "page_idx": 3}, {"type": "text", "text": "In the abstract domain, we use the zonotope representations $\\mathbf{D}^{\\sharp}$ and $\\pmb{w}^{\\sharp}$ to abstract the possible datasets $D^{\\odot}$ and the set of possible model weights $\\pmb{w}^{\\odot*}$ . While it is theoretically possible to compute symbolic expressions for the standard closed form solution for linear regression, this can result in large expressions that contain fractions with polynomial numerators and denominators and, thus, computing prediction intervals based on such expressions is computationally infeasible (see App. L). Instead, we over-approximate the optimal parameters using an abstract operator \u03a6\u266fexact : w\u266f\u2192w\u266f that generates a sequence of abstract elements $\\{w^{\\sharp\\,k}\\}_{k=0}^{\\infty}$ : ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r}{{\\pmb w}^{\\sharp\\,k+1}=\\Phi_{e x a c t}^{\\sharp}({\\pmb w}^{\\sharp\\,k}),}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where the abstract operator $\\Phi_{e x a c t}^{\\sharp}$ given by $\\Phi_{e x a c t}^{\\sharp}({\\pmb w}^{\\sharp})={\\pmb w}^{\\sharp}-\\eta\\nabla L({\\pmb w}^{\\sharp})$ captures one gradient descent step in the abstract domain. Specifically, for any loss function $L$ whose gradient $\\nabla L$ consists of linear or polynomial expressions, such as the mean squared error (MSE) loss, \u03a6\u266fexact is an exact abstract transformer. This follows from the existence of exact abstract transformers for addition and multiplication over polynomial zonotopes [37] and the fact that abstract transformers compose (see App. E, Prop. B.1 and Prop. E.1). ", "page_idx": 3}, {"type": "text", "text": "Proposition 3.1. The abstract gradient descent operator $\\Phi_{e x a c t}^{\\sharp}$ is an exact abstract transformer for the concrete gradient descent operator $\\Phi$ . Formally, for any abstract $\\pmb{w}^{\\sharp}$ , ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\gamma\\left(\\Phi_{e x a c t}^{\\sharp}({\\bf w}^{\\sharp})\\right)=\\Phi(\\gamma\\left({\\bf w}^{\\sharp}\\right)),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Unfortunately, the sequence $\\{w^{\\sharp\\,k}\\}_{k=0}^{\\infty}$ does not have a fixed point as the highest-order symbolic terms in $w^{\\sharp\\,k}$ are multiplied with symbolic terms in the gradient. Thus, $\\pmb{w}^{\\sharp\\,k+1}=\\Phi_{e x a c t}^{\\sharp}(\\pmb{w}^{\\sharp\\,k})$ terms of higher orders than any term in $w^{\\sharp\\,k}$ . To identify when the abstract model weights represent all fixed points in the concrete domain, we define abstract fixed points using concretization. ", "page_idx": 4}, {"type": "text", "text": "Definition 3.2 (Fixed Point of Abstract Gradient Descent). An abstract model weight $w^{\\sharp\\ast}$ is a fixed point for an abstract transformer $F^{\\sharp}$ for the gradient descent operator $\\Phi\\it{i f,}$ , ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\gamma\\left({\\pmb w}^{\\sharp\\,*},{\\bf D}^{\\sharp}\\right)=\\gamma\\left(F^{\\sharp}({\\pmb w}^{\\sharp\\,*}),{\\bf D}^{\\sharp}\\right).\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Here, $\\gamma\\left(\\cdot,\\cdot\\right)$ denotes the joint concretization of $w^{\\sharp\\ast}$ and $\\mathbf{D}^{\\sharp}$ (see App. C.2 for more details). ", "page_idx": 4}, {"type": "text", "text": "Any abstract fixed point $w^{\\sharp\\;*}$ over-approximates all possible optimal model weights $\\pmb{w}^{\\odot*}$ . ", "page_idx": 4}, {"type": "text", "text": "Proposition 3.3. Consider an abstract transformer $F^{\\sharp}$ for the gradient descent operator $\\Phi$ . Let $w^{\\sharp\\;*}$ be a fixed point according to Def. 3.2. Then it holds that $\\gamma\\left(w^{\\sharp}\\,^{*}\\right)\\supseteq w^{\\odot*}$ . ", "page_idx": 4}, {"type": "text", "text": "As we demonstrate in App. F.3, $w^{\\sharp\\;*}$ can also be used to compute prediction ranges. In general, an abstract fixed point is not guaranteed to exist for every abstract transformer for $\\Phi$ . While $\\Phi_{e x a c t}^{\\sharp}$ as defined above has a fixed point (see Prop. F.1 in the appendix), two significant barriers remain. First, the representation size of the polynomial zonotope $\\overdot{\\mathbf{\\Omega}}_{w^{\\sharp}}^{\\sharp\\;i}$ for abstract model parameters grows exponentially in $i$ , the number of the steps of abstract gradient descent. Additionally, testing for convergence is challenging, as checking for containment is already NP-hard for linear zonotopes [39]. ", "page_idx": 4}, {"type": "text", "text": "4 Efficient Sound Approximation for Learning Linear Models ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "In this section, we present an efficient abstract gradient descent method for ridge regression that guarantees a fixed point and addresses the exponential growth of generated abstract model parameters. The core idea is to use the linearization and order reduction techniques introduced in the following to deal with intractable polynomial zonotopes. We develop a specific order reduction technique that admits a fixed point and enables us to find a closed-form solution for the fixed point. ", "page_idx": 4}, {"type": "text", "text": "4.1 Gradient Descent With Order Reduction ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "A linearization operator $\\mathbf{L}$ maps a polynomial zonotope $z^{\\sharp}$ to a linear zono over-approximates $z^{\\sharp}$ $!^{\\sharp}\\colon\\gamma\\left(\\mathbf{L}(z^{\\sharp})\\right)^{\\bullet}\\supseteq\\gamma\\,\\big(z^{\\sharp}\\big)$ . An order reduction operator $\\mathbf{R}$ takes a linear zonotope $\\ell^{\\sharp}$ as input and returns another linear zonotope $\\ell^{\\sharp}$ of reduced order (representation size) such that: $\\gamma\\left(\\mathbf{R}(\\ell^{\\sharp})\\right)\\supseteq\\gamma\\left(\\ell^{\\sharp}\\right)$ . Specific linearization and order reduction operators are discussed in App. G. The graph on the right shows the progression of the zonotope of parameters toward a fixed point from a randomF initialization by applying 200 iterations of the following abstract gradient descent operator $\\Phi^{\\sharp}$ . The number inside each zonotope indicates its corresponding iteration. ", "page_idx": 4}, {"type": "text", "text": "After 200 iterations the resulting zonotope is close to a fixed point shown in red and computed using techniques we introduce in the following. This operator first linearizes the gradient zonotope using $\\mathbf{L}$ , subtracts it from the current abstract model parameters $\\pmb{w}^{\\sharp}$ , and then reduces the order of the resulting zonotope using $\\mathbf{R}$ : ", "page_idx": 4}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/803853a36e6e5b39ec5c11d79c5cfd93c4c4edc057ffe7f07be7088507efcdee.jpg", "img_caption": [], "img_footnote": [], "page_idx": 4}, {"type": "equation", "text": "$$\n\\Phi^{\\sharp}({\\pmb w}^{\\sharp})={\\bf R}\\Big({\\pmb w}^{\\sharp}-{\\bf L}\\big(\\eta\\nabla L({\\pmb w}^{\\sharp})\\big)\\Big),\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "This operator is an abstract transformer for the gradient descent operator (Prop. H.1). While each step can be computed efficiently by bounding the order of the resulting zonotope, $\\Phi^{\\sharp}$ may not always converge to a fixed point. The graph on the left illustrates a real example where, despite the existence of a zonotope containing all optimal possible parameters (shown again in red), abstract gradient descent with linearization and order reduction keeps diverging, generating larger and larger zonotopes due to over-approximation error. In the following, we develop an order reduction operator that ensures abstract gradient descent with linearization converges to a fixed point for linear regression with $\\ell_{2}$ regularization. Additionally, we derive a closed-form solution for this fixed point. The red dotted zonotope in the graphs represents the fixed point generated by our method. ", "page_idx": 4}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/226fe717bed45674e9378cb5e099dd1695a93866c0d2baa0f45f8f6ab9601581.jpg", "img_caption": [], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "", "page_idx": 4}, {"type": "text", "text": "", "page_idx": 4}, {"type": "text", "text": "Decomposition of Gradients. A core idea in our approach is to decompose the abstract dataset into real and symbolic parts and use an order reduction operator that allows for the decomposition of the abstract gradient descent operator into components processing the real and symbolic parts in a specific evaluation order. Specifically, we observe that the components of the abstract training dataset $\\dot{\\mathbf{D}}^{\\sharp}=(X^{\\sharp},y^{\\sharp})$ can be decomposed into a sum of a real part (without error symbols) and a symbolic part (containing only symbolic terms). Furthermore, the abstract model weight $\\pmb{w}^{\\sharp}$ produced by $\\Phi^{\\sharp}$ can be decomposed as shown below. ${\\pmb w}_{R}$ is the real part of the zonotope and does not contain any error symbols, $\\boldsymbol{w_{D}^{\\sharp}}$ contains only symbolic terms with error symbols that also occur in $\\mathbf{D}^{\\sharp}$ , and $\\pmb{w}_{N}^{\\sharp}$ contains only symbolic terms introduced by linearization and order reduction, hence does not contain any error symbols from $\\mathbf{D}^{\\sharp}$ since these methods introduce fresh symbols. ", "page_idx": 5}, {"type": "equation", "text": "$$\nX^{\\sharp}=X_{R}+X_{S}^{\\sharp},\\qquad\\qquad y^{\\sharp}=y_{R}+y_{S}^{\\sharp}\\qquad\\qquad w^{\\sharp}=w_{R}+w_{D}^{\\sharp}+w_{N}^{\\sharp}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "The key observation that enables our approach is that one step of abstract gradient descent can now be decomposed into three components: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\Phi^{\\sharp}({\\pmb w}^{\\sharp})=\\Phi_{R}({\\pmb w}_{R})+\\Phi^{\\sharp}{\\cal D}({\\pmb w}_{R},{\\pmb w}_{D}^{\\sharp})+\\Phi^{\\sharp}{\\cal N}({\\pmb w}_{R},{\\pmb w}_{D}^{\\sharp},{\\pmb w}_{N}^{\\sharp})\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\Phi_{R}(w_{R})=w_{R}-\\eta\\cdot\\bigg(\\frac{2}{n}({\\cal X}_{R}{\\cal T}{\\cal X}_{R}w_{R}-{\\cal X}_{R}{\\cal T}_{\\cal y_{R}})+2\\lambda w_{R}\\bigg)}\\\\ &{\\quad\\Phi^{\\sharp}{\\cal D}(w_{R},w_{D}^{\\sharp})=w_{D}^{\\sharp}-\\eta\\cdot\\bigg((2\\lambda I+\\frac{2}{n}{\\cal X}_{R}{\\cal T}{\\cal X}_{R})w_{D}^{\\sharp}+\\frac{2}{n}({\\cal X}_{R}{\\cal T}{\\cal X}_{S}^{\\sharp}+{\\cal X}_{S}^{\\sharp}{\\cal X}_{R})w_{R}-\\frac{2}{n}{\\cal X}_{S}^{\\sharp}{\\cal y}_{R}-\\frac{2}{n}{\\cal X}_{R}{\\cal T}_{y_{S}^{\\sharp}}\\bigg)}\\\\ &{\\quad\\Phi^{\\sharp}{\\cal N}(w_{R},w_{D}^{\\sharp},w_{N}^{\\sharp})={\\bf R}\\bigg(w_{N}^{\\sharp}-\\eta\\cdot\\bigg((2\\lambda I+\\frac{2}{n}{\\cal X}_{R}{\\cal T}{\\cal X}_{R})w_{N}^{\\sharp}}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad+\\mathbf{L}\\bigg(\\frac{2}{n}\\Big(({\\cal X}_{R}{\\cal T}{\\cal X}_{S}^{\\sharp}+{\\cal X}_{S}^{\\sharp}{\\cal X}_{R})(w_{D}^{\\sharp}+w_{N}^{\\sharp})+{\\cal X}_{S}^{\\sharp}{\\cal X}_{S}^{\\sharp}(w_{R}+w_{D}^{\\sharp}+w_{N}^{\\sharp})-{\\cal X}_{S}^{\\sharp}{\\cal Y}_{y}^{\\sharp}\\Big)\\bigg)\\bigg)}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "$\\Phi_{R}(w_{R})$ , the real part updater, only relies on and updates ${\\pmb w}_{R}$ , the real part of the abstract weight, and coincides with the abstract gradient operator $\\Phi$ on the real part of abstract weights. $\\Phi^{\\sharp}{}_{D}(w_{R},w_{D}^{\\sharp})$ , the symbolic data-dependent updater, which is a function of $w_{D}^{\\sharp}$ itself and w\u266fN ", "page_idx": 5}, {"type": "image", "img_path": "", "img_caption": [], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "${\\pmb w}_{R}$ , updates $w_{D}^{\\sharp}$ based on some linear terms and consists of symbols that come from the abstract dataset $\\mathbf{D}^{\\sharp}$ and does not include any non-linear terms; hence applying this does not generate higherorder terms, so the output is a linear zonotope, and no linearization is needed. Additionally, no order reduction is needed since the number of error symbols remains constant. $\\Phi^{\\sharp}{}_{N}({\\pmb w}_{R},{\\pmb w}_{D}^{\\sharp},{\\pmb w}_{N}^{\\sharp})$ , the symbolic data-independent updater, is a function of $\\pmb{w}_{N}^{\\sharp}$ itself, $w_{D}^{\\sharp}$ , and ${\\pmb w}_{R}$ . It consists of the non-linear terms in the gradient, hence performs linearization to over-approximate higher-order terms and performs order reduction to reduce the number of error symbols, which would otherwise grow exponentially with the number of iterations. Therefore, it generates the updated $\\pmb{w}_{N}^{\\sharp}$ as a linear zonotope that does not share any symbol with $\\mathbf{D}^{\\sharp}$ , i.e., only consists of fresh symbols introduced by linearization and order reduction. See Appendix I for formal statements and proofs for this section. ", "page_idx": 5}, {"type": "text", "text": "Proposition 4.1. Any abstract model weights $\\pmb{w}^{\\sharp\\,\\ast}\\,=\\,\\pmb{w}_{R}^{\\ast}+\\pmb{w}_{D}^{\\sharp\\,\\ast}+\\pmb{w}_{N}^{\\sharp\\,\\ast}$ is a fixed point for the abstract gradient descent operator $\\Phi^{\\sharp}$ if the following conditions are satisfied: ", "page_idx": 5}, {"type": "equation", "text": "$$\n{\\pmb w}_{R}^{*}=\\Phi_{R}({\\pmb w}_{R}^{*}),\\qquad{\\pmb w}_{D}^{\\sharp\\,*}=\\Phi^{\\sharp}{\\cal D}\\big({\\pmb w}_{R}^{*},{\\pmb w}_{D}^{\\sharp\\,*}\\big)\\qquad{\\pmb w}_{N}^{\\sharp\\,*}\\simeq\\sharp^{\\sharp}{\\bf\\Phi}_{N}^{\\sharp}\\big({\\pmb w}_{R}^{*},{\\pmb w}_{D}^{\\sharp\\,*}{\\pmb w}_{N}^{\\sharp\\,*}\\big)\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "We summarize the fixed point construction process in Alg. 1. The algorithm takes as input an abstract dataset $\\mathbf{D}^{\\sharp}$ , a learning rate $\\eta$ , a regularization coefficient $\\lambda$ , and a transformation matrix $\\pmb{A}$ . The construction order is: first $\\pmb{w}_{R}^{*}$ , then $w_{D}^{\\sharp\\;*}$ , and finally $w_{N}^{\\sharp\\;*}$ , each step building on the previous results. Closed-form solutions for $\\pmb{w}_{R}^{*}$ and $w_{D}^{\\sharp\\;*}$ exist, as detailed in Lem. I.4. The fixed point of $\\Phi_{R}$ matches the fixed point of gradient descent on the real part of the abstract data, independent of other parts. Given $\\pmb{w}_{R}^{*}$ , $w_{D}^{\\sharp\\;*}$ is obtained by solving a system of linear equations from Eq. (3), ensuring zonotope containment by equalizing the coefficients of the same error symbols, which is a sufficient condition for zonotope equivalence. This involves solving a system of $m$ equations, where $m$ is the number of error symbols in $\\mathbf{D}^{\\sharp}$ . ", "page_idx": 5}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "aTloe nccoen,s twrue cet $w_{N}^{\\sharp\\;*}$ nitne r Eaq .c (h3a)l,l ewnhgiec bh eicnavuoslev etsh ez oRnHotSo apne de qLuHivShave different error symbols, making symbolic enforcement of equivalence inapplicable. We exploit the properties of the order reduction operator to create a system of linear equations whose solution yields a fixed point for $\\Phi^{\\sharp}{}_{N}$ . Recall that this component uses linearization to handle non-linear terms and applies order reduction to efficiently manage the order of the resulting linear zonotope. As shown on the right side, the order reduction operator in $\\Phi^{\\sharp}{}_{N}$ utilizes a transformation matrix $\\pmb{A}$ to project the higher-order linear zonotope into a new space and then over-approximates it using an interval hull\u2014a zonotope that is a box enclosing the input higher-order zonotope in the projected space\u2014and finally projects this box back into the original space using $A^{-1}$ . The core idea of transformation-based order reduction [38] is that interval hulls provide a better over-approximation in the projected space, where the shape of the input zonotope is closer to a box than in the original space, as shown in the graph on the right. ", "page_idx": 6}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/c4634205f67501c606ed25057ee39f22a1e878ccb16ed89c93eefd93e1ae8351.jpg", "img_caption": [], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "At a fixed point, the input and output interval hulls of $\\Phi^{\\sharp}{}_{N}$ should be equivalent in the projected space. This equivalence can be effectively enforced by checking for equal edge lengths along each dimension, which is sufficient for two interval hulls to be equivalent. This translates to a system of $k$ equations, where $k$ is the number of model parameters, hence can be done efficiently. We show that this system of equations is guaranteed to have a solution. We are now ready to state our main technical result. ", "page_idx": 6}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "Theorem 4.2 (Correctness of Alg. 1). Given a set of possible training datasets $D^{\\odot}$ associated with uncertain data $_{D}$ , and an appropriate abstraction function $\\alpha$ in the zonotope abstract domain, and given a regularization coefficient $\\lambda_{-}$ , Alg. $^{\\,l}$ , when provided with $\\mathbf{D}^{\\sharp}=\\alpha(\\mathbf{\\bar{D}}^{\\odot})$ as input, computes abstract model parameters $w^{\\sharp\\ast}$ such that: ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\gamma\\left(\\pmb{w}^{\\sharp\\;*}\\right)\\supseteq\\pmb{w}^{\\odot*},}\\end{array}\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "where $\\pmb{w}^{\\odot*}$ denotes the set of all optimal model parameters corresponding to $D^{\\odot}$ for linear regression with $\\ell_{2}$ regularization with regularization coefficient $\\lambda$ . ", "page_idx": 6}, {"type": "text", "text": "5 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We implement ZORRO using SymPy [45], a Python library for symbolic computations and evaluate the system on two key applications: (1) computing prediction ranges and robustness certification for linear models trained on uncertain data, and (2) robustness of model weights for causal inference using linear models as a case study. We also measured the performance of ZORRO under varying conditions, including varying the degree of training data uncertainty. All our experiments are performed on a single machine with an Apple M1 chip, 8 cores, and 16 GB RAM. Experiments are repeated 5 times with different random seeds, and we report the mean (error bars denote $3\\sigma$ ). The code is shared at https://github.com/lodino/Zorro. ", "page_idx": 6}, {"type": "text", "text": "Datasets, Baselines, and Metrics. For robustness verification we use regression tasks: for MPG [58] (392 instances) we predict fuel consumption based on car features (cylinders, horsepower, weight); for Insurance [30] (1338 instances) we predict medical insurance charges based on demographics (age, gender, BMI), habits (smoking), and geographical features. We use a 80:20 train-test split and inject random errors to the training data varying (i) the Uncertain Data Percentage, the percentage of instances that have uncertain features / labels, and (ii) the Uncertainty Radius, the difference between the minimum and maximum possible value of an uncertain feature expressed as a fraction of the feature\u2019s domain. There is no direct baseline capturing prediction ranges for learning linear regression models from uncertain data. Most existing works in robustness certification focuses on test-time robustness (cf. Sec. 1). The exception is [47], which only supports uncertainty in labels using interval arithmetic. We compare ZORRO against this approach for robustness certification, referred to as MEYER in the following, only for training label uncertainty. For robustness verification, a prediction is robust if the size of the prediction interval is smaller than a given threshold. We use the robustness ratio which is the fraction of the test data receiving robust predictions as a metric in all robustness verification experiments. The robustness threshold is set to $5\\%$ of the label range for the MPG data, and $0.8\\%$ of the label range for the Insurance data. Additionally, we assess the worst-case test loss using certain test data and uncertain model weights trained from uncertain training data. ", "page_idx": 6}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/004131d721e57963abbbc0fbb3bb90fd85f39a20a9c07e9f54fa6afef845fb2e.jpg", "img_caption": ["Figure 1: Robustness verification on using intervals (MEYER [47]) and zonotopes (ZORRO). "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "", "page_idx": 7}, {"type": "text", "text": "5.1 Robustness Verification ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "Prediction Robustness (Uncertain Labels). Fig. 1(a)(b) compares ZORRO with the baseline MEYER [47] on a setting where only training labels suffer from uncertainty. We vary the uncertainty radius and uncertain data percentage. As both systems provide sound over-approximations of prediction ranges, they may underestimate a model\u2019s robustness. As shown, ZORRO consistently certifies significantly higher robustness ratios than MEYER. This is due to the fact that MEYER uses interval-arithmetic which ignores the correlation between model weights in different dimensions and between the training labels and the weights, leading to overly conservative prediction ranges. Specifically, for higher uncertainty radius values, MEYER fails to certify robustness for most of the data while ZORRO still can certify robustness for $100\\%$ of the instances. ", "page_idx": 7}, {"type": "text", "text": "Prediction Robustness (Uncertain Features). We also evaluate the impact of training feature uncertainty (not supported by MEYER). Specifically, we introduce uncertainty into the vehicle weight column for the MPG dataset. As shown in Fig. 1(c), uncertainty in the features results in relatively less robust predictions compared to uncertain labels for a similar uncertainty radius (Fig. 1(a)). This is primarily because uncertain features result in more high-order terms in the closed form solution than uncertain labels which in turn leads to larger over-approximation errors during linearization. ", "page_idx": 7}, {"type": "text", "text": "In all experiments the standard deviation of the robustness ratio, calculated by repeating experiments with different random seeds, is large when the average robustness ratio is close to 0.5. This is because when the uncertain data percentage is low, the model will be robust no matter which training instances are selected to be uncertain. Likewise, when the uncertain data percentage is high, then most predictions will be uncertain no matter which training data points are uncertain. ", "page_idx": 7}, {"type": "text", "text": "Parameter Robustness. Next, we apply ZORRO for robustness certification of parameters in linear regression models, crucial for statistical estimation and causal analysis. We compare the ground truth coefficients for a treatment variable with the results obtained by ZORRO and through KNN imputation on a dataset with injected missing data. Fig. 2 shows the treatment variable coefficient and the regression model\u2019s intercept. The intercept captures the baseline level of the outcome variable when all predictors are zero, highlighting how baseline values can shift under uncertainty. While the model trained after KNN imputation sometimes correctly identifies the directionality of the treatment effect, this is not always the case as shown in Fig. 2(b). This highlights the needs for techniques like ZORRO which guarantee that the true treatment effect is within certain bounds. ", "page_idx": 7}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/37e13022267fd68f1db687905785182d1917909335d3f1f6bcc3a32ddcf2111c.jpg", "img_caption": ["Figure 2: Applying ZORRO to causal inference. The intercept (y-axis) is the model\u2019s bias term, the treatment effect (x-axis) is the coefficient for the treatment variable. "], "img_footnote": [], "page_idx": 8}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/0eab3ab1f60ebee96710143d0c7a18620e330a289dc21c98b8247ed7f5be062d.jpg", "img_caption": ["Figure 3: Range of the loss, through enumeration of all possible worlds (GT) and ZORRO. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "5.2 Solution Quality with Varying Uncertainty and Hyperparameters ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We evaluate ZORRO\u2019s effectiveness by testing the tightness of the over-approximation and the accuracy of possible models. Specifically, we examine how the over-approximation quality and worst-case loss are influenced by the level of data uncertainty and the regularization coefficient. ", "page_idx": 8}, {"type": "text", "text": "Varying Data Uncertainty. To evaluate how specific characteristics of the data affect the effectiveness of ZORRO, we injected errors into real datasets, varying uncertain data percentage and uncertainty range. We compare ZORRO with the ground truth range of the loss computed by enumerating all possible worlds (GT). The results shown in Fig. 3(a) demonstrate that ZORRO tightly over-approximates the ground truth loss range, especially for smaller uncertainty radius values. As uncertainty increases, the over-approximation gap widens due to the increased coefficient of higherorder terms in the gradient, which are linearized, leading to higher linearization errors. As shown in Fig. 3(b), the tightness of ZORRO\u2019s over-approximation is not affected by the dimension of the data. ", "page_idx": 8}, {"type": "text", "text": "Effect of Regularization. We investigate the impact of the regularization coefficient on the robustness of predictions and the worst-case loss of possible models. Following a similar approach to Sec. 5.1, we introduce uncertainty in both features and labels in the MPG dataset and use zonotopes with varying levels of uncertainty to over-approximate the training data uncertainty. The results, shown in Fig. 4, indicate that a higher regularization coefficient leads to more robust predictions, as regularization tends to \"compress\" all possible model weights towards the origin. Interestingly, the worst-case loss shows that $\\lambda=0$ is not optimal across all scenarios, especially when the fraction uncertain instances is high. Instead, a small, positive $\\lambda$ (e.g., 0.02 or 0.025) generally yields the best worst-case losses. Combining these results, the optimal regularization coefficient should enhance robustness (i.e., a higher robustness ratio) while maintaining an acceptable worst-case loss. Therefore, the regularization coefficient should be tuned based on a validation dataset to achieve a small range of accurate possible models. ", "page_idx": 8}, {"type": "text", "text": "6 Conclusions, limitations and broader impacts ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We introduce an approach for propagating uncertainty through model training and inference for linear models. Given an abstract uncertain training dataset that over-approximates the possible worlds of a training dataset, we develop abstract interpretation techniques to over-approximate the set of possible models and inference results for this set of models using zonotopes. This is challenging, as we need to compute fixed points of gradient descent in the abstract domain. Our main technical contribution is the development of closed-form solutions for such fixed points that can be solved efficiently. Our techniques efficiently over-approximate models and inference for several use cases, including robustness verification, uncertainty management in causal reasoning, and improving the interpretability and reliability of predictions and inferences. This framework can be particularly valuable in critical applications where data quality and robustness are paramount. While we propose an effective method for abstract learning of linear models, extending our approach to more complex models is challenging. Non-linear models, such as neural networks, would require more advanced linearization and order reduction techniques, as well as parallelization, to manage the increased complexity of the involved symbolic operations. In addition, adapting our method to a broader classes of models through efficiently approximating the fixed points remains a challenging and promising future direction. ", "page_idx": 8}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/5609916a764881db10eda4d7f86ab979148f9a08b559437874040a5b6ec83976.jpg", "img_caption": ["Figure 4: Varying regularization coefficient \u03bb: Robustness ratio (green) and worst-case test loss (red). "], "img_footnote": [], "page_idx": 9}, {"type": "text", "text": "", "page_idx": 9}, {"type": "text", "text": "7 Acknowledgment ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "This research was supported by NSF awards IIS-2340124, IIS-2420691, and IIS-2420577, as well as by NIH grant U54HG012510. The views, opinions, and findings presented are those of the authors and do not necessarily represent those of the NSF or NIH. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Amr Alanwar, Anne Koch, Frank Allg\u00f6wer, and Karl Henrik Johansson. Data-driven reachability analysis using matrix zonotopes. In Learning for Dynamics and Control, pages 163\u2013175. PMLR, 2021.   \n[2] Matthias Althoff. Reachability analysis and its application to the safety assessment of autonomous cars. PhD thesis, Technische Universit\u00e4t M\u00fcnchen, 2010.   \n[3] Matthias Althoff. Reachability analysis of nonlinear systems using conservative polynomialization and non-convex sets. In Proceedings of the 16th international conference on Hybrid systems: computation and control, pages 173\u2013182, 2013.   \n[4] Matthias Althoff and Bruce H Krogh. Zonotope bundles for the efficient computation of reachable sets. In 2011 50th IEEE conference on decision and control and European control conference, pages 6814\u20136821. IEEE, 2011.   \n[5] Stanley Bak, Sergiy Bogomolov, Brandon Hencey, Niklas Kochdumper, Ethan Lew, and Kostiantyn Potomkin. Reachability of koopman linearized systems using random fourier feature observables and polynomial zonotope refinement. In International Conference on Computer Aided Verification, pages 490\u2013510. Springer, 2022.   \n[6] Aharon Ben-Tal, Dick den Hertog, Anja De Waegenaere, Bertrand Melenberg, and Gijs Rennen. Robust solutions of optimization problems affected by uncertain probabilities. Advanced Risk & Portfolio Management\u00ae Research Paper Series, 2011.   \n[7] Emily Black, Manish Raghavan, and Solon Barocas. Model multiplicity: Opportunities, concerns, and solutions. In Proceedings of the 2022 ACM Conference on Fairness, Accountability, and Transparency, pages 850\u2013863, 2022.   \n[8] Xavier Bouthillier, Pierre Delaunay, Mirko Bronzi, Assya Trofimov, Brennan Nichyporuk, Justin Szeto, Nazanin Mohammadi Sepahvand, Edward Raff, Kanika Madan, Vikram Voleti, et al. Accounting for variance in machine learning benchmarks. Proceedings of Machine Learning and Systems, 3:747\u2013769, 2021.   \n[9] Leo Breiman. Heuristics of instability and stabilization in model selection. The annals of statistics, 24(6):2350\u20132383, 1996.   \n[10] Christophe Combastel. Functional sets with typed symbols: Mixed zonotopes and polynotopes for hybrid nonlinear reachability and filtering. Automatica, 143:110457, 2022.   \n[11] A Feder Cooper, Yucheng Lu, Jessica Forde, and Christopher M De Sa. Hyperparameter optimization is deceiving us, and how to stop it. Advances in Neural Information Processing Systems, 34:3081\u20133095, 2021.   \n[12] P. Cousot. Abstract interpretation. CSUR, 28(2):324\u2013328, 1996.   \n[13] Patrick Cousot and Radhia Cousot. Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. In Proceedings of ACM SIGACT-SIGPLAN symposium on Principles of programming languages, pages 238\u2013252, 1977.   \n[14] Patrick Cousot and Nicolas Halbwachs. Automatic discovery of linear restraints among variables of a program. In Proceedings of the 5th ACM SIGACT-SIGPLAN symposium on Principles of programming languages, pages 84\u201396, 1978.   \n[15] Alexander D\u2019Amour, Katherine Heller, Dan Moldovan, Ben Adlam, Babak Alipanahi, Alex Beutel, Christina Chen, Jonathan Deaton, Jacob Eisenstein, Matthew D Hoffman, et al. Underspecification presents challenges for credibility in modern machine learning. Journal of Machine Learning Research, 23(226):1\u201361, 2022.   \n[16] Fabricio Olivetti de Franca and Gabriel Kronberger. Prediction intervals and confidence regions for symbolic regression models based on likelihood profiles, 2022.   \n[17] Nicolas Dewolf, Bernard De Baets, and Willem Waegeman. Valid prediction intervals for regression problems. Artificial Intelligence Review, 56(1):577\u2013613, April 2022.   \n[18] Ilias Diakonikolas, Gautam Kamath, Daniel M. Kane, Jerry Li, Ankur Moitra, and Alistair Stewart. Robustness meets algorithms. Commun. ACM, 64(5):107\u2013115, apr 2021.   \n[19] Ilias Diakonikolas and Daniel M. Kane. Recent advances in algorithmic high-dimensional robust statistics. CoRR, abs/1911.05911, 2019.   \n[20] Tianyu Du, Shouling Ji, Lujia Shen, Yao Zhang, Jinfeng Li, Jie Shi, Chengfang Fang, Jianwei Yin, Raheem Beyah, and Ting Wang. Cert-rnn: Towards certifying the robustness of recurrent neural networks. CCS, 21(2021):15\u201319, 2021.   \n[21] Rina Foygel Barber, Emmanuel J Candes, Aaditya Ramdas, and Ryan J Tibshirani. The limits of distribution-free conditional predictive inference. Information and Inference: A Journal of the IMA, 10(2):455\u2013482, 2021.   \n[22] Timon Gehr, Matthew Mirman, Dana Drachsler-Cohen, Petar Tsankov, Swarat Chaudhuri, and Martin Vechev. Ai2: Safety and robustness certification of neural networks with abstract interpretation. In 2018 IEEE symposium on security and privacy $(S P)$ , pages 3\u201318. IEEE, 2018.   \n[23] Matthew L Ginsberg. Counterfactuals. Artificial intelligence, 30(1):35\u201379, 1986.   \n[24] Eric Goubault, Tristan Le Gall, and Sylvie Putot. An accurate join for zonotopes, preserving affine input/output relations. In Jan Midtgaard and Matthew Might, editors, Proceedings of International Workshop on Numerical and Symbolic Abstract Domains, volume 287, pages 65\u201376, 2012.   \n[25] Cornelia Gruber, Patrick Oliver Schenk, Malte Schierholz, Frauke Kreuter, and G\u00f6ran Kauermann. Sources of Uncertainty in Machine Learning \u2013 A Statisticians\u2019 View. arXiv, 2023.   \n[26] Arthur E. Hoerl and Robert W. Kennard. Ridge regression: Biased estimation for nonorthogonal problems. Technometrics, 42(1):80\u201386, 2000.   \n[27] Chengqiang Huang, Zheng Hu, Xiaowei Huang, and Ke Pei. Statistical certification of acceptable robustness for neural networks. In Artificial Neural Networks and Machine Learning, pages 79\u201390. Springer, 2021.   \n[28] Tomasz Imieli\u00b4nski and Witold Lipski Jr. Incomplete information in relational databases. Journal of the ACM (JACM), 31(4):761\u2013791, 1984.   \n[29] Matthew Jagielski, Alina Oprea, Battista Biggio, Chang Liu, Cristina Nita-Rotaru, and Bo Li. Manipulating machine learning: Poisoning attacks and countermeasures for regression learning. In 2018 IEEE symposium on security and privacy $(S P)$ , pages 19\u201335. IEEE, 2018.   \n[30] Arun Jangir and Willian Oliveira. Healthcare insurance, 2023. This dataset is licensed under CC0: Public Domain.   \n[31] Jinyuan Jia, Xiaoyu Cao, and Neil Zhenqiang Gong. Intrinsic certified robustness of bagging against data poisoning attacks. In Proceedings of the AAAI conference on artificial intelligence, volume 35, pages 7961\u20137969, 2021.   \n[32] Matt Jordan, Jonathan Hayase, Alex Dimakis, and Sewoong Oh. zonotope domains for lagrangian neural network verification. In NIPS, 2022.   \n[33] Bojan Karlas, Peng Li, Renzhi Wu, Nezihe Merve G\u00fcrel, Xu Chu, Wentao Wu, and Ce Zhang. Nearest neighbor classifiers over incomplete information: From certain answers to certain predictions. Proc. VLDB Endow., 14(3):255\u2013267, 2020.   \n[34] Pasha Khosravi, Yitao Liang, YooJung Choi, and Guy Van den Broeck. What to Expect of Classifiers? Reasoning about Logistic Regression with Missing Features. arXiv, 2019.   \n[35] Byol Kim, Chen Xu, and Rina Foygel Barber. Predictive inference is free with the jackknife $+\\cdot$ -afterbootstrap. In International Conference on Neural Information Processing Systems. Curran Associates Inc., 2020.   \n[36] Niklas Kochdumper and Matthias Althoff. Sparse polynomial zonotopes: A novel set representation for reachability analysis. IEEE Transactions on Automatic Control, 66(9):4043\u20134058, 2020.   \n[37] Niklas Kochdumper and Matthias Althoff. Constrained polynomial zonotopes. Acta Informatica, 60(3):279\u2013 316, 2023.   \n[38] Anna-Kathrin Kopetzki, Bastian Sch\u00fcrmann, and Matthias Althoff. Methods for order reduction of zonotopes. In 2017 IEEE 56th Annual Conference on Decision and Control (CDC), pages 5626\u20135633. IEEE, 2017.   \n[39] Adrian Kulmburg and Matthias Althoff. On the co-np-completeness of the zonotope containment problem. Eur. J. Control, 62:84\u201391, 2021.   \n[40] Sungyoon Lee, Hoki Kim, and Jaewook Lee. Graddiv: Adversarial robustness of randomized neural networks via gradient diversity regularization. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2022.   \n[41] David Lewis. Counterfactuals and comparative possibility. In IFS: Conditionals, Belief, Decision, Chance and Time, pages 57\u201385. Springer, 1973.   \n[42] Charles Marx, Flavio Calmon, and Berk Ustun. Predictive multiplicity in classification. In International Conference on Machine Learning, pages 6765\u20136774. PMLR, 2020.   \n[43] Peter McCullagh, Vladimir Vovk, Ilia Nouretdinov, Dmitry Devetyarov, and Alex Gammerman. Conditional prediction intervals for linear regression. In International Conference on Machine Learning and Applications, pages 131\u2013138, 2009.   \n[44] Johannes Mehrer, Courtney J Spoerer, Nikolaus Kriegeskorte, and Tim C Kietzmann. Individual differences among deep neural network models. Nature communications, 11(1):5725, 2020.   \n[45] Aaron Meurer, Christopher P Smith, Mateusz Paprocki, Ond\u02c7rej \u02c7Cert\u00edk, Sergey B Kirpichev, Matthew Rocklin, AMiT Kumar, Sergiu Ivanov, Jason K Moore, Sartaj Singh, et al. Sympy: symbolic computing in python. PeerJ Computer Science, 3:e103, 2017.   \n[46] Anna P. Meyer, Aws Albarghouthi, and Loris D\u2019Antoni. Certifying data-bias robustness in linear regression. CoRR, abs/2206.03575, 2022.   \n[47] Anna P Meyer, Aws Albarghouthi, and Loris D\u2019Antoni. The dataset multiplicity problem: How unreliable data impacts predictions. In Proceedings of the 2023 ACM Conference on Fairness, Accountability, and Transparency, pages 193\u2013204, 2023.   \n[48] Antoine Min\u00e9. The octagon abstract domain. Higher-order and symbolic computation, 19:31\u2013100, 2006.   \n[49] Matthew Mirman, Timon Gehr, and Martin Vechev. Differentiable abstract interpretation for provably robust neural networks. In International Conference on Machine Learning, pages 3578\u20133586. PMLR, 2018.   \n[50] Matthew Mirman, Alexander H\u00e4gele, Pavol Bielik, Timon Gehr, and Martin Vechev. Robustness certification with generative models. In ACM SIGPLAN International Conference on Programming Language Design and Implementation, pages 1141\u20131154, 2021.   \n[51] Mark Niklas M\u00fcller, Marc Fischer, Robin Staab, and Martin Vechev. Abstract interpretation of fixpoint iterators with applications to neural networks. Proceedings of the ACM on Programming Languages, 7(PLDI):786\u2013810, 2023.   \n[52] Nicolas M\u00fcller, Daniel Kowatsch, and Konstantin B\u00f6ttinger. Data poisoning attacks on regression learning and corresponding defenses. In Pacific Rim International Symposium on Dependable Computing (PRDC), pages 80\u201389. IEEE, 2020.   \n[53] Hongseok Namkoong and John C Duchi. Stochastic gradient methods for distributionally robust optimization with f-divergences. In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 29. Curran Associates, Inc., 2016.   \n[54] David J. Olive. Prediction intervals for regression models. Computational Statistics & Data Analysis, 51(6):3115\u20133122, 2007.   \n[55] Andrea Paudice, Luis Mu\u00f1oz-Gonz\u00e1lez, and Emil C Lupu. Label sanitization against label flipping poisoning attacks. In ECML PKDD Workshops, pages 5\u201315. Springer, 2019.   \n[56] Robert J Plemmons. M-matrix characterizations. i-nonsingular m-matrices. Linear Algebra and its applications, 18(2):175\u2013188, 1977.   \n[57] Boris T Polyak. Some methods of speeding up the convergence of iteration methods. Ussr computational mathematics and mathematical physics, 4(5):1\u201317, 1964.   \n[58] R. Quinlan. Auto MPG. UCI Machine Learning Repository, 1993. DOI: https://doi.org/10.24432/C5859H. This dataset is licensed under a Creative Commons Attribution 4.0 International (CC BY 4.0) license.   \n[59] Raymond Reiter. A theory of diagnosis from first principles. Artificial intelligence, 32(1):57\u201395, 1987.   \n[60] Elan Rosenfeld, Ezra Winston, Pradeep Ravikumar, and Zico Kolter. Certified robustness to label-filpping attacks via randomized smoothing. In International Conference on Machine Learning, pages 8230\u20138241. PMLR, 2020.   \n[61] Donald B Rubin. Multiple imputations in sample surveys-a phenomenological bayesian approach to nonresponse. In Proceedings of the survey research methods section of the American Statistical Association, volume 1, pages 20\u201334. American Statistical Association Alexandria, VA, USA, 1978.   \n[62] Donald B Rubin. Multiple imputation after $^{18+}$ years. Journal of the American statistical Association, 91(434):473\u2013489, 1996.   \n[63] Anian Ruoss, Mislav Balunovic, Marc Fischer, and Martin Vechev. Learning certified individually fair representations. In Advances in Neural Information Processing Systems, pages 7584\u20137596, 2020.   \n[64] Christian Schilling, Marcelo Forets, and Sebasti\u00e1n Guadalupe. Verification of neural-network control systems by integrating taylor models and zonotopes. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 36, pages 8169\u20138177, 2022.   \n[65] Soroosh Shafieezadeh-Abadeh, Peyman Mohajerin Esfahani, and Daniel Kuhn. Distributionally robust logistic regression. In Neural Information Processing Systems, 2015.   \n[66] Ilia Shumailov, Zakhar Shumaylov, Dmitry Kazhdan, Yiren Zhao, Nicolas Papernot, Murat A Erdogdu, and Ross J Anderson. Manipulating sgd with data ordering attacks. Advances in Neural Information Processing Systems, 34:18021\u201318032, 2021.   \n[67] Daniele Silvestro and Tobias Andermann. Prior choice affects ability of bayesian neural networks to identify unknowns. arXiv preprint arXiv:2005.04987, 2020.   \n[68] Gagandeep Singh, Timon Gehr, Matthew Mirman, Markus P\u00fcschel, and Martin Vechev. Fast and effective robustness certification. Advances in neural information processing systems, 31, 2018.   \n[69] Jasper Snoek, Hugo Larochelle, and Ryan P Adams. Practical bayesian optimization of machine learning algorithms. Advances in neural information processing systems, 25, 2012.   \n[70] Jacob Steinhardt, Pang Wei Koh, and Percy Liang. Certified defenses for data poisoning attacks. In NeurIPS, 2017.   \n[71] Damien Teney, Maxime Peyrard, and Ehsan Abbasnejad. Predicting is not understanding: Recognizing and addressing underspecification in machine learning. In European Conference on Computer Vision, pages 458\u2013476. Springer, 2022.   \n[72] Ba-Hien Tran, Simone Rossi, Dimitrios Milios, and Maurizio Filippone. All you need is a good functional prior for bayesian deep learning. Journal of Machine Learning Research, 23(74):1\u201356, 2022.   \n[73] Rens van de Schoot, Sarah Depaoli, Ruth King, Bianca Kramer, Kaspar M\u00e4rtens, Mahlet G Tadesse, Marina Vannucci, Andrew Gelman, Duco Veen, Joukje Willemsen, et al. Bayesian statistics and modelling. Nature Reviews Methods Primers, 1(1):1, 2021.   \n[74] Marianne Southall Winslett. Reasoning about action using a possible models approach. Number 1427-1432. Department of Computer Science, University of Illinois at Urbana-Champaign, 1988.   \n[75] Margaux Zaffran, Aymeric Dieuleveut, Julie Josse, and Yaniv Romano. Conformal prediction with missing values. In International Conference on Machine Learning, pages 40578\u201340604. PMLR, 2023.   \n[76] Xuezhou Zhang, Xiaojin Zhu, and Stephen Wright. Training set debugging using trusted items. In AAAI, 2018. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "A Linear Regression and Ridge Regression ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "In this section, we review standard loss functions for linear regression, specifically mean squared error (MSE) and the loss function used in ridge regression. can be trained via either the closed-form solution or gradient descent. Specifically, the closed-form solution requires computing the inversion of the covariance matrix, while the gradient descent only involves matrix addition and multiplication. Since the linear regression model is convex, gradient descent is guaranteed to converge to the global optimum. ", "page_idx": 14}, {"type": "text", "text": "Suppose we have a training data $D\\,=\\,(X,y)$ with $n$ i.i.d. samples , where the feature matrix $\\pmb{X}\\,=\\,[\\pmb{x}_{1}\\quad.\\dots\\quad\\pmb{x}_{n}]^{T}\\,\\in\\,\\mathbb{R}^{n\\times d}$ , and the labels $\\pmb{y}\\,=\\,\\left[y_{1},\\cdot\\cdot\\cdot\\,,y_{n}\\right]^{T}\\,\\in\\,\\mathbb{R}^{n}$ . Given an input $\\textbf{\\em x}$ and the model weight $\\mathbf{\\nabla}w$ , the prediction of the linear regression model $\\hat{\\pmb y}=\\pmb{w}^{T}\\pmb{x}$ (the bias term can be integrated into $\\pmb{w}$ , corresponding to an added column in $\\mathbf{\\deltaX}$ with constant 1\u2019s). ", "page_idx": 14}, {"type": "text", "text": "Loss Functions The mean squared error (MSE) loss on $_{D}$ is defined as shown below. ", "page_idx": 14}, {"type": "equation", "text": "$$\nL(\\pmb{X},\\pmb{y},\\pmb{w})=\\frac{1}{n}\\sum_{i=1}^{n}(y_{i}^{\\prime}-y_{i})^{2}=\\frac{1}{n}\\sum_{i=1}^{n}(w^{T}x_{i}-y_{i})^{2}=\\frac{1}{n}(\\pmb{X}w-y)^{T}(\\pmb{X}w-y).\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "In practice, regularization terms, e.g., based on the $l_{p}$ -norm of the model parameters, are often added to the original MSE loss to prevent overfitting by penalizing large weights. Using $l_{2}$ -regularization with a regularization coefficient $\\lambda$ which determines the strength of regularization is often called ridge regression. The loss function for ridge regression is: ", "page_idx": 14}, {"type": "equation", "text": "$$\nL(\\pmb{X},\\pmb{y},\\pmb{w})=\\frac{1}{n}(\\pmb{X}\\pmb{w}-\\pmb{y})^{T}(\\pmb{X}\\pmb{w}-\\pmb{y})+\\lambda\\cdot\\pmb{w}^{T}\\pmb{w}.\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "Gradient Descent for Linear Regression Due to the convexity of linear models, the locally optimal point, which can be obtained by gradient descent with an appropriate learning rate $\\eta$ , is globally optimal. In gradient descent, the model weights $\\pmb{w}$ are iteratively updated (with some learning rate $\\eta$ ) towards the reverse direction of the gradient \u2202L(\u2202X,wy,w). Thus, for ridge regression: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\frac{\\partial L(\\pmb{X},\\pmb{y},\\pmb{w})}{\\partial\\pmb{w}}=\\frac{2}{n}(\\pmb{X}^{T}\\pmb{X}\\pmb{w}-\\pmb{X}^{T}\\pmb{y})+2\\lambda\\pmb{w}.\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "Thus, one step of gradient descent $\\Phi$ is: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\pmb{w}^{i+1}=\\pmb{w}^{i}-\\eta\\frac{2}{n}(\\pmb{X}^{T}\\pmb{X}\\pmb{w}-\\pmb{X}^{T}\\pmb{y})+2\\lambda\\pmb{w}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "Closed-form Solution for Linear Regression The convex nature of linear models ensures that the optimal weight ${\\pmb w}={\\pmb w}^{*}$ , which minimizes the loss $L(X,y,w)$ , can be computed by establishing \u2202L(X,y,w)= 0: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\begin{array}{c}{{\\displaystyle\\frac{\\partial{\\cal L}({\\pmb X},{\\pmb y},{\\pmb w}^{*})}{\\partial{\\pmb w}^{*}}=\\frac{2}{n}({\\pmb X}^{T}{\\pmb X}{\\pmb w}^{*}-{\\pmb X}^{T}{\\pmb y})+2\\lambda{\\pmb w}^{*}=0}}\\\\ {{\\Rightarrow}}\\\\ {{\\Rightarrow}}\\\\ {{\\Rightarrow}}\\end{array}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "B Background on Abstract Interpretation ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Abstract interpretation [13] is a technique for over-approximating the results of computations over a set of inputs. This is achieved by associating sets of elements of a concrete domain $\\mathbb{D}$ with elements from an abstract domain $\\mathbb{D}^{\\sharp}$ . In this context, various abstract domains are employed: interval domains represent variables as ranges of possible values [13], octagon domains allow for constraints between pairs of variables within a specific bound [48], and polynomial zonotopes which represent convex polytopes using polynomial constraints [14]. Abstract interpretation, while originally designed for static program analysis such as strictness analysis, has also found applications in wide range of other domains including reachability analysis [1, 5, 2, 10, 36, 4], robustness verification for neural networks [32, 64], learning robust models by providing bounds on the loss for a set of inputs [51, 63, 49, 22], and many others. ", "page_idx": 14}, {"type": "text", "text": "", "page_idx": 15}, {"type": "text", "text": "We now state some important, but well-known, facts about abstract transformers that we utilize in our derivations. ", "page_idx": 15}, {"type": "text", "text": "B.1 Abstract Transformers ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "In Def. 2.5, we presented the standard definition of abstract transformers as functions over abstract domains that over-approximate the application of functions in the concrete domains to sets of elements. To clarify the connection between abstract transformers and possible world semantics observe that both take a concrete function $F:\\mathbb{D}\\rightarrow\\mathbb{D}^{\\prime}$ and lift it to sets of inputs $S\\in{\\mathcal{P}}(\\mathbb{D})$ through point-wise applications: ", "page_idx": 15}, {"type": "equation", "text": "$$\nF(S)=\\{F(e)\\mid e\\in S\\}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Thus, abstract interpretation is a natural fti for over-approximating PWS by over-approximating sets of possible worlds using abstract elements and then over-approximates computations with PWS for a function $F$ using abstract transformers for such a function. ", "page_idx": 15}, {"type": "text", "text": "B.2 Abstract Transformers Compose ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Importantly, abstract transformers compose. This enables us to decompose a complex computation into simpler operations and build an abstract transformer for the computation by composing abstract transformations for these simpler operations. ", "page_idx": 15}, {"type": "text", "text": "Proposition B.1 (Abstract Transformers Compose). Consider (exact) abstract transformers $f^{\\sharp}$ and $g^{\\sharp}$ for functions $f$ and $g_{\\mathrm{:}}$ , then $g^{\\sharp}\\circ f^{\\sharp}$ is an (exact) abstract transformer for $g\\circ f$ . ", "page_idx": 15}, {"type": "text", "text": "C Symbolic and Standard Representation of Zonotopes ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "We now provide a more detailed account of the correspondence between the symbolic and standard geometric representation of zonotopes and polynomial zonotopes and discuss why matrices and sets of symbolic matrices as used in our abstract domain can equivalently be thought of as (polynomial) zonotopes. ", "page_idx": 15}, {"type": "text", "text": "C.1 Symbolic vs. Geometric Representation ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "We defined zonotopes $z^{\\sharp}$ as vectors $\\Psi^{d}$ where $\\Psi$ denotes polynomials over variables (called error symbols) $\\mathcal{E}$ . The concretization of such a symbolic representation of a zonotope is the set of vectors in $\\mathbb{R}^{d}$ that can be derived from $z^{\\sharp}$ by assigning values from $[-1,1]$ to each variable $\\epsilon\\in\\mathcal{E}$ . We encode such variable assignments as vectors $[-1,1]^{\\vert\\,\\mathcal{E}\\,\\vert}$ . ", "page_idx": 15}, {"type": "text", "text": "Definition C.1 (Polynomial zonotopes - Symbolic Representation). $A\\ d$ -dimensional polynomial zonotope is a vector $\\overline{{z^{\\sharp}}}\\in\\Psi^{d}$ [10]. Let $m=|\\,\\mathcal{E}\\,|$ . The concretization of $z^{\\sharp}$ is defined as: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\gamma\\left(z^{\\sharp}\\right)=\\left\\{z^{\\sharp}(e)\\mid e\\in[-1,1]^{|\\,\\varepsilon\\,|}\\right\\}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "A common measure of the representation size of a zonotope is its order. The order of a $d_{\\cdot}$ -dimensional (polynomial) $z^{\\sharp}$ in symbolic representation is the total number of distinct monomials in $z^{\\sharp}$ divided by $d$ : ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathrm{ORD}\\big(z^{\\sharp}\\big)=\\frac{\\#\\mathcal{M}(z^{\\sharp})}{d}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "where $\\#\\mathcal{M}(\\psi)$ denotes the cardinality of the set of distinct monomials in polynomial $\\psi$ . ", "page_idx": 15}, {"type": "text", "text": "A more common way to represent $d$ -dimensional zonotopes is by fixing a set $\\boldsymbol{S}$ of monomials over $\\mathcal{E}$ and writing the zonotope as a central point $c\\in\\mathbb{R}^{d}$ and a sum of generator vectors $\\mathbf{\\boldsymbol{g}}_{i}\\in\\mathbb{R}^{d}$ multiplied with the monomials from $\\boldsymbol{S}$ . The generator vector $\\scriptstyle g_{i}$ assigns a coefficient to monomial $S[i]$ for each of the $d$ dimensions. ", "page_idx": 15}, {"type": "text", "text": "Definition C.2 (Polynomial zonotopes - Geometric Representation). The geometric representation of a $d$ -dimensional polynomial zonotope is a sum of a center point $c\\in\\mathbb{R}^{d}$ and the monomials over error symbols in $\\mathcal{E}$ from a set $\\boldsymbol{S}$ multiplied by coefficients encoded in set of generator vectors $\\mathbf{\\boldsymbol{g}}_{i}\\in\\mathbb{R}^{d}$ : ", "page_idx": 16}, {"type": "equation", "text": "$$\nz^{\\sharp}=c+\\sum_{i=1}^{|S|}g_{i}S[i]\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "For the geometric representation, the order of a $d$ -dimensional (polynomial) $z^{\\sharp}$ over monomials $\\boldsymbol{S}$ is defined as: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathrm{ORD}(z^{\\sharp})={\\frac{|S|}{d}}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Note that the order of the symbolic and geometric representation of a zonotope are the same. As an example consider the 4-dimensional polynomial zonotope z\u266fshown in symbolic representation (left) and standard representation (right). ", "page_idx": 16}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/595dc0745e3cec0767835901f2681cd495de298b504668c9642041406459f36c.jpg", "img_caption": [], "img_footnote": [], "page_idx": 16}, {"type": "text", "text": "C.2 Symbolic Matrices and Sets of Symbolic Matrices ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "We use matrices over symbolic expressions and sets of heterogeneous abstract matrices to represent the state of a computation and allow matrices from such a set to share variables to encode relationships between the elements of such matrices. The semantics we associate with such a set is that of a joint concretization. For $S^{\\sharp}=\\{M_{i}^{\\sharp}\\}$ , we define: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\gamma\\left(S^{\\sharp}\\right)=\\{M_{i}^{\\sharp}(e)\\mid M_{i}^{\\sharp}\\in S^{\\sharp}\\wedge e\\in[-1,1]^{n}\\}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "zonotopes encode convex sets of points in Rd. We can think of a symbolic matrix M \u266f\u2208\u03a8n\u00d7m as a $n\\cdot m$ -dimensional polynomial zonotope. Similarly, a set of symbolic matrices $S^{\\sharp}=\\{M_{i}^{\\sharp}\\in$ $\\mathbb{R}^{n_{i}\\times m_{i}}\\}$ can be thought of as a $l$ -dimensional polynomial zonotope $\\mathbb{R}^{l}$ where $\\textstyle l=\\sum_{i}n_{i}\\cdot m_{i}$ . If every symbolic expression in a matrix or set of matrices is a linear combination of error symbols (an affine form), then such objects can equivalently be represented as zonotopes. ", "page_idx": 16}, {"type": "text", "text": "For instance, below on the left we show a zonotope matrix $W^{\\sharp}$ (all expressions are linear) and two possible worlds in its concretization (for assignments $[-1,-1]$ and [0, 0.5]). ", "page_idx": 16}, {"type": "equation", "text": "$$\nW^{\\sharp}={\\left[\\begin{array}{l l}{\\epsilon_{1}+3}&{\\epsilon_{2}}\\\\ {15}&{22\\epsilon_{1}}\\end{array}\\right]}\\qquad W^{\\sharp}\\left(\\left[{-1\\atop-1}\\right]\\right)={\\left[\\begin{array}{l l}{2}&{-1}\\\\ {15}&{-22}\\end{array}\\right]}\\qquad W^{\\sharp}\\left(\\left[0.5\\right]\\right)=\\left[15\\quad{0.5}\\right]\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "C.3 Abstract Training Data and Model Weights ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Using possible world semantics to compute all possible model weights $\\pmb{w}^{\\odot*}$ given a set of possible training datasets $D^{\\odot}$ , there will be a natural correspondence between a model weight $\\pmb{w}\\in\\pmb{w}^{\\odot*}$ and the dataset $D\\in D^{\\odot}$ from which is was derived. When training in the abstract domain such correlations can be preserved by sharing error symbols between the abstract training data $\\mathbf{D}^{\\sharp}$ and corresponding model weights $\\bar{\\pmb{w}^{\\sharp}}$ . When such sharing occurs, then it is critical to reason about the joint concretization when determining whether an abstract fixed point as been achieved. Testing equivalence (equal concretization) of $\\pmb{w}^{\\sharp}$ alone can lead to false positives, as $w^{\\sharp}{}_{1}\\,\\simeq\\!\\sharp\\ w^{\\sharp}{}_{2}$ does not in general imply $(\\mathbf{D}^{\\sharp},\\pmb{w}^{\\sharp}_{1})\\,\\simeq_{\\sharp}\\,\\,(\\mathbf{D}^{\\sharp},\\pmb{w}^{\\sharp}{}_{2})$ . This is due to the fact that a particular concrete model weight $\\pmb{w}\\,\\in\\,\\gamma\\left(\\pmb{w}^{\\sharp}{}_{1}\\right)\\,=\\,\\gamma\\left(\\pmb{w}^{\\sharp}{}_{2}\\right)$ may be associated with different datasets in $(\\mathbf{D}^{\\sharp},w^{\\sharp}{}_{1})$ and $\\mathbf{D}^{\\sharp},w^{\\sharp}{}_{2})$ because of shared error symbols between $\\mathbf{D}^{\\sharp}$ and the abstract model weights. Thus, concretization equivalence between model weights only does not imply equivalent results after application of a gradient decent step. ", "page_idx": 16}, {"type": "text", "text": "", "page_idx": 17}, {"type": "text", "text": "To further illustrate this consider, two pairs of abstract model weights $\\pmb{w}^{\\sharp}{}_{1}$ and $w^{\\sharp}{}_{2}$ . ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left(w^{\\sharp}{}_{1}=\\left[{}^{2}+{}^{2}{}\\epsilon_{1}\\right],\\mathbf{D}^{\\sharp}=\\left[{}^{\\epsilon}{}_{1}\\right]\\right)}\\\\ {\\qquad\\quad+{}^{\\aa}}\\\\ {\\left(w^{\\sharp}{}_{2}=\\left[{}^{2}+{}^{2}{}\\epsilon_{3}\\right],\\mathbf{D}^{\\sharp}=\\left[{}^{\\epsilon}{}_{5}\\right]\\right)}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "The only difference between $\\pmb{w}^{\\sharp}{}_{1}$ and $\\pmb{w}^{\\sharp}{}_{2}$ is that $\\pmb{w}^{\\sharp}{}_{1}$ shares a variable $(\\epsilon_{1})$ with $\\mathbf{D}^{\\sharp}$ while $\\pmb{w}^{\\sharp}{}_{2}$ does not. Observe that $\\gamma\\left(w^{\\sharp}{}_{1}\\right)=\\gamma\\left(w^{\\sharp}{}_{2}\\right)$ . However, applying a step of gradient decent to $\\pmb{w}^{\\sharp}{}_{1}$ and $\\pmb{w}^{\\sharp}{}_{2}$ may lead to abstract models that are not equivalent. For sake of this example, consider a hypothetical gradient operator $\\Phi_{d u m m y}^{\\sharp}$ that subtracts the data from the current model weight. ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r l r}&{}&{\\left(\\Phi_{d u m m y}^{\\sharp}({\\pmb w}^{\\sharp}{}_{1})=\\left[\\,2+\\epsilon_{1}\\atop-2+\\epsilon_{2}\\right],{\\bf D}^{\\sharp}=\\left[\\,\\epsilon_{1}\\atop5\\,\\right]\\right)}\\\\ &{}&{\\left(\\Phi_{d u m m y}^{\\sharp}({\\pmb w}^{\\sharp}{}_{2})=\\left[\\,2+2\\epsilon_{3}-\\epsilon_{1}\\atop-2+\\epsilon_{2}\\,\\right],{\\bf D}^{\\sharp}=\\left[\\,\\epsilon_{1}\\atop5\\,\\right]\\right)}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Note that \u03a6\u266fdummy( $\\Phi_{d u m m y}^{\\sharp}({\\pmb w}^{\\sharp}{}_{1})\\not\\simeq\\sharp_{d u m m y}^{\\sharp}({\\pmb w}^{\\sharp}{}_{2})$ . Thus, even if two abstract model weights have equal concretization this does not guarantee that a fixed point has been reached when also taking the data into account. This is important as otherwise it is not possible that the abstract model weights contain all possible optimal model weights $\\pmb{w}^{\\odot*}$ . Instead, we need to consider the joint concretization of model weight and data, s.t. if $\\bar{\\gamma}\\left(S^{\\sharp}{}_{1}\\right)=\\gamma\\left(S^{\\sharp}{}_{2}\\right)$ then concretization equivalence is guaranteed to hold for all subsequent iterations. ", "page_idx": 17}, {"type": "text", "text": "D Examples Of Training Data Uncertainty and Abstraction ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "In this section, we discuss several causes of training (and test) data uncertainty, how to encode them as possible worlds, and abstraction functions for approximating such uncertainty in our symbolic model. ", "page_idx": 17}, {"type": "text", "text": "D.1 Measurement Uncertainty ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Sensors typically have some measurement uncertainty. If the measurement error $\\epsilon$ is know, e.g., provided by the instrument manufacturer or estimated through repeated measurements and calibration, then for a set of sensor readings used in training $D=\\{(\\pmb{x}_{i},y_{i})\\}$ , then each possible world in $D^{\\odot}$ is derived from $_{D}$ by replacing values $\\pmb{x}_{i}[j]$ with values in $\\mathbf{\\boldsymbol{x}}_{i}[j]\\pm\\boldsymbol{\\epsilon}$ . ", "page_idx": 17}, {"type": "text", "text": "D.2 Missing Values and Imputation ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Consider a training dataset $_{D}$ where some of the features are missing for some of the datapoints in $_{D}$ . If each feature $\\mathcal{X}_{i}$ \u2019s domain is an interval $[l_{i},u_{i}]$ and assuming that missing values can be represented as independent random variables, then the set of possible worlds of the training data $D^{\\odot}$ are all training datasets that can be derived from $_{D}$ by replacing each missing value in a feature $\\mathcal{X}_{i}$ with a value from $[l_{i},u_{i}]$ . ", "page_idx": 17}, {"type": "text", "text": "We can use an abstraction function $\\alpha_{m i s s i n g}$ that represents each missing value as an interval $[l_{i},u_{i}]$ . In the symbolic representation, this is encoded as the central point of the interval of an error symbol $\\epsilon$ with a coefficient half of the interval\u2019s length. We associate a separate error symbol with each missing value. For $D\\in\\mathbb{R}^{n\\times m}$ , we define $\\alpha_{m i s s i n g}$ for $i\\in[1,n]$ and $j\\in[1,m]$ as: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\alpha_{m i s s i n g}(D_{i j})=\\left\\{\\frac{u_{j}\\!+\\!l_{j}}{2}+\\frac{u_{j}\\!-\\!l_{j}}{2}\\epsilon_{i,j}\\right.\\!\\!\\!\\!\\!\\!\\mathrm{if}\\left.D_{i j}=\\perp\\!\\!\\!\\!\\!\\perp\\right.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "For instance, consider the training dataset $D\\in\\mathbb{R}^{3\\times2}$ shown below where $\\perp$ denotes a missing value. ", "page_idx": 18}, {"type": "equation", "text": "$$\nD=\\left(\\!\\!{\\begin{array}{l l}{3}&{{\\frac{1}{6}}}\\\\ {1}&{{6}}\\\\ {\\bot}&{{9}}\\end{array}}\\!\\!\\right)\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Assuming that both features have a domain [0, 10], we get: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\alpha_{m i s s i n g}(D)=\\binom{3}{5+5\\epsilon_{3,1}}\\qquad\\qquad6\\qquad\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "If the independence assumption on missing values holds, then $\\gamma\\left(\\alpha_{m i s s i n g}(D)\\right)\\,=\\,D^{\\odot}$ . If the independence assumption does not hold, then $D^{\\odot}$ would be a subset of the worlds described above and $\\alpha_{m i s s i n g}(D)$ is a still a valid abstraction function, albeit an over-approximating one: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\gamma\\left(\\alpha_{m i s s i n g}(D)\\right)\\supseteq D^{\\odot}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Imputation If we make the stronger assumption the unknown ground truth value corresponding to a missing value is in a set of estimations $\\{a_{1},\\ldots,a_{m}\\}$ returned by a set of imputation methods, then we can use $[m i n(\\{a_{i}\\}),m a x(\\{a_{i}\\})]$ instead of $[l_{i},u_{i}]$ . ", "page_idx": 18}, {"type": "text", "text": "Training Label Uncertainty The abstract transformer $\\alpha_{m i s s i n g}$ can also be used if training data labels are missing. ", "page_idx": 18}, {"type": "text", "text": "E Abstract Transformers for Zonotopes ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "In this section we introduce (exact) abstract transformers for (polynomial) zonotopes that have been introduced in related work and discuss their computation complexity and the space requirements for the output zonotope $z^{\\sharp}$ in terms of its order $\\dot{\\mathrm{ORD}}(z^{\\sharp})$ (see Sec. 2.2). Kochdumper et al. [37, Table 1] shows an overview of which operations are exact for linear and polynomial zonotopes (and other set representations). Relevant to for our purpose is that exact transformers exist for polynomial zonotopes for all operations used in the learning algorithms for linear models we consider. ", "page_idx": 18}, {"type": "text", "text": "Proposition E.1 (Exact Transformers for Polynomial Zonotopes). There exist exact abstract transformers for scalar addition and multiplication as well as for matrix addition and multiplication for polynomial zonotopes [3]. There exist exact transformers for scalar addition and matrix addition for zonotopes. Abstract transformers for multiplication and matrix multiplication for zonotopes exist, but are not exact. ", "page_idx": 18}, {"type": "text", "text": "We present the details of these operations in the following. ", "page_idx": 18}, {"type": "text", "text": "E.1 Arithmetic Operations ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Addition. Scalar and matrix addition are exact in both zonotopes and polynomial zonotopes. Given two matrix (polynomial) zonotopes $V^{\\sharp}$ and $W^{\\sharp}$ in $\\Psi^{n\\times m}$ , their addition $\\begin{array}{r}{\\dot{Z}^{\\sharp}=V^{\\sharp}+W^{\\sharp}}\\end{array}$ is defined by adding entries. For each $i\\in[1,n]$ and $j\\in[1,m]$ : ", "page_idx": 18}, {"type": "equation", "text": "$$\nZ^{\\sharp}{}_{i j}=V^{\\sharp}{}_{i j}+W^{\\sharp}{}_{i j}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "The order of $Z^{\\sharp}$ is the sum of the orders of $V^{\\sharp}$ and $W^{\\sharp}$ : ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\operatorname{ORD}(Z^{\\sharp})=\\operatorname{ORD}(V^{\\sharp})+\\operatorname{ORD}(W^{\\sharp})\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Scalar multiplication. Multiplying a (polynomial) zonotope matrix $W^{\\sharp}$ with a scalar $c$ is exact using the abstract transformer $p o l y$ defined below. We simply multiply each entry in the matrix by $c$ .For each $i\\in[1,n]$ and $j\\in[1,m]$ : ", "page_idx": 18}, {"type": "equation", "text": "$$\n(c\\cdot_{p o l y}W^{\\sharp})_{i j}=c\\cdot W^{\\sharp}{}_{i j}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Multiplication with a scalar abstract value $d\\in\\Psi$ is exact for polynomial zonotope matrices, but increases the order of the input zonotope: ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\operatorname{ORD}(d\\cdot W)=\\operatorname{ORD}(d)\\cdot\\operatorname{ORD}(W)\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Here we define the order of a scalar abstract value $d\\in\\Psi$ to be the number of monomials in the representation of $d$ . For a linear zonotope $W$ $,d\\cdot W^{\\sharp}{}_{i j}$ is in general not linear as it contains higherorder terms. Thus, matrix multiplication for linear zonotopes requires application of linearization (see App. G): ", "page_idx": 19}, {"type": "equation", "text": "$$\nd\\cdot_{L i n}\\,{\\cal W}={\\bf L}(d\\cdot_{p o l y}\\,{\\bf W})\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Matrix multiplication. Matrix multiplication is defined using scalar multiplication and addition. As discussed above, addition is exact for both linear and polynomial zonotopes. However, scalar multiplication of symbolic expressions is only exact for polynomial zonotopes, but requires linearization and, thus, over-approximation, for linear zonotopes. That is, matrix multiplication is exact for polynomial zonotopes only. Consider two matrices $\\bar{V^{\\sharp}}\\in\\Psi^{n\\times m}$ and $V^{\\sharp}\\in\\Psi^{m^{\\star}\\!\\,k}$ , then matrix multiplication is defined as usual, but using abstract transformers for scalar addition and multiplication. Each symbolic entry in the matrix $V^{\\sharp}\\cdot W^{\\sharp}$ is a sum of $m$ elements, each the multiplication of one entry of $V^{\\sharp}$ with one entry of $W^{\\sharp}$ . Thus, ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\operatorname{ORD}(V^{\\sharp}\\cdot W^{\\sharp})=m\\cdot\\operatorname{ORD}(V^{\\sharp})\\cdot\\operatorname{ORD}(W^{\\sharp})\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "For linear zonotopes, we have to again apply linearization to make sure that the output is a linear zonotope. ", "page_idx": 19}, {"type": "text", "text": "F Abstract Transformers for Gradient Descent ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "F.1 Abstract Fixed Points Over-Approximate Possible Fixed Points ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Proof of Prop. 3.3. Initially, we will assume that $\\boldsymbol{w^{\\sharp\\,j}}$ is computed through repeated application of $F^{\\sharp}$ . Let $n$ be the smallest number such that $\\pmb{w}^{\\sharp\\,*}=\\pmb{w}^{\\sharp\\,n}\\doteq F^{\\sharp}(\\pmb{w}^{\\sharp\\,n-1},\\mathbf{D}^{\\sharp})$ for iteration with abstract transformer $F^{\\sharp}$ . As $F^{\\sharp}$ is an abstract transformer for $\\Phi$ and abstract transformers compose (Prop. B.1), we know that for every $D_{i}\\in D^{\\odot}$ and $n\\in\\mathbb N$ , we have $(\\pmb{w}_{i}^{n},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,n},\\pmb{\\mathbf{D}}^{\\sharp}\\right)$ . To prove the claim it is sufficient to show that for every such $D_{i}$ we have $(\\pmb{w}_{i}^{*},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,n},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ . WLOG consider some $D_{i}\\;\\in\\;D^{\\odot}$ and $(\\pmb{w}_{i}^{n},\\pmb{D}_{i})\\;\\in\\;\\gamma\\left(\\pmb{w}^{\\sharp\\;n},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ . Let $m\\,\\in\\,\\mathbb{N}$ be the smallest number such that $\\pmb{w}_{i}^{*}=\\pmb{w}_{j}^{m}$ . If $m\\leq n$ , then based on the fact that $F^{\\sharp}$ is an abstract transformer (over-approximates $\\Phi$ ), the result holds as $(\\pmb{w}_{i}^{n},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,n},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ . Now consider the case where $m>n$ . We will show through induction that for all $j\\in[n+1,m]$ , $(\\pmb{w}_{i}^{j},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,n},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ and, thus $(\\pmb{w}_{i}^{*},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,n},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ . ", "page_idx": 19}, {"type": "text", "text": "Induction start. For $j=n$ the result trivially holds based on the definition of abstract fixed points. ", "page_idx": 19}, {"type": "text", "text": "Induction step. Assume that $(\\pmb{w}_{i}^{j},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,n},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ for $j\\in[n,m-1]$ , we have to show that this implies that $\\overline{{(\\pmb{w}_{i}^{j+1},D_{i})}}\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,n},\\mathbf{D}^{\\sharp}\\right)$ . By definition, we have ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\pmb{w}_{i}^{j+1}=\\Phi(\\pmb{w}_{i}^{j})\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "As $F^{\\sharp}$ is an abstract transformer for $\\Phi$ , we have, $(\\pmb{w}_{i}^{j+1},\\pmb{D}_{i})\\;\\in\\;\\gamma\\left(\\pmb{w}^{\\sharp\\,n+1},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ . Now based on the fact that $w^{\\sharp\\,n}$ is an abstract fixed point according to Def. 3.2 and, thus, $\\gamma\\left(\\pmb{w}^{\\sharp\\,n},\\mathbf{D}^{\\sharp}\\right)\\ \\supseteq$ $\\gamma\\left(\\pmb{w}^{\\sharp\\,n+1},\\mathbf{D}^{\\sharp}\\right)$ , it follows that $(\\pmb{w}_{i}^{j+1},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,n},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ . ", "page_idx": 19}, {"type": "text", "text": "So far we have demonstrated that a fixed point $w^{\\sharp\\;*}$ that appears in the iteration sequence $\\{w^{\\sharp\\,j}\\}_{j=0}^{\\infty}$ contains all optimal model weights $\\pmb{w}^{\\odot*}$ . We now prove the stronger result that as long as $w^{\\sharp\\;*}$ fulfills the condition of Def. 3.2, no matter it is the result of an iteration sequence using $F^{\\sharp}$ or not, its concretization encloses $\\pmb{w}^{\\odot*}$ . Consider one $D_{i}\\,\\in\\,\\gamma\\left(\\mathbf{D}^{\\sharp}\\right)$ and as above let $\\pmb{w}_{i}^{*}$ denote its optimal model weight. We will demonstrate that $(\\pmb{w}_{i}^{*},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,*},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ . First note that given that gradient descent for linear models is convex, for any initial model weight ${\\pmb w}_{i}^{0}$ , the sequence $\\{w_{i}^{j}\\}_{j=0}^{\\infty}$ converges to $\\pmb{w}_{i}^{*}$ . Specifically, let $\\pmb{w}$ denote the model weight such that $(\\pmb{w},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\ast},\\pmb{\\mathrm{{D}}}^{\\sharp}\\right)$ ", "page_idx": 19}, {"type": "text", "text": "and let $n_{i}$ denote the smallest integer such that ${\\pmb w}_{i}^{n_{i}}={\\pmb w}_{i}^{*}$ for the sequence generated starting from ${\\pmb w}_{i}^{0}={\\pmb w}$ . However, now we can apply the same proof by induction shown above to demonstrate that $(\\bar{\\pmb{w}}_{i}^{n_{i}},\\pmb{D}_{i})\\in\\gamma\\left(\\pmb{w}^{\\sharp\\,*},\\pmb{\\mathrm{D}}^{\\sharp}\\right)$ . This concludes the proof. \u53e3 ", "page_idx": 20}, {"type": "text", "text": "F.2 Exact Abstract Transformer for Gradient Descent ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "In this section we show that the abstract transformer for gradient descent introduced in sec. 3 has a fixed point. ", "page_idx": 20}, {"type": "text", "text": "Proposition F.1. The abstract gradient descent operator $\\Phi^{\\sharp}$ has a fixed point $w^{\\sharp\\ast}$ . ", "page_idx": 20}, {"type": "text", "text": "Proof of Prop. F.1. The existence of a fixed point is implied by the fact that $\\Phi^{\\sharp}$ is an exact abstract transformer of the concrete gradient descent operator $\\Phi$ . Consider $\\gamma\\left({w^{\\sharp\\,0},{\\bf D}^{\\sharp}}\\right)=\\{(w_{i}^{0},D_{i})\\}$ . Let $n_{i}$ be the smallest integer such that ${\\pmb w}_{i}^{n_{i}}={\\pmb w}_{i}^{*}$ and let $n=\\operatorname*{max}_{i}n_{i}$ , i.e., at iteration $n$ , the concrete model weights have converged in every possible world in the concretization of $(\\boldsymbol{w}^{\\sharp\\,0},\\mathbf{D}^{\\sharp})$ . As $\\Phi^{\\sharp}$ is an exact abstract transformer, we can show by induction that $\\gamma\\left({\\pmb w}^{\\sharp\\,j},{\\bf D}^{\\sharp}\\right)=\\{({\\pmb w}_{i}^{j},{\\pmb D}_{i})\\}$ for any $j$ . As all computations in the concretization have converged at $n$ , we know that $\\pmb{w}_{i}^{n+1}=\\Phi(\\pmb{w}_{i}^{n})=\\pmb{w}_{i}^{n}$ and, thus, $\\{(\\pmb{w}_{i}^{n},D_{i})\\}=\\{(\\pmb{w}_{i}^{n+1},D_{i})\\}$ . As $\\Phi^{\\sharp}$ is exact, we get the desired result: $\\gamma\\left(w^{\\sharp\\,n},\\mathbf{D}^{\\sharp}\\right)=$ $\\{(w_{i}^{n},D_{i})\\}=\\{(w_{i}^{n+1},D_{i})\\}=\\gamma\\,\\big(w^{\\sharp\\,n+1},{\\bf D}^{\\sharp}\\big).$ \u53e3 ", "page_idx": 20}, {"type": "text", "text": "F.3 Prediction with Abstract Model Weight Fixed Points ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "We now discuss how to use the abstract model weights $w^{\\sharp\\ast}$ returned by our abstract transformer for learning linear models during inference to over-approximate the possible set of predictions for a test data point. We start by discussing test data that is not uncertain and then extend the discussion to the case where the test data is also uncertain. ", "page_idx": 20}, {"type": "text", "text": "Deterministic Test Data For now let us assume that the test data is not uncertain. The following corollary then enables us to use abstract gradient descent for inference and for over-approximating the prediction ranges. ", "page_idx": 20}, {"type": "text", "text": "Corollary F.2. Let $f_{w}(x)$ denote the linear model for parameters $\\mathbf{\\nabla}w$ . Given an incomplete training dataset $_{D}$ associated with a set of possible worlds $D^{\\odot}$ , the prediction range $V(x)$ for a test data point $\\textbf{\\em x}$ can be over-approximated by: ", "page_idx": 20}, {"type": "equation", "text": "$$\nV^{\\sharp}({\\pmb x})=\\left[\\operatorname*{min}_{{\\pmb w}\\in\\gamma({\\pmb w}^{\\sharp}\\ast)}f_{{\\pmb w}}({\\pmb x}),\\operatorname*{max}_{{\\pmb w}\\in\\gamma({\\pmb w}^{\\sharp}\\ast)}f_{{\\pmb w}}({\\pmb x})\\right],\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "where $w^{\\sharp\\ast}$ is the fixed point of the abstract gradient descent operator $\\Phi^{\\sharp}$ applied to $\\mathbf{D}^{\\sharp}=\\alpha(\\mathbf{D}^{\\odot})$ , the abstract representation of $\\mathbf{\\bar{\\b{D}}}^{\\odot}$ in the zonotope domain. ", "page_idx": 20}, {"type": "text", "text": "The prediction returned by a linear model with parameters $\\pmb{w}$ for a data point $\\textbf{\\em x}$ is ${\\pmb w}^{T}{\\pmb x}$ . As $\\textbf{\\em x}$ does not contain any symbolic term this is the sum of linear terms multiplied by constants, i.e., the result is a 1-dimensional linear zonotope which is a linear expression of the form: ", "page_idx": 20}, {"type": "equation", "text": "$$\nc_{0}+\\sum_{i=1}^{m}c_{i}\\epsilon_{i}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "where $c_{i}\\in R$ and $\\epsilon_{i}\\,\\in\\,\\mathcal{E}$ . The minimum and maximum value of a 1-d linear zonotope can be determined efficiently as shown below: ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\left[c_{0}-\\sum_{i=1}^{m}|c_{i}|,c_{0}+\\sum_{i=1}^{m}|c_{i}|\\right]\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Uncertain Test Data In Sec. 2 we modeled uncertainty in the training data as sets of possible worlds $D^{\\odot}$ . As mentioned in that section, our techniques also supports uncertain test data, i.e., both the training and test data may be uncertain. ", "page_idx": 20}, {"type": "text", "text": "In the most general case, the training and test data may be correlated.1 We model this as a set of possible worlds $(D^{\\odot},{\\bf X}_{\\mathrm{test}}{}^{\\odot})$ where each world is a pair of a training dataset $D_{i}$ and a test dataset Xtesti: ", "page_idx": 21}, {"type": "equation", "text": "$$\n(D,\\mathbf{X}_{\\mathrm{test}})^{\\odot}=\\{(D_{1},\\mathbf{X}_{\\mathrm{test1}}),\\dots,(D_{m},\\mathbf{X}_{\\mathrm{test}m})\\}\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "If training and test data are independent, then we can specify their worlds separately ( $D^{\\odot}$ and $\\mathbf{X}_{\\mathrm{test}}{}^{\\odot})$ and assume the worlds of $(D,\\mathbf{X}_{\\mathrm{test}})^{\\odot}$ to be their cross product. Uncertainty propagation for inference then requires us to compute the set of possible predictions: ", "page_idx": 21}, {"type": "equation", "text": "$$\n\\pmb{y}^{\\odot}=\\{f(\\mathbf{X}_{\\mathrm{test}i})~|~\\exists(D_{i},\\mathbf{X}_{\\mathrm{test}i})\\in(D,\\mathbf{X}_{\\mathrm{test}})^{\\odot}:f_{i}=A(D_{i})\\}\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "For inference in the abstract domain we first have to select an appropriate abstraction function for the test data, e.g., using the same abstraction function $\\alpha$ we use for the training data. The only difference to the case discussed above is that a test data point is now also an abstract element $x^{\\sharp}$ and the prediction $w^{\\sharp}x^{\\sharp}$ is a polynomial zonotope as it contains higher order terms that are the result of multiplying linear terms. To efficiently determine the minimum and maximum we can, e.g., employ linearization to map the polynomial zonotope into a linear one and apply the solution described above for finding the minimum and maximum of a linear zonotope. ", "page_idx": 21}, {"type": "text", "text": "G Linearization and Order Reduction Techniques ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "G.1 Linearization ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "The purpose of linearization is to over-approximate an input polynomial zonotope with a linear zonotope. ", "page_idx": 21}, {"type": "text", "text": "Definition G.1 (Linearization Operator $\\mathbf{L}$ ). A linearization operator L maps a polynomial zonotope $z^{\\sharp}$ to a linear zonotope $\\ell^{\\sharp}$ . It replaces high-order polynomial terms with new error symbols, ensuring that all expressions are linear while maintaining an over-approximation: ", "page_idx": 21}, {"type": "equation", "text": "$$\n\\gamma\\left(\\mathbf{L}(z^{\\sharp})\\right)\\supseteq\\gamma\\left(z^{\\sharp}\\right).\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "During inference, computing the prediction intervals using the linear zonotope representation can be done efficiently with linear programming. However, more importantly, in our construction of abstract fixed points we use a specific order reduction technique that requires prior linearization in each gradient descent step to enforce the existence of a fixed point. For a $d$ -dimensional polynomial zonotope $z^{\\sharp}$ with a set of monomials $\\boldsymbol{S}$ : ", "page_idx": 21}, {"type": "equation", "text": "$$\nz^{\\sharp}=c+\\sum_{i=1}^{|S|}g_{i}S[i],\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "we have its linearization: ", "page_idx": 21}, {"type": "equation", "text": "$$\n{\\bf L}(z^{\\sharp})=c+\\sum_{\\begin{array}{l}{{i\\in\\sigma_{l}}}\\end{array}}{g_{i}S}[i]\\;\\;\\;+\\;\\;\\;\\quad\\quad\\sum_{\\begin{array}{l}{{i\\notin\\sigma_{l}}}\\end{array}}{g_{i}\\epsilon_{i}^{\\prime}}\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "where $\\sigma_{l}$ denotes the set of indices of all linear terms in $z^{\\sharp}$ . Here, the third part over-approximates each high-order term in $z^{\\sharp}$ by replacing it with a new error symbol. ", "page_idx": 21}, {"type": "text", "text": "G.2 Order Reduction Operators ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Order reduction operators are used to reduce the representation size of a zonotope. That is, an order reduction operator takes as input a linear zonotope $\\boldsymbol{\\ell^{\\sharp}}$ and return a linear zonotope of smaller order ", "page_idx": 21}, {"type": "text", "text": "(smaller representation size) that over-approximates $\\ell^{\\sharp}$ . For linear zonotopes this means that order reduction operators reduce the number of distinct error symbols that occur in a zonotope by merging error symbols. ", "page_idx": 22}, {"type": "text", "text": "Definition G.2 (Order Reduction Operator $\\mathbf{R}$ ). An order reduction operator $\\mathbf{R}$ takes a linear zonotope $\\ell^{\\sharp}$ as input and returns another linear zonotope of reduced order: ", "page_idx": 22}, {"type": "equation", "text": "$$\n\\gamma\\left(\\mathbf{R}(\\ell^{\\sharp})\\right)\\supseteq\\gamma\\left(\\ell^{\\sharp}\\right)\\qquad\\qquad\\qquad\\qquad\\mathrm{ORD}(\\mathbf{R}(\\ell^{\\sharp}))<\\mathrm{ORD}(\\ell^{\\sharp})\n$$", "text_format": "latex", "page_idx": 22}, {"type": "text", "text": "We now present details about two commonly adopted order reduction techniques: Interval Hull $(I H)$ and transformation-based Interval Hull (TIH) in App. G. In this section, we use the geometric representation of zonotopes (see Def. C.2). Note that for a linear zonotope, each $S[i]$ consists of a single error term $\\epsilon_{i}$ . Thus, we can write such a zonotope $\\ell^{\\sharp}$ as: ", "page_idx": 22}, {"type": "equation", "text": "$$\n\\ell^{\\sharp}=c+\\sum_{i=1}^{|S|}g_{i}\\epsilon_{i}\n$$", "text_format": "latex", "page_idx": 22}, {"type": "text", "text": "IH merges a selected subset $\\delta_{s}$ of the error symbols of a zonotope and their corresponding generator vectors. For a $d$ -dimensional zonotope $\\ell^{\\sharp}$ : ", "page_idx": 22}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/eaa90f52611a7c7132c963e675710e3c88027587c5e82868ae14d651711ecfee.jpg", "img_caption": [], "img_footnote": [], "page_idx": 22}, {"type": "text", "text": "The selected terms $\\delta_{s}$ are merged into a $d$ -dimensional box described by $d$ new error symbols $\\{\\epsilon_{1}^{\\prime},\\cdots,\\epsilon_{d}^{\\prime}\\}$ . We will drop $\\delta_{s}$ if all error symbols of the input zonotope are selected. ", "page_idx": 22}, {"type": "text", "text": "The error symbols getting merged $(\\delta_{s})$ are often determined based on some heuristic, e.g., symbols with lowest coefficients. TIH ${\\bf R}_{T I H}$ first projects the zonotope to another space using an invertible linear transformation matrix $A\\in\\mathbb{R}^{d\\times d}$ , then applies IH, and finally projects the resulting zonotope back with $A^{-1}$ . IH is a special case of TIH where $A=I$ . ", "page_idx": 22}, {"type": "equation", "text": "$$\n{\\bf R}_{T I H}(\\delta_{s},A,z^{\\sharp})=A^{-1}{\\bf R}_{I H}(A z^{\\sharp}).\n$$", "text_format": "latex", "page_idx": 22}, {"type": "text", "text": "Intuitively, the purpose of the linear transformation $\\pmb{A}$ is to project the zonotope to a space where its shape is closer to a box, to reduce the loss of precision brought by order reduction [2, 38]. One of the most widely used TIH is PCA-based order reduction, whose transformation is obtained from the PCA of the set of all generator vectors of the input zonotope [38, 51]. ", "page_idx": 22}, {"type": "text", "text": "Order Reduction for PTIME Zonotope Training With linearization, the number of error symbols in the model weights zonotope $w^{\\sharp}$ still grows exponentially with rate ${\\mathcal{O}}(p^{2})$ , leading to exponential time complexity for gradient descent. We can overcome this challenge through order reduction, which enforces the maximum number of terms in the symbolic expressions of model weights zonotopes [38]. Note that for a linear zonotope, each $S[i]$ consists of a single error term $\\epsilon_{i}$ . Thus, we can write such a zonotope $\\ell^{\\sharp}$ as: ", "page_idx": 22}, {"type": "equation", "text": "$$\n\\ell^{\\sharp}=c+\\sum_{i=1}^{|S|}g_{i}\\epsilon_{i}\n$$", "text_format": "latex", "page_idx": 22}, {"type": "text", "text": "Order reduction $\\mathbf{R}$ reduces the order (representation size) of a linear zonotope $\\ell^{\\sharp}$ . This is achieved by merging error symbols in $\\boldsymbol{S}$ , while ensuring that the result over-approximation the input zonotope, i.e., ", "page_idx": 22}, {"type": "equation", "text": "$$\n\\gamma\\left(\\mathbf{R}(\\ell^{\\sharp})\\right)\\supseteq\\gamma\\left(\\ell^{\\sharp}\\right)\n$$", "text_format": "latex", "page_idx": 22}, {"type": "text", "text": "Two commonly adopted order reduction approaches [38] are Interval Hull $(I H)$ , denoted as ${\\bf R}_{I H}$ , and Transformation-based Interval Hull (TIH), denoted as ${\\bf R}_{T I H}$ [2, 38, 64]. Specifically, IH merges a set of error symbols $\\delta_{s}\\subseteq\\{\\epsilon_{i}\\}$ and their corresponding generator vectors (here $\\delta_{k}=\\{\\epsilon_{i}\\}-\\delta_{s}\\bar{)}$ : ", "page_idx": 23}, {"type": "equation", "text": "$$\n\\mathbf{R}_{I H}(z^{\\sharp})=\\mathbf{R}_{I H}\\left(c+\\sum_{i=1}^{|S|}g_{i}S[i]\\right)=c+\\sum_{i\\in\\delta_{k}}g_{i}S[i]+d i a g\\big(\\sum_{i\\in\\delta_{s}}|g_{i}[1]|,\\cdots\\,,\\sum_{i\\in\\delta_{s}}|g_{i}[d]|\\big)\\left[\\begin{array}{l}{\\epsilon_{1}^{\\prime}}\\\\ {\\vdots}\\\\ {\\epsilon_{d}^{\\prime}}\\end{array}\\right]\n$$", "text_format": "latex", "page_idx": 23}, {"type": "text", "text": "The selected terms $\\delta_{s}$ are merged into a $d$ -dimensional box described by $d$ new error symbols $\\{\\epsilon_{1}^{\\prime},\\cdots,\\epsilon_{d}^{\\prime}\\}$ . The error symbols getting merged $(\\delta_{s})$ are often determined based on some heuristic [38], e.g., the symbols with lowest coefficients. Similar to $\\mathrm{IH}$ , TIH also merges error terms using $\\mathrm{IH}$ , but in some projected space. TIH first projects the zonotope to another space using an invertible linear transformation matrix $A\\in\\mathbb{R}^{d\\times d}$ , then conducts $\\mathrm{IH}$ , and finally projects the resulting zonotope back into the original space with $A^{-1}$ : ", "page_idx": 23}, {"type": "equation", "text": "$$\n\\mathbf{R}_{T I H}(z^{\\sharp})=A^{-1}\\mathbf{R}_{I H}(A z^{\\sharp}).\n$$", "text_format": "latex", "page_idx": 23}, {"type": "text", "text": "Intuitively, the linear transformation $A$ aims to project the zonotope to a space where its shape is closer to a box, to reduce the loss of precision brought by order reduction [2, 38]. One of the most widely used TIH is PCA-based order reduction, whose transformation is obtained from the PCA of all generator vectors [38, 51]. ", "page_idx": 23}, {"type": "text", "text": "H Efficient Abstract Gradient Descent with Order Reduction ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "As mentioned in sec. 4.1, to address the tractability issues with abstract gradient descent, we employ two key techniques: linearization and order reduction. We employ linearization at each step of gradient descent to ensure that the resulting abstract representation of model parameters remains a linear zonotope. ", "page_idx": 23}, {"type": "text", "text": "Given a linearization operator $\\mathbf{L}$ and order reduction operator $\\mathbf{R}$ , we construct an abstract gradient descent operator, $\\Phi^{\\sharp}$ : ", "page_idx": 23}, {"type": "equation", "text": "$$\n\\Phi^{\\sharp}({\\pmb w}^{\\sharp})={\\bf R}\\Big({\\pmb w}^{\\sharp}-{\\bf L}\\big(\\eta\\nabla L({\\pmb w}^{\\sharp})\\big)\\Big),\n$$", "text_format": "latex", "page_idx": 23}, {"type": "text", "text": "which ensures that the abstract representation size remains bounded while providing efficient overapproximation. This operator is an abstract transformer for the concrete gradient descent operator. ", "page_idx": 23}, {"type": "text", "text": "Proposition H.1. For any linearization L and order reduction $\\mathbf{R}$ , the abstract gradient descent $\\Phi^{\\sharp}$ is an abstract transformer for the concrete gradient descent operator $\\Phi$ . Formally, for any abstract $w^{\\sharp}$ , ", "page_idx": 23}, {"type": "equation", "text": "$$\n\\gamma\\left(\\Phi^{\\sharp}({\\pmb w}^{\\sharp})\\right)\\supseteq\\Phi(\\gamma\\left({\\pmb w}^{\\sharp}\\right)),\n$$", "text_format": "latex", "page_idx": 23}, {"type": "text", "text": "Proof. Given that abstract transformers compose (Prop. B.1), we can decompose $\\Phi$ into separate steps and construct an abstract transformer for $\\Phi$ by composing abstract transformers for the individual steps. We can inject identity functions anywhere into the computation without changing its result. Let ident represent an identify function of an appropriate type and $F^{\\sharp}$ be the abstract operator resulting from injecting identity functions as shown below, then: ", "page_idx": 23}, {"type": "equation", "text": "$$\nF^{\\sharp}({\\pmb w}^{\\sharp})=i d e n t{\\Big(}{\\pmb w}^{\\sharp}-i d e n t{\\big(}\\eta\\nabla L({\\pmb w}^{\\sharp}){\\big)}{\\Big)}={\\pmb w}^{\\sharp}-{\\big(}\\eta\\nabla L({\\pmb w}^{\\sharp}){\\big)}=\\Phi_{e x a c t}^{\\sharp}({\\pmb w}^{\\sharp})\n$$", "text_format": "latex", "page_idx": 23}, {"type": "text", "text": "Since $\\Phi_{e x a c t}^{\\sharp}$ is an abstract transformer for $\\Phi$ , so is $F^{\\sharp}$ . Now observe that both $\\mathbf{L}$ and $\\mathbf{R}$ are abstract transformers for ident as ", "page_idx": 23}, {"type": "equation", "text": "$$\n\\gamma\\left(\\mathbf{L}(\\pmb{w}^{\\sharp})\\right)\\supseteq\\gamma\\left(\\pmb{w}^{\\sharp}\\right)=i d e n t(\\gamma\\left(\\pmb{w}^{\\sharp}\\right))\n$$", "text_format": "latex", "page_idx": 23}, {"type": "text", "text": "Thus, $\\Phi^{\\sharp}$ is an abstract transformer for $\\Phi$ . ", "page_idx": 23}, {"type": "text", "text": "Note that Prop. 3.3 then implies that a fixed point $w^{\\sharp\\ast}$ for $\\Phi^{\\sharp}$ is an over-approximation of all possible model weights $\\pmb{w}^{\\odot*}$ : ", "page_idx": 23}, {"type": "equation", "text": "$$\n\\gamma\\left(w^{\\sharp}\\,^{*}\\right)\\supseteq w^{\\odot*}\n$$", "text_format": "latex", "page_idx": 23}, {"type": "text", "text": "H.1 Abstract Gradient Descent With Order Reduction And Fixed Points ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "While $\\Phi^{\\sharp}$ ensures that every step of gradient descent can be computed efficiently as we bound the order of the resulting zonotope in each step, this operator typically does not have a fixed point and even if it does, we still would have to solve an NP-hard problem [39] to detected that we have converged. The reason for the lack of a fixed point is that both linearization and order reduction results in over-approximation and the over-approximation error may grow in each iteration. Recall that we did show a real example of where this operator diverges in Sec. 4.1. ", "page_idx": 24}, {"type": "text", "text": "I An Efficient Approximate Abstract Transformer for Ridge Regression ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "In this section and the next section we present the proof of our main technical result: Thm. 4.2. Recall that Thm. 4.2 states that Alg. 1 computes abstract model parameters $w^{\\sharp\\;*}$ that are a fixed point for the abstract transformer $\\Phi^{\\sharp}$ using a closed form solution. Because $\\Phi^{\\sharp}$ was shown to be an abstract transformer for gradient decent this then implies that $w^{\\sharp\\ast}$ over-approximates all possible model weights $\\pmb{w}^{\\odot*}$ . We start by presenting additional details of the decomposition we employ to force a fixed points, formally prove that the condition on $w^{\\sharp\\ast}$ from Prop. 4.1 is a sufficient for $\\dot{\\pmb{w}}^{\\sharp\\;*}$ being a fixed point for $\\Phi^{\\sharp}$ , and then develop a closed form solution that requires solving a system of linear equations. For $\\pmb{w}_{N}^{\\sharp}$ , the parts of the abstract model weights that exclusively contains symbols that do not appear in the abstract training dataset $\\mathbf{D}^{\\sharp}$ , the equation system only has a solution if the regularization coefficient $\\lambda$ is larger then or equal to a constant $\\beta$ that depends on $\\mathbf{D}^{\\sharp}$ . Based on our experience and extensive experimental evaluation, we typically have $\\beta=0$ , i.e., the closed form solution exists for any regularization coefficient $\\lambda$ . Nonetheless, we present a technique for achieving any desired $\\beta\\geq0$ by splitting zonotopes into smaller parts with lower $\\beta$ , computing fixed points for each split individually, and merging the final result. These techniques will be presented in app. J. ", "page_idx": 24}, {"type": "text", "text": "I.1 Decomposing Fixed Point Equations For Abstract Gradient Descent ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "We now present additional details about our decomposition of the gradient from Sec. 4.1 for linear regression with $\\ell_{2}$ regularization (ridge regression). The loss function $L$ for ridge regression an $\\ell_{2}$ penalty, is given by: ", "page_idx": 24}, {"type": "equation", "text": "$$\nL(\\pmb{X},\\pmb{y},\\pmb{w})=\\frac{1}{n}(\\pmb{X}\\pmb{w}-\\pmb{y})^{T}(\\pmb{X}\\pmb{w}-\\pmb{y})+\\lambda\\cdot\\pmb{w}^{T}\\pmb{w},\n$$", "text_format": "latex", "page_idx": 24}, {"type": "text", "text": "where $\\lambda$ is the regularization coefficient (see App. A for details). ", "page_idx": 24}, {"type": "text", "text": "Recall that we observed that an abstract model weight zonotope $\\pmb{w}^{\\sharp}$ can be decomposed into parts that can be dealt with separately in the sense that we will show that a sufficient condition for achieving a fixed point $w^{\\sharp\\ast}$ is that each component has a fixed point. Given an abstract training dataset $\\mathbf{D}^{\\sharp}$ , we use $X^{\\sharp}$ and $\\pmb{y}^{\\sharp}$ to denote its feature matrix and labels. We decompose them into real (concrete) and symbolic components: ", "page_idx": 24}, {"type": "equation", "text": "$$\n\\begin{array}{c}{{{\\pmb X}^{\\sharp}={\\pmb X}_{R}+{\\pmb X}_{S}^{\\sharp}}}\\\\ {{{\\pmb y}^{\\sharp}={\\pmb y}_{R}+{\\pmb y}_{S}^{\\sharp}}}\\end{array}\n$$", "text_format": "latex", "page_idx": 24}, {"type": "text", "text": "where $\\pmb{X}_{R}\\ \\in\\ \\mathbb{R}^{n\\times d}$ and $\\pmb{y}_{R}\\ \\in\\ \\mathbb{R}^{n}$ represent the real centers of zonotopes $X^{\\sharp}$ and $\\pmb{y}^{\\sharp}$ , while ${\\pmb X}_{S}^{\\sharp}\\in\\Lambda^{n\\times d}$ and $y_{S}^{\\sharp}\\in\\Lambda^{n}$ contain the symbolic terms. ", "page_idx": 24}, {"type": "text", "text": "Similarly, we decompose the abstract model weights at iteration $i$ into real and symbolic components: ", "page_idx": 24}, {"type": "equation", "text": "$$\n\\pmb{w}^{\\sharp\\,i}=\\pmb{w}_{R}^{i}+\\pmb{w}_{S}^{\\sharp\\,i},\n$$", "text_format": "latex", "page_idx": 24}, {"type": "text", "text": "where $\\pmb{w}_{R}^{i}\\in\\mathbb{R}^{d}$ represents the real center, and $w_{S}^{\\sharp\\,i}\\in\\Lambda^{d}$ contains the symbolic terms. The symbolic terms are further decomposed into those containing data symbols $(\\boldsymbol{w_{D}^{\\sharp\\,i}})$ , i.e., symbols that are shared with $\\mathbf{D}^{\\sharp}$ , and those introduced via linearization and order reduction in linear abstract gradient descent $(\\pmb{w}_{N}^{\\sharp\\,i})$ , i.e., that do not appear in $\\mathbf{D}^{\\sharp}$ . ", "page_idx": 24}, {"type": "equation", "text": "$$\n\\pmb{w}_{S}^{\\sharp\\;i}=\\pmb{w}_{D}^{\\sharp\\;i}+\\pmb{w}_{N}^{\\sharp\\;i}.\n$$", "text_format": "latex", "page_idx": 24}, {"type": "text", "text": "Accordingly, we decompose the abstract gradient presented in Eq. (9) into several distinct components: real numbers $(\\mathcal{G}_{R})$ , linear symbolic expressions that share symbols with $\\mathbf{D}^{\\sharp}\\left(\\mathcal{G}_{L}^{D}\\right)$ , linear symbolic expressions that do not share symbols with $\\mathbf{D}^{\\sharp}\\ (\\mathcal{G}_{L}^{N})$ , and high-order symbolic expressions $(\\mathcal{G}_{H})$ . Using the loss function for ridge regression (see Eq. (5) in App. A): ", "page_idx": 25}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\Phi^{\\sharp}(w^{\\sharp})={\\mathbf R}\\Big(w^{\\sharp}-{\\mathbf L}\\big(\\eta\\nabla L(w^{\\sharp})\\big)\\Big)={\\mathbf R}\\Big(w^{\\sharp}-\\eta{\\mathbf L}\\Big(\\frac2n(X^{\\sharp^{T}}X^{\\sharp}w^{\\sharp}-X^{\\sharp^{T}}y^{\\sharp})+2\\lambda w^{\\sharp}\\Big)\\Big)}\\\\ &{\\qquad\\qquad={\\mathbf R}\\Big(w_{R}+w_{D}^{\\sharp}+w_{N}^{\\sharp}-\\eta{\\mathbf L}\\Big(\\frac2n\\Big((X_{R}+X_{S}^{\\sharp})^{T}(X_{R}+X_{S}^{\\sharp})(w_{R}+w_{D}^{\\sharp}+w_{N}^{\\sharp})}\\\\ &{\\qquad\\qquad\\qquad-(X_{R}+X_{S}^{\\sharp})^{T}(y_{R}+y_{S}^{\\sharp})\\Big)+2\\lambda(w_{R}+w_{D}^{\\sharp}+w_{N}^{\\sharp})\\Big)\\Big)}\\\\ &{\\qquad\\qquad={\\mathbf R}\\Big(w_{R}-\\eta\\cdot\\mathcal G_{R}+w_{D}^{\\sharp}-\\eta\\cdot\\mathcal G_{L}^{D}+w_{N}^{\\sharp}-\\eta\\cdot\\mathcal G_{L}^{N}-\\eta\\cdot{\\mathbf L}(\\mathcal G_{H})\\Big)}\\end{array}\n$$", "text_format": "latex", "page_idx": 25}, {"type": "text", "text": "where ", "page_idx": 25}, {"type": "equation", "text": "$$\n\\begin{array}{l}{{\\mathcal{G}_{R}=\\displaystyle\\frac{2}{n}({\\boldsymbol{X}_{R}}^{T}{\\boldsymbol{X}_{R}}{\\boldsymbol{w}_{R}}-{\\boldsymbol{X}_{R}}^{T}{\\boldsymbol{y}_{R}})+2\\lambda{\\boldsymbol{w}_{R}}}}\\\\ {{\\mathcal{G}_{L}^{D}=(2\\lambda I+\\displaystyle\\frac{2}{n}{\\boldsymbol{X}_{R}}^{T}{\\boldsymbol{X}_{R}}){\\boldsymbol{w}_{D}^{\\sharp}}+\\displaystyle\\frac{2}{n}({\\boldsymbol{X}_{R}}^{T}{\\boldsymbol{X}_{S}^{\\sharp}}+{\\boldsymbol{X}_{S}^{\\sharp}}^{T}{\\boldsymbol{X}_{R}}){\\boldsymbol{w}_{R}}-\\frac{2}{n}{\\boldsymbol{X}_{S}^{\\sharp}}{\\boldsymbol{y}_{R}}-\\frac{2}{n}{\\boldsymbol{X}_{R}}^{T}{\\boldsymbol{y}_{S}^{\\sharp}}}}\\\\ {{\\mathcal{G}_{L}^{N}=(2\\lambda I+\\displaystyle\\frac{2}{n}{\\boldsymbol{X}_{R}}^{T}{\\boldsymbol{X}_{R}}){\\boldsymbol{w}_{N}^{\\sharp}}}}\\\\ {{\\mathcal{G}_{H}=\\displaystyle\\frac{2}{n}\\Big(({\\boldsymbol{X}_{R}}^{T}{\\boldsymbol{X}_{S}^{\\sharp}}+{\\boldsymbol{X}_{S}^{\\sharp}}^{T}{\\boldsymbol{X}_{R}})({\\boldsymbol{w}_{D}^{\\sharp}}+{\\boldsymbol{w}_{N}^{\\sharp}})+{\\boldsymbol{X}_{S}^{\\sharp}}^{T}{\\boldsymbol{X}_{S}^{\\sharp}}({\\boldsymbol{w}_{R}}+{\\boldsymbol{w}_{D}^{\\sharp}}+{\\boldsymbol{w}_{N}^{\\sharp}})-{\\boldsymbol{X}_{S}^{\\sharp}}^{T}{\\boldsymbol{y}_{S}^{\\sharp}}\\Big)}}\\end{array}\n$$", "text_format": "latex", "page_idx": 25}, {"type": "text", "text": "In Eq. (10) we substitute definitions which are further expanded in Eq. (11) using new notation for rearranged parts of the gradient (Eq. (12) to (15)). Furthermore, in this step we also use the fact that linearization only affects higher order terms and $\\mathcal{G}_{H}$ is the only component of the gradient with non-linear terms. Now consider the relationship of Eq. (12) to (15) to ", "page_idx": 25}, {"type": "text", "text": "Enforcing Fixed Points With Parameterized Order Reduction. We now introduce an order reduction operator $\\mathbf{R}_{A}$ that is a specific type of TIH (see App. G) which only merges non-data symbols and is parameterized by its transformation matrix $\\pmb{A}$ , identify a sufficient condition for achieving an abstract fixed point for gradient descent with this order reduction operator, and demonstrate that the fixed point exists for any coefficient $\\lambda$ of $l_{2}$ -regularization that is larger than a data-dependent constant $\\beta$ . Furthermore, we show how such a fixed point $w^{\\sharp\\;*}$ can be computed using closed form solutions for ${\\pmb w}_{R}$ , $w_{D}^{\\sharp}$ and $\\pmb{w}_{N}^{\\sharp}$ . ", "page_idx": 25}, {"type": "text", "text": "Recall from App. G that the TIH order reduction operator ${\\bf R}_{T I H}(\\delta_{s},A)$ is parameterized by $\\delta_{s}$ (the set of error symbols to merge) and a transformation matrix $\\pmb{A}$ . Consider the input to order reduction as shown in Eq. (10).We use $\\mathcal{E}_{D}$ to denote the error symbols that this input shares with the data (that occur in $\\mathbf{D}^{\\sharp}$ ) and $\\mathcal{E}_{N}$ to denote those that only occur in the input to order reduction. Then we define $\\mathbf{R}_{A}=\\mathbf{R}_{T I H}(\\mathcal{E}_{N},A)$ , i.e., we only merge symbols that are not shared with the data to ensure that the correspondence between model weights and possible worlds is preserved by letting $\\pmb{w}^{\\sharp}$ share symbols in linear expressions with $\\mathbf{D}^{\\sharp}$ . The linear part that does not share symbols with $\\mathbf{D}^{\\sharp}$ has $\\dot{O}(p^{2}q)$ monomials (where $p=|\\,\\mathcal{E}_{D}\\,|$ and $q$ is the number of error symbols in $\\dot{\\pmb{w}}^{\\sharp}$ ). Now expanding the definition of abstract gradient descent with order reduction using $\\mathbf{R}_{A}$ as the order reduction operator (for some given transformation matrix $\\pmb{A}$ ), we get: ", "page_idx": 25}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\Phi_{(\\mathbf{L},\\mathbf{R}_{A})}^{\\sharp}(w^{\\sharp})=\\mathbf{R}_{A}(w_{R}-\\eta\\mathcal{G}_{R}+w_{D}^{\\sharp}-\\eta\\mathcal{G}_{L}^{D}+w_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H})))}&{}\\\\ {=w_{R}-\\eta\\mathcal{G}_{R}+w_{D}^{\\sharp}-\\eta\\mathcal{G}_{L}^{D}+\\mathbf{R}_{A}(w_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H})))}&{}\\\\ {=\\underbrace{w_{R}-\\eta\\mathcal{G}_{R}}_{\\Phi_{R}(w_{R})}+\\underbrace{w_{D}^{\\sharp}-\\eta\\mathcal{G}_{L}^{D}}_{\\Phi^{\\sharp}_{D}(w_{R},w_{D}^{\\sharp})}+\\underbrace{A^{-1}\\big(\\mathbf{R}_{I H}(A(w_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H}))))\\big)}_{\\Phi^{\\sharp}_{N}(w_{R},w_{D}^{\\sharp},w_{N}^{\\sharp})}}&{}\\end{array}\n$$", "text_format": "latex", "page_idx": 25}, {"type": "text", "text": "Eq. (18) shows the components of $\\Phi_{({\\bf L},{\\bf R}_{A})}^{\\sharp}(w^{\\sharp})$ and related them to the notation $\\Phi_{R}(w_{R})$ , $\\Phi^{\\sharp}{}_{D}(w_{R},w_{D}^{\\sharp})$ , and $\\Phi^{\\sharp}{}_{N}({\\pmb w}_{R},{\\pmb w}_{D}^{\\sharp},{\\pmb w}_{N}^{\\sharp})$ we introduced in Eq. (2). Specifically, $\\Phi_{R}({\\bf{w}}_{R})\\;=\\;$ $(w_{R}-\\eta\\mathcal{G}_{R})$ does not contain any error symbols and, thus, corresponds to the real number part of the updated model weight. Similarly, $\\Phi^{\\sharp}{}_{D}(w_{R},w_{D}^{\\sharp})\\;=\\;(w_{D}^{\\sharp}\\,-\\,\\eta\\mathcal{G}_{L}^{D})$ only contains linear symbolic expression with symbols that are from $\\mathbf{D}^{\\sharp}$ . The remaining part, $\\Phi^{\\sharp}{}_{N}({\\pmb w}_{R},{\\pmb w}_{D}^{\\sharp},{\\pmb w}_{N}^{\\sharp})=$ $\\begin{array}{r l}{\\lefteqn{A\\bigl(\\mathbf{R}_{I H}\\bigl(A^{-1}(w_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H})))\\bigr)\\bigr)}\\qquad}&{{}}\\end{array}$ does not share symbols with $\\mathbf{D}^{\\sharp}$ , as it consists of new symbols generated from order reduction. ", "page_idx": 25}, {"type": "text", "text": "", "page_idx": 26}, {"type": "text", "text": "I.2 Constructing Fixed Points For Abstract Gradient Descent ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Having defined \u03a6(\u266fL,RA) which was denoted by \u03a6(\u266fL ,R) in app. H, we are now ready to state the first part of our main technical result: under some mild assumptions on $\\lambda$ being larger than some datadependent constant $\\beta$ , $\\Phi_{(\\mathbf{L},\\mathbf{R}_{A})}^{\\sharp}$ has a fixed point and, importantly, this fixed point can be computed efficiently. In practice, we often have $\\beta=0$ . However, if this is not the case, we demonstrate later that at the cost of reduced computational efficiency we can reduce $\\beta$ by splitting $\\mathbf{D}^{\\sharp}$ into several zonotopes and solving the problem independently for each zonotope as we will details in App. J. ", "page_idx": 26}, {"type": "text", "text": "Theorem I.1 (Existence of Abstract Fixed Points). Consider an abstract training dataset $\\mathbf{D}^{\\sharp}$ . There exists a constant $\\beta$ specific to $\\mathbf{D}^{\\sharp}$ such that $\\Phi_{(\\mathbf{L},\\mathbf{R}_{A})}^{\\sharp}$ has a fixed point for any $\\lambda\\geq\\beta$ . ", "page_idx": 26}, {"type": "text", "text": "In the remainder of this section, we prove Thm. I.1 by demonstrating how to construct such a fixed point efficiently. We start by identifying a sufficient condition for $w^{\\sharp\\;*}$ to be a fixed point, then demonstrate that the problem of finding a $w^{\\sharp\\ast}$ that fulfills this sufficient condition can be decomposed based on our decomposition $\\pmb{w}^{\\sharp\\,*}=\\pmb{w}_{R}^{*}+\\pmb{w}_{D}^{\\sharp\\,*}+\\pmb{w}_{N}^{\\sharp\\,*}$ presented earlier. Specifically, certain components are independent of other components suggesting an evaluation order where we find a fixed point for one component treating the previously computed fixed points for other components as constants. Then we proceed to prove closed form solutions for $\\pmb{w}_{R}^{*}$ and for $w_{D}^{\\sharp\\;*}$ given $\\pmb{w}_{R}^{*}$ . Finally, given $\\pmb{w}_{R}^{*}$ and $w_{D}^{\\sharp\\;*}$ we construct a system of equations whose solution gives a fixed point for $w_{N}^{\\sharp\\;*}$ and demonstrate that this system of equations has a closed form solution for any $\\lambda\\geq\\beta$ ", "page_idx": 26}, {"type": "text", "text": "A Sufficient Condition for Abstract Fixed Points. Recall from Def. 3.2 that the fixed point $w^{\\sharp\\;*}$ must satisfy $\\gamma\\left(w^{\\sharp\\,*},{\\bf D}^{\\sharp}\\right)\\supseteq\\gamma\\left(\\Phi_{({\\bf L},{\\bf R}_{A})}^{\\sharp}(w^{\\sharp\\,*}),{\\bf D}^{\\sharp}\\right)$ . We now present a sufficient condition for this to hold. Intuitively this condition requires the invariance of different components of $\\Phi_{({\\bf L},{\\bf R}_{A})}^{\\sharp}(w^{\\sharp})$ when doing joint concretization with $\\mathbf{D}^{\\sharp}$ . ", "page_idx": 26}, {"type": "text", "text": "Proposition I.2. If an abstract model weight $\\pmb{w}^{\\sharp\\,*}=\\pmb{w}_{R}^{*}+\\pmb{w}_{D}^{\\sharp\\,*}+\\pmb{w}_{N}^{\\sharp\\,*}$ satisfies the following three conditions, then it is an abstract fixed point of the abstrRact graDdient deNscent operator $\\Phi_{(\\mathbf{L},\\mathbf{R}_{A})}^{\\sharp}$ : ", "page_idx": 26}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\pmb{w}_{R}^{*}=\\pmb{w}_{R}^{*}-\\eta\\mathcal{G}_{R}}\\\\ &{\\pmb{w}_{D}^{\\sharp\\,*}=\\pmb{w}_{D}^{\\sharp\\,*}-\\eta\\mathcal{G}_{L}^{D}}\\\\ &{\\pmb{w}_{N}^{\\sharp\\,*}\\simeq\\pmb{\\mathrm{\\mathbb{R}}}\\pmb{\\mathrm{A}}\\left(\\pmb{w}_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H}))\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 26}, {"type": "text", "text": "Proof. Consider the definition of an abstract fixed point $w^{\\sharp\\;*}$ Def. 3.2 applied to $\\Phi_{({\\bf L},{\\bf R}_{A})}^{\\sharp}\\ )$ ", "page_idx": 26}, {"type": "equation", "text": "$$\n\\gamma\\left(w^{\\sharp\\,*},{\\bf D}^{\\sharp}\\right)\\supseteq\\gamma\\left(\\Phi_{({\\bf L},{\\bf R}_{A})}^{\\sharp}(w^{\\sharp\\,*}),{\\bf D}^{\\sharp}\\right)\n$$", "text_format": "latex", "page_idx": 26}, {"type": "text", "text": "This can certainly be achieved if ", "page_idx": 26}, {"type": "equation", "text": "$$\n\\begin{array}{r}{{\\pmb w}^{\\sharp\\;*},{\\bf D}^{\\sharp}\\simeq_{\\sharp}\\Phi_{({\\bf L},{\\bf R}_{A})}^{\\sharp}({\\pmb w}^{\\sharp\\;*}),{\\bf D}^{\\sharp}}\\end{array}\n$$", "text_format": "latex", "page_idx": 26}, {"type": "text", "text": "This requires equal joint concretization of the fixed point the pairs $(\\boldsymbol{w}^{\\sharp*},\\mathbf{D}^{\\sharp})$ and $(\\Phi_{(\\mathbf{L},\\mathbf{R}_{A})}^{\\sharp}(w^{\\sharp\\ast}),\\mathbf{D}^{\\sharp})$ t.h  Tcoe rutnaidne rdstaatansde ttsh eiend t fhoer  jjooiinntt  ccoonnccrreettiizzaattiioonn.  hIefr ew neo twe otuhladt  coenrltya icno nmsoiddeerl $\\pmb{w}$ $_{D}$   \nequivalence of the abstract model weight, two zonotopes $\\pmb{w}^{\\sharp}$ and $w^{\\sharp^{\\prime}}$ may be equivalent $\\pmb{w}^{\\sharp}\\simeq_{\\sharp}\\pmb{w}^{\\sharp^{\\prime}}$ , but pair a particular model weight $\\pmb{w}\\in\\gamma\\left(\\pmb{w}^{\\sharp}\\right)=\\gamma\\left(\\pmb{w}^{\\sharp^{\\prime}}\\right)$ with different datasets $D_{1}\\in\\gamma\\left(\\mathbf{D}^{\\sharp}\\right)$ and $D_{2}\\in\\gamma\\left(\\mathbf{D}^{\\sharp}\\right)$ . Thus, it is possible that ${\\pmb w}^{\\sharp}\\simeq_{\\sharp}\\Phi_{({\\bf L},{\\bf R}_{A})}^{\\sharp}({\\pmb w}^{\\sharp})$ holds but $\\gamma\\left(w^{\\sharp}\\right)=\\gamma\\left(w^{\\sharp^{\\prime}}\\right)$ does not contain all model weights from $\\pmb{w}^{\\odot*}$ . ", "page_idx": 26}, {"type": "text", "text": "First observe that requiring equality of abstract elements is a stricter condition than equivalence wrt. $\\simeq\\sharp$ as ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\pmb{w}^{\\sharp}{}_{1}=\\pmb{w}^{\\sharp}{}_{2}\\Rightarrow\\pmb{w}^{\\sharp}{}_{1}\\simeq_{\\sharp}\\pmb{w}^{\\sharp}{}_{2}\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "Also note that $w_{D}^{\\sharp}$ is the only component of $w^{\\sharp\\;*}$ that contains symbols. Thus, requiring equality in Eq. (20) is sufficient for ensuring equivalent join concretization with $\\mathbf{D}^{\\sharp}$ as long as Eq. (19) and Eq. (21) also hold. Furthermore, Eq. (19) and Eq. (20) imply: ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\mathcal{G}_{R}=0~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "Expanding $\\pmb{w}^{\\sharp\\,*}=\\pmb{w}_{R}^{*}+\\pmb{w}_{D}^{\\sharp\\,*}+\\pmb{w}_{N}^{\\sharp\\,*}$ and substituting into Eq. (18) we get ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\Phi_{(\\mathbf{L},\\mathbf{R}_{A})}^{\\sharp}(w^{\\sharp\\,*})=w_{R}^{*}-\\eta\\mathcal{G}_{R}+w_{D}^{\\sharp\\,*}-\\eta\\mathcal{G}_{L}^{D}+\\mathbf{R}_{A}\\big(w_{N}^{\\sharp\\,*}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H}))\\big)}\\\\ &{\\qquad\\qquad\\qquad=w_{R}^{*}+w_{D}^{\\sharp\\,*}+\\mathbf{R}_{A}\\big(w_{N}^{\\sharp\\,*}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H}))\\big)}\\end{array}\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "Thus, using Eq. (21) and the fact that $\\pmb{w}_{N}^{\\sharp}$ does not share any symbols with $\\mathbf{D}^{\\sharp}$ , we get the desired result: ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\begin{array}{r}{)\\wedge(20)\\wedge w_{N}^{\\sharp*}\\simeq_{\\sharp}\\mathbf{R}_{A}\\left(w_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H}))\\right)\\Rightarrow(w^{\\sharp*},\\mathbf{D}^{\\sharp})\\simeq_{\\sharp}(\\Phi_{(\\mathbf{L},\\mathbf{R}_{A})}^{\\sharp}(w^{\\sharp*}),\\mathbf{D}^{\\sharp})}\\end{array}\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "Independence of Fixed Point Components. Recall that we observed that some components of the gradient depend only on some components of $w^{\\sharp\\;*}$ . Specifically, $g_{R}$ only depends on $\\pmb{w}_{R}^{*}$ and $\\mathcal{G}_{L}^{D}$ only depends on $\\pmb{w}_{R}^{*}$ and $w_{D}^{\\sharp\\;*}$ . This implies that we can find a fixed point by first computing $\\pmb{w}_{R}^{*}$ , then finding $w_{D}^{\\sharp\\;*}$ treating $\\pmb{w}_{R}^{*}$ as a constant, and finally determine $w_{N}^{\\sharp\\;*}$ treating both $\\pmb{w}_{R}^{*}$ and $w_{D}^{\\sharp\\;*}$ as a constant. ", "page_idx": 27}, {"type": "text", "text": "Lemma I.3 (Independence of Fixed Point Components). The following independence relationships hold: ", "page_idx": 27}, {"type": "text", "text": "Proof. The definition of $\\mathcal{G}_{R}$ is shown in Eq. (12). The only component of $w^{\\sharp\\ast}$ that appears in the definition of $\\mathcal{G}_{R}$ is $\\pmb{w}_{R}^{*}$ . Thus, the equations defining $\\pmb{w}_{R}^{*}$ only depend on $\\pmb{w}_{R}^{*}$ and are independent of $w_{D}^{\\sharp\\;*}$ and $w_{N}^{\\sharp\\;*}$ . Using a similar argument we can show that $\\mathcal{G}_{L}^{D}$ does not depend on $w_{N}^{\\sharp\\;*}$ . \u53e3 ", "page_idx": 27}, {"type": "text", "text": "Closed Form Solutions for Real And Linear Data Components of Abstract Model Weights. Before explaining how to determine w\u266fN\u2217 , utilizing the lemma above we derive closed form solutions for $\\pmb{w}_{R}^{*}$ and $w_{D}^{\\sharp\\;*}$ . ", "page_idx": 27}, {"type": "text", "text": "Lemma I.4 (Closed Form Solutions for $\\pmb{w}_{R}^{*}$ and $w_{D}^{\\sharp\\;*}$ ). Given $\\mathbf{D}^{\\sharp}$ , $\\pmb{w}_{R}^{*}$ as defined below fulfills Eq. (19) ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\pmb{w}_{R}^{*}=(\\pmb{X}_{R}^{\\ T}\\pmb{X}_{R}+\\lambda n\\boldsymbol{I})^{-1}\\pmb{X}_{R}^{\\ T}\\pmb{y}_{R}\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "Given $\\mathbf{D}^{\\sharp}$ and $\\pmb{w}_{R}^{*}$ , $w_{D}^{\\sharp\\;*}$ as defined below fulfills Eq. (20). ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\pmb{w}_{D}^{\\sharp\\ast}=(\\pmb{X}_{R}^{\\mathrm{~\\tiny~T~}}\\pmb{X}_{R}+\\lambda\\pmb{n}{I})^{-1}\\Big(\\pmb{X}_{S}^{\\sharp}\\pmb{y}_{R}+\\pmb{X}_{R}^{\\mathrm{~\\tiny~T~}}\\pmb{y}_{S}^{\\sharp}-(\\pmb{X}_{R}^{\\mathrm{~\\tiny~T~}}\\pmb{X}_{S}^{\\sharp}+\\pmb{X}_{S}^{\\sharp\\mathrm{~\\tiny~T~}}\\pmb{X}_{R})\\pmb{w}_{R}^{\\ast}\\Big)\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "Proof. Fixed Point for $\\underline{w}_{R}^{*}$ . Substituting the definition of $g_{R}$ from Eq. (12) into Eq. (21): ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad w_{R}^{*}=w_{R}^{*}-\\eta\\cdot\\left(\\frac{2}{n}({X_{R}}^{T}{X_{R}}w_{R}^{*}-{X_{R}}^{T}{y_{R}})+2\\lambda w_{R}^{*}\\right)}\\\\ &{\\Leftrightarrow\\frac{2\\eta}{n}\\cdot\\left({{X_{R}}^{T}}{X_{R}}w_{R}^{*}-{X_{R}}^{T}{y_{R}}+\\lambda n w_{R}^{*}\\right)=0}\\\\ &{\\Leftrightarrow{X_{R}}^{T}{X_{R}}w_{R}^{*}-{X_{R}}^{T}{y_{R}}+\\lambda n w_{R}^{*}=0}\\\\ &{\\Leftrightarrow({X_{R}}^{T}{X_{R}}+\\lambda n I)w_{R}^{*}={X_{R}}^{T}{y_{R}}}\\\\ &{\\Leftrightarrow w_{R}^{*}=({X_{R}}^{T}{X_{R}}+\\lambda n I)^{-1}{X_{R}}^{T}{y_{R}}}\\end{array}\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "The last step relies on the fact that $\\mathbf{{X}}_{R}{}^{T}\\mathbf{{X}}_{R}+\\lambda n I$ is invertible which is guaranteed for $\\lambda>$ 0 [26]. Note that, as expected since the fixed point equation for $\\pmb{w}_{R}^{*}$ does not contain any symbolic expressions, the closed form for $\\pmb{w}_{R}^{*}$ is equal to the well-known closed form for ridge regression. Fixed Point for $\\underline{w_{D}^{\\sharp\\;*}}$ . Note that given the independence of $\\pmb{w}_{R}^{*}$ from $w_{D}^{\\sharp\\;*}$ , we can assume that $\\pmb{w}_{R}^{*}$ has been determined using the closed form solution shown above. Thus, we can treat $\\pmb{w}_{R}^{*}$ as a constant in the following derivation. We start by substituting the definition or Eq. (13) into Eq. (20). ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{w_{D}^{\\sharp*}=w_{D}^{\\sharp*}-\\eta\\bigg((2\\lambda I+\\frac{2}{n}X_{R}{^T}X_{R})w_{D}^{\\sharp*}+\\frac{2}{n}(X_{R}{^T}X_{S}^{\\sharp}+X_{S}^{\\sharp}{^T}X_{R})w_{R}^{*}}\\\\ &{\\qquad\\qquad\\qquad-\\frac{2}{n}(X_{S}^{\\sharp}y_{R}+X_{R}{^T}y_{S}^{\\sharp})\\bigg)}\\\\ &{\\Leftrightarrow0=\\frac{2\\eta}{n}\\Big((X_{R}{^T}X_{R}+\\lambda n I)w_{D}^{\\sharp*}+(X_{R}{^T}X_{S}^{\\sharp}+X_{S}^{\\sharp}{^T}X_{R})w_{R}^{*}-X_{S}^{\\sharp}y_{R}-X_{R}{^T}y_{S}^{\\sharp}\\Big)}\\\\ &{\\Leftrightarrow0=(\\lambda n I+X_{R}{^T}X_{R})w_{D}^{\\sharp*}+(X_{R}{^T}X_{S}^{\\sharp}+X_{S}^{\\sharp}{^T}X_{R})w_{R}^{*}-X_{S}^{\\sharp}y_{R}-X_{R}{^T}y_{S}^{\\sharp}}\\\\ &{\\Leftrightarrow(\\lambda n I+X_{R}{^T}X_{R})w_{D}^{\\sharp*}=-\\Big((X_{R}{^T}X_{S}^{\\sharp}+X_{S}^{\\sharp}{^T}X_{R})w_{R}^{*}-X_{S}^{\\sharp}y_{R}-X_{R}{^T}y_{S}^{\\sharp}\\Big)}\\\\ &{\\Leftrightarrow w_{D}^{\\sharp*}=(X_{R}{^T}X_{R}+\\lambda n I)^{-1}\\Big(X_{S}^{\\sharp}y_{R}+X_{R}{^T}y_{S}^{\\sharp}-(X_{R}{^T}X_{S}^{\\sharp}+X_{S}^{\\sharp}X_{R})w_{R}^{*}\\Big)\\qquad(25)}\\end{array}\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Note that matrix inversion is applied to $({\\boldsymbol{X}}_{R}{}^{T}{\\boldsymbol{X}}_{R}+\\lambda n{\\boldsymbol{I}})$ which does not contain any symbolic terms and as discussed above this matrix is guaranteed to be invertible. \u53e3 ", "page_idx": 28}, {"type": "text", "text": "Analysis of the Fixed Point Equations for $w_{N}^{\\sharp\\;*}$ . Using the closed form solutions established in Lem. I.4, we can compute $\\pmb{w}_{R}^{*}$ and $w_{D}^{\\sharp\\;*}$ fulfilling Eq. (19) and Eq. (20). In the remainder of this subsection we show how to compute a solution $w_{N}^{\\sharp\\;*}$ to Eq. (21) for a given $\\lambda\\geq\\beta$ (regularization coefficient), i.e., we prove Thm. I.1 that postulated the existence of such fixed points $w^{\\sharp\\;*}$ constructively. ", "page_idx": 28}, {"type": "text", "text": "To find a fixed point $w_{N}^{\\sharp\\;*}$ , we are searching for an abstract model weight that fulfills Eq. (21): ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\pmb{w}_{N}^{\\sharp\\;*}\\simeq_{\\sharp}\\mathbf{R}_{A}\\left(\\pmb{w}_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H}))\\right)\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "This implies that $w_{N}^{\\sharp\\;*}$ needs to be equivalent to the result of $\\mathbf{R}_{A}$ on some input zonotope $w_{N}^{\\sharp}-$ $\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H})$ . Recall the definition of $\\mathbf{R}_{A}$ for a linear input zonotope $\\ell^{\\sharp}$ : ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\mathbf{R}_{A}(\\ell^{\\sharp})=A^{-1}\\mathbf{R}_{I H}(A\\ell^{\\sharp})\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Note that $\\mathbf{R}_{A}$ applies ${\\bf R}_{I H}$ to all error symbols in its input. Thus, ${\\bf R}_{I H}(\\cdot)$ is a $d_{\\cdot}$ -dimensional box in the projected space into which the input $\\ell^{\\sharp}$ is mapped into by $\\pmb{A}$ . Furthermore, as $\\pmb{w}_{N}^{\\sharp}{-\\eta}(\\mathcal{G}_{L}^{N}{+}\\mathbf{L}(\\mathcal{G}_{H})$ does only contain symbolic terms, the interval hull (the box computed by $\\mathbf{R}_{I H}$ ) is centered at 0. ", "page_idx": 28}, {"type": "text", "text": "Lemma I.5. Any solution $\\pmb{w}_{N}^{\\sharp}$ of Eq. (26) is equivalent to the image of a box $b^{\\sharp}$ centered at 0 produced by $A^{-1}$ , i.e., ", "page_idx": 28}, {"type": "equation", "text": "$$\nw_{N}^{\\sharp}\\simeq_{\\sharp}A^{-1}b^{\\sharp}\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Proof. IH does not change the center of a zonotope and $\\pmb{A}$ is a linear map. Now observe that all terms in Eq. (14) and (15) are symbolic (contain error symbols). Thus, the RHS of Eq. (26) that is the input to order reduction is a zonotope with center 0. \u53e3 ", "page_idx": 28}, {"type": "text", "text": "A linear zonotope that is a box in $d_{\\cdot}$ -dimensional space with center 0 is, up to equivalence, uniquely determined by the diameter of the box in each dimension. That is, if we use $k_{i}\\geq0$ to denote the diameter of the box in the $i^{t h}$ dimension and $\\pmb{k}\\in\\mathbb{R}^{d}$ to denote the vector of these elements, then we can write any such zonotope $b^{\\sharp}$ as: ", "page_idx": 28}, {"type": "equation", "text": "$$\nb^{\\sharp}=\\left[\\begin{array}{c}{\\!\\!\\left[k_{1}\\epsilon_{1}\\right]\\!\\!}\\\\ {\\vdots\\!\\!}\\\\ {\\!\\!\\left[k_{d}\\epsilon_{d}\\right]\\!\\!}\\end{array}\\right]=\\left[\\!\\!\\begin{array}{c c c c}{\\!\\!\\left[k_{1}}&{\\cdots}&{\\!\\!\\left[\\epsilon_{1}\\right]\\!\\!}\\\\ {\\vdots\\!\\!}&{\\!\\!\\ddots}&{\\!\\!\\vdots\\!\\!}\\\\ {0}&{\\cdots}&{\\!\\!\\!k_{d}\\!\\!}\\end{array}\\right]\\!\\!\\!}\\end{array}\\!\\!\\left[\\!\\!\\begin{array}{c}{\\!\\!\\left[\\epsilon_{1}\\right]\\!\\!}\\\\ {\\vdots\\!\\!}\\\\ {\\!\\!\\epsilon_{d}\\!\\!}\\end{array}\\!\\!\\right]=d i a g\\{\\pmb{k}\\}\\left[\\!\\!\\begin{array}{c}{\\!\\!\\left[\\epsilon_{1}\\right]\\!\\!}\\\\ {\\vdots\\!\\!}\\\\ {\\!\\!\\epsilon_{d}\\!\\!}\\end{array}\\!\\!\\right]\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Combining Eq. (26) with Eq. (27), we know that $\\pmb{w}_{N}^{\\sharp}$ is a zonotope that is equivalent to the image of $A^{-1}$ on a box $b^{\\sharp}$ parameterized by $\\pmb{k}$ . We will only consider solutions of this form:2 ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\pmb{w}_{N}^{\\sharp\\,*}=\\pmb{A}^{-1}d i a g\\{\\pmb{k}\\}\\left[\\stackrel{\\epsilon_{1}}{\\underline{{\\vdots}}}\\right]=\\sum_{i=1}^{d}k_{i}\\pmb{a}_{i}\\epsilon_{i}\n$$", "text_format": "latex", "page_idx": 29}, {"type": "text", "text": "where $\\pmb{a}_{1},\\cdots,\\pmb{a}_{d}$ are the column vectors of $A^{-1}$ . As the naming of error symbols is irrelevant, finding a solution to Eq. (26) now amounts to finding a vector $\\pmb{k}$ as the error symbols are now treated as fixed. ", "page_idx": 29}, {"type": "text", "text": "Now we can substitute the formula for $w_{N}^{\\sharp\\;*}$ from Eq. (28) into the RHS of Eq. (26) as shown below. Recall from app. G.2 that IH merges different error symbols by adding up the absolute values of their coefficients. For the $i^{t h}$ dimension, each $k_{j}$ will appear with a certain coefficient. For some terms, the symbolic expression for the $i^{t h}$ dimension may contain error symbols that do not have any $k_{l}$ in their coefficients. Thus, without considering for now the precise values for each coefficient we know that the box produced by $\\mathrm{IH}$ in the RHS is of the form shown below where $C\\in\\mathbb{R}^{d\\times d}$ is a matrix with non-negative entries $c_{i,j}\\geq0$ (at position $(i,j),$ ), and $c_{0}\\in\\mathbb{R}^{d}$ is a vector with non-negative elements $c_{i,0}\\geq0$ (at dimension $i$ ). Intuitively, $c_{i,j}$ is the coefficient of $k_{j}$ in the $i^{t h}$ dimension and $c_{i,0}$ is the sum of the coefficients of error symbols that do not have any $k_{j}$ in their coefficients (e.g., the fresh symbols introduced by linearization). Note since IH does calculate coefficients of the error symbols in the output as a sum of absolute values, we know that all entries of $_{C}$ and $c_{\\mathrm{0}}$ are positive. Furthermore, recall that we assumed that $k_{j}\\geq0$ . ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{R}_{A}(w_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H})))=A^{-1}\\mathbf{R}_{I H}(A(w_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H}))))}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\left[(c_{1,0}+\\sum_{j=1}^{d}c_{1,j}k_{j})\\epsilon_{1}^{\\prime}\\right]}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\vdots}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\left[(c_{d,0}+\\sum_{j=1}^{d}c_{d,j}k_{j})\\epsilon_{d}^{\\prime}\\right]}\\end{array}\n$$", "text_format": "latex", "page_idx": 29}, {"type": "text", "text": "Substituting the LHS and RHS of Eq. (21) with Eq. (28) and (29), we get: ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad A^{-1}d i a g\\{k\\}\\left[\\Biggl\\{\\!\\!\\begin{array}{l}{\\epsilon_{1}}\\\\ {\\vdots}\\\\ {\\epsilon_{d}}\\end{array}\\!\\!\\right]\\simeq\\xi^{-1}d i a g\\{c_{0}+C k\\}\\left[\\Biggl\\{\\!\\!\\begin{array}{l}{\\epsilon_{1}^{\\prime}}\\\\ {\\vdots}\\\\ {\\epsilon_{d}^{\\prime}}\\end{array}\\!\\!\\right]}\\\\ &{\\quad\\Leftrightarrow d i a g\\{k\\}\\left[\\Biggl\\{\\!\\!\\begin{array}{l}{\\epsilon_{1}}\\\\ {\\vdots}\\\\ {\\epsilon_{d}}\\end{array}\\!\\!\\right]\\simeq z\\}\\;d i a g\\{c_{0}+C k\\}\\left[\\Biggl\\{\\!\\!\\begin{array}{l}{\\epsilon_{1}^{\\prime}}\\\\ {\\vdots}\\\\ {\\epsilon_{d}^{\\prime}}\\end{array}\\!\\!\\right]\\right.}\\\\ &{\\quad\\Leftrightarrow k=c_{0}+C k}\\\\ &{\\quad\\Leftrightarrow(I-C)k=c_{0}\\quad s.t.\\ k\\approx0}\\\\ &{\\quad\\Leftrightarrow(1-c_{i,i})k_{i}-\\displaystyle\\sum_{j=1}^{d}(c_{i,j}k_{j})=c_{i,0}\\quad s.t.\\ k_{i}\\geq0\\forall i\\in[1,d]}\\end{array}\n$$", "text_format": "latex", "page_idx": 29}, {"type": "text", "text": "Intuitively, the equivalence of boxes from Eq. (30) is equivalent to the equality of their diameters which yields Eq. (31). Therefore, any $\\pmb{k}\\in\\mathbb{R}^{d}$ satisfying Eq. (31) gives us a fixed point $w_{N}^{\\sharp\\;*}$ . In Eq. (32) we make explicit our assumption that $k_{i}\\geq0$ and finally in Eq. (33) we write Eq. (32) as a system of linear equations. ", "page_idx": 29}, {"type": "text", "text": "Existence of a Closed Form Solution for the Fixed Point Equations for $w_{N}^{\\sharp\\;*}$ What remains to be shown to prove Thm. I.1 is that Eq. (33) is guaranteed to have a solution. For that we will investigate the structure of $_{C}$ and $c_{\\mathrm{0}}$ . Recall that the matrix $_{C}$ and $c_{\\mathrm{0}}$ are obtained from IH order reduction on input (see Eq. (29)) ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\pmb{A}(\\pmb{w}_{N}^{\\sharp}-\\eta(\\mathcal{G}_{L}^{N}+\\mathbf{L}(\\mathcal{G}_{H}))).}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "$w_{N}^{\\sharp\\;*}$ and $\\mathcal{G}_{L}^{N}$ share the same set of symbols, while they do not share any error symbols with $\\mathbf{L}({\\mathcal{G}}_{H})$ , as linearization always generates new error symbols. This implies that the terms of $A(w_{N}^{\\sharp}-\\eta\\mathcal{G}_{L}^{N})$ and $-\\eta A{\\bf L}(\\mathcal{G}_{H})$ will not cancel out. In other words, they contribute separately to the diameter $\\pmb{k}$ of the merged box produced by IH. Therefore, we will look into their contributions separately. ", "page_idx": 30}, {"type": "text", "text": "For $A(w_{N}^{\\sharp}-\\eta\\mathcal{G}_{L}^{N})$ , we substitute the definitions of $\\mathcal{G}_{L}^{N}$ and $w_{N}^{\\sharp\\;*}$ to get: ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\pmb{A}(w_{N}^{+}-\\eta\\mathcal{G}_{L}^{N})=\\pmb{A}\\left((1-2\\eta\\lambda)I-\\frac{2\\eta}{n}X_{R}^{r}X_{R}\\right)w_{N}^{\\pm}}&{\\qquad\\qquad\\qquad(34)}\\\\ {=\\pmb{A}\\left((1-2\\eta\\lambda)I-\\frac{2\\eta}{n}X_{R}^{r}X_{R}\\right)A^{-1}\\left[\\begin{array}{c}{k_{1}\\epsilon_{1}}\\\\ {\\vdots}\\\\ {k_{d}\\epsilon_{d}}\\end{array}\\right]}&{\\qquad\\mathrm{(expand~}w_{N}^{\\pm})}\\\\ {=\\pmb{A}\\left(\\pmb{A}(1-2\\eta\\lambda)\\pmb{A}^{-1}-\\frac{2\\eta}{n}\\pmb{A}X_{R}^{r}X_{R}\\pmb{A}^{-1}\\right)A^{-1}\\left[\\begin{array}{c}{k_{1}\\epsilon_{1}}\\\\ {\\vdots}\\\\ {k_{d}\\epsilon_{d}}\\end{array}\\right]}&{}\\\\ {(\\pmb{I}=\\pmb{A}A^{-1}\\pmb{\\mathscr{u}})\\pmb{X}_{R}^{T}X_{R}\\pmb{A}^{-1}}&{\\qquad\\qquad\\qquad\\qquad}\\\\ {=\\left(\\pmb{A}(1-2\\eta\\lambda)\\pmb{A}^{-1}-\\frac{2\\eta}{n}\\pmb{A}X_{R}^{r}X_{R}\\pmb{A}^{-1}\\right)\\left[\\begin{array}{c}{k_{1}\\epsilon_{1}}\\\\ {\\vdots}\\\\ {k_{d}\\epsilon_{d}}\\end{array}\\right]}&{\\qquad\\qquad\\qquad(35)}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "This contributes $\\begin{array}{r}{\\left(|1-2\\eta\\lambda-\\frac{2\\eta}{n}q_{i,i}|k_{i}+\\frac{2\\eta}{n}\\sum_{j=1\\atop j\\neq i}^{d}|q_{i,j}|k_{j}\\right)}\\end{array}$ to the diameter of the merged box along dimension $i$ , where $q_{i,j}$ is the element in $A X_{R}{}^{T}X_{R}A^{-1}$ at position $(i,j)$ . By choosing a small learning rate $\\eta$ to let $\\begin{array}{r}{1\\textrm{--}2\\eta\\lambda\\textrm{--}\\frac{2\\eta}{n}q_{i,i}\\textrm{\\geq0}}\\end{array}$ the contribution is equal to $\\begin{array}{r}{\\Big((1-2\\eta\\lambda-\\frac{2\\eta}{n}q_{i,i})k_{i}+}\\end{array}$ $\\begin{array}{r}{\\frac{2\\eta}{n}\\sum_{j=1}^{d}|q_{i,j}|k_{j}\\rangle}\\end{array}$ . From Eq. (34) it is obvious that this component has a shared term $w_{N}^{\\sharp\\;*}$ containing $\\pmb{k}$ and as $w_{N}^{\\sharp\\;*}$ is centered at 0, we know that this component has only symbolic terms. This in turn implies that this component only contributes to the coefficient matrix $_{C}$ and does not contribute to the constant part $c_{\\mathrm{0}}$ of the system of linear equations. ", "page_idx": 30}, {"type": "text", "text": "Now consider the other component ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r l r}&{-\\eta A\\mathbf{L}(\\mathcal{G}_{H})}\\\\ &{=-\\eta A\\mathbf{L}\\left(\\frac{2}{n}\\Big((X_{R}^{T}X_{S}^{\\sharp}+X_{S}^{\\sharp}^{T}X_{R})(w_{D}^{\\sharp}+w_{N}^{\\sharp})+X_{S}^{\\sharp}^{T}X_{S}^{\\sharp}(w_{R}+w_{D}^{\\sharp}+w_{N}^{\\sharp})-X_{S}^{\\sharp}{\\mathcal{G}}_{S}^{\\sharp}\\Big)\\right)}\\\\ &{=-\\eta A\\mathbf{L}\\left(\\frac{2}{n}\\Big((\\underline{{X_{R}}}^{T}X_{S}^{\\sharp}+X_{S}^{\\sharp}^{T}X_{R}+X_{S}^{\\sharp}^{T}X_{S}^{\\sharp})w_{N}^{\\sharp}\\right.}\\\\ &{}&{\\qquad\\qquad\\qquad\\qquad\\qquad\\left.\\mathrm{conthues~to~}\\mathcal{C}}\\\\ &{}&{\\qquad\\qquad\\qquad+\\underbrace{\\left(X_{R}^{T}X_{S}^{\\sharp}+X_{S}^{\\sharp}^{T}X_{R}\\right)w_{D}^{\\sharp}}_{\\mathrm{conthues~to~}\\mathcal{C}}+X_{S}^{\\sharp}{\\mathcal{T}}_{S}^{\\sharp}(w_{R}+w_{D}^{\\sharp})-X_{S}^{\\sharp}{\\mathcal{T}}_{S}^{\\sharp}\\Big)\\right)}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "Note that the first part of the equation is the only part that contains $\\pmb{w}_{N}^{\\sharp}$ which in turn contains the variables $\\pmb{k}$ for which we want to solve. As every element of this part of the equation contains some $k_{i}$ it only contributes to $_{C}$ . In contrast the second part of the equation does not contain any variable $k_{i}$ and, thus, is the only part of both components that contribute to $c_{\\mathrm{0}}$ . Let us use $\\begin{array}{r}{\\frac{2\\eta}{n}C^{\\prime}k}\\end{array}$ to denote the matrix of coefficients that is the sum of absolute values of coefficients of $\\begin{array}{r}{\\frac{2}{n}({X_{R}}^{T}{X_{S}^{\\sharp}}+{X_{S}^{\\sharp}}^{T}{X_{R}}+{X_{S}^{\\sharp}}^{T}{X_{S}^{\\sharp}})w_{N}^{\\sharp}}\\end{array}$ that will be projected by $\\pmb{A}$ stemming from the first part of the equation in the expanded version of $\\mathbf{L}(\\mathcal{G}_{H})$ . We use $c_{i,j}^{\\prime}\\geq0$ to denote the element of $C^{\\prime}$ at $(i,j)$ . As mentioned before this is the only part of this component that contains terms containing unknowns $k_{i}$ . We use $c_{\\mathrm{0}}^{\\prime}$ to denote the contribution from the second part of Eq. (37) towards the output of linearization L. Then based on the fact that the second part of this component is the only part of both components that contributes to $c_{0}$ , we know that the whole contribution of the component from Eq. (36) towards $C+c_{0}$ is: ", "page_idx": 30}, {"type": "text", "text": "", "page_idx": 31}, {"type": "equation", "text": "$$\n\\eta\\pmb{c}_{0}^{\\prime}+\\frac{2\\eta}{n}{\\cal C}^{\\prime}k\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "In summary, the system of linear equations from Eq. (33) can be written as: ", "page_idx": 31}, {"type": "equation", "text": "$$\n\\begin{array}{l l l}{{\\displaystyle\\left(2\\eta\\lambda+\\frac{2\\eta}{n}q_{i,i}-\\frac{2\\eta}{n}c_{i,i}^{\\prime}\\right)k_{i}-\\frac{2\\eta}{n}\\sum_{j=1\\atop j\\neq i}^{d}\\left(|q_{i,j}|+c_{i,j}^{\\prime}\\right)k_{j}=\\eta c_{i,0}}}&{{s.t.\\;k_{i}\\geq0}}&{{\\forall i\\in[1,d]}}\\\\ {{\\displaystyle\\Leftrightarrow\\!\\left(\\lambda n+q_{i,i}-c_{i,i}^{\\prime}\\right)\\!k_{i}-\\sum_{j=1\\atop j\\neq i}^{d}\\left(|q_{i,j}|+c_{i,j}^{\\prime}\\right)\\!k_{j}=\\frac{n}{2}c_{i,0}}}&{{s.t.\\;k_{i}\\geq0}}&{{\\forall i\\in[1,d].}}\\end{array}\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "In the expanded system of linear equations, the diagonal elements of the coefficient matrix are $(\\lambda n+q_{i,i}-c_{i,i}^{\\prime})$ , while the off-diagonal elements are $-(|q_{i,j}|+c_{i,j}^{\\prime})$ . ", "page_idx": 31}, {"type": "text", "text": "Lemma I.6. If for all $i\\in[1,d]$ , ", "page_idx": 31}, {"type": "equation", "text": "$$\n(\\lambda n+q_{i,i}-c_{i,i}^{\\prime})\\geq\\sum_{\\stackrel{j=1}{j\\neq i}}^{d}\\big(|q_{i,j}|+c_{i,j}^{\\prime}\\big),\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "then the system of linear equations from Eq. (39) has a solution. ", "page_idx": 31}, {"type": "text", "text": "Proof. When this condition holds, the coefficient matrix of this system of linear equations is diagonally dominant. Also considering all diagonal elements are non-negative $((\\lambda n+q_{i,i}-c_{i,i}^{\\prime})\\geq$ $\\begin{array}{r}{\\sum_{j=1}^{d}\\left(|q_{i,j}|+c_{i,j}^{\\prime}\\right)\\ge0}\\end{array}$ and all off-diagonal elements are non-positive, the coefficient matrix is an M-matrix3. For any M-matrix $_M$ , the inverse $M^{-1}$ exists and is has all non-negative entries. Furthermore, for any system of linear equations represented as matrix equation $M x=b$ where $\\textbf{\\em x}$ are the variables of the equation system, ${\\bf\\dot{\\omega}}{M}^{-1}{b}$ is a solution. As our matrix $I-C$ is an M-matrix, we know that its inverse exists and has only positive entries and we can compute a solution $\\pmb{k}$ as: ", "page_idx": 31}, {"type": "equation", "text": "$$\n\\pmb{k}=(I-C)^{-1}\\pmb{c}_{0}\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "Given that all elements $c_{i,0}$ are positive and that $(I-C)^{-1}$ is positive, the solution $\\pmb{k}$ for Eq. (39) is also positive. \u53e3 ", "page_idx": 31}, {"type": "text", "text": "The correctness of Thm. I.1 follows immediately based on the sufficient condition for the existence of solution stated in Lem. I.6, . ", "page_idx": 31}, {"type": "text", "text": "Corollary I.7 (Proof of Thm. I.1). Given an input abstract training dataset $\\mathbf{D}^{\\sharp}$ , let $\\begin{array}{r l}{\\beta}&{{}=}\\end{array}$ $\\begin{array}{r}{\\frac{1}{n}\\operatorname*{max}_{i}\\left(\\sum_{j=1\\atop j\\neq i}^{d}\\left(|q_{i,j}|+c_{i,j}^{\\prime}\\right)+c_{i,i}^{\\prime}-q_{i,i}\\right)}\\end{array}$ For any regularization coefficient $\\lambda\\geq\\beta$ , we can compute an abstract fixed point $w^{\\sharp\\;*}$ for the model weights according to Def. 3.2. ", "page_idx": 31}, {"type": "text", "text": "Proof. To find an abstract fixed point of the model weights ", "page_idx": 31}, {"type": "equation", "text": "$$\n\\pmb{w}^{\\sharp\\,*}=\\pmb{w}_{R}^{*}+\\pmb{w}_{D}^{\\sharp\\,*}+\\pmb{w}_{N}^{\\sharp\\,*}\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "that fulfills the sufficient condition for an abstract fixed point from Prop. I.2, we first use the closed form solutions from Lem. I.4 to compute w\u2217R and then using w\u2217R compute w\u266fD\u2217 . These are guaranteed to fulfill the first two conditions of Prop. I.2. As the regularization coefficient $\\begin{array}{r}{\\lambda\\,\\geq\\,\\beta\\,=\\,\\frac{1}{n}\\operatorname*{max}_{i}\\left(\\sum_{j=1\\atop j\\neq i}^{d}\\left(\\lvert q_{i,j}\\rvert+c_{i,j}^{\\prime}\\right)+c_{i,i}^{\\prime}-q_{i,i}\\right)}\\end{array}$ , the condition from Lem. I.6 holds. Thus, the linear system of equations for a w\u266fN\u2217 that fulfills the last condition of Prop. I.2 has a solution that we can compute using any techniques for solving a system of linear equation. It follows that $\\pmb{w}^{\\sharp\\,*}=\\pmb{w}_{R}^{*}+\\pmb{w}_{D}^{\\bar{\\sharp}\\,*}+\\pmb{w}_{N}^{\\sharp\\,*}$ fulflils all conditions of Prop. I.2 and is an abstract fixed point according to Def. 3.2. \u53e3 ", "page_idx": 32}, {"type": "text", "text": "J Weakening the Requirements on Regularization ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "The existence of a fixed point $w^{\\sharp\\ast}$ as postulated in Thm. I.1 only holds for sufficiently large regularization $\\lambda\\ \\geq\\ \\beta$ where $\\beta$ depends on $\\mathbf{D}^{\\sharp}$ . The majority of real world examples without multicolinearity in the real part of the training data that we have investigated have $\\beta=0$ . However, we still provide a technique to reduce $\\beta$ if the need should arise at the cost of increasing the runtime of our approach. Specifically, we will make use of splitting [2] which divides an input zonotope into multiple zonotopes of smaller expand. We apply splitting to $\\mathbf{D}^{\\sharp}$ , then compute the fixed point for each zonotope in the result of splitting, and finally combine these fixed point using a join operation for zonotopes that over-approximates the union of the concretizations of two zonotopes (allows us to merge multiple zonotope such that the merged zonotope has a concretization that over-approximates the concretizations of all of the inputs). We will demonstrate that this approach enables us to reduce $\\beta$ to any value $\\ge0$ . Intuitively, this works because we can reduce the extend of the input zonotope for the fixed point computation to the extend necessary to ensure $\\beta=0$ . Albeit in worst-case this can require a splitting operator that generates a number of zonotopes that is exponential in the dimension. ", "page_idx": 32}, {"type": "text", "text": "J.1 Splitting and Join for zonotopes ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Intuitively, a splitting operator divides an input zonotope into two or more zonotopes such that the union of their concretization is the same as the concretization of the input zonotope. ", "page_idx": 32}, {"type": "text", "text": "Definition J.1 (Split Operator). An operator $\\mathbf{S}$ that maps a zonotope $\\ell^{\\sharp}$ to a set of zonotopes $\\{\\ell_{1}^{\\sharp},\\cdots,\\ell_{m}^{\\sharp}\\}$ is for any input zonotope $\\ell^{\\sharp}$ we have: ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\mathbf{S}(\\ell^{\\ddagger})=\\{\\ell_{1}^{\\ddagger},\\cdot\\cdot\\cdot,\\ell_{m}^{\\ddagger}\\}\\quad s.t.\\bigcup_{i}\\gamma\\left(\\ell_{i}^{\\ddagger}\\right)=\\gamma\\left(\\ell^{\\ddagger}\\right).\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "As an example of a split operator consider the binary split (2-split) at dimension $i$ denoted by $\\mathbf{S}_{2,i}$ that splits the input zonotope into two parts by scaling the $i^{t h}$ generator $\\scriptstyle\\mathbf{\\boldsymbol{g}}_{i}$ by $\\frac{1}{2}$ and shifting the center of the zonotope by $\\textstyle{\\frac{1}{2}}g_{i}\\left(-{\\frac{1}{2}}g_{i}\\right)$ : ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\mathrm{S}_{2,i}(\\ell^{\\sharp})=\\Big\\{\\ell_{1}^{\\sharp},\\ell_{2}^{\\sharp}\\Big\\}=\\Big\\{c+}&{\\underset{\\diamond\\mathrm{\\tiny~\\textnormal{\\it~\\/~j~}}}{\\sum}g_{j}\\epsilon_{j}\\quad,c+}&{\\underset{\\epsilon_{i}\\in[0,1]}{\\sum}g_{j}\\epsilon_{j}\\quad\\Big\\}}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\underset{\\mathrm{other}\\;\\epsilon_{j}\\in[-1,1]}{\\operatorname*{oner}}}&{\\underset{\\mathrm{other}\\;\\epsilon_{j}\\in[-1,1]}{\\operatorname*{or}}}\\\\ &{=\\Big\\{c-\\frac{1}{2}g_{i}+\\frac{1}{2}g_{i}\\epsilon_{i}+\\displaystyle\\sum_{j\\neq i}g_{j}\\epsilon_{j},\\quad c+\\frac{1}{2}g_{i}+\\frac{1}{2}g_{i}\\epsilon_{i}+\\underset{j\\neq i}{\\sum}g_{j}\\epsilon_{j}\\Big\\}}\\end{array}\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "As $\\gamma\\left(\\pmb{\\ell}_{1}^{\\sharp}\\right)\\cup\\gamma\\left(\\pmb{\\ell}_{2}^{\\sharp}\\right)=\\gamma\\left(\\pmb{\\ell}^{\\sharp}\\right),\\mathbf{S}_{2,i}(\\cdot)$ is a split operator according to Def. J.1. We can generalize 2-split to an $(m,i)$ -split $\\mathbf{S}_{m,i}$ that divides the zonotope evenly into $m$ parts along the $i^{t h}$ dimension. We will call the composition of $(m,i)$ -splits across all dimensions as a $\\mu$ -split. Given $\\textstyle\\mu={\\frac{1}{m}}$ for $m\\in\\mathbb{N}$ as input, the effect of the $\\mu$ -split $\\mathbf{S}_{\\mu}$ is the generators of each zonotope in the result of splitting are the generators of the input zonotope scaled by $\\mu$ . Thus, $\\mu$ -splitting allows us to downscale the generators of a zonotope. For a $d$ -dimensional zonotope and $\\begin{array}{r}{\\dot{\\mu}=\\frac{1}{m}}\\end{array}$ , $\\bar{\\bf S}_{\\mu}$ returns $d^{m}$ zonotopes. ", "page_idx": 32}, {"type": "text", "text": "Definition J.2 ( $\\mu$ -split). For $d$ -dimensional zonotopes and $\\textstyle\\mu\\,=\\,{\\frac{1}{m}}$ for $m\\in\\mathbb{N}$ , the $\\mu$ -split $\\mathbf{S}_{\\mu}$ is defined as: ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\mathbf{S}_{m,d}\\circ\\hdots\\circ\\mathbf{S}_{m,1}\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "where the $(m,i)$ -split $\\mathbf{S}_{m,i}$ is defined as shown below and the application of a split operator to a set of zonotopes is defined as applying the split operator to every element in the set. ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\mathbf{S}_{m,i}(\\ell^{\\sharp})=\\{\\ell^{\\sharp}{}_{i}\\}_{j=1}^{m}\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "for ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\ell^{\\sharp}{}_{j}=c+\\frac{-m+2j-1}{m}g_{i}+\\frac{1}{m}g_{i}\\epsilon_{i}+\\sum_{j\\ne i}g_{j}\\epsilon_{j}\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "For example, $\\mathbf{S}_{2}(1+\\epsilon_{1})=\\{0.5+0.5\\epsilon_{1},1.5+0.5\\epsilon_{1}\\}$ . It is easy to see that $\\mathbf{S}_{\\mu}$ is indeed a split according to Def. J.1. ", "page_idx": 33}, {"type": "text", "text": "Proposition J.3 ( $\\mathbf{S}_{\\mu}$ is a Split Operator). $\\mathbf{S}_{\\mu}$ is a split operator for any $\\textstyle\\mu={\\frac{1}{m}}$ were $m\\in\\mathbb{N}$ . ", "page_idx": 33}, {"type": "text", "text": "Next we introduce join operators for zonotopes and then demonstrate that for any abstract transformer $F^{\\sharp}$ for a function $F$ , we can construct another abstract transformer for $F$ by (i) splitting the input zonotope using some split operator S, (ii) applying $F^{\\sharp}$ separately on each zonotope returned by the split, and (iii) merge the results using a join that we introduce next.4 ", "page_idx": 33}, {"type": "text", "text": "Definition J.4 (Join). An operator $\\sqcup$ is a join for zonotopes if it over-approximates union of concretization. That is, for any set $S^{\\sharp}$ of zonotopes: ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\gamma\\left(\\bigsqcup S^{\\sharp}\\right)\\supseteq\\bigcup_{z^{\\sharp}\\in S^{\\sharp}}\\gamma\\left(z^{\\sharp}\\right).\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "Several join operators have been proposed for zonotopes, e.g., [24]. Next we establish that new abstract transformers can be constructed by wrapping existing transformers with split and join. This ensures that our approach of combining our abstract fixed point calculation with splitting yields valid fixed points. ", "page_idx": 33}, {"type": "text", "text": "Lemma J.5 (Abstract Transformers Are Sound on Splits). Consider a zonotope $z^{\\sharp}$ and let $F^{\\sharp}$ be an abstract transformer for a function $F$ . Furthermore, let \u2294be a join operator, S be a split operator, and let $\\mathbf{S}(\\ell^{\\sharp})=\\{\\ell^{\\sharp}{}_{1},\\dots,\\ell^{\\sharp}{}_{m}\\}$ . Then, ${F_{{\\bf S},\\sqcup}}^{\\sharp}=\\sqcup\\circ{F^{\\sharp}}\\circ{\\bf S}$ is an abstract transformer for $F$ . ", "page_idx": 33}, {"type": "text", "text": "Proof. We have to show that ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\gamma\\left(F_{{\\bf S},\\sqcup}^{\\!\\;\\;\\sharp}(\\ell^{\\sharp})\\right)\\supseteq F(\\gamma\\left(\\ell^{\\sharp}\\right)).\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "We have ", "page_idx": 33}, {"type": "text", "text": "(Def. J.1 for S) (function application on sets of concrete elements is point-wise application) ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\begin{array}{r l}&{F(\\gamma(\\ell^{*}))}\\\\ &{=F_{\\ell}\\left(\\begin{array}{l}{\\xi}\\\\ &{\\gamma}\\end{array}\\right)}\\\\ &{=\\boldsymbol{\\varepsilon}^{\\prime}\\sin\\left(\\theta\\right)}\\\\ &{=F_{\\ell}\\left(\\begin{array}{l}{\\sin\\left(\\theta\\right)}\\\\ {\\sin^{2}\\left(\\theta\\right)}\\end{array}\\right)}\\\\ &{=\\left(\\begin{array}{l}{\\sin\\left(\\theta\\right)}\\\\ {\\sin^{2}\\left(\\theta\\right)}\\end{array}\\right)}\\\\ &{\\mapsto\\dot{\\left[\\begin{array}{l}{F}\\\\ {\\sin^{2}\\left(\\theta\\right)}\\end{array}\\right]}}\\\\ &{\\stackrel{{\\mathrm{(a)}}}{=}\\left(\\begin{array}{l}{\\left(F^{*}(\\ell^{*})\\right)}\\\\ {\\vdots}\\\\ {\\left(F^{*}(\\ell^{*})\\right)}\\end{array}\\right)}\\\\ &{\\stackrel{{\\mathrm{(a)}}}{=}\\frac{1}{\\sqrt{\\pi}}\\left(\\begin{array}{l}{F^{*}(\\ell^{*})}\\\\ {\\vdots}\\\\ {F^{*}(\\ell^{*})}\\end{array}\\right)}\\\\ &{\\geq\\gamma\\left(\\begin{array}{l}{\\left(\\begin{array}{l}{\\sin\\left(\\theta\\right)}\\\\ {\\sin^{2}\\left(\\theta\\right)}\\end{array}\\right)}\\\\ {\\left(\\begin{array}{l}{\\sin\\left(\\theta\\right)}\\end{array}\\right)}\\end{array}\\right)}\\\\ &{=\\gamma\\left(\\begin{array}{l}{\\left(F_{\\ell^{*}}\\right)}\\\\ {\\sin^{2}\\left(\\theta\\right)}\\end{array}\\right)}\\end{array}}\\end{array}\n$$", "text_format": "latex", "page_idx": 33}, {"type": "equation", "text": "$$\n(\\gamma\\left(z_{1}^{\\sharp}\\sqcup z_{2}^{\\sharp}\\right)\\supseteq\\gamma\\left(z_{1}^{\\sharp}\\right)\\cup\\gamma\\left(z_{2}^{\\sharp}\\right))\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "J.2 Weakening Regularization Requirements ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Equipped with the $\\mu$ -split and a join operator, we are ready to analyze how the introduction of a $\\mu$ -split can be used to achieve an arbitrarily small $\\beta$ . Given the input data $\\mathbf{D}^{\\sharp}$ , the learning rate $\\eta\\ge\\beta$ , the regularization coefficient $\\lambda$ , the transformation matrix $\\pmb{A}$ , we use $\\Gamma(\\mathbf{D}^{\\sharp},\\eta,\\lambda,A)$ to denote the function that computes the fixed point w\u266fS\u2217 for these inputs using the process outlined in Corollary I.7. From Lem. J.5 follows that $\\Gamma_{\\mathbf{S}_{\\mu},\\sqcup}$ is an abstract transformer for gradient descent and, thus, according to Prop. 3.3 over-approximates $\\pmb{w}^{\\odot*}$ ", "page_idx": 34}, {"type": "text", "text": "Next, we show that given an abstract training dataset $\\mathbf{D}^{\\sharp}$ and a desired regularization coefficient $\\lambda_{t a r g e t}$ , we can find a value of $\\mu$ such that the abstract fixed point construction with $\\mu$ -splitting computes a fixed point. Recall that $\\Gamma$ can construct a fixed point if $\\lambda\\geq\\beta$ where $\\beta$ is a constant that depends on $\\mathbf{D}^{\\sharp}$ . We will show that by choosing $\\mu$ carefully, we can achieve $\\beta\\leq\\lambda_{t a r g e t}$ for each zonotope in the result of the split and, thus, $\\Gamma$ will return a valid fixed point for each zonotope in the split result. ", "page_idx": 34}, {"type": "text", "text": "Lemma J.6. For any abstract training dataset $\\mathbf{D}^{\\sharp}$ and desired regularization coefficient $\\lambda,$ , there exists $m\\in\\mathbb{N}$ such that for $\\textstyle\\mu={\\frac{1}{m}}$ , $\\Gamma_{\\mathbf{S}_{\\mu},\\sqcup}$ returns a fixed point $w^{\\sharp\\;*}$ . ", "page_idx": 34}, {"type": "text", "text": "Proof. Consider an abstract training dataset $\\mathbf{D}^{\\sharp}=(X^{\\sharp},y^{\\sharp})$ with $X^{\\sharp}=X_{R}+X_{S}^{\\sharp}$ . WLOG consider a single abstract training dataset $\\mathbf{D}^{\\sharp}{}_{i}$ in the result of $\\mu$ -split on $\\mathbf{D}^{\\sharp}$ : ", "page_idx": 34}, {"type": "equation", "text": "$$\n\\mathbf{D}^{\\sharp}{}_{i}\\in\\mathbf{S}_{\\mu}(\\mathbf{D}^{\\sharp})\n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "We will show that using the regularization coefficient $\\lambda$ , we can find $\\mu$ such that the precondition $\\lambda\\geq\\beta$ for $\\Gamma$ to compute a fixed point holds. Then applying Lem. J.5 we get the desired result. ", "page_idx": 34}, {"type": "text", "text": "First observe that since $\\mathbf{D}^{\\sharp}{}_{i}$ is in the result of $\\mu$ -splitting, we know that it has the following shape where the symbolic component $X_{S}^{\\sharp}$ is scaled by $\\mu$ and the real component $X_{R i}$ of $\\mathbf{D}^{\\sharp}{}_{i}$ typically differs from $X^{\\sharp}$ as $\\mu$ -splitting changes the center of the zonotope. ", "page_idx": 34}, {"type": "equation", "text": "$$\n\\pmb{X}^{\\sharp}{}_{i}=\\pmb{X}_{R i}+\\mu\\pmb{X}_{S}^{\\sharp}\n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "Recall that $\\begin{array}{r}{\\frac{2\\eta}{n}C^{\\prime}k}\\end{array}$ denotes the matrix of coefficients that is the sum of absolute values of coefficients of $\\begin{array}{r}{\\frac{2}{n}A({\\pmb X_{R}}^{\\top}{\\pmb X}_{S}^{\\sharp}+{\\pmb X}_{S}^{\\sharp}{}^{T}{\\pmb X}_{R}+{\\pmb X}_{S}^{\\sharp}{}^{T}{\\pmb X}_{S}^{\\sharp}){\\pmb w}_{N}^{\\sharp}}\\end{array}$ . Plugging in the definition of $X^{\\sharp}{}_{i}$ from above, we get a matrix $\\scriptstyle{\\frac{2\\eta}{n}}C^{\\prime}k$ that is the sum of absolute values of coefficients of ", "page_idx": 34}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\frac{2}{n}A({X_{R\\,i}}^{T}\\mu{X_{S}^{\\dagger}}+\\mu{{X_{S}^{\\dagger}}^{T}}{X_{R\\,i}}+\\mu{{X_{S}^{\\dagger}}^{T}}\\mu{{X_{S}^{\\dagger}}})w_{N}^{\\dagger}}\\\\ &{=\\!\\frac{2}{n}A(\\mu{{X_{R\\,i}}^{T}}{X_{S}^{\\dagger}}+\\mu{{X_{S}^{\\dagger}}^{T}}{X_{R\\,i}}+\\mu^{2}{{X_{S}^{\\dagger}}^{T}}{X_{S}^{\\dagger}})A^{-1}\\left[\\!\\begin{array}{l}{{k_{1}\\epsilon_{1}}}\\\\ {\\vdots}\\\\ {{k_{d}\\epsilon_{d}}}\\end{array}\\!\\right]}\\\\ &{=\\!\\Big(\\underbrace{\\frac{2\\mu}{n}A({X_{R\\,i}}^{T}{X_{S}^{\\dagger}}+{X_{S}^{\\dagger}}^{T}{X_{R\\,i}})A^{-1}}_{\\mathrm{courtintes~to~c_{i,j}^{-1}~}}+\\underbrace{\\frac{2\\mu^{2}}{n}A({X_{S}^{\\dagger}}^{T}{X_{S}^{\\dagger}})A^{-1}}_{\\mathrm{courtintes~to~c_{i,j}^{2}~}}\\!\\Big)\\left[\\!\\begin{array}{l}{{k_{1}\\epsilon_{1}}}\\\\ {\\vdots}\\\\ {{k_{d}\\epsilon_{d}}}\\end{array}\\!\\right].}\\end{array}\n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "Recall that $c_{i,j}^{\\prime}$ denotes entry of $C^{\\prime}$ at row $i$ and column $j$ . Here, ${\\boldsymbol{X}}_{S}^{\\sharp}{}^{T}{\\boldsymbol{X}}_{S}^{\\sharp}$ has higher order than $({\\pmb X}_{R}{}^{T}{\\pmb X}_{S}^{\\sharp}+{\\pmb X}_{S}^{\\sharp}{}^{T}{\\pmb X}_{R})$ , thus their terms will not cancel out. Therefore, we can decompose the contribution to $\\ \\tilde{c_{i,j}^{\\prime}}$ into the above two parts, denoted as ", "page_idx": 34}, {"type": "equation", "text": "$$\nc_{i,j}^{\\prime}=c_{i,j}^{1}+c_{i,j}^{2}.\n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "Given scalar $\\mu$ , let ", "page_idx": 34}, {"type": "equation", "text": "$$\nc_{\\mu}^{\\prime}=\\operatorname*{max}_{u,v}c_{u,v}^{\\prime}\n$$", "text_format": "latex", "page_idx": 34}, {"type": "text", "text": "i.e., $c_{\\mu}^{\\prime}$ denotes the largest entry $c_{i,j}^{\\prime}$ in $\\mathbf{D}^{\\sharp}{}_{i}$ ", "page_idx": 34}, {"type": "text", "text": "Let $i$ and $j$ such that $c_{\\mu}^{\\prime}=c_{i,j}^{\\prime}$ , we have: ", "page_idx": 35}, {"type": "equation", "text": "$$\nc_{\\mu}^{\\prime}=\\mu c_{i,j}^{1}+\\mu^{2}c_{i,j}^{2}\\leq\\mu c_{i,j}^{1}+\\mu c_{i,j}^{2}=\\mu c_{m a x}^{\\prime},\n$$", "text_format": "latex", "page_idx": 35}, {"type": "text", "text": "where c\u2032max is a constant that is equal to the maximum $c_{i,j}^{\\prime}$ before scaling $X_{S}^{\\sharp}$ through $\\mu$ -splitting. ", "page_idx": 35}, {"type": "text", "text": "Next, we prove the lemma for a specific transformation $A=V^{T}$ during order reduction derived through singular value decomposition (SVD). Using SVD, we can decompose the covariance matrix $\\bar{X_{R i}}^{T}\\bar{X_{R i}}$ of the real number part of features $X_{R i}$ as shown below ", "page_idx": 35}, {"type": "equation", "text": "$$\n\\begin{array}{r}{{\\pmb X}_{R_{i}}^{~T}{\\pmb X}_{R_{i}}=V\\Sigma V^{T}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 35}, {"type": "text", "text": "For $A=V^{T}$ , and using the fact that $V$ is a rotation in SVD which implies $V^{-1}=V^{T}$ , we get: ", "page_idx": 35}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad A X_{R_{i}^{\\phantom{T}}}X_{R_{i}A}-1}\\\\ &{=A(V\\Sigma V^{T})A^{-1}}\\\\ &{=V^{T}(V\\Sigma V^{T})V^{T}{}^{-1}}\\\\ &{=(V^{-1}V)\\Sigma(V^{-1}V^{-1}{}^{-1})}\\\\ &{=\\Sigma}\\end{array}\n$$", "text_format": "latex", "page_idx": 35}, {"type": "text", "text": "Thus, the matrix $A\\pmb{X}_{R_{i}}^{~T}\\pmb{X}_{R_{i}}\\pmb{A}^{-1}=\\pmb{\\Sigma}$ is a diagonal matrix, meaning that all off-diagonal elements of it $\\left<|q_{i,j}|\\right>$ for all $(i\\neq j)$ ) in Corollary I.7) are zero. In addition, the diagonal element $\\Sigma[i,i]$ $\\mathbf{\\check{\\psi}}_{q_{i,i}}$ in Corollary I.7) is the $i^{t h}$ eigenvalue of the covariance matrix $X_{R i}^{\\,\\,\\,T}X_{R i}$ , which must be positive when assuming no multicolinearity. ", "page_idx": 35}, {"type": "text", "text": "To sum up, $\\beta$ from Corollary I.7 can be re-written as: ", "page_idx": 35}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\lefteqn{\\beta=\\frac{1}{n}\\operatorname*{max}_{i}\\big(c_{i,i}^{\\prime}+\\frac{d}{\\int_{\\hat{\\mathcal{H}}}(|q_{i,j}|+c_{i,j}^{\\prime})-q_{i,i}\\big)}}}\\\\ &{\\leq\\frac{1}{n}\\operatorname*{max}_{i}\\big(c_{\\mu}^{\\prime}+\\displaystyle\\sum_{j\\neq i}^{}c_{\\mu}^{\\prime}-q_{i,i}\\big)}\\\\ &{\\leq\\frac{1}{n}\\operatorname*{max}_{i}\\big(\\mu c_{m a x}^{\\prime}+\\displaystyle\\sum_{j\\neq i}^{d}\\mu c_{m a x}^{\\prime}-q_{i,i}\\big)}\\\\ &{\\leq\\frac{1}{n}\\operatorname*{max}_{i}\\big(\\mu c_{m a x}^{\\prime}+\\displaystyle\\sum_{j\\neq i}^{d}\\mu c_{m a x}^{\\prime}-q_{i,i}\\big)}\\\\ &{=\\frac{1}{n}\\operatorname*{max}_{i}\\big(d\\mu c_{m a x}^{\\prime}-q_{i,i}\\big)=\\frac{1}{n}d\\mu\\omega_{m a x}^{\\prime}-\\frac{1}{n}\\operatorname*{min}_{i}(q_{i,i})}\\end{array}\n$$", "text_format": "latex", "page_idx": 35}, {"type": "text", "text": "where $\\textstyle{\\frac{1}{n}}\\operatorname*{min}_{i}(q_{i,i})$ is a positive constant. Therefore, when setting $\\begin{array}{r}{\\mu\\,=\\,\\frac{\\operatorname*{min}_{i}\\left(q_{i,i}\\right)}{d c_{m a x}^{\\prime}}\\,>\\,0}\\end{array}$ , we have $\\begin{array}{r}{\\beta\\leq\\frac{1}{n}d\\mu c_{m a x}^{\\prime}-\\frac{1}{n}\\operatorname*{min}_{i}(q_{i,i})=0.}\\end{array}$ \u53e3 ", "page_idx": 35}, {"type": "text", "text": "K An Approximate Abstract Transformer for Ridge Regression ", "text_level": 1, "page_idx": 35}, {"type": "text", "text": "Alg. 2 is the detailed version of Alg. 1 we presented in the main paper. Like Alg. 1, Alg. 2 takes as input an abstract dataset $\\mathbf{D}^{\\sharp}$ that over-approximates $D^{\\odot}$ , a learning rate $\\eta$ , a regularization coefficient $\\lambda$ , and a transformation matrix $\\pmb{A}$ used for order reduction (e.g., the SVD-based transformation discussed in App. J.2). In Line 1, we first use function constructFPEquations to compute fixed points for $\\pmb{w}_{R}^{*}$ and $\\boldsymbol{w_{D}^{\\sharp}}$ using the closed form solution from Lem. I.4 and construct the equation system $\\Xi$ for $w_{N}^{\\sharp\\;*}$ (Eq. (39)). Furthermore, this function also computes the threshold $\\beta$ on the regularization coefficient for this system of equations to have a solution. If $\\beta$ is smaller or equal to the desired regularization coefficient $\\lambda$ (Line 10), then we solve the linear equations $\\Xi$ (Line 11) and then returns the fixpoint $w^{\\sharp\\;*}$ . Otherwise, we determine a sufficiently small splitting factor $\\mu$ that ensures that $\\beta\\le\\lambda$ for each $\\pmb{w}^{\\sharp}{}_{i}$ in the result of the split (Line 3), compute the fixed point for each such $\\pmb{w}^{\\sharp}{}_{i}$ (Lines 6 and 8), and merge these fixed points using join to compute the final result (Line 9). ", "page_idx": 35}, {"type": "text", "text": "Algorithm 2: Constructing a Fixed Point for Abstract Gradient Descent ", "page_idx": 36}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/999a574ccf1ccde71f87efbadd1d0e104523de9099d12a35bb311176814521d0.jpg", "img_caption": [], "img_footnote": [], "page_idx": 36}, {"type": "text", "text": "L Infeasibility of Symbolically Evaluating the Closed-form Solution for Ridge Regression ", "text_level": 1, "page_idx": 36}, {"type": "text", "text": "In this section, we demonstrate why evaluating the closed-form solution for linear regression with MSE is not feasible. It produces symbolic expressions with many variables and large symbolic terms (their representation size) that include the fractions with denominators and enumerators that are polynomial expressions. Apart from the size of these expressions, computing viable prediction intervals from such a symbolic representation of model weights is computationally hard. We use MSE loss for simplicity, but the same arguments also apply to ridge regression. ", "page_idx": 36}, {"type": "text", "text": "We illustrate the issues using a randomly-generated toy dataset with 10 samples and 3 uncertain data cells in the third column (corresponding to 3 error symbols $\\epsilon_{0},\\epsilon_{1},\\epsilon_{2})^{5}$ : ", "page_idx": 36}, {"type": "equation", "text": "$$\nX^{\\sharp}={\\left[\\begin{array}{l l l l}{1.0}&{1.6}&{1.36_{0}+1.4}\\\\ {1.0}&{0.8}&{1.5}\\\\ {1.0}&{-1.7}&{-1.9}\\\\ {1.0}&{-0.57}&{1.1}\\\\ {1.0}&{-0.39}&{0.36}\\\\ {1.0}&{0.035}&{1.2}\\\\ {1.0}&{-0.34}&{-0.73}\\\\ {1.0}&{0.038}&{0.36_{1}+0.44}\\\\ {1.0}&{1.5}&{1.2\\epsilon_{2}+1.3}\\\\ {1.0}&{-0.98}&{-0.66}\\end{array}\\right]}\\qquad y^{\\sharp}={\\left[\\begin{array}{l}{4.6}\\\\ {-1.5}\\\\ {0.39}\\\\ {-5.7}\\\\ {-3.0}\\\\ {-3.6}\\\\ {-0.44}\\\\ {0.46}\\\\ {2.2}\\\\ {-3.0}\\end{array}\\right]}\n$$", "text_format": "latex", "page_idx": 36}, {"type": "text", "text": "Then, symbolically evaluating the closed-form solution for linear regression with MSE loss, we obtain the symbolic expression representing all possible model weights: ", "page_idx": 37}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{v^{\\sharp*}=(X^{\\sharp^{T}}X^{\\sharp})^{-1}X^{\\sharp^{T}}y^{\\sharp}}\\\\ &{\\qquad=\\left[\\frac{1.5.10^{6}e_{0}^{-4}\\mathrm{{\\textcentering~\\alpha}}^{-1}\\mathrm{.10}^{6}e_{0}\\mathrm{{\\epsilon}}_{1}-4.5.10^{5}e_{0}\\mathrm{{\\epsilon}}_{2}-1.2\\cdot\\mathrm{10}^{6}e_{0}+9.2\\cdot\\mathrm{10}^{4}{\\epsilon}_{1}^{2}+4.0\\cdot\\mathrm{10}^{3}{\\epsilon}_{1}e_{2}-2.4\\cdot\\mathrm{10}^{5}e_{1}+1.0\\cdot\\mathrm{10}^{6}e_{2}^{2}-2.1\\cdot\\mathrm{10}^{6}e_{2}-1.4\\cdot\\mathrm{10}^{7}e_{0}\\mathrm{{\\epsilon}}_{1}\\right]}{-1.1\\cdot\\mathrm{10}^{6}e_{0}^{2}+\\mathrm{{3.1}}\\mathrm{{4.1}}^{-1}\\mathrm{{0}}^{6}e_{0}\\mathrm{{\\epsilon}}_{2}+1.1\\cdot\\mathrm{10}^{6}e_{0}-8.3\\cdot\\mathrm{{10}}^{4}{\\epsilon}_{1}^{2}+7\\cdot\\mathrm{1}^{0}{\\mathrm{4}}e_{1}\\mathrm{{\\epsilon}}_{2}+6.1\\cdot\\mathrm{10}^{3}{\\epsilon}_{1}-9.3\\cdot\\mathrm{{10}}^{8}{\\epsilon}_{2}+9.5\\cdot\\mathrm{10}^{8}{\\epsilon}_{2}-2.1\\cdot\\mathrm{10}^{3}{\\epsilon}_{1}}\\\\ &{\\qquad=\\left[\\frac{-9.5\\cdot\\mathrm{10}^{4}e_{0}^{-4}\\mathrm{{2.3}}\\cdot\\mathrm{10}^{4}{\\epsilon}_{0}\\mathrm{{\\epsilon}}_{1}+2.6\\cdot\\mathrm{10}^{5}{\\epsilon}_{0}\\mathrm{{2+2.3}}\\cdot\\mathrm{10}^{5}{\\epsilon}_{0}\\mathrm{{--1.4}}\\cdot\\mathrm{10}^{4}{\\epsilon}_{1}^{2}+7.0\\cdot\\mathrm{10}^{4}{\\epsilon}_{1}^{2}+3.6\\cdot\\mathrm{10}^{6}{\\epsilon} \n$$", "text_format": "latex", "page_idx": 37}, {"type": "text", "text": "Next, we consider one test sample $\\pmb{x}_{t}=[1,-1,1]$ and apply this closed-form model weight expression to infer its prediction range $V^{\\sharp}({\\pmb x}_{t})$ (cf. Corollary F.2). With merely 3 uncertain data points in the training data, the prediction of this test data point ", "page_idx": 37}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\hat{y}_{t}=w^{\\ell*}x_{t}}\\\\ &{\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! \n$$", "text_format": "latex", "page_idx": 37}, {"type": "text", "text": "already consists of fractions of complex polynomial expressions. Finding the viable prediction range for this data point, i.e. the minimum and maximum possible prediction for the point across all models in the concretization of the symbolic expression, using this expression is infeasible, as it is harder than finding an extrema for multivariate polynomials under linear constraints6, which is known to be NP-hard. In practice, expressions will be significantly larger as they will involve more error symbols. Assume each column has $p$ uncertain cells, and $q$ is the number of uncertain labels, the number of distinct monomials is $\\bar{O(p^{d}d^{2d}q)}$ , where $d$ is the number of dimensions, and the $d$ in exponents mainly comes from the matrix inversion when computing the determinant. ", "page_idx": 37}, {"type": "text", "text": "In summary, the symbolic expressions obtained from symbolically evaluating the closed-form solution for linear regression are not suitable for representing the space of possible model weights. ", "page_idx": 37}, {"type": "text", "text": "M Additional Experiments ", "text_level": 1, "page_idx": 37}, {"type": "text", "text": "M.1 Robustness Verification Additional Results ", "text_level": 1, "page_idx": 37}, {"type": "text", "text": "For a better comparison with MEYER [47], we use heatmaps to visualize the robustness ratios averaged over 5 repeated experiments with different random seeds. In App. M.1, ZORRO exhibits much less yellow regions (representing higher uncertainty) compared to MEYER. Especially when the uncertainty is high (bottom-right part), there are many cases that ZORRO returns high robustness ratio but MEYER does not. Recall that both approach gives sound over-approaximation of prediction robustness, thus the robustness ratios returned by both are lower bounds of the ground truth prediction robustness ratio. Therefore, the aforementioned cases correspond to highly robust ground truth (no less than the result of ZORRO), where ZORRO gives tight over-approximations but MEYER does not. ", "page_idx": 37}, {"type": "text", "text": "M.2 Micro Benchmark ", "text_level": 1, "page_idx": 37}, {"type": "text", "text": "We use range of loss as the metric to measure the quality (tightness) of uncertain training result. range of loss for samples are calculated by max loss - min loss across all sampled results. Loss range for symbolic representations are calculated my measuring the range of the interval concretization of the loss function result. Notice that samplings return a subset of all possible result which has no soundness guarantees, as a result, produces an under-approximation of the loss range. The symbolic fixed point approach produces an over-approximated loss range. We take 1,000 (1k) and 10,000 (10k) samples from all possible worlds as under approximations to the concrete range when number of possible worlds are to large to compute the ground truth range. ", "page_idx": 37}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/3d77db4ea9851a2851e2d9ad72aded2d6dbc8fe1b469ee6e28064d78a2530c53.jpg", "img_caption": ["Figure 5: Robustness verification under label errors using intervals (MEYER) or zonotopes (ZORRO). ", "(b) Insurance "], "img_footnote": [], "page_idx": 38}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/4940418ad47f4e62873c9c711300e207869990dbaaf156ed9dc63be59234c3ff.jpg", "img_caption": ["Figure 6: Fixed point versus samplings "], "img_footnote": [], "page_idx": 38}, {"type": "text", "text": "Varying ratio of tuples contains uncertain data Figure 6a shows the loss range results while updating the ratio of uncertain rows from 0.01 to 0.12. ZORRO has a tight range considering all samples are under approximations of ground truth range especially in . As uncertainty increases, the over-approximation gap widens due to the increased coefficient of higher order terms in the gradient, which are linearized, leading to higher linearization errors. ", "page_idx": 38}, {"type": "text", "text": "Increasing uncertainty radius Figure 6b shows the result by increasing the radius of uncertain data (imputation results) by multiplier of 0.06 to 0.44 where 0.06 means the range for each uncertain data is increased by $6\\%$ . Similar to amount of uncertainty, ", "page_idx": 38}, {"type": "text", "text": "Varying dimensions Figure 6c Shows the result by change number of dimensions to the training data. Result indicates tightness of ZORRO \u2019s over-approximation is not affected by the dimension of the data. ", "page_idx": 38}, {"type": "text", "text": "Figure 7 added sampling result to Figure 3 shows additionally that sampling result is an under approximation of the ground truth result. ", "page_idx": 38}, {"type": "text", "text": "M.3 Additional Experiments on Varying Regularization Coefficients ", "text_level": 1, "page_idx": 38}, {"type": "text", "text": "Fig. 8 shows the effect of varying regularization coefficients on the worst-case loss and prediction robustness ratio. To avoid much overlapping in the plots, we used one standard deviation as the error bar. Similar to the conclusions in Sec. 5.2, $\\lambda=0$ is often not the optimal regularization coefficient in terms of accuracy or robustness. In fact, a small, positive $\\lambda$ could result in higher accuracy and better robustness, and this optimal $\\lambda$ varies across different settings. In general, higher data uncertainty requires higher $\\lambda$ , which coincides with the intuition of using regularization in traditional settings of linear regressions, which aims to mitigate the effect of data noises or errors. ", "page_idx": 38}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/0ce0121d905ccbd58374d245b0dd809e5047ce5c21a3f65425e667560cb403bb.jpg", "img_caption": ["Figure 7: The range of losses obtained by enumerating all possible worlds (GT), sampling 1000 possible worlds (1k), and ZORRO. "], "img_footnote": [], "page_idx": 39}, {"type": "text", "text": "Figure 9: Robustness ratio (red y-axis) and worst-case test loss (green y-axis) vs. regularization coefficient $\\lambda$ (x-axis), with varying percentages of uncertain labels. ", "page_idx": 39}, {"type": "text", "text": "M.4 Comparing with Bayesian Regression ", "text_level": 1, "page_idx": 39}, {"type": "text", "text": "We ran empirical evaluations to demonstrate how data quality issues pose challenges for Bayesian linear regression (implemented with torchbnn [40]), making them inapplicable to our setting. Using the setting from the third plot in Fig 1c, where the uncertain data percentage is set to $10\\%$ , we tested Bayesian linear regression on different possible worlds using two methods: impute-and-predict and sampling from possible worlds. The results show that the prediction intervals generated by Bayesian methods do not cover the ground truth prediction, i.e., the prediction by the model trained on the ground truth training data. In contrast, our approach guarantees $100\\%$ coverage across all cases. ", "page_idx": 39}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/ca47a80527f10822774bbab69e5e4612774ac07fcaced702535a4db9afb200e9.jpg", "img_caption": ["Figure 8: Results with uncertain training labels. ", "Table 1: Bayesian approach on imputed data. ", "Table 2: Bayesian approach on sampled possible worlds. "], "img_footnote": [], "page_idx": 39}, {"type": "table", "img_path": "v9RqRFSLQ2/tmp/ce182bd4ba81d64b2ef4f20b2b88410102c1ae7270001d32cf7f9b95e83fd75d.jpg", "table_caption": [], "table_footnote": [], "page_idx": 39}, {"type": "table", "img_path": "v9RqRFSLQ2/tmp/8da3e0767a4e101378a354294739ace7864edf6493681656d5270a2447f3fdbc.jpg", "table_caption": [], "table_footnote": [], "page_idx": 39}, {"type": "text", "text": "M.5 Varying Robustness Threshold ", "text_level": 1, "page_idx": 39}, {"type": "text", "text": "Different practical applications may differ in how much uncertainty they are willing to tolerate, thus leading to varying choices of robustness thresholds. To account for this in the experiments, we selected both a low threshold $0.5\\%$ for the insurance data) and a high threshold ${5\\%}$ for the MPG data). As presented in Fig 10, we also explored other thresholds, which did not impact the trends significantly: Zorro can consistently certify a larger fraction of the test data points than the baseline due to its use of the more expressive zonotope domain. ", "page_idx": 39}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/32c2f30e5055f5460d786ab37c6951a3557af2a6d4d5c35118f2f4d2d8e68112.jpg", "img_caption": ["Figure 10: Varying robustness threshold from $0.4\\%$ to $2.4\\%$ with fixed uncertainty radius $6\\%$ "], "img_footnote": [], "page_idx": 40}, {"type": "text", "text": "M.6 Varying Uncertain Feature ", "text_level": 1, "page_idx": 40}, {"type": "text", "text": "The variability of trained models will depend on the correlation that features with uncertainty have with the label, which then also affects our over-approximation of this set. As a rule of thumb, model variability will increase with the correlation between the uncertain feature and the labels, leading to less robust predictions. We conducted an additional experiment using the MPG dataset, focusing on the feature \u201cacceleration,\u201d which has relatively low correlation with the label. Unlike the feature \u201cweight\u201d (Fig. 1c), where the robustness drops when the uncertainty radius is $10\\%$ , the robustness for \u201cacceleration\u201d starts to drop only when the uncertainty radius is increased to $16\\%$ . The result shown in Fig 11 indicates that features with lower predictive power have less impact on the robustness of a model compared to features that are highly correlated with the label. ", "page_idx": 40}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/3ab700605b624ab68d75ce73c221a32584fef2b87b3054d4134c6906dfc09417.jpg", "img_caption": ["Figure 11: Robustness verification with errors in feature \"acceleration\". "], "img_footnote": [], "page_idx": 40}, {"type": "text", "text": "M.7 Runtime of ZORRO ", "text_level": 1, "page_idx": 40}, {"type": "text", "text": "We evaluated the runtimes for computing the closed-form solution on the MPG dataset, varying the numbers of uncertain data points, in Fig 12. With the same number of uncertainty data points, uncertain features lead to more complex computations of covariance matrices, and result in higher runtimes compared to label uncertainty, where the covariance matrix remains real-valued. ", "page_idx": 40}, {"type": "image", "img_path": "v9RqRFSLQ2/tmp/f9fc30b1c92f80e48e0934bd1f26ba432ba448babee9b80e030e5ef5cc326716.jpg", "img_caption": ["Figure 12: ZORRO runtimes on MPG data. "], "img_footnote": [], "page_idx": 40}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 41}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 41}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 41}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 41}, {"type": "text", "text": "Justification: We state our contributions and scope in Sec. 1. ", "page_idx": 41}, {"type": "text", "text": "Guidelines: ", "page_idx": 41}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 41}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 41}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 41}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 41}, {"type": "text", "text": "Justification: We discuss the limitations of our approach in Sec. 5 and app. I and J. ", "page_idx": 41}, {"type": "text", "text": "Guidelines: ", "page_idx": 41}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 41}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 41}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 41}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 41}, {"type": "text", "text": "Justification: We provide intuitions in the main body of the paper (Sec. 3 and 4). We include the complete proofs in the appendix, and refer to them in the main body of the paper (App. F and H to J) ", "page_idx": 42}, {"type": "text", "text": "Guidelines: ", "page_idx": 42}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 42}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 42}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 42}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 42}, {"type": "text", "text": "Justification: Descriptions in the main body of the paper (Sec. 3 to 5), and the formulas and technical details in App. I and J are sufficient for reproducing our approach and experimental results. ", "page_idx": 42}, {"type": "text", "text": "Guidelines: ", "page_idx": 42}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 42}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 43}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 43}, {"type": "text", "text": "Justification: We share the anonymize Github repository containing the data and code in the paper. ", "page_idx": 43}, {"type": "text", "text": "Guidelines: ", "page_idx": 43}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 43}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 43}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 43}, {"type": "text", "text": "Justification: We describe the experiment settings in detail in Sec. 5. ", "page_idx": 43}, {"type": "text", "text": "Guidelines: ", "page_idx": 43}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 43}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 43}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 43}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 43}, {"type": "text", "text": "Justification: We repeat experiments with different random seeds and show the mean and standard deviation in the results. ", "page_idx": 43}, {"type": "text", "text": "Guidelines: ", "page_idx": 43}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 43}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 44}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 44}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 44}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 44}, {"type": "text", "text": "Justification: We describe the sufficient information on the computer resources in Sec. 5. Guidelines: ", "page_idx": 44}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 44}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 44}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 44}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 44}, {"type": "text", "text": "Justification: We reviewed the NeurIPS Code of Ethics and make sure the paper conforms with it. ", "page_idx": 44}, {"type": "text", "text": "Guidelines: ", "page_idx": 44}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 44}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 44}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 44}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 44}, {"type": "text", "text": "Justification: We discuss the broader impacts of our technique in Sec. 6. ", "page_idx": 44}, {"type": "text", "text": "Guidelines: \u2022 The answer NA means that there is no societal impact of the work performed. ", "page_idx": 44}, {"type": "text", "text": "\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 45}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 45}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 45}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 45}, {"type": "text", "text": "Justification: This paper has no such risk. Guidelines: ", "page_idx": 45}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 45}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 45}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 45}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 45}, {"type": "text", "text": "Justification: We credit all existing assests used in the paper, and include the license information in the reference. ", "page_idx": 45}, {"type": "text", "text": "Guidelines: ", "page_idx": 45}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 45}, {"type": "text", "text": "", "page_idx": 46}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 46}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 46}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 46}, {"type": "text", "text": "Justification: We provide documentations for the released anonymized code (Sec. 5). ", "page_idx": 46}, {"type": "text", "text": "Guidelines: ", "page_idx": 46}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 46}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 46}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 46}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 46}, {"type": "text", "text": "Justification: This paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 46}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 46}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 46}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 46}, {"type": "text", "text": "Answer: [NA] ", "text_level": 1, "page_idx": 46}, {"type": "text", "text": "Justification: This paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 46}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 46}, {"type": "text", "text": "", "page_idx": 47}]