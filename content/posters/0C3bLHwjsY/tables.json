[{"figure_path": "0C3bLHwjsY/tables/tables_6_1.jpg", "caption": "Table 1: A bad example used to show hardness results for any randomized and non-rejecting algorithms and the tightness of competitive analysis for SAMP.", "description": "This table presents a bad example to demonstrate the hardness results for randomized and non-rejecting algorithms in online matching problems under long-run fairness. It also illustrates the tightness of the competitive analysis of the SAMP algorithm.  The example involves a bipartite graph with multiple rare online types and a single common type, along with several offline agents each capable of serving only specific online types. This setup is designed to show that non-rejecting algorithms cannot achieve better than 1/2-competitiveness, while highlighting the near-optimal performance of SAMP in specific scenarios.", "section": "5 Proof of Theorem 2"}, {"figure_path": "0C3bLHwjsY/tables/tables_18_1.jpg", "caption": "Table 1: A bad example used to show hardness results for any randomized and non-rejecting algorithms and the tightness of competitive analysis for SAMP.", "description": "This table presents a specific example graph structure used in the paper's analysis to prove hardness results.  The graph is a bipartite graph representing an online matching problem with multiple 'rare types' of online agents and a 'common type'.  Each rare type can only be matched with a single offline server, while the common type can be matched with any server.  The table helps illustrate the limitations of non-rejecting policies and randomized policies and demonstrates the tightness of the algorithm SAMP's competitive ratio.  Arrival rates of the different online agent types are also specified to support the analysis.", "section": "5 Proof of Theorem 2"}, {"figure_path": "0C3bLHwjsY/tables/tables_19_1.jpg", "caption": "Algorithm 5: Alternate Algorithm that Pre-reserves Capacities (RESERVE)", "description": "The RESERVE algorithm first solves a linear program to determine the optimal allocation of offline agents to online types, then uses dependent rounding to create a randomized assignment of offline agents to online types. Finally, it uses a first-come-first-serve policy to match incoming online agents to their pre-assigned offline agents.", "section": "G.2 Algorithm RESERVE when All Online Types are Common"}]