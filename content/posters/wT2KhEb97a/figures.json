[{"figure_path": "wT2KhEb97a/figures/figures_3_1.jpg", "caption": "Figure 1: Runtime of APPR in the locally evolving set process on the com-dblp graph with s = 0, a = 0.1, and e = 1/m. The red region of the left figure is TAPPR. The right two figures show active ratios and vol(ST)/\u044d\u0442 \u2264 1/\u0454.", "description": "This figure shows the runtime of the Approximate Personalized PageRank (APPR) algorithm in a locally evolving set process.  The left panel displays the volume of the active set (St) over time, with the red area representing the total runtime of APPR. The middle panel shows the active ratio (yt) and the right panel displays the ratio of the average volume of active sets to the running average of the residual ratio (vol(ST)/\u012bT).  The figure demonstrates that the vol(ST)/\u012bT ratio is always less than 1/e, supporting the theoretical analysis in the paper.", "section": "3.1 Locally evolving set process"}, {"figure_path": "wT2KhEb97a/figures/figures_5_1.jpg", "caption": "Figure 2: Comparison of runtime between APPR and LocSOR (left) and runtime bounds (right) as a function of e. We used the same setting as in Fig. 1.", "description": "This figure compares the actual runtime of the APPR and LocSOR algorithms with their corresponding theoretical upper and lower bounds, all plotted as functions of the error tolerance (e). The left panel shows the actual runtimes, highlighting that LocSOR is significantly faster than APPR for a wide range of error tolerances. The right panel focuses on the theoretical bounds, comparing the upper and lower bounds derived in the paper with Anderson's existing upper bound. The plot illustrates how the paper's upper bound is tighter than Anderson's for small error tolerances, and its lower bound is very effective for larger error tolerances.", "section": "Faster local variant of GS-SOR"}, {"figure_path": "wT2KhEb97a/figures/figures_7_1.jpg", "caption": "Figure 2: Comparison of runtime between APPR and LocSOR (left) and runtime bounds (right) as a function of e. We used the same setting as in Fig. 1.", "description": "This figure compares the actual runtime of the Approximate Personalized PageRank (APPR) algorithm with that of the proposed Locally evolving set process based GS-SOR (LocSOR) algorithm, as a function of the error tolerance (e).  The left panel shows the number of operations required for both methods, while the right panel compares different theoretical runtime bounds (upper and lower bounds for both algorithms, as well as Anderson's upper bound).  The figure highlights the improved runtime of LocSOR compared to APPR, especially when e is relatively large. The results demonstrate the effectiveness of the new runtime bound derived in the paper.", "section": "Local Methods via Evolving Set Process"}, {"figure_path": "wT2KhEb97a/figures/figures_8_1.jpg", "caption": "Figure 4: The speedup of local solvers as a function of \u03b5. The vertical line is \u03b5 = 1/n.", "description": "This figure compares the runtime of standard and local solvers for different values of epsilon (\u03b5). The x-axis represents the epsilon value, and the y-axis is the speedup, which is calculated as the ratio of the standard solver's runtime to the local solver's runtime.  The vertical line at \u03b5 = 1/n highlights a significant performance difference. The graph shows that the local solvers (LocGD, LocSOR, LOCHB, LOCCH) are significantly faster than their standard counterparts (GD, SOR, HB, CH), particularly when \u03b5 is close to 1/n. This demonstrates that the local solvers are significantly more efficient when the precision requirements are high.", "section": "Experiments"}, {"figure_path": "wT2KhEb97a/figures/figures_8_2.jpg", "caption": "Figure 2: Comparison of runtime between APPR and LocSOR (left) and runtime bounds (right) as a function of e. We used the same setting as in Fig. 1.", "description": "This figure compares the actual runtime of APPR and LocSOR with their theoretical runtime bounds. The left panel shows the actual number of operations performed by APPR and LocSOR for different values of epsilon (error tolerance), while the right panel shows the theoretical upper and lower bounds on the runtime of the algorithms as a function of epsilon. The results show that LocSOR is significantly faster than APPR, and that its actual runtime closely matches the theoretical lower bound. The figure also highlights the superiority of the proposed algorithm over existing local methods.", "section": "3 Local Methods via Evolving Set Process"}, {"figure_path": "wT2KhEb97a/figures/figures_8_3.jpg", "caption": "Figure 2: Comparison of runtime between APPR and LocSOR (left) and runtime bounds (right) as a function of e. We used the same setting as in Fig. 1.", "description": "This figure compares the actual runtimes of the Approximate Personalized PageRank (APPR) algorithm and the proposed Localized Successive Overrelaxation (LocSOR) algorithm against theoretical runtime bounds.  The left panel shows the runtime in terms of the number of operations for both algorithms as a function of the precision tolerance (e). The right panel visualizes the upper and lower runtime bounds derived in the paper in relation to the tolerance (e) and the actual number of operations performed. This comparison demonstrates the improved efficiency of LocSOR, particularly when e is relatively small.", "section": "3 Local Methods via Evolving Set Process"}, {"figure_path": "wT2KhEb97a/figures/figures_46_1.jpg", "caption": "Figure 2: Comparison of runtime between APPR and LocSOR (left) and runtime bounds (right) as a function of e. We used the same setting as in Fig. 1.", "description": "This figure compares the actual runtime of APPR and LocSOR with their theoretical upper and lower bounds for varying values of epsilon (e).  The left panel shows a comparison of actual runtimes on a specific graph, highlighting the significant speedup achieved by LocSOR over APPR. The right panel visualizes the theoretical bounds, illustrating how the new bounds presented in the paper are tighter than existing bounds, especially for small values of epsilon.", "section": "Local Methods via Evolving Set Process"}, {"figure_path": "wT2KhEb97a/figures/figures_46_2.jpg", "caption": "Figure 8: The speedup of local solvers compared with their standard counterparts.", "description": "The figure shows the speedup achieved by using local solvers (LocGD, LocSOR, LocHB, and LOCCH) compared to their standard counterparts (GD, SOR, HB, and CH).  The speedup is calculated as the ratio of the runtime of the standard solver to the runtime of the corresponding local solver. The x-axis represents the error tolerance (epsilon), and the y-axis represents the speedup. The results demonstrate that local solvers can significantly accelerate the computation, especially when epsilon is close to 1/n. This highlights the effectiveness of localization in improving efficiency.", "section": "Experiments"}, {"figure_path": "wT2KhEb97a/figures/figures_47_1.jpg", "caption": "Figure 2: Comparison of runtime between APPR and LocSOR (left) and runtime bounds (right) as a function of e. We used the same setting as in Fig. 1.", "description": "This figure compares the actual runtime of APPR and LocSOR with their theoretical runtime bounds as a function of the error tolerance (e).  It shows that the new upper bound for LocSOR is tighter than the existing upper bound for APPR, particularly when e is small. The lower bounds for both are more effective when e is relatively large.  The plot highlights the improvement in runtime efficiency offered by LocSOR compared to APPR, especially in low-error scenarios.", "section": "3 Local Methods via Evolving Set Process"}, {"figure_path": "wT2KhEb97a/figures/figures_47_2.jpg", "caption": "Figure 2: Comparison of runtime between APPR and LocSOR (left) and runtime bounds (right) as a function of e. We used the same setting as in Fig. 1.", "description": "This figure compares the actual runtime of the APPR algorithm with that of the LocSOR algorithm.  It also displays the upper and lower bounds calculated for the runtime of these algorithms as a function of the error tolerance (e). The left graph shows how the runtime differs between APPR and LocSOR; the right graph shows the theoretical upper and lower bounds for the runtime of APPR and illustrates how the proposed upper bound compares to the existing upper bound from the literature.", "section": "Local Methods via Evolving Set Process"}, {"figure_path": "wT2KhEb97a/figures/figures_48_1.jpg", "caption": "Figure 2: Comparison of runtime between APPR and LocSOR (left) and runtime bounds (right) as a function of e. We used the same setting as in Fig. 1.", "description": "This figure compares the actual runtime of the APPR and LocSOR algorithms with their theoretical upper and lower bounds as a function of the error tolerance (e).  The left panel shows the actual number of operations, while the right panel shows the corresponding bounds.  It demonstrates that the proposed LocSOR algorithm significantly outperforms the existing APPR approach for smaller values of e, aligning with the theoretical predictions.", "section": "3 Local Methods via Evolving Set Process"}, {"figure_path": "wT2KhEb97a/figures/figures_48_2.jpg", "caption": "Figure 2: Comparison of runtime between APPR and LocSOR (left) and runtime bounds (right) as a function of e. We used the same setting as in Fig. 1.", "description": "This figure compares the actual runtime of the Approximate Personalized PageRank (APPR) algorithm and the proposed Localized Successive Overrelaxation (LocSOR) algorithm. The left panel shows the performance of APPR and LocSOR for different values of epsilon (error tolerance), while the right panel shows the theoretical upper and lower bounds for the runtime of both algorithms. The results demonstrate that LocSOR achieves significantly better runtime compared to APPR, particularly for smaller values of epsilon.  The figure also shows that the new theoretical bounds developed in the paper accurately reflect the performance of the algorithm.", "section": "Faster local variant of GS-SOR"}, {"figure_path": "wT2KhEb97a/figures/figures_49_1.jpg", "caption": "Figure 13: Estimation error as a function of operations needed. For \u03b1 = 0.005, \u03b1 = 0.1, and \u03b1 = 0.25.", "description": "This figure compares the estimation error (in terms of log10 scale of ||x(T) - x*||1) against the number of operations for different values of the damping factor \u03b1 (0.005, 0.1, and 0.25) on two large graphs: ogbl-ppa and ogbn-products.  It showcases the performance of several localized iterative methods, including LocGD, LocSOR, LOCHB, and LOCCH. The results indicate how the number of operations required to achieve a certain estimation error varies across different methods and damping factors.", "section": "Experiments"}, {"figure_path": "wT2KhEb97a/figures/figures_49_2.jpg", "caption": "Figure 14: The graph conductance found by local graph clustering method using different local approximate methods. Experiments ran on 15 graphs. (\u20ac = 10\u207b\u2076)", "description": "This figure displays the graph conductance achieved by various local clustering methods across 15 different graphs.  The conductance is a measure of how well-connected a cluster is, with lower values indicating stronger connectivity.  The methods compared include APPR, LocCH, LocHB, LocSOR, ISTA, and FISTA. The figure illustrates the performance of each method in identifying clusters with low conductance.  It provides a visual comparison of the effectiveness of the different local clustering algorithms.", "section": "Experiments"}, {"figure_path": "wT2KhEb97a/figures/figures_52_1.jpg", "caption": "Figure 15. Comparison of the error reduction between the proposed LoCCH and the standard CGM on the papers100M dataset [23], in terms of the number of operations required.", "description": "This figure compares the error reduction performance of the proposed LOCCH algorithm against the standard CGM algorithm on the papers100M dataset.  The x-axis represents the number of operations needed, and the y-axis represents the logarithm of the error (||x\u0302-x*||1). The plot shows that LoCCH achieves a significantly faster error reduction than CGM, demonstrating its efficiency in solving large-scale linear systems.", "section": "G Related work"}]