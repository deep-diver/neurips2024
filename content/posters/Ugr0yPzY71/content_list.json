[{"type": "text", "text": "Faster Repeated Evasion Attacks in Tree Ensembles ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Lorenzo Cascioli Laurens Devos Department of Computer Science Department of Computer Science KU Leuven KU Leuven Leuven, Belgium Leuven, Belgium lorenzo.cascioli@kuleuven.be ", "page_idx": 0}, {"type": "text", "text": "Ondrej Kuzelka Faculty of Electrical Engineering Czech Technical University in Prague Prague, Czech Republic ", "page_idx": 0}, {"type": "text", "text": "Jesse Davis Department of Computer Science KU Leuven Leuven, Belgium ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Tree ensembles are one of the most widely used model classes. However, these models are susceptible to adversarial examples, i.e., slightly perturbed examples that elicit a misprediction. There has been significant research on designing approaches to construct such examples for tree ensembles. But this is a computationally challenging problem that often must be solved a large number of times (e.g., for all examples in a training set). This is compounded by the fact that current approaches attempt to find such examples from scratch. In contrast, we exploit the fact that multiple similar problems are being solved. Specifically, our approach exploits the insight that adversarial examples for tree ensembles tend to perturb a consistent but relatively small set of features. We show that we can quickly identify this set of features and use this knowledge to speedup constructing adversarial examples. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "One of the most popular and widely used classes of models is tree ensembles which encompasses techniques such as gradient boosting [16] and random forests [3]. However, like other flexible model classes such as (deep) neural networks [28, 17], they are susceptible to evasion attacks [23]. That is, an adversary can craft an imperceptible perturbation that, when applied to an otherwise valid input example, elicits a misprediction by the ensemble. As an example, consider a bank that uses a learned model to assess whether to approve or deny loan applications. In this setting, an evasion attack could entail slightly altering a potential customer\u2019s data (e.g., adding one month to their work seniority) that results in the model making a different decision on the customer\u2019s application. The slightly modified customer record is an adversarial example. There is significant interest in reasoning about tree ensembles to both generate such adversarial examples [15, 36] and perform empirical robustness checking [23, 8, 10] where the goal is to determine how close the nearest adversarial example is. ", "page_idx": 0}, {"type": "text", "text": "Generating adversarial examples is an NP-hard problem [23], which has spurred the development of approximate techniques [8, 36, 10]. These methods exploit the structure of the trees to find adversarial examples faster, e.g., by using graph transformations [8] or discrete (heuristic) search [36, 10, 12]. Still, these techniques can be slow, particularly if there is a large number of attributes in the domain. This is compounded by the fact that one often wants to generate large sets of adversarial examples. ", "page_idx": 0}, {"type": "text", "text": "A weakness to existing approaches is that they ignore the fact that adversarial example generation is often a sequential task where multiple similar problems are being solved in a row. That is, one has access to a large number of \u201cnormal\u201d examples each of which should be perturbed to elicit a misprediction. Alas, existing approaches treat each considered example in isolation and solve the problem from scratch. However, there are likely regularities among the problems, meaning that the algorithms perform redundant work. If these regularities can be identified efficiently and this information can be exploited to guide the search for an adversarial example, then the run time performance of repeated adversarial example generation can be improved. ", "page_idx": 0}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "Studying these regularities in order to make adversarial example generation faster is an important problem. First, it advances our understanding of the nature of adversarial examples in tree ensembles and their generation methods. This might inspire improvements to generation methods, and in turn lead to better defense or detection methods. Second, model evaluation by verification [26, 29, 10] is quickly becoming important as machine learning is applied in sensitive application areas. Being able to efficiently generate adversarial examples is crucial for computing empirical robustness (e.g., [10]), adversarial accuracy (e.g., [32]), and for model hardening (e.g., [23]). Third, some scenarios exist where an attacker would want to perform a large scale evasion attack. For example, some DNS registries use models to flag new domain registrations as potentially malicious (e.g., for phishing, fake webshops) [27] and scammers likely need to register many such domains. Finally, techniques in the planning community for analyzing policy safety through predicate abstraction involve performing repeated verification queries on the same model [30, 31, 22]. ", "page_idx": 1}, {"type": "text", "text": "We propose a novel approach that analyzes previously solved adversarial example generation tasks to inform the search for subsequent tasks. Our approach is based on the observation that for a fixed learned tree ensemble, adversarial examples tend to be generated by perturbing the same, relatively small set of features. We propose a theoretically grounded manner to quickly find this set of features. We then propose two novel strategies to use the identified features to guide the search for adversarial examples, one of which is guaranteed to produce an adversarial example if it exists. We apply our proposed approach to two different algorithms for generating adversarial examples [23, 10]. Empirically, our approaches result in speedups of up to $36\\mathrm{x}/21\\mathrm{x}$ and on average of $9\\mathrm{x}/4\\mathrm{x}\\;(\\pm\\;8\\mathrm{x}/3\\mathrm{x})$ . The source code for the presented algorithms and all the experiments is publicly available at https: //github.com/lorenzocascioli/faster-repeated-evasion-tree-ensembles. ", "page_idx": 1}, {"type": "text", "text": "2 Preliminaries ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "We briefly explain tree ensembles, evasion attacks, and the two adversarial generation methods used in the experiments. We assume a $d$ -dimensional input space $\\mathcal{X}\\subseteq\\mathbb{R}^{d}$ and binary output space ${\\boldsymbol{y}}\\,=\\,\\{-1,1\\}$ . We focus on binary classification because most existing methods for generating adversarial examples for tree ensembles are designed for this setting [1, 23, 10]. ", "page_idx": 1}, {"type": "text", "text": "Tree Ensembles Tree ensembles include algorithms such as (gradient) boosted decision trees (GBDTs) [16, 9] and random forests [3, 25]. A tree ensemble contains a number of trees and most implementations only learn binary trees. A binary tree $T$ contains two types of nodes. Internal nodes store references to a left and a right sub-tree, and a split condition on some attribute $f$ in the form of a less-than comparison $X_{f}<\\tau$ , where $\\tau$ is the split value. Leaf nodes have no children and only contain an output value. Each tree starts with a root node, the only one without a parent. ", "page_idx": 1}, {"type": "text", "text": "Given an example $x$ , an individual tree is evaluated recursively starting from the root node. In each internal node, the split condition is applied and if it is satisfied, then the example is sorted to the left subtree and if not it is sorted to the right one. This procedure terminates when a leaf node is reached. The final prediction of the ensemble $\\pmb{T}(\\boldsymbol{x})$ is obtained by combining the predicted leaf values for each tree in the ensemble. In gradient boosting, the class probability is computed by applying a sigmoid transformation to the sum of the leaf values. ", "page_idx": 1}, {"type": "text", "text": "Evasion Attacks An evasion attack involves manipulating valid inputs $x$ into adversarial examples $\\tilde{x}$ in order to elicit a misprediction [23]. Following existing work on tree ensembles [23, 7, 10], we say that $\\tilde{x}$ is an adversarial example for normal example $x$ when (1) $\\|\\tilde{x}-x\\|_{\\infty}<\\delta$ where $\\delta$ is a user-selected maximum distance (i.e., the two are sufficiently close), (2) the ensemble predicts the correct label for $x$ , and (3) the model\u2019s predicted labels for $\\tilde{x}$ and $x$ differ. ", "page_idx": 1}, {"type": "text", "text": "We briefly describe the two existing adversarial example generation methods $A:(T,x,\\delta,t_{\\operatorname*{max}})\\rightarrow$ $\\{S A T(\\tilde{x}),\\,U N S A T,\\,T I M E O U T\\}$ used in this paper: kantchelian [23] and veritas [10]. These methods take as input an ensemble $_T$ , a normal example $x$ , a maximum perturbation size $\\delta$ , and a timeout $t_{\\mathrm{max}}$ . They output $S A T(\\tilde{x})$ , where $\\tilde{x}$ is an adversarial example for $x$ , $U N S A T$ , indicating that no adversarial example exists, or $T I M E O U T$ , indicating that no result could be found within $t_{\\mathrm{max}}$ . Timeouts are explicitly handled because adversarial example generation is NP-hard [23]. ", "page_idx": 1}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "kantchelian formulates the adversarial example generation task as a mixed-integer linear program (MILP) and uses a generic MILP solver (e.g., Gurobi [20]). Specifically, kantchelian directly minimizes the $\\delta=\\|\\bar{\\boldsymbol{x}}-\\boldsymbol{\\tilde{x}}\\|_{\\infty}$ value. Given an example $x$ , it computes: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\operatorname*{min}_{\\tilde{x}}\\left\\|x-{\\tilde{x}}\\right\\|_{\\infty}\\quad{\\mathrm{subject~to}}\\quad T(x)\\neq T({\\tilde{x}}).\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "This approach exploits the fact that a tree ensemble can be viewed as a set of linear (in)equalities. Three sets of MILP variables are used. Predicate variables $p_{i}$ represent the split conditions, i.e., each $p_{i}$ logically corresponds to a split on an attribute $f$ $:p_{i}\\equiv f<\\tau$ . Leaf variables $l_{i}$ indicate whether a leaf node is active. The bound variable $b$ represents the $l_{\\infty}$ distance between the original example $x$ and the adversarial example $\\tilde{x}$ . Constraints between the variables encode the structure of the tree. A set of predicate consistency constraints encode the ordering between splits. For example, if two split values $\\tau_{1}<\\tau_{2}$ appear in the tree for attribute $f$ , and $p_{1}\\equiv f<\\tau_{1}$ and $p_{2}\\equiv f<\\tau_{2}$ , then $p_{1}\\implies p_{2}$ Leaf consistency constraints enforce that a leaf is only active when the splits on the root-to-leaf path to that leaf are satisfied. Lastly, the mislabel constraint requires the output to be a certain class: for leaf values $v_{i}$ $_{i},\\sum_{i}v_{i}l_{i}\\leqslant0$ . The objective directly minimizes the bound variable. ", "page_idx": 2}, {"type": "text", "text": "veritas improves upon kantchelian in terms of run time by formulating the adversarial example generation problem as a heuristic search problem in a graph representation of the ensemble (originally proposed by [8]). The nodes in this graph correspond to the leaves in the trees of the ensemble. Guided by a heuristic, the search then repeatedly selects compatible leaves. Leaves of two different trees are compatible when the conjunction of the split conditions along the root-to-leaf paths of the leaves are logically consistent. For a given $\\delta$ , veritas solves the following optimization problem:1 ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\operatorname{optimize}_{\\tilde{x}}\\ T(\\tilde{x})\\quad\\mathrm{subject\\;to}\\quad\\left\\|x-\\tilde{x}\\right\\|_{\\infty}<\\delta\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "The output of the model $\\pmb{T}(\\tilde{x})$ is maximized when the target class for $\\tilde{x}$ is positive, and minimized otherwise. While veritas can also directly optimize $\\delta$ , in this paper we will use a predefined $\\delta$ for veritas. To the best of our knowledge, veritas is the fastest approximate evasion attack for tree ensembles (see Appendix B.1). ", "page_idx": 2}, {"type": "text", "text": "3 Method ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Adversarial example generation methods are often applied in the following setting: ", "page_idx": 2}, {"type": "text", "text": "Given a tree ensemble $\\textbf{\\emph{T}}$ , a set of test examples $\\mathcal{D}$ , and a maximum perturbation size $\\delta$ Generate adversarial examples for each $x\\in\\mathcal{D}$ . ", "page_idx": 2}, {"type": "text", "text": "The goal of this paper is to exploit the fact that adversarial examples are sequentially generated for each example in $\\mathcal{D}$ . By analyzing previously found adversarial examples, we aim to improve the efficiency of adversarial example generation algorithms by biasing the search towards the perturbations that are most likely to lead to an adversarial example. ", "page_idx": 2}, {"type": "text", "text": "Our hypothesis is that some parts of the ensemble are disproportionately sensitive to small perturbations, i.e., crossing the thresholds of split conditions in these parts of the ensemble results in large changes in the predicted value. Prior work has hypothesized that robustness is related to fragile features and that such features are included in models because learners search for any signal that improves predictive performance [21]. One would expect that the attributes used in the split conditions in these disproportionately sensitive parts are exploited by adversarial examples more frequently than other attributes. Figure 1 illustrates this point by showing how often each attribute is perturbed in a set of a 10 000 adversarial examples generated by kantchelian for two datasets. The bar plots distinguish among attributes are (1) never modified by any adversarial example (left), (2) modified by at least one but at most $5\\%$ of all adversarial examples (middle), and (3) modified by more than $5\\%$ of the adversarial examples (right). Less than $10\\%$ of the attributes are used by more than $5\\%$ of the adversarial examples. The figure shows that regularities exist in constructed adversarial examples: examples generated for different normal examples tend to exhibit perturbations to the same small set of attributes. Thus the two questions are how can one identify these frequently-modified attributes and how can algorithms exploit this knowledge to more quickly generate adversarial examples. ", "page_idx": 2}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/f080c91f4f341500d7346b9b2c0a6e17d1409387824b6cbefcd62fcb5405a257.jpg", "img_caption": [""], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "Figure 1: Bar plots showing that most attributes are not modified by the majority of adversarial examples on the mnist and webspam datasets. The leftmost bar shows the number of attributes that are never changed by any of the 10 000 adversarial examples generated by kantchelian\u2019s approach. The middle bar shows the number of attributes that are modified at least once but at most by $5\\%$ of the adversarial examples. The rightmost bar shows the number of frequently modified features. ", "page_idx": 3}, {"type": "text", "text": "Our proposed approach has two parts. The first part simplifies the search for adversarial examples by only allowing perturbations to a limited subset of features. Namely, we exploit the knowledge that certain feature values are fixed to simplify the ensemble, by pruning away branches that can never be reached. The second part identifies a subset of commonly perturbed features by counting how often each feature is perturbed by adversarial examples. The size of this subset is determined by applying a theoretically grounded statistical test. ", "page_idx": 3}, {"type": "text", "text": "3.1 Modifying the Search Procedure ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Our proposed approach speeds up the adversarial example generation procedure by limiting the scope of the adversarial perturbations to a subset of features $F_{S}$ . This section assumes that we are given such a subset of features. The next section covers how to identify these features. ", "page_idx": 3}, {"type": "text", "text": "We consider three settings: full, pruned, and mixed. The full setting is the original configuration of kantchelian and veritas: the methods may perturb any attribute within a certain maximum distance $\\delta$ That is, for each attribute $f\\in F$ with value $x_{f}$ , the attribute values are limited to $[x_{f}-\\delta,x_{f}+\\delta]$ . Algorithm 1 summarizes the pruned and mixed approaches. We now describe both in greater detail. ", "page_idx": 3}, {"type": "text", "text": "Algorithm 1 Fast repeated adversarial example generation   \n1: parameters: maximum perturbation size $\\delta$ , timeouts $t_{\\mathrm{max}}^{f u l l}$ and $t_{\\mathrm{max}}^{p r u n}$ for full and pruned, genera  \ntion method $\\mathcal{A}:(\\mathbf{{\\cal{T}}},x,\\delta,t)\\rightarrow\\{S A T(\\tilde{x})$ , UNSAT, TIMEOUT}   \n2: function GENERATE $(T_{f u l l},\\mathcal{D},F_{S}$ , mixed flag)   \n3: $\\tilde{\\mathcal{D}}\\gets\\emptyset$   \n4: for $x\\in\\mathcal{D}$ do   \n5: $T_{p r u n}\\gets\\mathrm{PRUNE}\\left(T_{f u l l},F_{S},x\\right)$ (Sec. 3.1)   \n6: $\\dot{\\alpha^{}}\\!\\gets\\!A\\left(T_{p r u n},x,\\delta,t_{\\operatorname*{max}}^{p r u n}\\right)$   \n7: if $\\alpha\\neq S A\\bar{T}(\\tilde{x})$ \u2227mixed flag set then   \n8: $\\alpha\\leftarrow{A\\left(\\mathbf{{T}}_{f u l l},x,\\delta,t_{\\operatorname*{max}}^{f u l l}\\right)}$   \n9: end if   \n10: D\u02dc \u2190D\u02dc \u222a{\u03b1}   \n11: end for   \n12: return: $\\tilde{\\mathcal{D}}$   \n13: end function ", "page_idx": 3}, {"type": "text", "text": "Pruned Approach The pruned setting disallows modifications to the attributes in the non-selected set of attributes $F_{N S}\\,=\\,F\\,\\backslash\\,F_{S}$ . We accomplish this by pruning the trees in the ensemble. Any node splitting on attributes in $F_{N S}$ is removed. Its parent node is directly connected to the only child node that can be reached by examples with the fixed value for the attribute. Figure 2 shows an example of this procedure. We refer to this procedure as $\\operatorname{PRUNE}(\\mathbf{\\cal{T}},F_{S},x)$ . The adversarial example generation methods can be applied as normal to the pruned ensemble, but they will only generate adversarial examples with perturbations to the attributes in $F_{S}$ . Pruning simplifies the MILP problem of kantchelian because all predicate variables $p_{i}$ that correspond to splits in internal nodes of pruned ", "page_idx": 3}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/599e29bea709e68059f7823c43f98a19346c3a740073ff4c066d78bc9377c08f.jpg", "img_caption": [], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "Figure 2: An example tree using two attributes HEIGHT and AGE (left). Suppose $F_{N S}=\\{\\mathrm{AGE}\\}$ . Given an example where $\\mathrm{AGE}=55\\$ , we can prune away the internal node splitting on AGE. In the resulting tree (right), subtree (b) is pruned because it is unreachable given that $\\mathrm{AGE}=55\\$ and only subtrees (a) and (c) remain. ", "page_idx": 4}, {"type": "text", "text": "subtrees, and leaf variables $l_{i}$ that correspond to leaves of pruned subtrees can be removed from the mathematical formulation. For veritas, the search space is reduced in size because the pruned leaves are removed from the graph representation of the ensemble. Hence, for both systems, on average, the problem difficulty is reduced by pruning the ensembles. ", "page_idx": 4}, {"type": "text", "text": "Pruning the trees does not affect the validity of generated adversarial examples: if $\\tilde{x}$ is an adversarial example for a normal example $x$ generated on a pruned ensemble, then $\\tilde{x}$ is also an adversarial example for the full ensemble. ", "page_idx": 4}, {"type": "text", "text": "Proposition 3.1. Given normal example $x$ that is correctly classified by the full ensemble $\\textbf{\\em T}_{f u l l}$ . Let $T_{p r u n}\\,=\\,\\mathrm{PRUNE}(T_{f u l l},F_{S},x)$ and $\\tilde{x}=A(T_{p r u n},x,\\delta,t_{\\operatorname*{max}})$ (i.e., $T_{p r u n}(x)\\neq T_{p r u n}(\\tilde{x})$ and $\\|x-\\mathbf{\\bar{\\hat{x}}}\\|_{\\infty}<\\delta)$ . Then it holds that $T_{f u l l}(x)\\neq T_{f u l l}(\\tilde{x})$ . ", "page_idx": 4}, {"type": "text", "text": "Proof. Because only branches not visited by $x$ are removed, $T_{p r u n}(x)=T_{f u l l}(x)$ . The values for features in $F_{N S}$ are fixed, so these values are equal between $x$ and $\\tilde{x}$ . Hence, $\\tilde{x}$ only visits branches in $\\textbf{\\em T}_{f u l l}$ that are also in $T_{p r u n}$ . Therefore, $T_{p r u n}\\bar{(x)}=T_{f u l l}(\\tilde{x})$ . \u53e3 ", "page_idx": 4}, {"type": "text", "text": "However, an $U N S A T$ generated on a pruned ensemble is inconclusive: it might still be the case that an adversarial example exists for the full ensemble, albeit one with perturbations to features in $F_{N S}$ . The pruned setting generates a false negative if it reports $U N S A T$ , yet the full setting reports $S A T$ . ", "page_idx": 4}, {"type": "text", "text": "Mixed Approach The mixed setting takes advantage of the fast adversarial generation capabilities of the pruned setting, but falls back to the full setting when the pruned setting returns an UNSAT or times out. A much stricter timeout $t_{\\mathrm{max}}^{p r u n}$ is used for the pruned setting to fully take advantage of the fast $S A T s$ , while avoiding spending time on an uninformative UNSAT. The mixed setting is guaranteed to find an adversarial example if the full setting can find one. ", "page_idx": 4}, {"type": "text", "text": "Theorem 3.2. Assume a normal example x and maximum distance \u03b4. If an adversarial example can be found for the full ensemble $T_{f u l l}$ , then the mixed setting is guaranteed to find an $\\tilde{x}$ such that $\\|{\\boldsymbol x}-{\\boldsymbol\\tilde{x}}\\|_{\\infty}<\\delta$ and ${\\pmb T}_{f u l l}(x)\\neq{\\pmb T}_{f u l l}(\\dot{\\tilde{x}})$ . ", "page_idx": 4}, {"type": "text", "text": "Proof. The mixed setting first operates on the pruned ensemble $\\pmb{T}_{p r u n}$ using a tight timeout and optimizes Equation 1 or 2 using kantchelian or veritas respectively. This returns (1) an adversarial example $\\tilde{x}$ , (2) an $U N S A T$ or (3) times out. In case (1), the generated adversarial example $\\tilde{x}$ is also an adversarial example for the full ensemble (Prop 3.1). In cases (2) and (3), the mixed setting falls back to the full setting operating on the full ensemble $T_{f u l l}$ with the same timeout. Hence, it inherits the full method\u2019s guarantees. \u53e3 ", "page_idx": 4}, {"type": "text", "text": "3.2 Identifying Relevant Features ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "A good subset of relevant attributes $F_{S}$ should satisfy two properties. First, it should minimize the number of false negatives, which occur when the pruned approach reports $U N S A T$ , but the full approach reports $S A T$ . Second, the feature subset should be small. The smaller $F_{S}$ is, the more the ensemble can be pruned, and the larger the speedup is. These two objectives are somewhat in tension. Including more features will reduce the number of false negatives but limit the speedups, whereas using a very small subset will restrict the search too much resulting in many false negatives (or slow calls to the full search in the mixed setting). The procedure is given in Algorithm 2. ", "page_idx": 4}, {"type": "text", "text": "We address the first requirement by adding features to the subset that are frequently perturbed by adversarial examples. We rank features by counting how often each one differs between the perturbed adversarial examples in $\\tilde{\\mathcal{D}}$ so far and their corresponding normal examples in $\\mathcal{D}$ . ", "page_idx": 5}, {"type": "text", "text": "The second requirement is met by statistically testing whether the identified subset guarantees that the false negative rate is smaller than a given threshold $\\tau$ with probability at least $1-\\eta$ , for a specified confidence parameter $\\eta$ . If it is not guaranteed, then the subset is expanded. This is done at most 4 times for subsets of $5\\%$ , $10\\%$ , $20\\%$ , $30\\%$ of the features (EXPANDFEATURESET $(F_{S},\\mathcal{D},\\tilde{D})$ in Algorithm 2). If all tests fail, then a final feature subset of $40\\%$ of the most commonly modified features is used. We do not go beyond $40\\%$ because using the full feature set is then more efficient. Each test is executed on a small set of $n$ generated adversarial examples. A first zeroth set is used merely for obtaining the first feature counts. ", "page_idx": 5}, {"type": "text", "text": "The statistical tests are performed as follows. The null hypothesis is that FNR is greater than the threshold $\\tau$ . Take ${\\mathcal D}_{F}\\,=\\,\\left(x_{1},x_{2},.\\perp.\\cdot,x_{N}\\right)$ the dataset we use to find the feature subset $F_{S}$ . We define $\\mathbf{v}\\,=\\,(v_{1},v_{2},\\ldots,v_{N})$ to be the binary vector such that $v_{i}~=~1$ if the pruned search with the feature subset $F_{S}$ returns $U N S A T$ for the example $x_{i}$ but the full search returns $S A T$ , $\\begin{array}{r}{F N R=\\frac{1}{N}\\sum_{i=1}^{N}v_{i}}\\end{array}$ $v_{i}\\,=\\,0$ .i sTeh. e Tshmeanl lt sheet  torfu $n$ feaxlsaem npelegsa tfirvoe mr awteh iccohr rwesep aorne deisntgi mtoa $F_{S}$ tchaen  fbales ew rniettgeanti vaes rate is a random vector $\\mathbf{X}=(X_{1},X_{2},\\ldots,X_{n})$ sampled without replacement from $\\mathcal{D}_{F}$ . We also define $\\mathbf{V}=(V_{1},V_{2},\\ldots,V_{n})$ where $V_{i}$ is the binary random variable defined analogically to how we defined $v_{i}$ . It follows that $\\textstyle\\sum_{i=1}^{n}V_{i}$ is distributed as a hypergeometric random variable. We use the method of inversion of acceptance intervals to find a one-sided confidence interval $[0;\\Delta]$ for the false negative rate with confidence level equal to a given $1-\\eta$ (see, e.g., Section 5.2 in [2]), exploiting the fact that the cumulative distribution function of a hypergeometric distribution can be computed efficiently (CONFIDENCEINTERVAL $(\\bar{v},n,\\eta)$ in Algorithm 2). We reject the null hypothesis if the confidence interval does not contain the threshold $\\tau$ . It follows from the basic properties of confidence intervals that this yields the desired test with confidence $1-\\eta$ . Since we execute the test 4 times in the algorithm, we apply a union-bound correction of factor 4 (we use confidence level 0.9). Note that there is a trade-off. The higher $n$ , the better the statistical estimates and the counts are, but also the more examples we process with a potentially suboptimal feature subset. ", "page_idx": 5}, {"type": "text", "text": "Algorithm 2 Find feature subset   \n1: parameters: set of normal examples $\\mathcal{D}$ , sample size $n$ , acceptable false negative rate $\\tau$ , confi  \ndence parameter $\\eta$   \n2: $F_{S}\\gets\\emptyset$   \n3: for $k\\in0..4$ do   \n4: $\\tilde{\\mathcal{D}}\\gets\\mathrm{GENERATE}(\\pmb{T},\\mathcal{D}[k n,k(n+1)],F_{S},t r$ ue)   \n5: $\\begin{array}{r}{\\bar{v}\\leftarrow\\frac{1}{n}\\times}\\end{array}$ number of false negatives in $\\tilde{\\mathcal{D}}$   \n6: $[0;\\Delta]\\leftarrow$ CONFIDENCEINTERVAL $(\\bar{v},n,\\eta)$   \n7: if the threshold $\\tau$ is in $[0;\\Delta]$ , then EXPANDFEATURESET $(F_{S},\\mathcal{D},\\tilde{D})$   \n8: else break the loop   \n9: end for   \n10: return: $F_{S}$ ", "page_idx": 5}, {"type": "text", "text": "4 Experiments ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Empirically, we address three questions: (Q1) Is our approach able to improve the run time of generating adversarial examples? (Q2) How does ensemble complexity affect our approach\u2019s performance? (Q3) What is our empirical false negative rate? ", "page_idx": 5}, {"type": "text", "text": "Because the described procedure is based on identifying a subset of relevant features, it makes sense to exploit it only when the dataset has a large number of dimensions. Therefore, we present numerical experiments for ten binary classification tasks on high-dimensional datasets, using both tabular data and image data, as shown in Table 1. ", "page_idx": 5}, {"type": "text", "text": "Experimental Setup We apply 5-fold cross validation for each dataset. We use four of the folds to train an XGBoost [9], random forest [3, 25] or GROOT forest (a robustified ensemble type [32]) ", "page_idx": 5}, {"type": "text", "text": "ensemble $_T$ . From the test set, we randomly sample 10 000 normal examples and attempt to generate adversarial examples by perturbing each one using the kantchelian or veritas attack. Table 1 also reports the adopted values of maximum perturbation $\\delta$ and the hyperparameters of the learned ensembles, which were selected via tuning using the grid search described in Appendix B. The experiments were run on an Intel(R) E3-1225 CPU with 32GiB of memory. ", "page_idx": 6}, {"type": "text", "text": "Table 1: Datasets\u2019 characteristics: $N$ and $\\#F$ are the number of examples and the number of features. higgs and prostate are random subsets of the original, bigger datasets. Multi-class classification datasets were converted to binary classification: for covtype we predict majority-vs-rest, for mnist and fmnist we predict classes 0-4 vs. classes 5-9, and for sensorless classes 0-5 vs. classes 6-10. We also report adopted values of max allowed perturbation $\\delta$ and learners\u2019 tuned hyperparameters after the grid search described in Appendix B. Each ensemble $\\textbf{\\emph{T}}$ has maximum tree depth d and contains M trees. The learning rate for XGBoost is $\\eta$ . GROOT robustness is defined by $\\epsilon$ . ", "page_idx": 6}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/a5f4626931324972ca00f3235218449bc0e31c44e838e753aa6ebc7e3c675724.jpg", "table_caption": [], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "The pruned and mixed settings work as follows. We use the procedure from Section 3.2 to select a subset of relevant features. We use $\\tau=0.25$ , $n=100$ and $\\eta=0.1$ . We then apply Algorithm 2: we generate 5 sets of $n$ adversarial examples to (1) find which features are perturbed most often and (2) determine the size of the feature subset $F_{S}$ . Therefore the extracted feature set gives us a $1\\!-\\!\\eta=90\\%$ confidence that our true false negative rate is below $25\\%$ . After Algorithm 2 terminates, $F_{S}$ is fixed, and we run the pruned and mixed settings on all the remaining test examples (Algorithm 1). We set a timeout of one minute for the full setting, and a much stricter timeout of 1 (kantchelian) or 0.1 (veritas) seconds in the pruned setting. We can be stricter with veritas as it is an approximate method that is faster than the exact kantchelian.2 ", "page_idx": 6}, {"type": "text", "text": "Q1: Run Time Table 2 reports the average run time for the full setting and the average speedup given by the pruned and mixed settings. We present here results for XGBoost and random forest, and report results for GROOT together with more extended results in Appendix C. Considering all three model types and both attacks, speedups for the pruned setting are in the range $1.4\\mathrm{x}{-}36.2\\mathrm{x}$ with an average of $9\\mathrm{x}\\:(\\pm\\:8\\mathrm{x})$ , and for the mixed in the range $1.1\\mathrm{x}{-}20.5\\mathrm{x}$ with an average of $4\\mathrm{x}\\left(\\pm\\,3\\mathrm{x}\\right)$ . ", "page_idx": 6}, {"type": "text", "text": "We notice that generating adversarial examples is more difficult for random forests (RF) than XGB. This leads to our strategies offering larger wins for RF than for XGB, with average speedups of $9.4\\mathrm{x}/3.5\\mathrm{x}$ $(\\pm\\,7.2\\mathrm{x}/1.6\\mathrm{x})$ for RF and $4.7\\mathbf{x}/2.7\\mathbf{x}$ $\\left\\langle\\pm\\,3.4\\mathrm{x}/1.2\\mathrm{x}\\right\\rangle$ for XGB. The robustified GROOT forests are even harder to attack, meaning our methods offer even larger improvements with average speedups of $11.4\\mathrm{x}/4.9\\mathrm{x}$ $\\pm\\,9.9\\mathrm{x}/5.0\\mathrm{x})$ .3 ", "page_idx": 6}, {"type": "text", "text": "Tables 5 and 6 in the supplement also report additional statistics on the presented experiments. On average, the mixed setting falls back to the full search $10.5\\%$ of the time. The model and attack type do not seem to have a strong influence on the proportion of calls to the full search. This helps it achieve a speedup by taking advantage of the fast $S A T$ results of the pruned setting while still offering the theoretical guarantee from Theorem 3.2. ", "page_idx": 6}, {"type": "text", "text": "We also report the attack success rate, which is the fraction of times where our methods generate an adversarial example given that a valid adversarial example exists for the full model. The pruned search has an average success rate of $90\\%$ $(\\pm~6\\%)$ . The mixed search has success rate $100\\%$ by definition (Theorem 3.2). ", "page_idx": 6}, {"type": "text", "text": "Table 2: Average run times and speedups when attempting to generate 10 000 adversarial examples using kantchelian/veritas on an XGBoost/random forest ensemble for full, pruned and mixed. A \\* means that the dataset exceeded the global timeout of six hours. ", "page_idx": 7}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/1d01439c9414f4166fb024817ad7c7d6e58edeca849569463d1038ce11ac825b.jpg", "table_caption": [], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "Figure 3 shows the number of executed searches as a function of time for four combinations of attack algorithm and model type.4 For XGB, both attacks benefit. Moreover, the mixed setting is typically very close in run time to the pruned. On RF, the pruned setting offers larger speedups. However, we see a more noticeable difference between the pruned and the mixed search on several datasets. This indicates that the mixed strategy falls back more often to an expensive full search. ", "page_idx": 7}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/52508677bda1eb37c6f0ae145a5a12b3cb41211cc4175cb247f219219eca0a7b.jpg", "img_caption": ["Figure 3: Average run times for 10 000 calls to full, pruned and mixed for kantchelian (top) and veritas (bottom). Results are given for both XGBoost and random forest for four selected datasets. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "Finally, it is natural to wonder how the quality of the generated adversarial examples is affected by the modified search procedure. While this is difficult to quantify, Figure 4 provides some examples of constructed adversarial examples for the mnist dataset and an XGBoost ensemble. Visually, the examples constructed by full and pruned settings for both attacks are very similar. The examples constructed using kantchelian look more similar to the base example than those for veritas because kantchelian finds the closest possible adversarial example whereas veritas has a different objective: it constructs an adversarial example that will elicit a highly confident misprediction. See Appendix E for more generated examples. ", "page_idx": 7}, {"type": "text", "text": "Q2: Scaling Behavior Two key hyperparameters of tree ensembles are the maximum depth of each learned tree and the number of trees in the ensemble. We explore how varying these affects our approach, employing the same setup as described in Q1. We use the mnist dataset and omit kantchelian with RFs due to its computational cost. Figure 5 (top) shows how the run time to perform 10 000 searches varies as function of the maximum tree depth for a fixed ensemble size of 50. The run times for the pruned and mixed approaches grow very slowly as the depths are increased. In contrast, the full search scales worse: deeper trees lead to higher run times. Figure 5 (bottom) shows how the run time to perform 10 000 searches varies as function of the ensemble size for a fixed maximum tree depth of 6 for XGB and 10 for RF. Again, the pruned and mixed approaches show much better scaling behavior. Note that veritas\u2019s full search shows a very large jump on RF when moving from 75 to 100 trees. These results indicate that our approaches will offer even better run time performance than the standard full search for more complex ensembles. ", "page_idx": 7}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/c9e0fc1f8f4dbda200f014302bbe7ef4bc2bbc178328d7931f206b1368613aba.jpg", "img_caption": ["Figure 4: Generated adversarial examples for an mnist digit and an XGBoost ensemble, using both attacks (full vs pruned). "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/c51f23a345489d7183efa0b07bfd0339b3ae43156ceeadaa2aca784964a4bd4a.jpg", "img_caption": ["Figure 5: Run time of full, mixed and pruned settings using veritas XGB, veritas RF, kantchelian XGB on mnist, and varying the max depth (top) and number of estimators in the ensemble (bottom). "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "Q3: Empirical FNR We use Algorithm 2 to bound the false negative rate to be less than $25\\%$ with high probability. Tables 5 and 6 in the supplement report the empirical false negative rates for all experiments. The average false negative rate is $7.5\\%$ and the maximum is $17.1\\%$ . Hence, empirically we achieve better results than the theory guarantees. Neither the ensemble method nor the attack type strongly influence the false negative rate. These small false negative rates still allow dramatically reducing the number of considered features. On average, $F_{S}$ contains $17\\%$ of the features. Out of 300 experiments,5 we only select the maximum percentage of features 17 times. Generally, kantchelian requires slightly more features than veritas and RF models requires slightly more features than XGB/GROOT models. ", "page_idx": 8}, {"type": "text", "text": "To provide a better intuition on the relationship between the empirical FNR and the speedup, Figure 6 shows this tradeoff on two datasets using XGBoost. In essence, higher FNRs correspond to smaller feature subsets, hence larger speedups. ", "page_idx": 8}, {"type": "text", "text": "5 Related Work ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "Adversarial examples have been theoretically studied and defined in multiple different ways [14, 18]. ", "page_idx": 8}, {"type": "text", "text": "Approaches to reason about learned tree ensembles have received substantial interest in recent years including algorithms to perform evasion attacks [23, 15] (i.e., generate adversarial examples), ", "page_idx": 8}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/b382440eec42f4620fb21bb0060e5a287c2aba2342cd1397d9fb9946362aae72.jpg", "img_caption": [], "img_footnote": [], "page_idx": 9}, {"type": "text", "text": "Figure 6: Speedups achieved by the pruned setting when attempting to generate 10 000 adversarial examples using kantchelian (left) and veritas (right) on an XGB ensemble, varying the empirical false negative rate. The dotted horizontal line corresponds to a speedup of 1x, i.e., same run time of the full setting. ", "page_idx": 9}, {"type": "text", "text": "perform robustness checking [8], and verify that the ensembles satisfy certain criteria [11, 10, 26, 29]. Kantchelian et al. [23] were the first to show that tree ensembles are susceptible to evasion attacks. Their MILP formulation is still the most frequently used method to check robustness and generate adversarial examples. Beyond this exact approach, several approximate approaches exist [8, 10, 35, 36] though not all of them are able to generate concrete adversarial examples (e.g., [8, 35]). ", "page_idx": 9}, {"type": "text", "text": "Other work focuses on making tree ensembles more robust. Approaches for this include adding generated adversarial examples to the training data (model hardening) [23], or modifying the splitting procedure [7, 4, 32]. Gaining further insights into how evasion attacks target tree ensembles, like those contained in this paper, may inspire novel ways to improve the robustness of learners. ", "page_idx": 9}, {"type": "text", "text": "Another line of work aims at directly training tree ensembles that admit verification in polynomial time [5, 13]. However, a drawback to current approaches is that they result in (large) decreases in predictive performance. ", "page_idx": 9}, {"type": "text", "text": "Finally, performing evasion attacks has been studied for other model classes with deep neural networks receiving particular attention [28, 17, 24, 6]. However, state-of-the-art algorithms are tailored to one specific model type as they typically exploit specific properties of the model, e.g., the work on tree ensembles often exploits the logical structure of a decision tree. ", "page_idx": 9}, {"type": "text", "text": "6 Conclusions ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "This paper explored two methods to efficiently generate adversarial examples for tree ensembles. We showed that considering only the same subset of features is typically sufficient to generate adversarial examples for tree ensemble models. We proposed a simple procedure to quickly identify such a subset of features, and two generic approaches that exploit it to speed up adversarial examples generation. We showed how to apply them to an exact (kantchelian) and approximate (veritas) evasion attack on three types of tree ensembles, and discussed their properties and run time performances. ", "page_idx": 9}, {"type": "text", "text": "Limitations. Our approach speeds up evasion attacks in the specific scenario when the same model is repeatedly attacked. Plus, it excels on high-dimensional datasets. Our evaluation only considered $l_{\\infty}$ attacks, whereas other norms such $l_{1}$ and $l_{2}$ are also relevant. ", "page_idx": 9}, {"type": "text", "text": "Impact Statement. While this work does make attacking tree ensembles faster, it is also important to understand what attackers may do. This work also targets increasing the applicability of robustness checking and hardening techniques, which can lead to approaches for training more robust models. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgements. This research is supported by the Research Foundation Flanders (FWO, LC: 11I8125N), The European Union\u2019s Horizon Europe Research and Innovation program under the grant agreement TUPLES No. 101070149 (LC, LD, OK, JD), and the Flemish Government under the \u201cOnderzoeksprogramma Artific\u00eble Intelligentie (AI) Vlaanderen\u201d program (JD). ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] M. Andriushchenko and M. Hein. Provably robust boosted decision stumps and trees against adversarial attacks. In Advances in Neural Information Processing Systems, 2019. ", "page_idx": 9}, {"type": "text", "text": "[2] J. Bartroff, G. Lorden, and L. Wang. Optimal and fast confidence intervals for hypergeometric successes. The American Statistician, 2023.   \n[3] L. Breiman. Random forests. Machine learning, 2001.   \n[4] S. Calzavara, C. Lucchese, G. Tolomei, S. A. Abebe, and S. Orlando. Treant: training evasionaware decision trees. Data Mining and Knowledge Discovery, 2020.   \n[5] S. Calzavara, L. Cazzaro, G. E. Pibiri, and N. Prezza. Verifiable learning for robust tree ensembles. In Proceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security, 2023.   \n[6] N. Carlini and D. Wagner. Towards evaluating the robustness of neural networks. In IEEE Symposium on Security and Privacy, 2017.   \n[7] H. Chen, H. Zhang, D. Boning, and C.-J. Hsieh. Robust decision trees against adversarial examples. In Proceedings of the 36th International Conference on Machine Learning, 2019.   \n[8] H. Chen, H. Zhang, S. Si, Y. Li, D. Boning, and C.-J. Hsieh. Robustness verification of tree-based models. In Advances in Neural Information Processing Systems, 2019.   \n[9] T. Chen and C. Guestrin. XGBoost: A scalable tree boosting system. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2016.   \n[10] L. Devos, W. Meert, and J. Davis. Versatile verification of tree ensembles. In Proceedings of the 38th International Conference on Machine Learning, 2021.   \n[11] L. Devos, W. Meert, and J. Davis. Verifying tree ensembles by reasoning about potential instances. In Proceedings of the 2021 SIAM International Conference on Data Mining (SDM), 2021.   \n[12] L. Devos, L. Cascioli, and J. Davis. Robustness verification of multiclass tree ensembles. In Proceedings of the AAAI Conference on Artificial Intelligence, 2024.   \n[13] L. Devos, D. C. Oru\u00e7, W. Meert, H. Blockeel, and J. Davis. Tree ensemble compression for interpretability. In Advances in Interpretable Machine Learning and Artificial Intelligence (AIMLAI), 2024.   \n[14] D. I. Diochnos, S. Mahloujifar, and M. Mahmoody. Adversarial risk and robustness: General definitions and implications for the uniform distribution. In Advances in Neural Information Processing Systems, 2018.   \n[15] G. Einziger, M. Goldstein, Y. Sa\u2019ar, and I. Segall. Verifying robustness of gradient boosted models. In Proceedings of the AAAI Conference on Artificial Intelligence, 2019.   \n[16] J. H. Friedman. Greedy function approximation: a gradient boosting machine. Annals of statistics, 2001.   \n[17] I. J. Goodfellow, J. Shlens, and C. Szegedy. Explaining and harnessing adversarial examples. In International Conference on Learning Representations, 2015.   \n[18] P. Gourdeau, V. Kanade, M. Kwiatkowska, and J. Worrell. On the hardness of robust classification. Journal of Machine Learning Research, 2021.   \n[19] J.-Q. Guo, M.-Z. Teng, W. Gao, and Z.-H. Zhou. Fast provably robust decision trees and boosting. In Proceedings of the 39th International Conference on Machine Learning, 2022.   \n[20] Gurobi Optimization, LLC. Gurobi Optimizer Reference Manual, 2023. URL https://www. gurobi.com.   \n[21] A. Ilyas, S. Santurkar, D. Tsipras, L. Engstrom, B. Tran, and A. Madry. Adversarial examples are not bugs, they are features. In Advances in Neural Information Processing Systems, 2019.   \n[22] C. Jain, L. Cascioli, L. Devos, M. Vinzent, M. Steinmetz, J. Davis, and J. Hoffmann. Safety verification of tree-ensemble policies via predicate abstraction. In Proceedings of the 27th European Conference on Artificial Intelligence, 2024.   \n[23] A. Kantchelian, J. D. Tygar, and A. Joseph. Evasion and hardening of tree ensemble classifiers. In Proceedings of the 33th International Conference on Machine Learning, 2016.   \n[24] G. Katz, C. Barrett, D. Dill, K. Julian, and M. Kochenderfer. Reluplex: An efficient SMT solver for verifying deep neural networks. In Computer Aided Verification, 2017.   \n[25] F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, and E. Duchesnay. Scikit-learn: Machine learning in Python. Journal of Machine Learning Research, 2011.   \n[26] F. Ranzato and M. Zanella. Abstract interpretation of decision tree ensemble classifiers. In Proceedings of the AAAI Conference on Artificial Intelligence, 2020.   \n[27] J. Spooren, T. Vissers, P. Janssen, W. Joosen, and L. Desmet. Premadoma: An operational solution for DNS registries to prevent malicious domain registrations. In Proceedings of the 35th Annual Computer Security Applications Conference, 2019.   \n[28] C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. Goodfellow, and R. Fergus. Intriguing properties of neural networks. In International Conference on Learning Representations, 2014.   \n[29] J. T\u00f6rnblom and S. Nadjm-Tehrani. Formal verification of input-output mappings of tree ensembles. Science of Computer Programming, 2020.   \n[30] M. Vinzent, M. Steinmetz, and J. Hoffmann. Neural network action policy verification via predicate abstraction. In Proceedings of the International Conference on Automated Planning and Scheduling, 2022.   \n[31] M. Vinzent, S. Sharma, and J. Hoffmann. Neural policy safety verification via predicate abstraction: CEGAR. In Proceedings of the AAAI Conference on Artificial Intelligence, 2023.   \n[32] D. Vos and S. Verwer. Efficient training of robust decision trees against adversarial examples. In Proceedings of the 38th International Conference on Machine Learning, 2021.   \n[33] D. Vos and S. Verwer. Robust optimal classification trees against adversarial examples. In Proceedings of the AAAI Conference on Artificial Intelligence, 2022.   \n[34] D. Vos and S. Verwer. Adversarially robust decision tree relabeling. In Machine Learning and Knowledge Discovery in Databases. ECML PKDD 2022., 2022.   \n[35] Y. Wang, H. Zhang, H. Chen, D. Boning, and C.-J. Hsieh. On lp-norm robustness of ensemble decision stumps and trees. In Proceedings of the 37th International Conference on Machine Learning, 2020.   \n[36] C. Zhang, H. Zhang, and C.-J. Hsieh. An efficient adversarial attack for tree ensembles. In Advances in Neural Information Processing Systems, 2020. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "A Analysis of the Problem Setting ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "Adversarial examples are often generated for tasks like computing adversarial accuracy [32], computing empirical robustness [10], and performing model hardening [23]. The effect of using the approximation proposed in this paper differs for each task. ", "page_idx": 12}, {"type": "text", "text": "Computing the adversarial accuracy of a classifier only requires determining whether an adversarial example $\\tilde{x}$ exists within the given $\\delta$ for each provided normal example $x$ . Because the mixed strategy reverts to the original complete search when the pruned approach returns an $U N S A T$ , as stated in Theorem 3.2 it is guaranteed to find an adversarial example if it exists. Hence, the mixed strategy can speed up computing the adversarial accuracy without affecting its value. ", "page_idx": 12}, {"type": "text", "text": "Computing the empirical robustness of a classifier requires finding the nearest adversarial example $\\tilde{x}$ for each normal example $x$ . Because the pruned approach does not consider all features and the mixed approach may not, they may return an adversarial example that is further away than if the full search space was considered. Hence, when using an exact attack like kantchelian, the empirical robustness computed using the mixed strategy is an overestimate of the true empirical robustness. We show this and we study what happens with an approximate method in Appendix E. ", "page_idx": 12}, {"type": "text", "text": "In model hardening, a large number of adversarial examples are generated and added to the training data [23]. The pruned approach can be used to generate a lot more adversarial examples in a fixed amount of time. ", "page_idx": 12}, {"type": "text", "text": "B Employed Datasets, Models and Attacks ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "We expand the discussion on Table 1, which reports the characteristics of the employed datasets and models. In our experiments, we use ten high-dimensional datasets where the number of dimensions is greater than 25. We verified that our approach does not bring consistent run time improvements for datasets with less than 25 features, or with a fully categorical domain (where the $l_{\\infty}$ norm loses meaning). ", "page_idx": 12}, {"type": "text", "text": "Table 1 also reports the hyperparameters of the learned ensembles, which are tuned through grid search. For all model types, we choose the number of trees in $\\{10,20,50\\}$ . Max depth is chosen in the range [3, 6] for XGBoost, and in $\\{5,7,10\\}$ for random forest and GROOT forest (which typically need deeper trees to work better). XGBoost learning rate is chosen among $\\{0.1,0.5,0.9\\}$ . GROOT forest $\\epsilon$ is chosen among $\\left\\lbrace0.01,0.05,0.1,0.3,0.5\\right\\rbrace$ , and we select the model with the largest $\\epsilon$ such that GROOT forest accuracy does not drop below $90\\%$ of the corresponding RF accuracy. Note that in GROOT a bigger $\\epsilon$ corresponds to a more robust model, hence accuracy drops up to a point where the model can become useless in practice. ", "page_idx": 12}, {"type": "text", "text": "When running kantchelian on random forests and GROOT forests, we had to limit the number of estimators to 25 due to the extremely long run times. ", "page_idx": 12}, {"type": "text", "text": "While the model sizes are smaller, these ensembles are already challenging for the full settings of kantchelian and veritas. This is also highlighted in Q2 from Section 4 where we empirically study the effect of increasing the ensemble size on performance. Those results show that the full procedures becomes increasingly slower as the ensemble complexity grows, and our method offers larger wins. ", "page_idx": 12}, {"type": "text", "text": "Table 3 gives specific reference to each of the considered datasets. ", "page_idx": 12}, {"type": "text", "text": "B.1 Comparison with LT Attack ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "We evaluate our two methods on a representative set of scenarios, varying the model type (XGBoost, random forest, GROOT forest), and the evasion attack variant (one exact (kantchelian) and one approximate (veritas)). Given the fact that (1) it is reasonable to expect that most evasion attacks will benefit from smaller pruned models, and (2) we see improvement across all these settings, we are confident that run time improvements also translate to other evasion attack methods. ", "page_idx": 12}, {"type": "text", "text": "In practice, other approximate attacks alternative to veritas exist. To the best of our knowledge, no alternative outperforms veritas run times. Computationally, we have compared veritas to another popular state-of-the-art method: LT-attack [36]. On the full setting, they have the same success rate and veritas is 25 to 60 times faster, as shown in Table 4 for XGBoost ensembles. ", "page_idx": 12}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/2dfa3396111c6d658c138f134010a9db34b4a235816fcaf03e257edafa3f3257.jpg", "table_caption": ["Table 3: References to all the ten datasets used in the experiments. "], "table_footnote": [], "page_idx": 13}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/283f92e72c765354f828b5ef259b5c4a398bad6162ff5866817189074b07d03b.jpg", "table_caption": ["Table 4: Average run times for generating 10 000 adversarial examples using LT-attack and veritas in the full search setting. "], "table_footnote": [], "page_idx": 13}, {"type": "text", "text": "C Expanded Experimental Results ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Tables 5 (kantchelian) and 6 (veritas) report the average times and speedups when attempting to generate 10 000 adversarial examples in each of our experimental scenarios. The averages are computed over five folds. There is one table for each combination of attack (kantchelian, veritas) and ensemble type (XGB, random forest, GROOT forest). For each dataset, we also report the average size of the relevant feature subset $F_{S}$ , the percent of searches in the mixed setting that require making a call to the full search, the false negative rate (proportion of times that pruned returns UNSAT but full returns $S A T$ ), the pruned setting success rate (i.e., an adversarial example can be generated with the full search, and the pruned setting finds a valid adversarial example), and the percent of examples that were skipped due to the full search reaching the global timeout of six hours. The pruned and mixed settings never reach the global timeout. Note that the mixed setting has attack success rate of $100\\%$ by definition. ", "page_idx": 13}, {"type": "text", "text": "Figures 7 (kantchelian) and 8 (veritas) show the number of executed searches as a function of time for kantchelian and veritas on all ten datasets. Each plot contains the results for XGB (top), RF (middle) and GROOT forest (bottom). Hence these plots show the complete set of results from Figure 3 in the main paper. ", "page_idx": 13}, {"type": "text", "text": "C.1 Run Time Standard Deviation and Timeouts ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Tables 7 (kantchelian) and 8 (veritas) extend the run time results of the presented experiments by additionally reporting standard deviations. ", "page_idx": 13}, {"type": "text", "text": "Tables 7 (kantchelian) and 8 (veritas) also show the percentage of searches that timed out for each dataset, ensemble type and method. In short, XGBoost ensembles are on average easier to verify, and the searches almost never time out. On the other hand, random forests and GROOT forests are more challenging. It can happen that with a strict timeout, the pruned setting is not able to find a solution, as the task remains complex even working with a reduced feature set. In those cases, pruned ends with a TIMEOUT and mixed will have to execute the full search. ", "page_idx": 13}, {"type": "text", "text": "C.2 Tradeoff FNR vs Speedup ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "We further extend Figure 6 from Q3 in Section 4, which explicitly shows the relationship between the empirical false negative rate and the speedup of the pruned setting. ", "page_idx": 13}, {"type": "text", "text": "Table 5: Average run times (and speedups) when attempting to generate 10 000 adversarial examples using kantchelian on an XGBoost/random forest/GROOT forest ensemble for all three approaches: full, pruned and mixed. We also report the average size of the relevant feature subset, the number of calls to the full setting during mixed $\\equiv$ number of $U N S A T+$ number of TIMEOUT for pruned), the number of false negatives (pruned returns $U N S A T$ , but full returns $S A T$ ), the pruned attack success rate (i.e., pruned succeeds in generating an adversarial example if an example can be generated for the full ensemble), and the percent of examples that were skipped due to the full search reaching the global timeout of six hours. Experiments that exceeded the timeout are starred. The pruned and mixed settings never reach the global timeout. ", "page_idx": 14}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/821781489fe798e74560beeb0f56ebe5280c33d1f20a2804ec62a4896df5e0e1.jpg", "table_caption": ["Kantchelian, XGBoost "], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "Table 6: Average run times (and speedups) when attempting to generate 10 000 adversarial examples using veritas on an XGBoost/random forest/GROOT forest ensemble for all three approaches: full, pruned and mixed. We also report the average size of the relevant feature subset, the number of calls to the full setting during mixed ( $\\equiv$ number of $U N S A T\\,+$ number of TIMEOUT for pruned), the number of false negatives (pruned returns UNSAT, but full returns $S A T$ ), the pruned attack success rate (i.e., pruned succeeds in generating an adversarial example if an example can be generated for the full ensemble), and the percent of examples that were skipped due to the full search reaching the global timeout of six hours. Experiments that exceeded the timeout are starred. The pruned and mixed settings never reach the global timeout. ", "page_idx": 15}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/eec4f7b7160e811be9240dc8267978346e935a9bab320114bcfaefc089a90ba1.jpg", "table_caption": ["Veritas, XGBoost "], "table_footnote": [], "page_idx": 15}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/184b4d7b4d5e79950dd134ce2a433cbefbd66b4ab3f41c39b4f504fe4684a6aa.jpg", "img_caption": ["Figure 7: Run times to attempt to generate adversarial examples for 10 000 test examples with the three presented settings (full, pruned and mixed), using kantchelian on an XGBoost/random forest/GROOT forest ensemble, averaged over 5 folds. "], "img_footnote": [], "page_idx": 16}, {"type": "text", "text": "In Figure 9, we show the empirical FNR on the $\\mathbf{X}$ -axis versus the speedup of the pruned approach on the y-axis, using an XGB ensemble on four selected datasets. The empirical FNR is the fraction of times the pruned approach returns UNSAT but the full approach returns $S A T$ . Going from left to right along the x-axis, higher values of the FNR correspond to smaller subsets of selected features, hence more aggressive pruning. Using less features, the pruned search becomes faster, at the cost of more false negatives. ", "page_idx": 16}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/42932b1200688d8956a8ed0524f0d7cba497daf9334c0b46d05cc061f137fa48.jpg", "img_caption": ["Figure 8: Run times to attempt to generate adversarial examples for 10 000 test examples with the three presented settings (full, pruned and mixed), using veritas on an XGBoost/random forest/GROOT forest ensemble, averaged over 5 folds. "], "img_footnote": [], "page_idx": 17}, {"type": "text", "text": "", "page_idx": 17}, {"type": "text", "text": "Table 7: Average run times (with standard deviations) when attempting to generate 10 000 adversarial examples using kantchelian on an XGBoost/random forest/GROOT forest ensemble for all three approaches: full, pruned and mixed. The average fraction of timeouts incurred during the search is also reported. ", "page_idx": 18}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/b1a2ca74ee7ff4e747a75c98cac20a4fbe8fb0eef5be2b40a11a651f597f67f8.jpg", "table_caption": [], "table_footnote": [], "page_idx": 18}, {"type": "text", "text": "There are cases where false negatives are less problematic, such as when one simply needs to generate a lot of adversarial examples for model hardening [23]. In these cases, the pruned approach really excels at offering run time improvements. ", "page_idx": 18}, {"type": "text", "text": "Note that for the considered datasets, FNR values higher than $25\\%$ are rare and only occur for very small subsets of features (e.g., 5 out of the 784 features in mnist). ", "page_idx": 18}, {"type": "text", "text": "D Sensitivity Analysis ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "We briefly discuss how sensitive our algorithm is to the choice of its hyperparameters, namely the threshold and confidence for the statistical test in the feature selection process (see 3.2) and the timeout for the pruned setting. ", "page_idx": 18}, {"type": "text", "text": "Table 8: Average run times (with standard deviations) when attempting to generate 10 000 adversarial examples using veritas on an XGBoost/random forest/GROOT forest ensemble for all three approaches: full, pruned and mixed. The average fraction of timeouts incurred during the search is also reported. ", "page_idx": 19}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/4ce791ebb83bb3f7b4a84f4fc8c8bdf49c5b7e9bcb566bd275c833dade7ffbd0.jpg", "table_caption": [], "table_footnote": [], "page_idx": 19}, {"type": "text", "text": "D.1 Sensitivity to Statistical Test Parameters ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "The statistical test described in 3.2 takes as hyperparameters the acceptable false negative rate $\\tau$ and the confidence $1-\\eta$ . We perform a sensitivity analysis where we vary $\\tau\\in[0.05,0.\\dot{1},0.25,0.5]$ and $1-\\eta\\in[0.8,0.9,0.95]$ on the miniboone dataset. ", "page_idx": 19}, {"type": "text", "text": "Table 9 shows the mixed speedup for (veritas, XGBoost) for all combinations of the considered values for $\\tau$ (FNR) and $1-\\eta$ (confidence). For all settings, our approach improves upon the run time of always running a full search (i.e., speedup is always $>1$ ). When $\\tau=0.05$ , many features are selected and hence there is less pruning. $\\tau=0.1$ and $\\tau=0.25$ perform identically. When $\\tau=0.5$ , the value of $1-\\eta$ impacts the selected feature set. A confidence of 0.95 keeps the same feature set of $\\tau=0.1$ and $\\tau=0.25$ . However, a lower confidence results in an even smaller feature set, which degrades the performance of the mixed setting because there are more calls to the full search. ", "page_idx": 19}, {"type": "text", "text": "Hence more in general, the threshold on the false negative rate $\\tau$ is inversely proportional to the number of chosen features: the larger the selected feature subset, the lower the FNR will be. This is in tension with the goal of using as small of a feature subset as possible, to speed up the pruned ", "page_idx": 19}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/c2f89ee71fe394dba24d1d0c5bcc919d1b8f5f5048caba7ce13306a92ec77910.jpg", "img_caption": [""], "img_footnote": [], "page_idx": 20}, {"type": "text", "text": "Figure 9: Speedups introduced by the pruned setting when attempting to generate 10 000 test examples using kantchelian (top) and veritas (bottom) on an XGB ensemble, varying the empirical false negative rate. Higher FNRs correspond to smaller feature subsets. The dotted horizontal line corresponds to a speedup of 1x, i.e., same run time of the full setting. ", "page_idx": 20}, {"type": "text", "text": "setting. Moreover, a larger confidence $1-\\eta$ can increase the number of selected features as it shrinks the confidence interval for the empirical FNR. ", "page_idx": 20}, {"type": "text", "text": "Table 9: Speedup of the mixed setting when attempting to generate 10 000 adversarial examples for miniboone using (veritas, XGBoost), for different values of $\\tau$ (threshold on the allowed false negative rate) and $1-\\eta$ (confidence of the statistical test). ", "page_idx": 20}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/740260945db4443966b2e15c2069be7314c197d9d0483912da90220308cd74ba.jpg", "table_caption": [], "table_footnote": [], "page_idx": 20}, {"type": "text", "text": "D.2 Sensitivity to Timeouts ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Timeouts always need to be explicitly handled, due to the hardness of the evasion problem [23]. While Tables 7 and 8 show that in most of our experiments timeouts are rare or totally absent, to complete the discussion we perform a sensitivity analysis on the value used for the pruned setting timeout. We vary $t_{\\mathrm{max}}^{p r u n}\\in[0.00\\bar{1},0.01,0.1,1]$ seconds when attempting to generate 10 000 adversarial examples on the fmnist dataset. We only consider veritas for RF in this experiment. ", "page_idx": 20}, {"type": "text", "text": "Table 10 shows the fraction of timeouts for the pruned setting as well as the pruned speedup and the mixed speedup for each value of $t_{\\mathrm{max}}^{p r u n}$ . The smaller $t_{\\mathrm{max}}^{p r u n}$ , the larger the number pruned timeouts, which corresponds to a faster (but less accurate) pruned search. If the timeout value is too low, this adversely affects mixed search because it leads to more calls to the full procedure. Conversely, if $t_{\\mathrm{max}}^{p r u n}$ is too large, the search becomes slower as the pruned setting starts losing time on a few slow instances. ", "page_idx": 20}, {"type": "text", "text": "", "page_idx": 21}, {"type": "text", "text": "Thus the ideal $t_{\\mathrm{max}}^{p r u n}$ lays in between the two extremes. In the presented case, $t_{\\mathrm{max}}^{p r u n}=0.01$ works best. The best choice likely depends on the specific dataset, model, and attack type. However, tuning its value is time consuming (i.e., negates the benefits of the proposed approach). ", "page_idx": 21}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/9fd0f9f7198d8afe11c79981b69d5712ff5a2b65ff8eaa3cf3382fcfab66577e.jpg", "table_caption": ["Table 10: Fraction of pruned timeouts and speedup of the pruned and mixed settings when attempting to generate 10 000 adversarial examples for fmnist using (veritas, random forest), for different values of the pruned setting timeout $t_{\\mathrm{max}}^{p r u n}$ (in seconds). "], "table_footnote": [], "page_idx": 21}, {"type": "text", "text": "E Quality of Generated Adversarial Examples ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "We extend Figure 4 by further discussing the quality of generated adversarial examples, providing more examples, and looking in detail at their distance with respect to the base examples. ", "page_idx": 21}, {"type": "text", "text": "Figure 10 shows a large set of adversarial examples generated for mnist digits using kantchelian and veritas on an XGBoost ensemble. For each attack, we plot the base example $x$ and the two adversarial examples generated with the full and the pruned setting. ", "page_idx": 21}, {"type": "text", "text": "E.1 Empirical Robustness ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Tables 11 (kantchelian) and 12 (veritas) show the average empirical robustness in all the performed experiments for the full, pruned and mixed settings. An ensemble\u2019s empirical robustness is defined as the average distance to the nearest adversarial example for each $x$ in a test set. We use adversarial examples generated with the experiments presented in Q1 in Section 4 (and Appendix C). ", "page_idx": 21}, {"type": "text", "text": "The objective of the kantchelian attack is to find the closest adversarial example. Given that the method is exact, the full setting returns the optimal solution. The pruned search works with a restricted feature set, thus it might not be able to find the closest adversarial example, if that requires altering features not included in the selected feature subset. As a consequence, the empirical robustness values for the pruned and mixed search are overestimates of the true value given by the full setting. ", "page_idx": 21}, {"type": "text", "text": "Unlike kantchelian, veritas does not try to find the closest adversarial example. Instead, it maximizes the confidence that the ensemble assigns to the incorrect label. In this case, there is little difference in the empirical robustness values among all considered settings, with the pruned and mixed settings typically managing to even lower the distance to the base example. ", "page_idx": 21}, {"type": "text", "text": "E.2 Change in Predicted Probability for Adversarial Examples ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "veritas tries to generate an adversarial example such that the ensemble assigns as high a probability as possible to the incorrect label. Hence, a natural empirical measure for the quality of the generated examples is to compare the difference in the ensembles probabilistic predictions for the adversarial examples generated by each approach. Namely, we compute $\\pmb{T}(\\tilde{x})-\\bar{\\pmb{T}}(\\tilde{x}^{\\prime})$ where $\\tilde{x}$ is generated by the full search, ${\\tilde{x}}^{\\prime}$ is generated by the pruned (mixed) search, and (in an abuse of notation) ${\\cal T}(x)$ returns the probability an example belongs to most likely class. ", "page_idx": 21}, {"type": "text", "text": "Table 13 shows the average differences in predicted probability between full and pruned/mixed adversarial examples. ", "page_idx": 21}, {"type": "text", "text": "Using kantchelian, adversarial examples generated with our approaches are assigned very similar probabilities to those generated with the full search. In veritas, differences are typically higher, as the model output is directly optimized. ", "page_idx": 21}, {"type": "text", "text": "Table 11: Average empirical robustness (i.e., distance to the closest adversarial example) for the full, mixed and pruned methods using kantchelian attack on XGBoost/random forest/GROOT forest ensembles. ", "page_idx": 22}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/1cb0938ea37675e1eb1bca25ffb3645230bbbe5f1c8dfd738006110f90484d29.jpg", "table_caption": ["Kantchelian, XGBoost "], "table_footnote": [], "page_idx": 22}, {"type": "text", "text": "F Expanded Related Work ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Adversarial examples have been theoretically studied and defined in multiple different ways [14, 18]. More specifically, Ilyas et al. showed how certain features in a dataset might be fragile and thus naturally lead to adversarial examples [21]. Approaches to reason about learned tree ensembles have received substantial interest in recent years. These include algorithms for performing evasion attacks [23, 15] (i.e., generate adversarial examples), perform robustness checking [8], and verify that the ensembles satisfy certain criteria [11, 10, 26, 29]. Kantchelian et al. [23] were the first to show that, just like neural networks, tree ensembles are susceptible to evasion attacks. Their MILP formulation is still the most frequently used method to check robustness and generate adversarial examples. Other notable methods for adversarial example generation are SMT-based systems [15, 11]. These approaches propose varying ways to encode a tree ensemble in a set of logical formulas using the primitives from Satisfiability Modulo Theories (SMT). While the formulation of an ensemble in SMT is very elegant, it tends to perform worse than MILP in practice. ", "page_idx": 22}, {"type": "text", "text": "Because MILP and SMT are exact approaches,6they search for the optimal answer which in certain cases can be difficult (i.e., time consuming) to find. Often an approximate answer will be sufficient and several approximate methods have been proposed that are specifically tailored to tree ensembles. Chen et al. proposed a $K$ -partite graph representation in which a max-clique corresponds to a specific output of the ensemble [8, 35]. They introduced a fast method to approximately evaluate robustness, ", "page_idx": 22}, {"type": "text", "text": "Table 12: Average empirical robustness (i.e., distance to the closest adversarial example) for the full, mixed and pruned methods using veritas attack on XGBoost/random forest/GROOT forest ensembles. ", "page_idx": 23}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/01170366cebd002b6070dc4bed533b5571388132848fbf425a85ca5f29563602.jpg", "table_caption": ["Veritas, XGBoost "], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "but it cannot generate concrete adversarial examples. Devos et al. further improved upon this work by proposing a heuristic search procedure in this graph which is capable of finding concrete adversarial examples very effectively [10]. Zhang et al. propose a method based on a greedy discrete search through the space of leaves specifically optimized for fast adversarial example generation [36]. ", "page_idx": 23}, {"type": "text", "text": "Other work focuses on making tree ensembles more robust. There are multiple approaches: adding generated adversarial examples to the training data (model hardening) [23], modifying the splitting procedure [7, 4, 32], using the framework of optimal decision trees to encode robustness constraints [33], relabeling and pruning the leaves of the trees [34], simplifying the base learner [1] and using a robust 0/1 loss [19]. Gaining further insights into how evasion attacks target tree ensembles, like those contained in this paper, may inspire novel ways to improve the robustness of learners. ", "page_idx": 23}, {"type": "text", "text": "Another line of work aims at directly training tree ensembles that admit verification in polynomial time [5, 13]. However, a drawback to current approaches is that they result in (large) decreases in predictive performance. ", "page_idx": 23}, {"type": "text", "text": "Finally, performing evasion attacks has been studied for other model classes with deep neural networks receiving particular attention [28, 17, 24, 6]. However, state-of-the-art algorithms are tailored to one specific model type as they typically exploit specific properties of the model, e.g., the work on tree ensembles often exploits the logical structure of a decision tree. ", "page_idx": 23}, {"type": "text", "text": "Table 13: Average difference in predicted probability between an adversarial example generated using kantchelian/veritas with the full setting and an adversarial example generated with the pruned/mixed setting, for the same base example. All adversarial examples are those generated during the experiments from Section 4 and Appendix C. ", "page_idx": 24}, {"type": "table", "img_path": "Ugr0yPzY71/tmp/3ea65113292b93c84617afa9c5bccf23d357a0889e63451a2bee6ab23671a3d1.jpg", "table_caption": ["Kantchelian "], "table_footnote": [], "page_idx": 24}, {"type": "image", "img_path": "Ugr0yPzY71/tmp/613f80e2e411e0ff140af571b9f136856af9702435f268b44afe80e038ef846e.jpg", "img_caption": [], "img_footnote": [], "page_idx": 25}, {"type": "text", "text": "Figure 10: Adversarial examples generated for mnist with both attacks (kantchelian and veritas) on an XGBoost ensemble, to show the quality of generated examples. ", "page_idx": 25}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: In the abstract and introduction we claim that we can identify a subset of relevant features to perform faster repeated evasion attacks by only perturbing those features. Q1 in Section 4 supports our claim. We provide further evidence in Appendix C. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 26}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: The limitations of the proposed methods are discussed in the paper. In Sections 1 and 3 we clearly state that our approach speeds up adversarial example generation in scenarios where a lot of repeated evasion attacks need to be performed. We discuss the specific scenarios where this is the case in Sections 1, 3 and in Appendix A. At the beginning of Section 4, we also point out that our approach works best on high-dimensional datasets. We summarize these limitations in Section 6. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 26}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Justification: Theoretical results are only present in Section 3, which also reports the needed references and proofs. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 27}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: In the paper we clearly describe all the adopted tree ensemble types (XGB, RF, GROOT, Section 2), evasion attacks (kantchelian and veritas, Section 2), and datasets (Section 4 and Appendix B). The method is described in Section 3 with the aid of Algorithms 1 and 2. We then describe our experimental methodology in Section 4. Table 1 reports all datasets characteristics, each tuned model\u2019s hyperparameters, and the max perturbation size $\\delta$ for each attack. Finally, Table 3 points toward the publicly available sources we gathered the datasets from. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully.   \n(c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset).   \n(d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 27}, {"type": "text", "text": "", "page_idx": 28}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: We provide full access to the code that implements our method and reproduces all the experiments from the paper at https://github.com/lorenzocascioli/ faster-repeated-evasion-tree-ensembles. ", "page_idx": 28}, {"type": "text", "text": "Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 28}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Justification: We perform 5-fold cross validation as described in Section 4. Appendix B reports the full grid employed to tune all our ensembles through grid search. Plus, it discusses the choice of the employed evasion attacks. ", "page_idx": 28}, {"type": "text", "text": "Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 28}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 29}, {"type": "text", "text": "Justification: Given that our key performance metric is run time, we always report standard deviations on run times and related metrics (e.g., when we discuss speed ups in Sections 1 and 4). Tables 7 and 8 in the supplement report run time standard deviations for all the performed experiments. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 29}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 29}, {"type": "text", "text": "Justification: The compute worker characteristics and memory are specified in Section 4. Run times are the key performance metric, hence they are thoroughly discussed in Section 4 and Appendix C. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 29}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 29}, {"type": "text", "text": "Justification: We are aware of the code of ethics and do not violate any clause. Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. ", "page_idx": 29}, {"type": "text", "text": "\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 30}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 30}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 30}, {"type": "text", "text": "Justification: We included an impact statement in Section 6. ", "page_idx": 30}, {"type": "text", "text": "Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 30}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 30}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 30}, {"type": "text", "text": "Justification: - ", "page_idx": 30}, {"type": "text", "text": "Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks. ", "page_idx": 30}, {"type": "text", "text": "\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 30}, {"type": "text", "text": "12. Licenses for existing assets ", "page_idx": 30}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 31}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 31}, {"type": "text", "text": "Justification: Only the authors contributed to this paper. The adopted datasets (Table 3), models and attack methods (Section 2) are all publicly available and properly referenced. The license has been selected for submission in OpenReview (CC BY 4.0). ", "page_idx": 31}, {"type": "text", "text": "Guidelines: ", "page_idx": 31}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 31}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 31}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 31}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 31}, {"type": "text", "text": "Justification: The code implementing our new method (described in Section 3) as well as all the presented experiments are publicly distributed at https://github.com/ lorenzocascioli/faster-repeated-evasion-tree-ensembles. ", "page_idx": 31}, {"type": "text", "text": "Guidelines: ", "page_idx": 31}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 31}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 31}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 31}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 31}, {"type": "text", "text": "Justification: - ", "page_idx": 31}, {"type": "text", "text": "Guidelines: ", "page_idx": 31}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper. ", "page_idx": 31}, {"type": "text", "text": "\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 32}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 32}, {"type": "text", "text": "Answer: [NA] Justification: - Guidelines: ", "page_idx": 32}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 32}]