[{"type": "text", "text": "Deep Graph Neural Networks via Posteriori-Sampling-based Node-Adaptive Residual Module ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Jingbo Zhou1,2,\u2217 Yixuan $\\mathbf{D}\\mathbf{u}^{2,3}$ ,\u2217 Ruqiong Zhang2,3,\u2217 $\\mathbf{J}\\mathbf{u}\\mathbf{n}\\,\\mathbf{X}\\mathbf{i}\\mathbf{a}^{1}$ , Zhizhi $\\mathbf{Y}\\mathbf{u}^{3}$ , Zelin $\\mathbf{Zang^{1}}$ , Di $\\mathbf{Jin^{3}}$ , Carl Yang4, Rui Zhang2,\u2020 Stan Z. Li1\u2020   \n1Westlake University, 2Jilin University, 3Tianjin University, 4Emory University {zhoujingbo, stan.zq.li}@westlake.edu.cn ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Graph Neural Networks (GNNs), a type of neural network that can learn from graph-structured data through neighborhood information aggregation, have shown superior performance in various downstream tasks. However, as the number of layers increases, node representations become indistinguishable, which is known as over-smoothing. To address this issue, many residual methods have emerged. In this paper, we focus on the over-smoothing issue and related residual methods. Firstly, we revisit over-smoothing from the perspective of overlapping neighborhood subgraphs, and based on this, we explain how residual methods can alleviate over-smoothing by integrating multiple orders neighborhood subgraphs to avoid the indistinguishability of the single high-order neighborhood subgraphs. Additionally, we reveal the drawbacks of previous residual methods, such as the lack of node adaptability and severe loss of high-order neighborhood subgraph information, and propose a Posterior-Sampling-based, Node-Adaptive Residual module (PSNR). We theoretically demonstrate that PSNR can alleviate the drawbacks of previous residual methods. Furthermore, extensive experiments verify the superiority of the PSNR module in fully observed node classification and missing feature scenarios. Our code is available at https://github.com/jingbo02/PSNR-GNN. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "GNNs have emerged in recent years as the most powerful model for processing graph-structured data and have demonstrated exceptional performance across various fields, such as social networks [22], recommender systems [6], and drug discovery [4]. Through the message-passing mechanism that propagates and aggregates information of neighboring nodes, GNNs provide a general framework for learning information on graph structure. Despite the remarkable success, according to previous studies [17, 32], GNNs show significant performance degradation as the number of layers increase. One of the main reasons for this situation is over-smoothing [17, 21, 32, 15]. Over-smoothing refers to the phenomenon in which node representations become increasingly similar to each other as GNNs recursively aggregate more neighborhood information. This indistinguishability will inevitably degrade the performance of deep GNNs, restricting their ability to effectively model long-range dependencies among multi-hop neighbors. ", "page_idx": 0}, {"type": "text", "text": "Several methods have recently been proposed to alleviate over-smoothing in deep GNNs. According to [26], these methods fall into three categories: Normalization and Regularization [34, 33], Change of GNN dynamics [5], and Residual connections [32, 16]. Among all of them, the residual-based method is inspired by the success of residual neural networks (ResNets) [9] in computer vision. This type of method introduces a residual connection to the GNNs architecture. For example, JKNet [32] learns node representations by aggregating the outputs of all previous layers at the last layer. DenseGCN [16] concatenates the results of the current layer and all previous layers as the node representations of this layer. APPNP [15] uses the initial residual connection to retain the initial feature information with probability $\\alpha$ , and utilizes information aggregated at the current layer with probability $1-\\alpha$ . GCNII [3] shares a similar framework with APPNP, and it further introduces an identical mapping to avoid overfitting. ", "page_idx": 0}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "In this paper, we study the over-smoothing issue in GNNs, with a particular emphasis on residual methods. First, we revisit the over-smoothing phenomenon of GNNs from the new perspective of overlapping neighborhood subgraphs and explain the essential reason why the residual method can alleviate the over-smoothing. In essence, these methods mainly use multiple neighborhood subgraph aggregations to alleviate the indistinguishability of the single neighborhood subgraph aggregation, thereby improving the performance of the model. On this basis, we find that these residual methods often lack node adaptivity in utilizing multi-order neighborhood subgraph information, and at the same time, they still struggle to mitigate information loss when dealing with high-order neighborhood subgraphs, which hinders further improvement in the performance of deep GNNs. Although some residual methods, such as DenseGNN, can avoid these drawbacks, they tend to introduce more parameters at deeper layers. This can lead to significant memory consumption and is prone to gradient explosion, limiting the scalability of the methods. ", "page_idx": 1}, {"type": "text", "text": "Considering these limitations, we propose a Posteriori-Sampling-based Node-Adaptative Residual Module (PSNR). More specifically, this module introduces a graph encoder to learn the posterior distribution of the required residual coefficients for each node in different layers with minor overhead. And then, we can obtain the specific fine-grained node-adaptive residual coefficients by sampling from the distribution. The contributions of this paper are as follows: ", "page_idx": 1}, {"type": "text", "text": "\u2022 Perspective: We revisit the over-smoothing issue from a novel perspective of high-order neighborhood subgraph coincidences and explain why the residual methods can alleviate it. Through this lens, we reveal several significant drawbacks of prior residual methods that limit the performance and scalability of GNNs.   \n\u2022 Method: We propose PSNR, a lightweight and model-agnostic module to mitigate the drawbacks of previous residual methods and provide theoretical justification for its advantages.   \n\u2022 Experiments: Extensive experiments verify that the PSNR module can effectively mitigate oversmoothing and further improve the performance of GNNs, especially in the case of missing feature that require deep GNNs. ", "page_idx": 1}, {"type": "text", "text": "2 Related Work ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "2.1 Notations ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "A connected undirected graph is represented by $\\mathcal{G}=(\\mathcal{V},\\mathcal{E})$ , where $\\mathcal{V}=\\{v_{1},v_{2},\\ldots,v_{N}\\}$ is the set of $N$ nodes and $\\mathcal{E}\\subseteq\\mathcal{V}\\times\\mathcal{V}$ is the edge set. The node features are represented in the matrix $\\mathbf{H}\\in\\mathbb{R}^{N\\times d}$ , where $d$ represents the length of the feature. Let $\\mathbf{A}\\in\\{0,1\\}^{N\\times\\dot{N}}$ denotes the adjacency matrix and $\\mathbf{A}_{i j}=1$ only if an edge exists between nodes $v_{i}$ and $v_{j}$ . ${\\bf D}^{'}\\!\\in\\mathbb{R}^{\\ensuremath N\\times\\ensuremath N}$ is the diagonal degree matrix, where each element $d_{i}$ represents the number of edges connected to node $v_{i}$ . $\\bar{\\mathbf{A}}=\\mathbf{A}+\\mathbf{I},\\bar{\\mathbf{D}}=\\mathbf{D}+\\mathbf{I}$ represent the adjacency matrix and degree matrix with self-loop, respectively. ", "page_idx": 1}, {"type": "text", "text": "2.2 Graph Neural Networks ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "A GNN layer updates the representation of each node via aggregating itself and its neighbors\u2019 representations. Specifically, a layer\u2019s output $\\mathbf{H}^{\\prime}$ consists of new representations $\\mathbf{h}^{\\prime}$ of each node computed as: ", "page_idx": 1}, {"type": "equation", "text": "$$\n\\mathbf{h}_{i}^{\\prime}=\\mathrm{f}_{\\theta}\\left(\\mathbf{h}_{i},\\mathrm{AGGREGATE}\\left(\\left\\{\\mathbf{h}_{j}\\mid v_{j}\\in\\mathcal{V},\\left(v_{i},v_{j}\\right)\\in\\mathcal{E}\\right\\}\\right)\\right),\n$$", "text_format": "latex", "page_idx": 1}, {"type": "text", "text": "where $\\mathbf{h}_{i}^{\\prime}$ indicates the new representation of node $v_{i}$ and $\\operatorname{f}_{\\theta}(\\cdot)$ denotes the update function. The difference between different GNNs lies in the update function $\\mathbf{f}_{\\theta}(\\cdot)$ and the AGGREGATE $(\\cdot)$ function, which are also key to the performance of GNNs. Graph Convolutional Network (GCN) [14] ", "page_idx": 1}, {"type": "table", "img_path": "VywZsAGhp0/tmp/b529ade2e759440d9c6f5e8af849c5a04a9e25bacbf3cdf450ea39a653e163d5.jpg", "table_caption": ["Table 1: Common residual connections for GNNs. "], "table_footnote": [], "page_idx": 2}, {"type": "text", "text": "is a classical massage-passing GNNs follows layer-wise propagation rule: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k+1}=\\sigma\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\mathbf{H}_{k}\\mathbf{W}_{k}\\right),\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $\\mathbf{H}_{k}$ is the feature matrix of the $k$ -th layer, $\\mathbf{W}_{k}$ is a layer-specific learnable weight matrix, $\\sigma(\\cdot)$ denotes an activation function. ", "page_idx": 2}, {"type": "text", "text": "2.3 Residual connection ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Several works have used residual connection to alleviate the over-smoothing issue. Common residual connections for GNNs are summarized in Table 1, where ${\\mathbf{H}}_{k}$ represents the output of the $k$ -th layer, $\\mathbf{W}_{k}$ is a learnable weight matrix for the $k$ -th layer, $\\alpha$ serves as a hyperparameter denoting the residual coefficient, and $\\sigma(\\cdot)$ denotes an activation function. Additionally, in DenseGNN, AGG represents a function with the concatenation of outputs from all previous layers as the input to the current layer, while in JKNet, AGG refers to the aggregation of all previous representations through concatenation, max-pooling, or LSTM-attention only at the final layer. Details can be found in Appendix B. ", "page_idx": 2}, {"type": "text", "text": "3 Why does the residual method alleviate over-smoothing? ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this section, we revisit over-smoothing from the perspective of overlapping high-order neighborhood subgraphs. Based on this, we elucidate the role of various residual methods in alleviating over-smoothing and identify their shortcomings. ", "page_idx": 2}, {"type": "text", "text": "3.1 Revisit over-smoothing from the perspective of neighborhood subgraphs overlapping ", "text_level": 1, "page_idx": 2}, {"type": "image", "img_path": "VywZsAGhp0/tmp/b56dc1fcbcbbf36f3e946dbe79c6537973d239a72dc6507adfd34ad2a206c70f.jpg", "img_caption": ["Figure 1: SMV for node groups of different degrees. More results are shown in Appendix C. "], "img_footnote": [], "page_idx": 2}, {"type": "text", "text": "For message-passing GNNs without the residual connection, the information domain of each node after $k$ -layer aggregation is a corresponding $k$ -order neighborhood subgraph. Intuitively, the size of its $k$ -order neighborhood subgraph grows exponentially as $k$ increases, leading to a significant increase in the overlap between the $k$ -order neighborhood subgraphs of different nodes. As a result, the aggregation result of different nodes on their respective $k$ -order neighborhood subgraphs becomes indistinguishable. This explanation can be partially validated from the perspective of node degrees. Considering nodes with high degrees tend to have larger neighborhood subgraph overlap, the correlation between neighborhood subgraph overlap and oversmoothiong can be validated if nodes with higher degree exhibit more pronounced over-smoothing. To verify this point, we conduct experiments on three graph datasets: Cora, Citeseer, and Pubmed. Initially, nodes are grouped based on their degrees, with nodes having degrees falling within the range of $[2^{i},2^{i+1})$ assigned to the $i$ -th group. Subsequently, we perform aggregation with different layers of GCN and GAT and then calculate the degree of smoothing of the node representations within each group separately. The metric proposed in [19] is used to measure the smoothness of the node representations within each group, namely smoothness metric value (SMV), which calculates the average distances between the nodes within the group: ", "page_idx": 2}, {"type": "text", "text": "", "page_idx": 3}, {"type": "equation", "text": "$$\n\\operatorname{SMV}(\\mathbf{X})=\\frac{1}{N(N-1)}\\sum_{i\\neq j}\\mathcal{D}\\left(\\mathbf{X}_{i,:},\\mathbf{X}_{j,:}\\right),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\mathcal{D}(\\cdot,\\cdot)$ denotes the normalized Euclidean distance between two vectors: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathcal{D}(\\mathbf{x},\\mathbf{y})=\\frac{1}{2}\\left\\|\\frac{\\mathbf{x}}{\\|\\mathbf{x}\\|}-\\frac{\\mathbf{y}}{\\|\\mathbf{y}\\|}\\right\\|_{2}.\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "From the definition, a smaller value of SMV indicates a greater similarity in node representations. We show the result of GAT in Figure 1. More results can be found in Appendix C. It can be observed that the groups of nodes with higher degree tend to be more similar to each other within the group in different layers. This finding supports our claim. ", "page_idx": 3}, {"type": "text", "text": "3.2 The role of residual method in alleviating over-smoothing ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "After verifying the conclusion that neighborhood subgraph overlap leads to over-smoothing, a natural idea is to alleviate the overlap of the single neighborhood subgraph by utilizing multiorder neighborhood subgraph aggregations. In the following section, we show that the previous $k$ -layer residual-based GNNs essentially represent different forms of utilizing neighborhood subgraph aggregations from 0 to $k$ orders. ", "page_idx": 3}, {"type": "table", "img_path": "VywZsAGhp0/tmp/fcce3ff42be61132bfb7456acdacc49694316bc59ba8904d5211cb266e5264e3.jpg", "table_caption": ["Table 2: Utilization of neighborhood subgraphs by various residual methods. "], "table_footnote": [], "page_idx": 3}, {"type": "text", "text": "In the rest of this paper, we take GCN, a classical residual-free message-passing GNN, as an example. Assuming that $\\mathbf{H}$ is non-negative, the ELU function and the weight matrix can be ignored for simplicity. Combined with the formula of GCN in Eq. 2, the $k$ -order neighborhood subgraph aggregation can be formulated as $\\mathbf{N}^{k}\\mathbf{H}$ , where $\\mathbf{N}=\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}$ . To show more intuitively how different residual models utilize multi-order neighborhood subgraph aggregation $\\mathbf{N}^{k}\\mathbf{H}$ , we rewrite their formula in Table 2. Details of the derivation of the closed-form formula in this part are given in Appendix D. As can be observed, the output of GCN\u2019s residual-based variants contains multi-order matrix products that represent different order neighborhood subgraph aggregations from 0 to $k$ . There are two main ways to exploit them: (1) Summation, such as ResGCN and APPNP. Such methods employ linear summation over the aggregation of different order neighborhood subgraphs; (2) Aggregation functions, such as DenseGNN and JKNet. Such methods make direct and explicit exploitation of different order neighborhood subgraph aggregations through operations such as concatenation. ", "page_idx": 3}, {"type": "text", "text": "However, the utilization of multi-order neighborhood subgraph aggregations in these methods presents the following issues: Firstly, the summation methods all use a fixed coefficient to sum the neighborhood subgraph aggregations. Consequently, these methods inherently presume that the information from the neighborhood subgraph of the same order is equally important for different nodes, which lacks node adaptivity. Secondly, for ResGNN, APPNP, and JKNet, when the number of layers increases, the output of these methods still involves many high-order matrix products that are over-smoothed. This leads to severe information loss when aggregating high-order neighborhood subgraphs, which in turn degrades model performance at deeper layers. Although DenseGNN seems to alleviate the above issues to some extent, the recursive use of all previous neighborhood subgraph aggregation would introduce more parameters as the model deepens. This increases memory consumption and raises the risk of gradient explosion at deeper layers. ", "page_idx": 3}, {"type": "text", "text": "4 The Proposed Method PSNR ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "4.1 Methodology ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "To solve the above issues, we propose a node-adaptive and lightweight residual module named PSNR. The motivation is to learn the adaptive residual coefficients for each node, thereby achieving fine-grained and node-level neighborhood subgraph aggregation to improve the performance of GNNs. However, directly learning these coefficients through backpropagation presents significant challenges. The primary challenge lies in the lack of transferability of learned coefficients. Specifically, in tasks such as semi-supervised node classification, nodes in the test and validation sets often cannot propagate information to the training nodes through multiple message-passing steps. Therefore, we cannot learn effective coefficients for these nodes during the training phase. ", "page_idx": 4}, {"type": "text", "text": "As a remedy, we regard node-level residual coefficients as hidden parameters. Our strategy involves estimating their posterior distribution ${\\bf P}(\\eta_{k}|{\\bf A},{\\bf H}_{k},k)$ . In most cases, since the training, validation, and test sets originate from the same distribution, the posterior distribution learned from the training data possesses transferability to the validation and testing nodes. We can assume the posterior distribution to be Gaussian: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\eta_{k}\\sim\\mathcal{N}(\\mu(\\mathbf{A},\\mathbf{H}_{k},k),\\sigma^{2}(\\mathbf{A},\\mathbf{H}_{k},k)).\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "A graph encoder can be used to model this distribution. This encoder leverages graph topology and node information as inputs. Subsequently, to enable backpropagation, we employ the reparameterization trick. This technique enables us to represent the sampling process from the aforementioned distribution as follows: ", "page_idx": 4}, {"type": "image", "img_path": "VywZsAGhp0/tmp/0547aa8d2d0ce609e6e4516dfa81e74ddaae192cd626faa2bf91039551ed5fbd.jpg", "img_caption": ["Figure 2: The framework of PSNR Module. "], "img_footnote": [], "page_idx": 4}, {"type": "equation", "text": "$$\n\\eta_{k}=\\mu(\\mathbf{A},\\mathbf{H}_{k},k)+\\zeta\\cdot\\sigma(\\mathbf{A},\\mathbf{H}_{k},k),\\;\\zeta\\sim\\mathcal{N}(0,1).\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Furthermore, we parameterize $\\mu(\\mathbf{A},\\mathbf{H}_{k},k)$ and $\\sigma(\\mathbf{A},\\mathbf{H}_{k},k)$ as an arbitrary GNN layer. While the posterior distributions of residual coefficients vary across different layers, we do not parameterize a specific encoder for each layer. Instead, we employ the same graph encoder and use the positional embedding generated from the layer number $k$ to differentiate the posterior distributions of residual coefficients for various layers. Consequently, the PSNR module can be formulated as follows: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{H}_{k-1}^{\\prime}=\\mathrm{GraphConv}\\left(\\mathbf{H}_{k-1}\\right)}\\\\ &{\\mathbf{H}_{k}=\\mathbf{H}_{1}+\\phi(d i a g(\\eta_{k-1}))\\left(\\mathbf{H}_{1}-\\mathbf{H}_{k-1}^{\\prime}\\right),\\;\\eta_{k-1}\\sim\\mathcal{N}(\\mu_{k-1},\\sigma_{k-1}{^2})}\\\\ &{\\mu_{k},\\sigma_{k}=\\mathrm{GraphEncoder}_{\\mu,\\sigma}(\\mathbf{H}_{1}-\\mathbf{H}_{k}^{\\prime}+\\gamma\\,\\mathrm{LayerEmb}(k)),}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\mathrm{{GraphConv}(\\cdot)}$ is the $k$ -th layer of any backbone GNN, $\\mathbf{H}_{k}$ denotes the node representation matrix of the $k$ -th layer, and $\\mathbf{H}_{k}^{\\prime}$ represents the output matrix of the $k$ -th layer. The first equation corresponds to the aggregation operation of the backbone GNN at the $k$ -th layer. $\\eta_{k}$ represents the node-level residual coefficient at the k-th layer, where the element \u03b7(ki) corresponds to the residual coefficient at the $i$ -th node. In addition, $\\eta_{k}$ follows a high-dimensional Gaussian distribution: $\\mathcal{N}(\\mu_{k},{\\sigma_{k}}^{2})$ , and each time before each residual calculation, the distribution is first sampled to obtain the exact residual coefficients. $\\mu_{k}$ and $\\sigma_{k}$ represent the mean and standard deviation of the distribution, respectively. $d i a g(\\eta_{k})$ represents a diagonal matrix transformed from $\\eta_{k}$ , where the $i$ -th diagonal element is precisely the $i$ -th element of $\\eta_{k}$ . $\\phi(\\cdot)$ represents the sigmoid function, which constrains the residual coefficient to $(0,1)$ . GraphEn $\\operatorname{coder}_{\\mu,\\sigma}(\\cdot)$ is a posterior encoder, which can be any graph convolution layer that is independent of the backbone GNN. LayerEmb $(k)$ represents the positional embedding [29] with layer number $k$ as input. $\\gamma$ is a learnable coefficient serving as the layer embedding factor. The analysis of the residual coefficients can be found in Appendix H. ", "page_idx": 4}, {"type": "text", "text": "Also, it is noteworthy that PSNR introduces randomness by sampling residual coefficients during both training and testing phases, thereby adding learnable random perturbations. This is different to other methods including DropEdge [24], GRAND [8] and DropMessage [7] that only incorporate randomness during the training phase and primarily introduce perturbations to node features and graph structure. We provide the theoretical analysis for this design in Section 4.2. Additionally, we clarify the difference between PSNR and other subgraph-based methods in Appendix F. ", "page_idx": 4}, {"type": "text", "text": "4.2 Theoretical justifications on the advantages of the PSNR module ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "In this section, we theoretically show that the PSNR module achieves finer-grained and node-adaptive neighborhood subgraph aggregations while avoiding the loss of high-order subgraph information. Firstly, combining with Equation 5, the matrix form of the iterative formula for PSNR-GCN is: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\mathbf{H}_{1}+\\boldsymbol{\\Lambda}_{k-1}\\left(\\mathbf{H}_{1}-\\tilde{\\mathbf{D}}^{-1/2}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-1/2}\\mathbf{H}_{k-1}\\right).\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "For simplicity, we use $\\Lambda_{k}$ to denote $d i a g(\\eta_{k})$ . Subsequently, based on this recursive form of formula, we derive the closed-form expression of PSNR-GCN as: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\sum_{i=2}^{k-1}\\prod_{j=i}^{k-1}\\tilde{\\mathbf{N}}_{j}(\\mathbf{M}_{i}-\\mathbf{M}_{i-1})+\\prod_{i=1}^{k-1}\\tilde{\\mathbf{N}}_{i}\\left(\\mathbf{H}_{1}+\\mathbf{M}_{1}\\right)-\\mathbf{M}_{k-1},\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\tilde{\\mathbf{N}}_{i}\\,=\\,-\\Lambda_{k-1}\\mathbf{N}$ , and $\\mathbf{M}_{k}\\,=\\,-\\left(\\Lambda_{k}\\mathbf{N}+\\mathbf{I}\\right)^{-1}\\left(\\mathbf{I}+\\Lambda_{k}\\right)\\mathbf{H}_{1}$ . The detailed derivation of this formula can be found in Appendix E. The first two terms consist of cumulative product terms of different orders, similar to the form of $\\mathbf{N}^{k}\\mathbf{H}$ , thus approximating a new version of neighborhood subgraph aggregation. Additionally, the formula involves the aggregation of all neighborhood subgraphs from 1 to $k$ orders. This ensures that our method, like other residual methods, can comprehensively utilize multi-order neighborhood subgraph aggregations to enhance performance. Furthermore, since $\\Lambda_{k}$ is a diagonal matrix computed by a learnable posterior encoder with graph structure, node feature and layer number as input, the neighborhood subgraph aggregation of PSNRGCN is fine-grained and node-adaptive. This sets it apart from methods like ResGCN and APPNP. ", "page_idx": 5}, {"type": "text", "text": "Beyond that, we can also demonstrate that the PSNR module can reduce the information loss of high-order subgraph aggregation, thereby further improving the performance of GNNs at deeper layers. Specifically, we aim to prove that as the order $k$ increases, the smoothing rate of the cumulative product terms in PSNR is slower than that of the matrix power terms in other methods. Since we need to analyse the smoothing rate, which involves analyzing the asymptotic behavior of cumulative product terms or matrix power terms as the order increases, we can generalize the problem setup. Therefore, we only need to prove the following proposition to support our claim. ", "page_idx": 5}, {"type": "text", "text": "Proposition 1 Let $S\\;=\\;\\{\\mathbf{S}_{j}\\;=\\;\\Lambda_{j}\\mathbf{N}|j\\;\\in\\;\\mathbb{N}_{0}\\}.$ , where $\\Lambda_{j}$ represents a random diagonal matrix with each diagonal element $\\Lambda_{j,i i}$ satisfying $0~<~\\Lambda_{j,i i}~<~1$ , and let $\\mathbf{X}$ be any feature matrix. Then, as the order $k$ increases, the product of elements in the set $\\boldsymbol{S}$ and the matrix X, denoted as $\\begin{array}{r}{\\mathbf{X}^{(k)}=\\prod_{i=1}^{k}\\mathbf{S}_{i}\\mathbf{X},}\\end{array}$ , converges to a rank-one matrix with identical rows slower than $\\mathbf{X}_{G C N}^{(k)}=\\mathbf{N}^{k}\\mathbf{X}$ ", "page_idx": 5}, {"type": "text", "text": "Since the diagonal elements of the diagonal matrix $\\Lambda$ are all results of the sigmoid function, we can assume that they have a lower bound $\\epsilon>0$ . Therefore, in this setting, each element $\\mathbf{S}_{i}$ in the set $\\boldsymbol{S}$ is a row-stochastic matrix satisfying the following property. ", "page_idx": 5}, {"type": "text", "text": "Property 1 For a row-stochastic matrix $\\mathbf{S}_{k}$ , there exists an $\\epsilon>0$ satisfying the following conditions: $\\mathbf{\\mu}^{l}.\\ \\epsilon\\leq\\mathbf{S}_{k,i j}\\leq1,$ , $i f(i,j)\\in\\mathcal{E}$ ,   \n2. $\\mathbf{S}_{k,i j}=0$ , $i f(i,j)\\notin\\mathcal{E}$ . ", "page_idx": 5}, {"type": "text", "text": "We can refer to the conclusion in [31]. [31] describes the attention matrix of GAT as a row-stochastic matrix satisfying Property 1. Leveraging mathematical tools such as joint spectral radius from the perspective of dynamical systems, this work proves that the convergence rate of GAT is bounded below by GCN. Due to all the matrix $\\mathbf{S}_{i}$ from $\\boldsymbol{S}$ also satisfies Property 1, this conclusion can be borrowed to prove Proposition 1, thereby demonstrating that the PSNR module can alleviate the loss of high-order neighborhood subgraph information. Furthermore, this conclusion also explains the introduction of randomness during both the training and testing phases. This random perturbation further reduces the smoothing rate, thereby enhancing the model\u2019s performance. ", "page_idx": 5}, {"type": "text", "text": "4.3 Complexity analysis ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "We take PSNR-GCN as an example to provide a complexity analysis of the PSNR module. The time complexity of a vanilla GCN layer mainly comes from the matrix multiplication of $\\mathbf{N}$ and $\\mathbf{H}$ , hence its complexity is $O(n^{2}d)$ . And the main computational parts of PSNR module are the computation of mean and standard deviation, sampling of $p_{k}^{(i)}$ , scalar multiplication and matrix addition, which correspond to a complexity of $Q(n^{2}d),O(n),O(n d)$ , and $O(n d)$ , respectively. Thus the time complexity of the PSNR module is $O(n^{2}d)$ and the time complexity of a GCN layer equipped the PSNR module is $O(n^{2}d)$ . As for space complexity, PSNR module needs to store the computed mean and variance for each node, i.e., $O(2n)$ , which can be approximately considered as $O(n)$ . Section 5.6 compares memory consumption with other residual methods on large graphs. ", "page_idx": 5}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "5 Experiment ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "In this section, we assess the performance of the PSNR module in comparison to other methods and answer the following research questions (RQ): RQ1. How well does the PSNR alleviate oversmoothing? RQ2. How does PSNR perform compared to other baseline when used with different backbone? RQ3. Can PSNR enable deeper networks to perform better under the missing feature scenario? RQ4. How scalable is the PSNR on large graph datasets? ", "page_idx": 6}, {"type": "text", "text": "5.1 Datasets ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We conducted experiments on ten real-world datasets, including three citation network datasets, i.e., Cora, Citeseer, Pubmed [27], two web network datasets, i.e., Chameleon and Squirrel [25], co-author/co-purchase network datasets, i.e., Coauthor-CS [28], Amazon-Photo [28] and three larger datasets, i.e., Flickr [20], Coauthor-Physics [28] and Ogbn-arxiv [10]. More details of these datasets and data-splitting procedures can be found in Appendix G. ", "page_idx": 6}, {"type": "text", "text": "5.2 Baselines and experimental settings ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We consider two fundamental GNNs, GCN [14] and GAT [30]. For GCN, we test the performance of PSNR-GCN and its residual variant models, including ResGCN [16], DenseGCN [16], GCNII [3] and JKNet [32]. For GAT, we directly equip it with the following residual module: Res-GAT, InitialRes-GAT, Dense-GAT, JK-GAT and PSNR-GAT. And we adopt the GraphSAGE layer as the GraphEncoder of the PSNR module. The impact of different graph encoders on the experiments can be found in Appendix I. In addition, we compare three recent representative methods belonging to different categories aimed at alleviating oversmoothing issues: DropMessage [7] for the drop category, DeProp [18] for the norm category, and Half-Hop [1] for graph data processing. For the missing feature setting, we also conduct comparisons with several classical oversmoothing mitigation techniques, including BatchNorm [11], PairNorm [33], DGN [34], Decorr [12], DropEdge [24]. For all baselines, the linear layers in the models are initialized with a standard normal distribution, and the convolutional layers are initialized with Xavier initialization. The Adam optimizer [13] is used for training. Experimental results are obtained from the server with four core Intel(R) Xeon(R) Platinum 8358 CPUs $\\textcircled{a}2.60\\mathrm{GHZ}$ , one NVIDIA A100 GPU (80G), and models and datasets used in this paper are implemented using the Deep Graph Library (DGL) and Pytorch Geometric (PyG). Further details on the specific parameter settings can be found in Appendix G. ", "page_idx": 6}, {"type": "text", "text": "5.3 Effectiveness in mitigating over-smoothing (RQ1) ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "In this section, we aim to assess whether the PSNR module can mitigate the oversmoothing phenomenon in deep GNNs. We select representative datasets Cora, Amazon-Photo, and Chameleon. Using GCN as the backbone network, we compare our method against several residual methods: ResGCN, GCNII, JKNet, and DenseGNN. We set the number of layers to 2, 4, 8, 16, 32, 64 and test on ten random splits, with the average accuracy serving as the final result. The experimental results are depicted in Figure 3. Consistent with the analysis in the main text, most methods can alleviate over-smoothing, but at deeper layers, such as 64 layer, over-smoothing still occurs. In contrast, compared to other residual methods, PSNR maintains stable performance even at deeper layers, demonstrating remarkable effectiveness in mitigating over-smoothing in deep GNNs. This is attributed to PSNR module can effectively reduce the loss of high-order neighborhood subgraph information. It is noteworthy that among the various residual methods, another initial residual method GCNII also alleviate over-smoothing well. However, the subsequent experiment will reveal that although the performance of GCNII remains relatively stable with varying layers, it leads to a decrease in overall performance. ", "page_idx": 6}, {"type": "image", "img_path": "VywZsAGhp0/tmp/15b6b9fa75bab45032e4d6f75c7d571eb7177d9c01d051edbdc9176ea889faa8.jpg", "img_caption": ["Figure 3: Different residual methods\u2019 effectiveness in mitigating over-smoothing. "], "img_footnote": [], "page_idx": 7}, {"type": "table", "img_path": "VywZsAGhp0/tmp/26bba0248359e5159e78bb1bb6c60952f6ef3f91a897b5e14beb747f9813394e.jpg", "table_caption": ["Table 3: Summary of classification accuracy $(\\%)$ results on real-world datasets. The best results are in bold, and the second best results are underlined. "], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "5.4 Fully observed feature setting (RQ2) ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "The PSNR module can effectively address the performance degradation of GNNs at deeper layers, but can it further enhance the overall performance of the model? In this section, we comprehensively evaluate the PSNR module across a wider range of datasets. Under the fully observed feature setting, we set the number of layers to 2, 4, 8, 16, 32, 64, and conduct experiments on ten random splits for each dataset, taking the average accuracy as the final result for each layer. The results of all layers of the model can be found in Appendix A. To evaluate the overall performance, we record the best results of each model in all layers for each dataset in Table 3. ", "page_idx": 7}, {"type": "text", "text": "As can be observed from the Table 3, PSNR outperforms all baselines in most cases. For example, compared to the vanilla model, PSNR improves the test accuracy on the Squirrel dataset by $7.52\\%$ and $12.92\\%$ , respectively. Compared with the vanilla GCN and GAT, the proposed PSNR can significantly improve the performance under the fully observed feature setting. ", "page_idx": 7}, {"type": "text", "text": "5.5 Missing feature setting (RQ3) ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "When do we need the deeper GNN? Real-world data often contain missing features. In that scenario, previous research [33] has shown that deep GNNs can help improve performance. For the nodes with missing features, due to the lack of information, they need a deeper network to gather more neighborhood information, thereby achieving better node representations. However, deep GNNs face the issue of performance degradation. In this section, we examine if PSNR module can improve the performance of GNNs in the context of missing feature. ", "page_idx": 7}, {"type": "text", "text": "Consistent with [33, 18, 12], we evaluate the performance of GNNs on three datasets, Cora, Citeseer, and Pubmed, and remove their node features from validation and test sets. Under this setting, the test nodes need more propagation layers to reach the training nodes. We reuse the metrics that already reported in [12] for None, BatchNorm [11], PairNorm [33], DGN [34], DeCorr [12], and DropEdge [24]. For all residual-based models, the results are obtained by varying the number of layers in $\\{2,4,6,8,10,15,20,30\\}$ and running five times for each number of layers. We select the layer #K that achieves the best performance and report its average accuracy. The results are reported in Table 4. By examining the results in Table 4, under the missing feature setting, the optimal number of layers to achieve the best performance is significantly higher than in the fully observed feature setting, demonstrating the importance of deep GNNs. And PSNR outperform other baselines in all cases through alleviating over-smoothing more effectively. Specially, on the Pubmed dataset, PSNR boost the accuracy of GCN and GAT by $40.6\\%$ and $38.8\\%$ , respectively. ", "page_idx": 7}, {"type": "table", "img_path": "VywZsAGhp0/tmp/4ce1a769d838e3eb656b088e46377bab7e760fae51365c1da50041df63550e80.jpg", "table_caption": ["Table 4: Test accuracy $(\\%)$ on missing feature setting. The best results are in bold and the second best results are underlined. "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "5.6 Performance on large graphs (RQ4) ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "To validate the scalability of PSNR, we conducted additional experiments on three larger graph datasets i.e., Coauthor-Physics, Flickr and Ogbn-arxiv, to further validate the effectiveness and scalability of our method. Specifically, we selected the GCN backbone for our experiment. We report the performance of GCN and various residual methods on three datasets and the memory consumption on the largest dataset, Ogbn-arxiv. The experimental results are presented in Table 5, from which we observe that PSNR-GCN scales well and achieves the best results across all three large datasets. Meanwhile, in terms of memory consumption, PSNR is slightly higher than GCN and ResGCN, comparable to GCNII with the same initial residuals, and significantly lower than JKNet and DenseGCN. Regarding training time, PSNR is roughly at the same level as JKNet, and its time is shorter than that of DenseNet. ", "page_idx": 8}, {"type": "table", "img_path": "VywZsAGhp0/tmp/33238f47226ea021fbc94f5f54e19549304d30b0189233f88e3c14410817e33b.jpg", "table_caption": ["Table 5: Comparison of different methods across various datasets and memory consumption (MB) and training time (ms / epoch) on Ogbn-arxiv. The best performance for each dataset is in bold, while the second best is underlined. "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "6 Conclusion and Future Work ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "In this paper, we addressed the oversmoothing in Graph Neural Networks (GNNs) with a focus on residual methods. We revisit the oversmoothing from the perspective of overlapping neighborhood subgraphs, explaining why residual methods can alleviate it. Our analysis revealed that current residual methods often lack node adaptivity and struggle with information loss in high-order neighborhoods subgraphs. To overcome these limitations, we introduce the Posteriori-Sampling-based Node-Adaptive Residual Module (PSNR). This innovative module uses a graph encoder to learn the posterior distribution of residual coefficients for each node at different layers, enabling fine-grained, node-adaptive neighborhood subgraph aggregation with minimal overhead. Extensive experiments confirmed that the PSNR module can effectively mitigate oversmoothing and improve performance, particularly in scenarios requiring deep networks. Despite the significant progress made by PSNR, training a deeper GNN remains challenging, prompting the need for further research in the future. ", "page_idx": 8}, {"type": "text", "text": "", "page_idx": 9}, {"type": "text", "text": "7 Acknowledgements ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "This work was supported by National Science and Technology Major Project (No. 2022ZD0115101), National Natural Science Foundation of China Project (No. 623B2086, No. U21A20427), Project (No. WU2022A009) from the Center of Synthetic Biology and Integrated Bioengineering of Westlake University and Integrated Bioengineering of Westlake University and Project (No. WU2023C019) from the Westlake University Industries of the Future Research Funding. Carl Yang was not supported by any funds from China. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Mehdi Azabou, Venkataramana Ganesh, Shantanu Thakoor, Chi-Heng Lin, Lakshmi Sathidevi, Ran Liu, Michal Valko, Petar Velickovic, and Eva L. Dyer. Half-hop: A graph upsampling approach for slowing down message passing. In Andreas Krause, Emma Brunskill, Kyunghyun Cho, Barbara Engelhardt, Sivan Sabato, and Jonathan Scarlett, editors, International Conference on Machine Learning, ICML 2023, 23-29 July 2023, Honolulu, Hawaii, USA, volume 202 of Proceedings of Machine Learning Research, pages 1341\u20131360. PMLR, 2023.   \n[2] Beatrice Bevilacqua, Fabrizio Frasca, Derek Lim, Balasubramaniam Srinivasan, Chen Cai, Gopinath Balamurugan, Michael M. Bronstein, and Haggai Maron. Equivariant subgraph aggregation networks. In The Tenth International Conference on Learning Representations, ICLR 2022, Virtual Event, April 25-29, 2022. OpenReview.net, 2022.   \n[3] Ming Chen, Zhewei Wei, Zengfeng Huang, Bolin Ding, and Yaliang Li. Simple and deep graph convolutional networks. In Proceedings of ICML, volume 119, pages 1725\u20131735, 2020.   \n[4] David Duvenaud, Dougal Maclaurin, Jorge Aguilera-Iparraguirre, Rafael G\u00f3mez-Bombarelli, Timothy Hirzel, Al\u00e1n Aspuru-Guzik, and Ryan P. Adams. Convolutional networks on graphs for learning molecular fingerprints. In Proceedings of NeurIPS, pages 2224\u20132232, 2015.   \n[5] Moshe Eliasof, Eldad Haber, and Eran Treister. PDE-GCN: novel architectures for graph neural networks motivated by partial differential equations. In Marc\u2019Aurelio Ranzato, Alina Beygelzimer, Yann N. Dauphin, Percy Liang, and Jennifer Wortman Vaughan, editors, Advances in Neural Information Processing Systems 34: Annual Conference on Neural Information Processing Systems 2021, NeurIPS 2021, December 6-14, 2021, virtual, pages 3836\u20133849, 2021.   \n[6] Wenqi Fan, Yao Ma, Qing Li, Yuan He, Yihong Eric Zhao, Jiliang Tang, and Dawei Yin. Graph neural networks for social recommendation. In Proceedings of WWW, pages 417\u2013426, 2019.   \n[7] Taoran Fang, Zhiqing Xiao, Chunping Wang, Jiarong Xu, Xuan Yang, and Yang Yang. Dropmessage: Unifying random dropping for graph neural networks. In Brian Williams, Yiling Chen, and Jennifer Neville, editors, Thirty-Seventh AAAI Conference on Artificial Intelligence, AAAI 2023, Thirty-Fifth Conference on Innovative Applications of Artificial Intelligence, IAAI 2023, Thirteenth Symposium on Educational Advances in Artificial Intelligence, EAAI 2023, Washington, DC, USA, February 7-14, 2023, pages 4267\u20134275. AAAI Press, 2023.   \n[8] Wenzheng Feng, Jie Zhang, Yuxiao Dong, Yu Han, Huanbo Luan, Qian Xu, Qiang Yang, Evgeny Kharlamov, and Jie Tang. Graph random neural networks for semi-supervised learning on graphs. In Hugo Larochelle, Marc\u2019Aurelio Ranzato, Raia Hadsell, Maria-Florina Balcan, and Hsuan-Tien Lin, editors, Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, virtual, 2020.   \n[9] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of CVPR, pages 770\u2013778, 2016.   \n[10] Weihua Hu, Matthias Fey, Marinka Zitnik, Yuxiao Dong, Hongyu Ren, Bowen Liu, Michele Catasta, and Jure Leskovec. Open graph benchmark: Datasets for machine learning on graphs. CoRR, abs/2005.00687, 2020.   \n[11] Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In Proceedings of ICML, volume 37, pages 448\u2013456, 2015.   \n[12] Wei Jin, Xiaorui Liu, Yao Ma, Charu C. Aggarwal, and Jiliang Tang. Feature overcorrelation in deep graph neural networks: A new perspective. In Proceedings of SIGKDD, pages 709\u2013719, 2022.   \n[13] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In Proceedings of ICLR, 2015.   \n[14] Thomas N. Kipf and Max Welling. Semi-supervised classification with graph convolutional networks. In Proceedings of ICLR, 2017.   \n[15] Johannes Klicpera, Aleksandar Bojchevski, and Stephan G\u00fcnnemann. Predict then propagate: Graph neural networks meet personalized pagerank. In Proceedings of ICLR, 2019.   \n[16] Guohao Li, Matthias M\u00fcller, Ali K. Thabet, and Bernard Ghanem. Deepgcns: Can gcns go as deep as cnns? In Proceedings of ICCV, pages 9266\u20139275, 2019.   \n[17] Qimai Li, Zhichao Han, and Xiao-Ming Wu. Deeper insights into graph convolutional networks for semi-supervised learning. In Proceedings of AAAI, pages 3538\u20133545, 2018.   \n[18] Hua Liu, Haoyu Han, Wei Jin, Xiaorui Liu, and Hui Liu. Enhancing graph representations learning with decorrelated propagation. In Ambuj K. Singh, Yizhou Sun, Leman Akoglu, Dimitrios Gunopulos, Xifeng Yan, Ravi Kumar, Fatma Ozcan, and Jieping Ye, editors, Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data Mining, KDD 2023, Long Beach, CA, USA, August 6-10, 2023, pages 1466\u20131476. ACM, 2023.   \n[19] Meng Liu, Hongyang Gao, and Shuiwang Ji. Towards deeper graph neural networks. In Rajesh Gupta, Yan Liu, Jiliang Tang, and B. Aditya Prakash, editors, KDD \u201920: The 26th ACM SIGKDD Conference on Knowledge Discovery and Data Mining, Virtual Event, CA, USA, August 23-27, 2020, pages 338\u2013348. ACM, 2020.   \n[20] Julian McAuley and Jure Leskovec. Image labeling on a network: using social-network metadata for image classification. In Computer Vision\u2013ECCV 2012: 12th European Conference on Computer Vision, Florence, Italy, October 7-13, 2012, Proceedings, Part IV 12, pages 828\u2013841. Springer, 2012.   \n[21] Kenta Oono and Taiji Suzuki. Graph neural networks exponentially lose expressive power for node classification. In Proceedings of ICLR, 2020.   \n[22] Bryan Perozzi, Rami Al-Rfou, and Steven Skiena. Deepwalk: Online learning of social representations. In Proceedings of SIGKDD, pages 701\u2013710, 2014.   \n[23] Chendi Qian, Gaurav Rattan, Floris Geerts, Mathias Niepert, and Christopher Morris. Ordered subgraph aggregation networks. In NeurIPS, 2022.   \n[24] Y. Rong, Wen-bing Huang, Tingyang Xu, and Junzhou Huang. Dropedge: Towards deep graph convolutional networks on node classification. Proceedings of ICLR, 2019.   \n[25] Benedek Rozemberczki, Carl Allen, and Rik Sarkar. Multi-scale attributed node embedding. Journal of Complex Networks, 9(2), 2021.   \n[26] T. Konstantin Rusch, Michael M. Bronstein, and Siddhartha Mishra. A survey on oversmoothing in graph neural networks. CoRR, abs/2303.10993, 2023.   \n[27] Prithviraj Sen, Galileo Namata, Mustafa Bilgic, Lise Getoor, Brian Gallagher, and Tina EliassiRad. Collective classification in network data. AI Magazine, 29(3):93\u2013106, 2008.   \n[28] Oleksandr Shchur, Maximilian Mumme, Aleksandar Bojchevski, and Stephan G\u00fcnnemann. Pitfalls of graph neural network evaluation. arXiv preprint arXiv:1811.05868, 2018.   \n[29] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, \u0141ukasz Kaiser, and Illia Polosukhin. Attention is all you need. Advances in neural information processing systems, 30, 2017.   \n[30] Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, P. Lio\u2019, and Yoshua Bengio. Graph attention networks. Proceedings of ICLR, 2017.   \n[31] Xinyi Wu, Amir Ajorlou, Zihui Wu, and Ali Jadbabaie. Demystifying oversmoothing in attention-based graph neural networks. In Alice Oh, Tristan Naumann, Amir Globerson, Kate Saenko, Moritz Hardt, and Sergey Levine, editors, Advances in Neural Information Processing Systems 36: Annual Conference on Neural Information Processing Systems 2023, NeurIPS 2023, New Orleans, LA, USA, December 10 - 16, 2023, 2023.   \n[32] Keyulu Xu, Chengtao Li, Yonglong Tian, Tomohiro Sonobe, Ken-ichi Kawarabayashi, and Stefanie Jegelka. Representation learning on graphs with jumping knowledge networks. In Proceedings of ICML, pages 5449\u20135458, 2018.   \n[33] Lingxiao Zhao and L. Akoglu. Pairnorm: Tackling oversmoothing in gnns. Proceedings of ICLR, 2019.   \n[34] Kaixiong Zhou, Xiao Huang, Yuening Li, D. Zha, Rui Chen, and Xia Hu. Towards deeper graph neural networks with differentiable group normalization. Proceedings of NeurIPS, 2020. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "A Fully Observed Node Classification ", "text_level": 1, "page_idx": 12}, {"type": "table", "img_path": "VywZsAGhp0/tmp/07a08d20da0fdae1849787e3a4a7eb64aa79a782dac48e40e6acd1965cead67d.jpg", "table_caption": ["Table 6: Node classification accuracy $(\\%)$ on GCN backbone. The best results across different layers are highlighted. "], "table_footnote": [], "page_idx": 12}, {"type": "table", "img_path": "VywZsAGhp0/tmp/6a5ba4fe02f5eb1a0710d00e6545ce513943bb948612cc8e91336bfe205fd0a0.jpg", "table_caption": ["Table 7: Node classification accuracy $(\\%)$ on GAT backbone. The best results across different layers are highlighted. "], "table_footnote": [], "page_idx": 13}, {"type": "text", "text": "B Residual Connection Defination ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Common residual connection for GNNs and their corresponding GNNs are described below. ", "page_idx": 14}, {"type": "text", "text": "Res. Res is composed of multiple residual blocks containing few stacked layers. Taking the initial input of the $n$ -th residual block as $\\mathbf{X}_{n}$ , and the stacked nonlinear layers within the residual block as ${\\bf F}({\\bf X})$ : ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathbf{X}_{n+1}=\\mathbf{F}(\\mathbf{X}_{n})+\\mathbf{X}_{n},\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "where residual mapping and identity mapping refer to ${\\bf F}({\\bf X})$ and $\\mathbf{X}$ on the right side of the above equation, respectively. Inspired by Res, Guohao Li & Matthias M\u00fcller(2019) proposed a residual connection learning framework for GCN and called this model ResGCN which can be simply described as follows: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\sigma\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\mathbf{H}_{k-1}\\mathbf{W}_{k-1}\\right)+\\mathbf{H}_{k-1}.\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "InitialRes. InitialRes is proposed for the first time in APPNP, unlike Res that carries information from the previous layers, it constructs a connection to the initial representation $\\mathbf{X}_{0}$ at each layer: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathbf{X}_{n+1}=(1-\\alpha)\\mathbf{H}(\\mathbf{X}_{n})+\\alpha\\mathbf{X}_{0},\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "where $\\mathbf{H}(\\mathbf{X})$ denotes the aggregation operation within one layer. InitialRes ensures that each node\u2019s representation retains at least an $\\alpha$ -sized portion of the initial feature information. Correspondingly, APPNP can be formulated as: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\left(1-\\alpha\\right)\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\mathbf{H}_{k-1}+\\alpha\\mathbf{H}.\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "Based on APPNP, GCNII introduces identity mapping from Res to make up for the deficiency in APPNP. ", "page_idx": 14}, {"type": "text", "text": "Dense. Dense proposes a more efficient way to reuse features between layers. The input is the outputs of all previous layers of the network and at each layer Dense concats them together: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathbf{X}_{n+1}=\\mathbf{H}([\\mathbf{X}_{0},\\mathbf{X}_{1},\\ldots,\\mathbf{X}_{n}]),\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "where $[\\cdot]$ denotes the concatenation of the feature map for the output of layers 0 to n. Inspired by Dense, DenseGCN applies a similar idea to GCN, i.e., let the output of the $k$ -th layer contains transformations from all previous GCN layers to exploit the information from different GCN layers: ", "page_idx": 14}, {"type": "equation", "text": "$$\n{\\bf H}_{k}={\\bf A G G}_{d e n s e}({\\bf H},{\\bf H}_{1},\\ldots,{\\bf H}_{k-1}).\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "JK. At the last layer, JK sifts from all previous representations $[{\\mathbf{X}}_{1},...,{\\mathbf{X}}_{N}]$ and combines them: ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{X}_{o u t p u t}=\\mathbf{A}\\mathbf{G}\\mathbf{G}(\\mathbf{X}_{1},\\ldots,\\mathbf{X}_{N}).}\\end{array}\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "The $A\\mathcal{G}\\mathcal{G}$ operation includes concatenation, Maxpooling and LSTM-attention. When it is introduced to GNN, i.e., JKNet, can be formulated as: ", "page_idx": 14}, {"type": "equation", "text": "$$\n{\\bf H}_{o u t p u t}={\\bf A}{\\bf G}{\\bf G}_{j k}({\\bf H}_{1},\\ldots,{\\bf H}_{k-1}).\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "C SMV for Node Groups of Different Degrees ", "text_level": 1, "page_idx": 15}, {"type": "image", "img_path": "VywZsAGhp0/tmp/e9a97cf2f68ffcf4e04d8e4bd3c51c6685212fc6af8cdbe4f4f5071295033e52.jpg", "img_caption": ["Result of GAT. "], "img_footnote": [], "page_idx": 15}, {"type": "text", "text": "D Derivation of the closed-form formulas in the table ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "ResGCN: We can write the recursive formula for ResGCN in the following form: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=(\\mathbf{I}+\\mathbf{N})\\mathbf{H}_{k-1}.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "In turn, the following form can be obtained by recursion: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=(\\mathbf{I}+\\mathbf{N})^{k}\\mathbf{H}.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Using the binomial theorem, we can obtain the closed-form formula for ResGCN as follows: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\sum_{j=0}^{k}\\mathbf{C}_{k}^{j}\\mathbf{N}^{j}\\mathbf{H}.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "APPNP: According to the recurrence formula of APPNP: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\alpha\\mathbf{H}+(1-\\alpha)\\mathbf{N}\\mathbf{H}_{k-1}.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "To obtain the closed-form formula, we can add a term $\\mathbf{T}$ to both sides of the equation: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}+\\mathbf{T}=\\left(1-\\alpha\\right)\\mathbf{N}\\mathbf{H}_{k-1}+\\alpha\\mathbf{H}+\\mathbf{T}.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "We aim to transform the equation into the following form: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}+\\mathbf{T}=\\left(1-\\alpha\\right)\\mathbf{N}\\left(\\mathbf{H}_{k-1}+\\mathbf{T}\\right).\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Then we need to make sure that there exists a very $\\mathbf{T}$ that satisfies the following equation: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\left(1-\\alpha\\right)\\mathbf{N}\\mathbf{T}=\\alpha\\mathbf{H}+\\mathbf{T},\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "which can be transformed into the following form: ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\left(\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}\\right)\\mathbf{T}=\\alpha\\mathbf{H}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "We can proof the following lemma: ", "page_idx": 15}, {"type": "text", "text": "Lemma 1 Given that $\\alpha\\in(0,1)$ , $\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}$ is invertible. ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Proof 1 Proving that $\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}$ is invertible is equivalent to demonstrating that it does not possess an eigenvalue of $\\boldsymbol{O}$ . Consider the Rayleigh quotient of $\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}$ : ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\frac{\\mathbf{X}^{T}\\left(\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}=\\left(1-\\alpha\\right)\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}-1.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "From spectral graph theory, we can know the following equation holds: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\mathbf{L}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}=\\sum_{(v_{i},v_{j})\\in\\mathcal{E}}\\left(\\frac{\\mathbf{X}_{i}}{\\sqrt{d_{i}+1}}-\\frac{\\mathbf{X}_{j}}{\\sqrt{d_{j}+1}}\\right)^{2}>0.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "We can decompose $\\mathbf{L}$ into $\\tilde{\\mathbf{D}}-\\tilde{\\mathbf{A}}$ , then we have: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{D}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}-\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}>0,\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "which is equivalent to: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}<\\frac{\\mathbf{X}^{T}\\mathbf{I}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}=1.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Combining Eq. 14 and Ineq. 17, we can obtain: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\frac{\\mathbf{X}^{T}\\left(\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}<\\left(1-\\alpha\\right)-1=-\\alpha<0.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Hence, 0 can\u2019t be the eigenvalue of $\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}$ . Therefore, $\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}$ is invertible. ", "page_idx": 16}, {"type": "text", "text": "Since Lemma 1 holds, we can derive the concrete form of $\\mathbf{T}$ : ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{T}=\\alpha\\left(\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}\\right)^{-1}\\mathbf{H}.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Thus we can keep recurring from Eq. 11 and obtain the following equation: ", "page_idx": 16}, {"type": "equation", "text": "$$\n{\\bf H}_{k}+{\\bf T}=\\left(\\left(1-\\alpha\\right){\\bf N}\\right)^{k}\\left({\\bf H}+{\\bf T}\\right),\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "which also can be written as: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\left(\\left(1-\\alpha\\right)\\mathbf{N}\\right)^{k}\\mathbf{H}+\\left(\\left(1-\\alpha\\right)\\mathbf{N}\\right)^{k}\\mathbf{T}-\\mathbf{T}.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "For the second and third terms in Eq. 21, we write $(1-\\alpha)\\,\\mathbf{N}$ as $\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}+\\mathbf{I}$ . We can use the binomial theorem to write $((1-\\alpha)\\,\\mathbf{N})^{k}$ as $\\sum_{j=0}^{k}\\left(\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}\\right)^{j}$ , then Eq. 21 can be written as : ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\left(\\left(1-\\alpha\\right)\\mathbf{N}\\right)^{k}\\mathbf{H}+\\sum_{j=1}^{k}\\left(\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}\\right)^{j}\\mathbf{T}.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Bring in the specific form of $\\mathbf{T}$ and further derive the closed-form formula of APPNP: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{H}_{k}=\\left(\\left(1-\\alpha\\right)\\mathbf{N}\\right)^{k}\\mathbf{H}+\\alpha\\displaystyle\\sum_{j=0}^{k-1}\\left(\\left(1-\\alpha\\right)\\mathbf{N}-\\mathbf{I}\\right)^{j}\\mathbf{H}}\\\\ &{\\quad=\\left(1-\\alpha\\right)^{k}\\mathbf{N}^{k}\\mathbf{H}+\\alpha\\displaystyle\\sum_{j=0}^{k-1}\\sum_{i=0}^{j}\\left(-1\\right)^{j-i}\\left(1-\\alpha\\right)^{i}\\mathbf{N}^{i}\\mathbf{H}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "E Derivation of the closed-form formula of PSNR-GCN ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "For each diagonal element $\\Lambda_{k,i i}$ of $\\Lambda_{k}$ , it is trivial to obtain: ", "page_idx": 17}, {"type": "equation", "text": "$$\n0<\\Lambda_{k,i i}<1.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "To derive the closed-form formula of PSNR-GCN, we need proof the following lemma first. ", "page_idx": 17}, {"type": "text", "text": "Lemma 2 Set all the diagonal elements of $\\Lambda$ to satisfy $0<\\Lambda_{i i}<1$ , then $(\\Lambda\\mathbf{N}+\\mathbf{I})$ is invertible. ", "page_idx": 17}, {"type": "text", "text": "Proof 2 Proving that $\\Lambda\\mathbf{N}+\\mathbf{I}$ is invertible is equivalent to demonstrating that its determinant is not equal to 0. Because all the diagonal elements of $\\Lambda$ satisfy $0<\\Lambda_{i i}<1_{\\phantom{i}}$ , then $\\Lambda$ is invertible. And due to ", "page_idx": 17}, {"type": "equation", "text": "$$\n|\\Lambda\\mathbf{N}+\\mathbf{I}|=|\\Lambda||\\mathbf{N}+\\Lambda^{-1}|.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Therefore, proving that its determinant is not equal to $\\boldsymbol{O}$ is equivalent to demonstrating that $|\\mathbf{N}+\\boldsymbol{\\Lambda}^{-1}|$ is not equal to $\\boldsymbol{O}$ , and further equivalent to demonstrating that $\\mathbf{N}+\\Lambda^{-1}$ does not have an eigenvalue of 0. ", "page_idx": 17}, {"type": "text", "text": "Consider the Rayleigh quotient of $\\mathbf{N}+\\boldsymbol{\\Lambda}^{-1}$ : ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\mathbf{R}_{1}=\\frac{\\mathbf{X}^{T}\\left(\\mathbf{N}+\\boldsymbol{\\Lambda}^{-1}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Split Eq. 26, and we can derive: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\mathbf{R}_{1}=\\frac{\\mathbf{X}^{T}\\mathbf{N}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}+\\frac{\\mathbf{X}^{T}\\boldsymbol{\\Lambda}^{-1}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "The second term of Eq. 27 can be easily written as follows: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\frac{\\mathbf{X}^{T}\\boldsymbol{\\Lambda}^{-1}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}=\\frac{\\sum_{i=1}^{N}\\boldsymbol{\\Lambda}_{i i}^{-1}x_{i}^{2}}{\\sum_{i=1}^{N}x_{i}^{2}}.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Since $0<\\Lambda_{i i}<1$ , therefore ${\\Lambda_{i i}}^{-1}>1$ , then ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\frac{\\mathbf{X}^{T}{\\boldsymbol{\\Lambda}}^{-1}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}>1.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "For the first item, we write its specific form as follows: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\frac{\\mathbf{X}^{T}\\mathbf{N}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}=\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "From spectral graph theory, we know that the following formula holds: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\left(\\mathbf{A}+\\mathbf{D}\\right)\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}=\\sum_{(v_{i},v_{j})\\in\\mathcal{E}}\\left(\\frac{\\mathbf{X}_{i}}{\\sqrt{d_{i}+1}}+\\frac{\\mathbf{X}_{j}}{\\sqrt{d_{j}+1}}\\right)^{2}>0.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Further mathematically transforming this formula, we can get the following form: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\left(\\mathbf{A}+\\mathbf{D}\\right)\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}}\\\\ &{\\phantom{\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\left(\\tilde{\\mathbf{A}}+\\tilde{\\mathbf{D}}\\right)\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}}\\\\ &{\\phantom{\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}+\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{D}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}-\\frac{2\\mathbf{X}^{T}\\tilde{\\mathbf{D}}^{-1}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}}\\\\ &{\\phantom{\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}+1-\\frac{2\\mathbf{X}^{T}\\tilde{\\mathbf{D}}^{-1}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}>0.}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Further, we get the following result: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}>\\frac{2\\mathbf{X}^{T}\\tilde{\\mathbf{D}}^{-1}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}-1.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "It is trivial to obtain: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\frac{2\\mathbf{X}^{T}\\tilde{\\mathbf{D}}^{-1}\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}=\\frac{2\\sum_{i=1}^{N}\\left(\\mathbf{d}_{i}+1\\right)^{-1}\\mathbf{x}_{i}^{2}}{\\sum_{i=1}^{N}x_{i}^{2}}>0.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Combining Eq. 27, Ineq. 28, Ineq. 34 and Ineq. 35, we can get the following inequality: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\frac{\\mathbf{X}^{T}\\left(\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}+\\Lambda^{-1}\\right)\\mathbf{X}}{\\mathbf{X}^{T}\\mathbf{X}}>0.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "It can be obtained that the eigenvalue of $\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-\\frac{1}{2}}+\\Lambda^{-1}$ is greater than $O_{3}$ , so $O$ is not an eigenvalue of it. Further, $\\Lambda\\mathbf{N}+\\mathbf{I}$ is invertible. ", "page_idx": 18}, {"type": "text", "text": "Now, we derive the closed form of the formula. Given the following recursive formula: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\mathbf{H}_{1}+\\boldsymbol{\\Lambda}_{k-1}\\left(\\mathbf{H}_{1}-\\tilde{\\mathbf{D}}^{-1/2}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-1/2}\\mathbf{H}_{k-1}\\right),\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where $\\tilde{\\mathbf{H}}_{1}=\\tilde{\\mathbf{D}}^{-1/2}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-1/2}\\mathbf{H}\\,,\\mathbf{A}_{k}=d i a g\\{\\lambda_{k}^{(1)},...\\lambda_{k}^{(n)}\\},\\lambda_{k}^{(i)}\\sim S i g m o i d(N(\\alpha_{k}^{(i)},\\beta_{k}^{(i)^{2}})).$ After mathematical transformation, Eq. 37 can be written as: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\left(\\mathbf{I}+\\Lambda_{k-1}\\right)\\mathbf{H}_{1}-\\Lambda_{k-1}\\tilde{\\mathbf{D}}^{-1/2}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-1/2}\\mathbf{H}_{k-1}.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Set $\\mathbf{N}=\\tilde{\\mathbf{D}}^{-1/2}\\tilde{\\mathbf{A}}\\tilde{\\mathbf{D}}^{-1/2}$ , then Eq. 38 can be abbreviated as: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\left(\\mathbf{I}+\\Lambda_{k-1}\\right)\\mathbf{H}_{1}-\\Lambda_{k-1}\\mathbf{N}\\mathbf{H}_{k-1}.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "We try to modify Eq. 39 to the form that is more suitable for obtaining the closed form of the formula: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}+\\mathbf{M}_{k-1}=-\\Lambda_{k-1}\\mathbf{N}\\left(\\mathbf{H}_{k-1}+\\mathbf{M}_{k-1}\\right).\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "To verify whether there exists such $\\mathbf{M}$ that satisfies the equation, we need to solve the following equation: ", "page_idx": 18}, {"type": "equation", "text": "$$\n-\\Lambda_{k-1}\\mathbf{N}\\mathbf{M}_{k-1}=\\left(\\mathbf{I}+\\Lambda_{k-1}\\right)\\mathbf{H}_{1}+\\mathbf{M}_{k-1},\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "which is equivalent to the following form: ", "page_idx": 18}, {"type": "equation", "text": "$$\n-\\left(\\Lambda_{k-1}\\mathbf{N}+\\mathbf{I}\\right)\\mathbf{M}_{k-1}=\\left(\\mathbf{I}+\\Lambda_{k-1}\\right)\\mathbf{H}_{1}.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Based on the definition, all the diagonal elements of $\\Lambda_{k}$ satisfy $0<\\lambda_{k}^{(i)}<1$ , so according to Lemma 2, $\\left(\\Lambda_{k-1}\\mathbf{N}+\\mathbf{I}\\right)$ is invertible. Then $\\mathbf{M}_{k-1}=-\\left(\\Lambda_{k-1}\\mathbf{N}+\\mathbf{I}\\right)^{-1}\\left(\\mathbf{I}+\\Lambda_{k-1}\\right)\\mathbf{H}_{1}$ , which means such ${{\\bf{M}}_{k-1}}$ that we require exists. ", "page_idx": 18}, {"type": "text", "text": "First, we perform the following mathematical transformation on Eq. 40: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}+\\mathbf{M}_{k-1}=-\\Lambda_{k-1}\\mathbf{N}\\left(\\mathbf{H}_{k-1}+\\mathbf{M}_{k-2}+\\mathbf{M}_{k-1}-\\mathbf{M}_{k-2}\\right),\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "which can be split into the following form: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{H}_{k}+\\mathbf{M}_{k-1}=-\\Lambda_{k-1}\\mathbf{N}\\left(\\mathbf{H}_{k-1}+\\mathbf{M}_{k-2}\\right)+\\left(-\\Lambda_{k-1}\\mathbf{N}\\right)\\left(\\mathbf{M}_{k-1}-\\mathbf{M}_{k-2}\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Let $\\tilde{\\bf N}_{k-1}$ denotes $-\\Lambda_{k-1}\\mathbf{N}$ , so the formula can be simply written as: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}+\\mathbf{M}_{k-1}=\\tilde{\\mathbf{N}}_{k-1}\\left(\\mathbf{H}_{k-1}+\\mathbf{M}_{k-2}\\right)+\\tilde{\\mathbf{N}}_{k-1}\\left(\\mathbf{M}_{k-1}-\\mathbf{M}_{k-2}\\right).\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "We first use Eq. 40 to recurse once, then derive the following formula: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}+\\mathbf{M}_{k-1}=\\tilde{\\mathbf{N}}_{k-1}\\tilde{\\mathbf{N}}_{k-2}\\left(\\mathbf{H}_{k-2}+\\mathbf{M}_{k-3}\\right)+\\tilde{\\mathbf{N}}_{k-1}\\left(\\mathbf{M}_{k-1}-\\mathbf{M}_{k-2}\\right).\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "By analogy, continuing to split and iterate, we can get the closed form of the output of the $k$ -th layer: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathbf{H}_{k}=\\sum_{i=2}^{k-1}\\prod_{j=i}^{k-1}{\\tilde{\\mathbf{N}}}_{j}\\left(\\mathbf{M}_{i}-\\mathbf{M}_{i-1}\\right)+\\prod_{i=1}^{k-1}{\\tilde{\\mathbf{N}}}_{i}\\left(\\mathbf{H}_{1}+\\mathbf{M}_{1}\\right)-\\mathbf{M}_{k-1}.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "F Comparing with other subgraph-based methods ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "It is worth noting that a lot of previous work mentions \"subgraph\". However, our approach is fundamentally different from these approaches. ", "page_idx": 19}, {"type": "text", "text": "Relation with other subgraph-based methods. While there are existing works [2, 23] related to subgraphs, they primarily focus on graph classification tasks, aiming to learn representations of entire graphs. Given the limited capacity of GNNs to effectively represent the entire graphs, these subgraph-based approaches employ various strategies to leverage information from multiple subgraph structures within the overall graph to improve the representation. ", "page_idx": 19}, {"type": "text", "text": "In contrast, our focus is on node-level tasks, specifically, enhancing the representations of individual nodes. In our context, we naturally refer to neighborhood subgraphs as different orders of egonetworks centered on a node (which can be regarded as subgraphs of the entire graph). Our work uncovers the relationship between these subgraphs and over-smoothing, as well as how to utilize them to enhance node representations. This distinction fundamentally sets our approach apart from other subgraph methods. ", "page_idx": 19}, {"type": "text", "text": "G Experiment Setup ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "G.1 Details of Datasets ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "The dataset statistics are shown in Table 8, and details on dataset splits are summarized as follows: ", "page_idx": 19}, {"type": "text", "text": "Experiment 5.3 & 5.4. For Cora, Citeseer, Coauthor-CS, Amazon-Photo, we randomly select 20 nodes per class for training set, 500 nodes for validation and 1000 nodes for testing. For Chameleon and Squirrel, we randomly divide each class\u2019s nodes into $60\\%$ , $20\\%$ , and $20\\%$ as the train, validation, and test sets, respectively. ", "page_idx": 19}, {"type": "text", "text": "Experiment 5.5. We follow the widely used semi-supervised setting in [14]. ", "page_idx": 19}, {"type": "text", "text": "Experiment 5.6. For larger datasets, We randomly divide each class\u2019s nodes into $20\\%$ , $20\\%$ , and $60\\%$ as the train, validation, and test sets, respectively. ", "page_idx": 19}, {"type": "table", "img_path": "VywZsAGhp0/tmp/352fbb67c1ebefad956b0b7b432663de3b72faa63e5236f19005f6eb5b2fc73c.jpg", "table_caption": ["Table 8: Dataset statistics of real-world datasets. "], "table_footnote": [], "page_idx": 19}, {"type": "text", "text": "G.2 Parameter Settings ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "We summarized the hyperparameters used in different experiments in Table 9. ", "page_idx": 19}, {"type": "table", "img_path": "VywZsAGhp0/tmp/eb156793b37c765e56471aad57ddc61b21b65fcc0e3cefdf8e7e416ea2dba486.jpg", "table_caption": ["Table 9: Hyperparameters for experiments "], "table_footnote": [], "page_idx": 19}, {"type": "text", "text": "H. The Analysis of PSNR Residual Coefficients ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "We conducted an empirical study using an 8-layer PSNR-GCN trained on the Cora dataset to obtain the best-performing model. We saved the mean and standard deviation of the learned residual coefficient distribution for each layer. Nodes were evenly divided into four groups based on their degree, with each group containing a similar number of nodes, and the average mean and standard deviation for each group across different layers are reported in Table 10. The following observations can be obtained from the table: the mean residual coefficient increases with the number of layers, suggesting that PSNR effectively retains high-order subgraph information. In certain layers, the variance of the residual coefficients rises, indicating that added randomness helps mitigate information loss in higher-order subgraphs. In the shallow layers, the mean values show no significant differences across node degrees; however, in deeper layers, nodes with higher degrees tend to exhibit lower mean values, indicating that these nodes retain more initial information due to significant subgraph overlap. All of these observations align with our expectations, illustrating how residual coefficients adapt based on node degree and layer depth. ", "page_idx": 19}, {"type": "text", "text": "", "page_idx": 20}, {"type": "table", "img_path": "VywZsAGhp0/tmp/4de3541ce1d5ff61225580bf3a8b433f5d541eb52e2afd7c96f01b834b063bca.jpg", "table_caption": ["Table 10: Summary of means and standard deviations for different layers "], "table_footnote": [], "page_idx": 20}, {"type": "text", "text": "I. Comparison of Experimental Results of Different GraphEncoders. ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "In practice, in addition to SAGE, encoders such as GAT and GCN can also be utilized. To provide further insight, we have included results for different encoders on the classical semi-supervised node classification task. The results are summarized in the table blow. ", "page_idx": 20}, {"type": "table", "img_path": "VywZsAGhp0/tmp/d5c74b9d4345631498e516ab2dd0cdefbc1c73d217d3c74c2d629aa0e34421bf.jpg", "table_caption": ["Table 11: Different GraphEncoder performance for SSNC task (layer 2) "], "table_footnote": [], "page_idx": 20}, {"type": "table", "img_path": "VywZsAGhp0/tmp/f9486d0160540e0a2b4c694769f84cd4198cefdd05818710fd9240b93d9a046f.jpg", "table_caption": ["Table 12: Different GraphEncoder performance for SSNC task (layer 4) "], "table_footnote": [], "page_idx": 20}, {"type": "text", "text": "The results indicate that each encoder has its strengths and performs differently across various datasets, demonstrating superior performance compared to the baseline and emphasizing the potential of PSNR. ", "page_idx": 20}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "The checklist is designed to encourage best practices for responsible machine learning research, addressing issues of reproducibility, transparency, research ethics, and societal impact. Do not remove the checklist: The papers not including the checklist will be desk rejected. The checklist should follow the references and precede the (optional) supplemental material. The checklist does NOT count towards the page limit. ", "page_idx": 21}, {"type": "text", "text": "Please read the checklist guidelines carefully for information on how to answer these questions. For each question in the checklist: ", "page_idx": 21}, {"type": "text", "text": "\u2022 You should answer [Yes] , [No] , or [NA] .   \n\u2022 [NA] means either that the question is Not Applicable for that particular paper or the relevant information is Not Available.   \n\u2022 Please provide a short (1\u20132 sentence) justification right after your answer (even for NA). ", "page_idx": 21}, {"type": "text", "text": "The checklist answers are an integral part of your paper submission. They are visible to the reviewers, area chairs, senior area chairs, and ethics reviewers. You will be asked to also include it (after eventual revisions) with the final version of your paper, and its final version will be published with the paper. ", "page_idx": 21}, {"type": "text", "text": "The reviewers of your paper will be asked to use the checklist as one of the factors in their evaluation. While \"[Yes] \" is generally preferable to \"[No] \", it is perfectly acceptable to answer \"[No] \" provided a proper justification is given (e.g., \"error bars are not reported because it would be too computationally expensive\" or \"we were unable to find the license for the dataset we used\"). In general, answering \"[No] \" or \"[NA] \" is not grounds for rejection. While the questions are phrased in a binary way, we acknowledge that the true answer is often more nuanced, so please just use your best judgment and write a justification to elaborate. All supporting evidence can appear either in the main paper or the supplemental material, provided in appendix. If you answer [Yes] to a question, in the justification please point to the section(s) where related material for the question can be found. ", "page_idx": 21}, {"type": "text", "text": "IMPORTANT, please: ", "page_idx": 21}, {"type": "text", "text": "\u2022 Delete this instruction block, but keep the section heading \u201cNeurIPS paper checklist\", \u2022 Keep the checklist subsection headings, questions/answers and guidelines below. \u2022 Do not modify the questions and only use the provided macros for your answers. ", "page_idx": 21}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Justification: Our paper\u2019s contributions and scope are presented in the abstract and introduction accurately. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 21}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: Limitations of our work are discussed in Section 6. Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 22}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Justification: We provide the proofs of all theorems and the derivations of all formulas in Section 4.2, Appendix D and Appendix E, respectively. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 22}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: We provide the details of experiments in Appendix G, which can ensure the reproducibility of our experimental result. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 23}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Justification: We only used public datasets and the anonymous link to the code is provided in the Abstract. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why. ", "page_idx": 23}, {"type": "text", "text": "\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable). \u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 24}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: We provide the details of training and test in Appendix G. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 24}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: The standard deviation of the experimental results is reported in most of the tables. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 24}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: We report the details about the compute resources in Section 5.2 Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. ", "page_idx": 24}, {"type": "text", "text": "\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 25}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: Our research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 25}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: We have discussed the potential positive societal impacts in section 6. It has no negative societal impact. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 25}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 25}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: [TODO] ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 26}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: All the original owners of assets (e.g., code, data, models) used in this paper are properly credited, and the license and terms of use are explicitly mentioned and properly respected. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 26}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Justification: Yes, we provide the anonymous link to the code. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 26}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 27}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 27}, {"type": "text", "text": "Justification: Our work does not involve any crowdsourcing nor research with human subjects. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 27}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 27}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 27}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing or research with human subjects. Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 27}]