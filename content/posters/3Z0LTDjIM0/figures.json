[{"figure_path": "3Z0LTDjIM0/figures/figures_1_1.jpg", "caption": "Figure 1: The maximal participation ratio p(f) = (\u2211i=1n |fi|2)2/(\u2211i=1n fi) of example diffusion vectors f over 18 graphs, ordered from small (cora) to large (ogbn-papers100M). The ratio p(f) is normalized by the number of nodes n.", "description": "This figure demonstrates the localization property of diffusion vectors for PPR, Katz, and HK.  The maximal participation ratio (p(f)), a measure of how concentrated the non-zero values of a vector are, is plotted against the graph index (ordered by graph size).  Lower values of p(f) indicate higher localization, meaning the significant values of the diffusion vector are concentrated in a small portion of the graph.  The figure shows that for these common graph diffusion equations, the diffusion vectors are indeed highly localized, a key property leveraged by the proposed framework for efficient computation.", "section": "2 GDEs, Localization, and Existing Local Solvers"}, {"figure_path": "3Z0LTDjIM0/figures/figures_4_1.jpg", "caption": "Figure 2: The first row illustrates the local diffusion process of APPR [2] over a toy network topology adopted from [40]. It uses TAPPR = 6 local iterations with TAPPR = 42 operations and additive error \u2248 0.29241. The second row shows the process of LocalSOR (\u03c9 = 1.19 \u2248 w*). It uses TLocalSOR = 5 local iterations with TLocalSOR = 28 operations and additive error \u2248 0.21479. LocalSOR uses fewer local iterations, costs less total active volume, and obtains better approximate solutions. We choose the source node s = 0 with \u20ac = 0.02 and a = 0.25.", "description": "This figure compares the local diffusion processes of APPR and LocalSOR on a small graph.  APPR (top row) takes more iterations and operations to achieve a similar level of accuracy compared to LocalSOR (bottom row).  This illustrates the efficiency gains of LocalSOR.", "section": "3.2 Sequential local updates via Successive Overrelaxation (SOR)"}, {"figure_path": "3Z0LTDjIM0/figures/figures_4_2.jpg", "caption": "Figure 3: Parameter tuning of \u03c9. ", "description": "This figure shows the number of operations required for LocalSOR and LocalGS as a function of the relaxation parameter \u03c9 for PPR calculations on the wiki-talk dataset. The shaded area represents the standard deviation across multiple runs. The dashed line indicates the average number of operations for LocalGS. The optimal \u03c9 value for LocalSOR is approximately 1.19, resulting in a significant reduction in the number of operations compared to LocalGS.", "section": "3.2 Sequential local updates via Successive Overrelaxation (SOR)"}, {"figure_path": "3Z0LTDjIM0/figures/figures_7_1.jpg", "caption": "Figure 4: Number of operations required for four representative methods and their localized counterparts over 18 graphs. The graph index is sorted according to the performance of LocalGS.", "description": "This figure compares the number of operations required by four global methods (GS, SOR, GD, CH) and their corresponding local versions (LocalGS, LocalSOR, LocalGD, LocalCH) for approximating graph diffusion vectors on 18 different graphs. The x-axis represents the graph index, ordered by the performance of LocalGS, which means the first graph is the one where LocalGS performs best, while the last graph is the one where LocalGS performs worst. The y-axis represents the number of operations, shown in logarithmic scale.  The figure demonstrates that all local methods significantly outperform their global counterparts, especially LocalGS and LocalGD which show the best overall performance. LocalSOR and LocalCH, although more efficient in convergence rate,  have smaller improvements.", "section": "5.1 Results on efficiency of local GDE solvers"}, {"figure_path": "3Z0LTDjIM0/figures/figures_7_2.jpg", "caption": "Figure 6: Running time (seconds) as a function of e for HK, Katz, and PPR GDEs on the wiki-talk dataset. We use APPR = 0.1, aKatz = 1/(||A||2 + 1), and \u0442\u043d\u043a = 10 with 50 sampled source nodes.", "description": "This figure shows the running time of three different GDE solvers (HK, Katz, and PPR) as a function of the precision parameter (e).  The experiment was run on the wiki-talk dataset using 50 randomly chosen source nodes.  The parameters for each solver (damping factor a for PPR, a for Katz, and temperature \u03c4 for HK) are specified in the caption.  The plot visually demonstrates how the running time of each solver changes with varying levels of precision.", "section": "5.1 Results on efficiency of local GDE solvers"}, {"figure_path": "3Z0LTDjIM0/figures/figures_7_3.jpg", "caption": "Figure 4: Number of operations required for four representative methods and their localized counterparts over 18 graphs. The graph index is sorted according to the performance of LocalGS.", "description": "This figure compares the number of operations required by four standard iterative solvers (GS, SOR, GD, CH) and their localized counterparts (LocalGS, LocalSOR, LocalGD, LocalCH) for computing graph diffusion vectors on 18 different graphs. The x-axis represents the graph index, and the y-axis represents the number of operations. Each group of four bars represents the operations required for a given graph by the four methods and their local counterparts. The graph index is sorted based on the performance of LocalGS, which shows that LocalGS significantly outperforms GS in terms of the number of operations for most graphs.", "section": "5.1 Results on efficiency of local GDE solvers"}, {"figure_path": "3Z0LTDjIM0/figures/figures_8_1.jpg", "caption": "Figure 7: Comparison of running time (seconds) for CPU and GPU implementations.", "description": "This figure compares the running times of global and local solvers (GD, LocalGD, SOR, LocalSOR, GS, LocalGS) for computing PPR vectors on the wiki-talk dataset.  It shows the running times as a function of epsilon (\u03b5), demonstrating the significant speedup achieved by local methods, especially LocalGD, particularly on a GPU architecture.  The figure highlights that the advantage of local methods over global methods is pronounced, especially when using GPUs and when epsilon is within a certain range.", "section": "5.2 Local GDE solvers on GPU-architecture"}, {"figure_path": "3Z0LTDjIM0/figures/figures_8_2.jpg", "caption": "Figure 8: InstantGNN model using local iterative solver (LocalSOR) to do propagation.", "description": "This figure visualizes the results of using InstantGNN with LocalSOR for propagation, training, and inference tasks on a dynamic graph. It shows that the local solver, LocalSOR, significantly outperforms LocalGS in terms of running time, especially for training. The accuracy achieved by both methods is comparable, indicating that LocalSOR offers an efficient way to improve the speed of training dynamic graph neural networks without sacrificing accuracy.", "section": "Dynamic PPR approximating and training GNN models"}, {"figure_path": "3Z0LTDjIM0/figures/figures_8_3.jpg", "caption": "Figure 16: Accumulated number of operations on some dynamic graphs.", "description": "The figure shows the accumulated number of operations needed by LocalSOR and LocalGS for solving dynamic PPR over 16 snapshots on three different dynamic graphs: ogbn-arxiv, ogbn-products and ogbn-papers100M. It compares the performance of the dynamic variants (LocalSOR(Dynamic) and LocalGS(Dynamic)) against the static variants (LocalSOR(Static) and LocalGS(Static)). It demonstrates that the dynamic variants of the algorithms are significantly more efficient in terms of operations than the static variants, especially as the number of snapshots increases. This highlights one of the key advantages of using local solvers in dynamic settings.", "section": "5.3 Dynamic PPR approximating and training GNN models"}, {"figure_path": "3Z0LTDjIM0/figures/figures_25_1.jpg", "caption": "Figure 10: The number of operations ratio between the APPR (FIFO-Queue) and Gauss-Southwell (Priority-Queue). The number of operations of APPR is defined as TFIFO-Queue = \u03a3t=0 |St|, TPriority-Queue = \u03a3k=0 (duk + log2|supp(r(k))|) where K is the total number of push operations used in Gauss-Southwell iteration and supp(r(k)) = {u: r(k)u \u2260 0, u \u2208 V} and log2 | supp(r(k))| is the number of operations needed by the priority queue for maintaining all residuals in r(k).", "description": "This figure compares the number of operations required by the APPR algorithm using FIFO queue and Gauss-Southwell algorithm using Priority queue. The results are shown for various datasets and parameters (\u03b1 and \u03b5). The x-axis represents the source node, and the y-axis represents the ratio of operations between the two methods (log scale).", "section": "B.6 FIFO-QUEUE and PRIORITY-QUEUE"}, {"figure_path": "3Z0LTDjIM0/figures/figures_28_1.jpg", "caption": "Figure 7: Comparison of running time (seconds) for CPU and GPU implementations.", "description": "This figure compares the running times of global and local solvers (GD, LocalGD, SOR, LocalSOR, GS, LocalGS) as a function of epsilon (e) on the wiki-talk dataset.  It showcases the performance gains achieved by using GPU implementations of the local solvers (LocalGD and LocalGD(GPU)) compared to their CPU-based counterparts and other global methods. The figure demonstrates that LocalGD(GPU) is generally the fastest, highlighting the advantages of using local methods and GPU acceleration.", "section": "5.2 Local GDE solvers on GPU-architecture"}, {"figure_path": "3Z0LTDjIM0/figures/figures_29_1.jpg", "caption": "Figure 4: Number of operations required for four representative methods and their localized counterparts over 18 graphs. The graph index is sorted according to the performance of LocalGS.", "description": "This figure compares the number of operations required by four standard iterative solvers (GS, SOR, GD, CH) and their localized versions (LocalGS, LocalSOR, LocalGD, LocalCH) for approximating graph diffusion vectors on 18 different graphs. The x-axis represents the graph index, ordered based on the performance of LocalGS, and the y-axis represents the number of operations (in log scale). The figure demonstrates that localized solvers significantly reduce the number of operations required, especially for larger graphs.", "section": "5.1 Results on efficiency of local GDE solvers"}, {"figure_path": "3Z0LTDjIM0/figures/figures_30_1.jpg", "caption": "Figure 4: Number of operations required for four representative methods and their localized counterparts over 18 graphs. The graph index is sorted according to the performance of LocalGS.", "description": "This figure compares the number of operations required by four standard iterative solvers (SOR, GS, GD, CH) and their localized versions (LocalSOR, LocalGS, LocalGD, LocalCH) for approximating graph diffusion vectors on 18 different graphs.  The x-axis represents the graph index, sorted by the performance of the LocalGS method. The y-axis shows the number of operations on a logarithmic scale.  The figure demonstrates that the localized methods consistently require far fewer operations than their global counterparts, highlighting the efficiency gains achieved through localization.", "section": "5.1 Results on efficiency of local GDE solvers"}, {"figure_path": "3Z0LTDjIM0/figures/figures_30_2.jpg", "caption": "Figure 4: Number of operations required for four representative methods and their localized counterparts over 18 graphs. The graph index is sorted according to the performance of LocalGS.", "description": "This figure compares the number of operations needed by four standard iterative methods (GS, SOR, GD, CH) and their localized versions (LocalGS, LocalSOR, LocalGD, LocalCH) for approximating graph diffusion vectors on 18 different graphs.  The x-axis represents the graphs, ordered by the performance of the LocalGS method. The y-axis shows the number of operations. The figure visually demonstrates the significant speedup achieved by the localized methods compared to their global counterparts, highlighting the efficiency gains from the proposed local diffusion process framework.", "section": "5.1 Results on efficiency of local GDE solvers"}, {"figure_path": "3Z0LTDjIM0/figures/figures_30_3.jpg", "caption": "Figure 4: Number of operations required for four representative methods and their localized counterparts over 18 graphs. The graph index is sorted according to the performance of LocalGS.", "description": "This figure compares the number of operations required for four standard iterative solvers (SOR, GS, GD, CH) and their localized counterparts (LocalSOR, LocalGS, LocalGD, LocalCH) across 18 different graphs. The x-axis represents the graph index, sorted based on the performance of LocalGS, indicating the relative efficiency of each method across various graph structures.  The y-axis represents the total number of operations, which measures the computational cost of each algorithm.  The figure visually demonstrates that the localized methods consistently require significantly fewer operations than their standard counterparts, highlighting the efficiency gains achieved through the proposed localization framework.", "section": "5.1 Results on efficiency of local GDE solvers"}, {"figure_path": "3Z0LTDjIM0/figures/figures_31_1.jpg", "caption": "Figure 16: Accumulated number of operations on some dynamic graphs.", "description": "This figure shows the accumulated number of operations for LocalSOR (Dynamic), LocalGS (Dynamic), LocalSOR (Static), and LocalGS (Static) on three dynamic graphs: ogbn-arxiv, ogbn-products, and ogbn-papers100M.  The x-axis represents the snapshot number, and the y-axis represents the accumulated number of operations. The plot shows that the dynamic versions of both LocalSOR and LocalGS have a significantly smaller number of operations compared to the static versions, demonstrating the efficiency of dynamic GDE calculations. The difference in performance between LocalSOR and LocalGS is also noticeable across different graphs.", "section": "5 Experiments"}, {"figure_path": "3Z0LTDjIM0/figures/figures_31_2.jpg", "caption": "Figure 8: InstantGNN model using local iterative solver (LocalSOR) to do propagation.", "description": "This figure compares the performance of InstantGNN models using LocalSOR and LocalGS for dynamic PPR approximation and training.  It shows the running time for propagation, training, and inference over 16 snapshots, along with the accuracy achieved.  LocalSOR demonstrates significant speed improvements for all three tasks, while maintaining comparable accuracy to LocalGS.", "section": "5.3 Dynamic PPR approximating and training GNN models"}, {"figure_path": "3Z0LTDjIM0/figures/figures_31_3.jpg", "caption": "Figure 6: Running time (seconds) as a function of e for HK, Katz, and PPR GDEs on the wiki-talk dataset. We use APPR = 0.1, @Katz = 1/(||A||2 + 1), and T\u043d\u043a = 10 with 50 sampled source nodes.", "description": "This figure compares the running times of standard and local solvers for computing Personalized PageRank (PPR), Katz centrality, and Heat Kernel (HK) diffusion vectors on the wiki-talk graph dataset as the precision parameter (\u03b5) varies.  It demonstrates how the performance of local solvers changes with respect to the precision needed and shows that local solvers can significantly speed up the computation under certain conditions.", "section": "5.1 Results on efficiency of local GDE solvers"}]