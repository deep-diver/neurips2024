[{"figure_path": "t7SGOv5W5z/figures/figures_1_1.jpg", "caption": "Figure 1: Illustration of unstructured data analysis defined in Section 2.", "description": "This figure illustrates how the Unstructured Query Engine (UQE) handles unstructured data.  It shows a table with structured columns (movie, rating) and unstructured columns (review_text).  The example demonstrates how a SQL-like query can be used to extract insights from both structured and unstructured data. A simple query selecting movies with a rating above 5 is shown, along with a more complex query using natural language to extract the 'reason why' a review is negative from the unstructured 'review_text' column. This highlights the engine's ability to handle both types of data and queries.", "section": "Problem"}, {"figure_path": "t7SGOv5W5z/figures/figures_5_1.jpg", "caption": "Figure 3: UQL compiler, in analogy to a typical C++ program compiler.", "description": "This figure illustrates the UQL compiler's architecture, drawing a parallel with a typical C++ compiler.  It shows the stages of query compilation, starting from high-level optimization (algebraic simplification, common subexpression elimination, dead code elimination), then moving to a high-level intermediate representation (IR) and subsequent optimization for minimizing token count.  The process continues to lowering (instruction selection, scheduling, register allocation), resulting in an optimized low-level IR. This is followed by code generation which, in the UQL context, translates to the creation of prompts and orchestration for LLM calls. Finally, execution utilizes the foundation model (LLM) to generate results. Different sampling techniques (stratified, active learning, round robin, random) are shown within the lower-level optimization stage, reflecting the approach for handling unstructured data within the UQL engine. The overall objective is to optimize both accuracy and cost by efficiently using LLMs for query processing.", "section": "4 Unstructured Query Engine"}]