[{"figure_path": "spwE9sLrfg/figures/figures_2_1.jpg", "caption": "Figure 1: Sequential source code in C++ and semantics of DSL in IR.", "description": "This figure shows an example of verified lifting (VL).  The left side (a) presents sequential C++ code for a matrix addition operation.  The right side (b) shows the equivalent representation in an intermediate representation (IR), which uses a Domain-Specific Language (DSL) to represent the operations in a higher-level, more abstract way, ignoring implementation details.  This IR serves as a bridge between the source code and the target DSL, enabling more efficient compilation and verification.", "section": "1 Introduction"}, {"figure_path": "spwE9sLrfg/figures/figures_3_1.jpg", "caption": "Figure 2: A high-level overview of our LLMLIFT framework for building verified lifting-based tools.", "description": "The figure illustrates the LLMLIFT framework, an LLM-based approach for building verified lifting tools. It shows the workflow from source code to a verified target DSL code.  The process includes prompting an LLM to generate both program summaries (PS) and loop invariants, verifying the equivalence using a theorem prover, and generating the final target code.  The framework incorporates a parser for checking the syntactic correctness of the LLM's output, as well as a feedback loop for iterative refinement.", "section": "3 LLM-Based Verified Lifting"}, {"figure_path": "spwE9sLrfg/figures/figures_4_1.jpg", "caption": "Figure 4: Prompt Structure", "description": "The figure shows the prompt structure used by the authors in their experiments.  The prompt consists of four main components: 1. Instructions: providing a high-level task description for the model. 2. DSL Semantics: specifying the semantics of the operators in the target DSL using Python as the intermediate representation (IR).  3. Specification: providing the source code as a specification for the desired outcome. 4. Source Program: providing the source code that needs to be translated to the target language.", "section": "3 LLM-Based Verified Lifting"}, {"figure_path": "spwE9sLrfg/figures/figures_14_1.jpg", "caption": "Figure 4: Prompt Structure.", "description": "This figure shows the structure of the prompt used to generate the program summary (PS) and invariants (Inv).  The prompt includes a task description, the semantics of DSL operators (expressed in Python), and the source program. This structure is designed to guide the language model in generating code that is both syntactically correct and semantically equivalent to the source code.", "section": "3 LLM-Based Verified Lifting"}, {"figure_path": "spwE9sLrfg/figures/figures_15_1.jpg", "caption": "Figure 1: Sequential source code in C++ and semantics of DSL in IR.", "description": "This figure demonstrates an example of verified lifting (VL) where a sequential C++ code is transpiled into a tensor processing framework's DSL (like PyTorch or NumPy). It shows the original sequential C++ code (a) and the equivalent code written using the DSL's operators, represented in a higher-level intermediate representation (IR) using Python (b). The IR serves as a functional description of the DSL, abstracting away implementation details and simplifying the translation process.  The process involves lifting the C++ code to Python operators and then translating the Python code to the DSL's syntax.", "section": "1 Introduction"}, {"figure_path": "spwE9sLrfg/figures/figures_17_1.jpg", "caption": "Figure 1: Sequential source code in C++ and semantics of DSL in IR.", "description": "This figure shows a sequential C++ code (on the left) which performs element-wise addition of two matrices followed by scalar subtraction.  The corresponding code (on the right) in an intermediate representation (IR) using a domain-specific language (DSL) is shown. The IR is an intermediate step in verified lifting, which is used to translate code from one language to another while ensuring functional equivalence. Python is used as the IR language in the paper's approach, and the figure illustrates how the source code's functionality is expressed using the DSL operators represented in the IR. This allows for verifying semantic equivalence during the translation process.", "section": "1 Introduction"}, {"figure_path": "spwE9sLrfg/figures/figures_17_2.jpg", "caption": "Figure 3: End-to-End Lifting Example.", "description": "This figure shows an example of how LLMLIFT works. It takes a C++ function as input, translates it into an intermediate representation (IR) using Python, generates a program summary (PS) and invariants (Inv) using LLMs, verifies that the PS is functionally equivalent to the source code using a theorem prover, and finally translates the PS into the target language (Apple MLX in this case).", "section": "3.2 LLM-based Verified Lifting"}, {"figure_path": "spwE9sLrfg/figures/figures_24_1.jpg", "caption": "Figure 4: Prompt Structure.", "description": "The figure shows the structure of the prompt used in the LLMLIFT framework.  It's designed to guide LLMs in generating program summaries (PS) and loop invariants (Inv). The prompt includes several components: a task description, a section for DSL semantics and operators, the source program, and instructions.", "section": "3 LLM-Based Verified Lifting"}]