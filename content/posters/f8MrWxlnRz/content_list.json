[{"type": "text", "text": "Adaptive Important Region Selection with Reinforced Hierarchical Search for Dense Object Detection ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Dingrong Wang Hitesh Sapkota \u2020 Qi Yu\u2217 Rochester Institute of Technology Amazon Inc. Rochester Institute of Technology Rochester, NY 14623 Sunnyvale, CA 94089 Rochester, NY 14623 dw7445@rit.edu sapkoh@amazon.com qi.yu@rit.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Existing state-of-the-art dense object detection techniques tend to produce a large number of false positive detections on difficult images with complex scenes because they focus on ensuring a high recall. To improve the detection accuracy, we propose an Adaptive Important Region Selection (AIRS) framework guided by Evidential Q-learning coupled with a uniquely designed reward function. Inspired by human visual attention, our detection model conducts object search in a top-down, hierarchical fashion. It starts from the top of the hierarchy with the coarsest granularity and then identifies the potential patches likely to contain objects of interest. It then discards non-informative patches and progressively moves downward on the selected ones for a fine-grained search. The proposed evidential Q-learning systematically encodes epistemic uncertainty in its evidential-Q value to encourage the exploration of unknown patches, especially in the early phase of model training. In this way, the proposed model dynamically balances exploration-exploitation to cover both highly valuable and informative patches. Theoretical analysis and extensive experiments on multiple datasets demonstrate that our proposed framework outperforms the SOTA models. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Dense object detection enjoys a wide range of applications in diverse domains [21, 40]. Representative use cases include surveillance video tracking by the police and merchandise recognition for online shopping [42, 6]. Despite its importance, dense object detection is an inherently challenging task as it requires predicting the bounding boxes for all objects present in a given image irrespective of their shape, size, and number. The inborn complexity of images, such as shadow/occlusion, image size, shape, color, and texture could also pose a significant hindrance in the detection process resulting in a lower accuracy [15]. ", "page_idx": 0}, {"type": "text", "text": "Existing efforts have contributed different techniques to address the key challenges in dense object detection. For instance, two-stage approaches have been popularized where the first stage extracts candidate objects and the second stage classifies the extracted object while providing the bounding boxes through a regression network [15]. Representative two-stage detectors include R-CNN [15] and Faster R-CNN [33]. Two-stage detectors are limited in the number of candidate object found in first stage through the regional proposal network (RPN) and suffer from a low recall, especially in dense scenarios. To tackle this, one-stage approaches have been explored that achieve a higher recall along with faster training and inference [26, 38]. There are mainly two types of one-stage approaches: Anchor-based (e.g., RetinaNet [26]) and Anchor-free (e.g., FCOS [38]). The former computes the bounding box of an object by regressing the offsets from a predefined anchor box whereas the latter directly outputs the position and size of an object. However, existing one-stage detectors usually exhibit inconsistency in localization quality estimation between training and testing, stemming from the lack of supervision and resulting in many false positive anchors as shown in [23]. In testing, some negative anchors may generate an unusually high-quality estimation score and be selected as positive anchors (i.e., false positives) due to lack of supervision. GFocal [23] alleviates this issue by leveraging the Focal Loss and aligning the localization quality and classification branches into a unified representation. While it achieved improved performance compared to previous one-stage detectors, GFocal still suffers from the problem of generating too many false positive predictions on small objects in a complex background because of selected low quality positive anchors, as shown in 1 (a) and (c). ", "page_idx": 0}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/ca69b012ca6ca26ccb03bc7f0c2fe51ca7e9f705a194902794822509f80ba795.jpg", "img_caption": ["Figure 1: Bounding boxes produced by GFocal [23], GFocal-V2 [22], and AIRS, where GFocal, GFocal-V2 still tend to generate unnecessary bounding boxes resulting from false positive anchors, comparing to the proposed AIRS model. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "Our analysis reveals that the non-adaptive criterion (which favors a high recall) in existing onestage detectors does not capture diverse types of candidate anchors residing on the Feature Pyramid Network (FPN) [25] and will result into many false positive anchors. This phenomenon becomes prominent when testing images are difficult with complex/noisy background. To tackle this challenge, we propose to conduct Adaptive Important Region Selection (AIRS) that is guided by a reinforcement learning (RL) agent performing Evidential Q-learning with a uniquely designed reward function. Similar to human visual attention, AIRS conducts object search in a top-down, hierarchical fashion. Benefiting from the top-down paradigm, the top layer in the hierarchy with a coarser granularity helps the model quickly identify most interesting regions that likely contain objects of interest. Only within those regions, the model performs a fine-grained search to more precisely locate the objects. Intuitively, the model only searches the patches from lower levels if the RL agent collects sufficient evidence on higher level supporting the presence of a potentially valuable object according to the learned evidential Q-value. ", "page_idx": 1}, {"type": "text", "text": "Furthermore, in the early phase of RL agent training, AIRS also encourages the agent to explore highly uncertain patches by leveraging the epistemic uncertainty provided by our evidential Q-value. Exploration of novel patches is also dynamically balanced with the exploitation of predicted high quality region. As a result, AIRS ensures that all potential patches have been adequately covered during the search process while avoiding the attendance of low-quality patches from fine-grained layers, leading to much improved precision without sacrificing the recall. As can be seen from Figure 1 (b) and (d), AIRS is able to identify all objects without producing any false positive bounding boxes. In contrast, GFocal, as shown in Figure 1(a) and (c), produces many false positive patches by paying too much attention on low-level details to maintain a high recall. To assess the effectiveness of AIRS, we perform extensive experiments on multiple real-world datasets with complex objects/backgrounds. Furthermore, we conduct a thorough theoretical analysis to show the convergence guarantee of our proposed evidential Q-learning. Our contributions are summarized below: ", "page_idx": 1}, {"type": "text", "text": "\u2022 an adaptive hierarchical object detection paradigm supported by an RL agent to mimic human visual attention that performs searching in the top-down fashion, \u2022 novel evidential Q-learning driven by a unique reward function, covering both potentially positive and highly uncertain patches through dynamically balancing exploitation and exploration, \u2022 theoretical guarantee on the fast convergence of the proposed evidential Q-learning algorithm, \u2022 SOTA object detection performance outperforming strong baselines on challenging datasets. ", "page_idx": 1}, {"type": "text", "text": "2 Related Work ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Object Detection. In dense object detection [10], both two-stage and one-stage detectors have been investigated in existing literature. Representative techniques in the former group include R-CNN [15], Faster R-CNN [33], where the detection involves two stages. Considering the limitation of slow training and inference in two-stage detectors, multiple one-stage detectors have been proposed, such as FCOS, ATSS and GFocal series [38, 45, 23, 22]. However, these methods still suffer from attending too many false positive anchors (region proposals) resulting from the architecture design and the training setting. To overcome this, we design an uncertainty-guided RL to perform hierarchical search that effectively reduces the false positive detections. ", "page_idx": 1}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "Deep Reinforcement Learning for Object Detection. DRL formulates object detection problem as a Markov-Decision Process (MDP). It tries to find the salient parts of an image that are more probable to contain a target object, and then further zoom into them [4, 8]. There are generally two different action settings for this MDP. In the first setting, a hierarchical method is proposed by [4], where the agent chooses to focus on one of the 5 sub-regions of the image (ie. top-left, top-right, bottom-left, bottom-right, center) at each time step. In the second setting, a dynamic method is proposed by [8], where the agent deforms a bounding box using simple transformation actions (horizontal moves, vertical moves, scale changes, and aspect ratio changes) at each step to find the specific location of an object in the image. However, the above methods only detect a fixed number of objects. To overcome this issue, Ba et al. introduce a deep recurrent attention model (RAM) to recognize multiple objects [3]. Further, Zhou et al. propose ReinforceNet, which performs region selection and refinement by integrating RL\u2019s action space with CNN based feature space [47]. Different from all these works, AIRS leverages the advanced Feature Pyramid Network structure and performs RL-driven hierarchical search guided by epistemic uncertainty with much improved detection performance. ", "page_idx": 2}, {"type": "text", "text": "Uncertainty in Deep Learning. There have been different approaches to quantify uncertainty in deep learning models. Sensoy et al. [36] propose an Evidential Deep Learning (EDL) network, which treats the predicted multi-class probability as a multinomial opinion as developed in subjective logic [18]. Malinin et al. [30] propose Prior Networks (PNs) that consider distributional mismatch to explicitly quantify the distributional uncertainty. Amini et al. [1] propose an evidential regression network that quantifies the aleatoric and epistemic uncertainty based on the hyper-parameters. Different from previous work, we propose novel evidential deep Q-learning through an evidential regression Q-network to quantify the epistemic uncertainty, which is used to explore regions that the RL-agent is less familiar with. ", "page_idx": 2}, {"type": "text", "text": "3 Methodology ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this section, we first present the overall object detection process. We then go through each of the key component in our framework. We conduct a theoretical analysis to show how the proposed AIRS leverages effective exploration and hierarchical search to ensure theoretically guaranteed performance. Finally, we describe the training and inference process and explain how AIRS could be used for real-world object detection problems. ", "page_idx": 2}, {"type": "text", "text": "3.1 The Overall Detection Process ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "The overall detection process is guided by an RL agent as shown in Figure 2a. Our RL environment consists of a Feature Pyramid Network (FPN) that projects an input image into different resolutions organized into a hierarchical structure. As an example, the FPN in Fig. 2a has three layers with P5 having the lowest resolution and P3 having the highest resolution (these numbers follow the original FPN [25]). Once a patch is selected by the RL agent, it is passed through the feature extractor followed by the recurrent neural network (RNN) to generate the state representation. The state representation then goes through the evidential Q-network, which formulates an evidential Normal-inverse Gaussain (NIG) distribution and outputs the Q-value estimate for each available action. Then by combining with the corresponding epistemic uncertainty in the Q-value estimate, we have the evidential Q-value which balances the estimated Q-value with the (lack of) knowledge of the RL agent on the chosen action. Thus, in the initial phase of RL training, there are more uncertain patches and the RL agent is expected to explore more actively. As training progresses, the agent should try to choose those actions leading to patches (regions) that are most valuable. Based on the evidential $\\mathrm{{Q}}.$ -value obtained by balancing epistemic uncertainty and estimated Q-value, the agent takes action, and then selects the next patch with the goal of maximizing the expected reward. ", "page_idx": 2}, {"type": "text", "text": "3.2 Description of Key Components ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "State Generation. To generate a state, we rely on the patches produced by RL environment from one of the $L+1$ layers in the FPN, where $L$ is the top layer and 0 being the bottom one. ", "page_idx": 2}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/d426511329fe6af3b526b1b60f32f13d082f3a9a12fbbe884dff74b374f39cf9.jpg", "img_caption": ["Figure 2: AIRS training and test pipelines "], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "In the FPN, each patch in the higher layer (low resolution) is mapped to multiple patches in a lower layer (high resolution). Once a patch from layer $l$ is selected, it is passed through the feature extractor to get the feature embedding vector $\\mathbf{e}_{t}\\in\\dot{\\mathbb{R}}^{d}$ . Finally, the feature embedding and previous state representation $({\\bf s}_{t-1})$ are concatenated and passed through the RNN to generate the next state representation ${\\bf s}_{t}\\,=\\,\\mathtt{R N N}({\\bf e}_{t},{\\bf s}_{t-1};\\pmb{\\theta}_{r})$ where $\\mathbf{s}_{0}=\\mathbf{0}$ and $\\theta_{r}$ is the parameters associated with the RNN. In this way, every state $\\mathbf{s}_{t}$ captures the knowledge of previous observations from environment via $\\mathbf{s}_{t-1}$ . ", "page_idx": 3}, {"type": "text", "text": "Evidential Q-Learning. To ensure detection of all positive patches, it is crucial to perform effective exploration. To achieve this, we design evidential Q-learning that performs exploration in a systematic way by leveraging epistemic uncertainty. Let $D$ denote the size of the action space. The $\\mathrm{^Q}$ -value for $d^{t h}$ action $q_{d,t}$ given state $\\mathbf{s}_{t}$ is assumed to draw from a Gaussian distribution with mean $\\mu_{d,t}$ and variance \u03c3d2,t. We further place Gaussian and Inverse-Gamma priors on the mean and variance, respectively [5]: ", "page_idx": 3}, {"type": "equation", "text": "$$\nq_{d,t}\\sim\\mathcal{N}(\\cdot|\\mu_{d,t},\\sigma_{d,t}^{2}),\\ \\mu_{d,t}\\sim\\mathcal{N}(\\cdot|\\gamma_{d,t},\\sigma_{d,t}^{2}\\nu_{d,t}^{-1}),\\ \\sigma_{d,t}^{2}\\sim\\mathrm{Inv-Gamma}(\\cdot|\\alpha_{d,t},\\beta_{d,t})\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\mathrm{Inv-Gamma}\\big(\\alpha_{d,t},\\beta_{d,t}\\big)$ is the Inverse Gamma distribution [1] and $(\\gamma_{d,t},\\nu_{d,t},\\alpha_{d,t},\\beta_{d,t})$ are evidential $\\mathrm{Q}$ -network outputs that form the evidential distributions as specified above. From these distributions, we can sample mean $\\mu_{d,t}$ and variance $\\sigma_{d,t}^{2}$ to generate Q-value estimate $q_{d,t}$ . It should be noted that, because of the Inv-Gamma term, effective sampling for $q_{d,t}$ through the reparametrization trick [19] becomes difficult. We instead generate mean and variance with their expectations: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathbb{E}[\\mu_{d,t}]=\\gamma_{d,t},\\quad\\mathbb{E}[\\sigma_{d,t}^{2}]=\\frac{\\beta_{d,t}}{(\\alpha_{d,t}-1)}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Thus, the $q$ -value is sampled as ", "page_idx": 3}, {"type": "equation", "text": "$$\nq_{d,t}\\sim\\mathcal{N}\\left(\\cdot|\\gamma_{d,t},\\frac{\\beta_{d,t}}{(\\alpha_{d,t}-1)}\\right)\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Using this trick, the gradient could be easily traced back to evidential Q-network\u2019s hyper-parameter outputs $\\left(\\gamma_{d,t},\\nu_{d,t},\\alpha_{d,t},\\beta_{d,t}\\right)$ for each action $a_{d,t}$ from the corresponding $\\mathrm{{Q}}.$ -value $q_{d,t}$ in evidential Q-learning. In addition to the Q-value estimate, it is also essential to integrate uncertainty to facilitate exploration of unknown patches, leading to the following evidential Q-value ", "page_idx": 3}, {"type": "equation", "text": "$$\nq_{d,t}^{e}=q_{d,t}+\\lambda\\mathrm{Var}[\\mu_{d,t}],\\quad\\mathrm{Var}[\\mu_{d,t}]=\\frac{\\mathbb{E}[\\sigma_{d,t}^{2}]}{\\nu_{d,t}}=\\frac{\\beta_{d,t}}{\\nu_{d,t}(\\alpha_{d,t}-1)}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\mathrm{Var}[\\mu_{d,t}]$ captures the epistemic uncertainty and $\\lambda$ balances epistemic uncertainty and Qvalue. The evidential decomposition of the total uncertainty allows us to separate uncertainty caused by the noise in the data (i.e., aleatoric uncertainty or $\\mathbb{E}[\\bar{\\sigma}_{d,t}^{2}])$ and uncertainty caused by lack of knowledge (i.e., epistemic uncertainty or $\\mathrm{Var}[\\mu_{d,t}])$ . Since the evidential-Q value only integrates with the epistemic uncertainty, it ensures that the exploration will focus on improving the knowledge of the agent while being robust to the noise in the data. ", "page_idx": 3}, {"type": "text", "text": "To generate the action vector, we consider both $q_{d,t}^{e}$ and the constraints that avoid the agent moving into an invalid region that includes already visited patches and void space (e.g., downward movements from layer 0, upward movement from layer $L$ ). To this end, we define a mask vector. Let $m_{l,t}^{d}$ be the mask value (binary) associated with the $d^{t h}$ action in $l^{t h}$ layer in $t^{t h}$ time step then the masked evidential Q-value is ", "page_idx": 3}, {"type": "text", "text": "", "page_idx": 4}, {"type": "equation", "text": "$$\n\\widetilde{\\mathbf{q}_{d,t}^{e}}=\\mathbf{q}_{d,t}^{e}\\otimes\\mathbf{m}_{l,t}^{d}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Let $j=\\arg\\operatorname*{max}_{d}\\{\\widetilde{q_{d,t}^{e}}\\}_{d=0}^{D-1}$ , then the action value for each entry $d\\in\\{0,1,..,D-1\\}$ is updated: ", "page_idx": 4}, {"type": "equation", "text": "$$\na_{d,t}=\\left\\{1,\\mathrm{if}\\:d=j;\\right.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "More detailed information of the constraint mask design can be found in Appendix C.3. ", "page_idx": 4}, {"type": "text", "text": "Based on the masked evidential Q-value $\\widetilde{\\mathbf{q}_{d,t}^{e}}$ , the RL agent selects the best action $a_{t}$ and receives a reward $r(\\mathbf{s}_{t},\\mathbf{a}_{t})$ . The agent repeats the selection process until reaching a limit $T$ steps or arriving at the terminal condition (i.e., upward movement in top-most layer $L$ ) is triggered. During each step, the agent stores the tuple of ${\\bf s}_{t},{\\bf a}_{t},r_{t},{\\bf s}_{t+1}$ into a replay buffer. After collecting $K$ training tuples, one batch of training tuples is sampled for off-policy $\\mathrm{{Q}}.$ -learning. The following loss is used to update the feature extractor $(\\pmb\\theta_{f})$ , RNN $(\\pmb\\theta_{r})$ , and evidential Q-network $(\\pmb\\theta_{e})$ : ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\mathcal{L}_{\\theta_{f},\\theta_{r},\\theta_{c}}=\\left(q_{d,t}(\\pmb{\\theta}_{f},\\pmb{\\theta}_{r},\\pmb{\\theta}_{e})-\\widehat{q_{d,t}}\\right)^{2},\\ \\widehat{q_{d,t}}=r(\\mathbf{s}_{t},\\mathbf{a}_{t})+\\gamma\\mathbb{E}_{s_{t+1}\\sim D}\\operatorname*{max}_{d}(q_{d,t+1})\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\widehat{q_{d,t}}$ is evaluated using the Bellman equation. ", "page_idx": 4}, {"type": "text", "text": "Action Interaction. The action interaction module translates the action into the location of the next patch to be selected. It considers a $D$ dimensional action vector, where the first $D-1$ actions: $\\bar{a}_{d,t},d\\in\\,[0,..,D-2]$ are downward movements that direct the agent currently located on layer $l$ into one of its mapping sub-patches in layer $l-1$ with $p_{i,t}^{l}$ being the current selected patch from $l$ layer. The location of the selected sub-patch from $l\\,-\\,1$ layer is provided by the index of the action-value whose entry is set to 1 (e.g., $a_{0,t}\\,=\\,1$ means top-left and $a_{1,t}\\,=\\,1$ means top-right). The last action ${a_{D-1,t}}$ denotes the upward movement to the parent patch in layer $l+1$ . The action interaction process is essentially a hierarchical tree search in FPN (with a virtual layer $L$ as the root node) and we provide illustrative examples in Appendix C.3. ", "page_idx": 4}, {"type": "text", "text": "Reward Design. The action space of the RL agent involves two major types of movements in the hierarchical search, downward and upward. To facilitate each type, we define a unique reward function. For downward movement actions, we compute the reward based on the ranking of the patch selected by the movement action compared to all other patches located on the same layer in terms of the number of the positive anchors they contain. Specifically, we compute the quality measure estimate of each anchor by investigating a range of metrics: centerness [38], IoU[32], GIoU[34], and DIoU [46]. It should be worth noting that all these metrics encode the supervised signal with a threshold to decide whether an anchor is positive or not. We follow the RetinaNet setting but use DIoU as our positive anchor criterion and conduct an ablation study to verify its superiority. After getting the positive anchors for each patch, we calculate the quality score $g(\\mathbf{s}_{t},\\mathbf{a}_{t})$ for each patch in terms of the number of positive anchors on it as \u201cground truth\" information. The details can be seen in Appendix C.1. In addition, we set up a penalty term with the downward movement in each time step representing the searching cost. Such a cost should be related to both training progress and the depth of search. For example, searching a bottom layer\u2019s patch in a later training phase when the model gets enough knowledge of the input should be considered costly. Given this insight and by combining the above two factors, we design our unique reward ", "page_idx": 4}, {"type": "equation", "text": "$$\nr(\\mathbf{s}_{t},\\mathbf{a}_{t})=g(\\mathbf{s}_{t},\\mathbf{a}_{t})-\\frac{n_{e p c o h}}{N_{e p o c h}}P_{s_{t},a_{t}}^{l}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "wher $n_{e p c o h},N_{e p o c h}$ are the current and total training epoch, $P_{s_{t},a_{t}}^{l}$ is the penal term for each layer $l$ , and $l$ is the layer index of next selected patch given $\\mathbf{s}_{t},\\mathbf{a}_{t}$ in time step $t$ . For upward movement, the reward is simply set to 0, which means when the downward movement\u2019s benefits for exploration cannot cover the search cost, the model prefers to return back and search other patches in the same layer. In this way, we achieve the exploitation-exploration balance in the reward design, besides the evidential Q-learning. ", "page_idx": 4}, {"type": "text", "text": "3.3 Theoretical Analysis ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "We establish the statistical guarantee for AIRS that integrates evidential Deep-Q learning with hierarchical search. Let $Q^{*}$ be the optimal action-value function and $Q^{\\pi_{k}}$ be the action-value function corresponding to the policy $\\pi_{k}$ . ", "page_idx": 4}, {"type": "text", "text": "Theorem 3.1. Under the assumption of the smoothness on the Bellman optimality operator, there exists a constant $C$ such that the following bound holds ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\|Q^{*}-Q^{\\pi\\kappa}\\|_{1}\\leq C\\phi_{e,f}\\frac{\\gamma}{1-\\gamma^{2}}|\\mathcal{A}|\\tau(\\eta,v)+\\frac{4\\gamma^{K+1}}{1-\\gamma^{2}}R_{m a x}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\boldsymbol{\\mathcal{A}}$ denotes the action space, $R_{m a x}$ upper bounds the uniquely designed reward, and $K$ is the total number of $R L$ iterations. The term $\\tau(\\eta,v)$ is associated with the Ho\u00a8lder smoothness criterion on neural network function $f$ , which is required here to ensure the finite sample guarantee with $\\eta\\ \\in\\ \\mathbb{Z}$ denoting the upper limit of the number of input variables on which the Ho\u00a8lder smooth function depends. This integer essentially controls the statistical rate for estimating the Ho\u00a8lder smooth function $I39J$ . Term v is the exponent in the Ho\u00a8lder smooth function with $v=1$ leading to the Lipschitz continuity. Finally, $\\phi_{e,f}$ is the upper bound on the cumulative discounted concentration parameter over $K$ steps. It quantifies the similarity between the sampling distribution obtained through $f$ and the actual distribution of $K^{t h}$ step Markov Decision Process (MDP) starting from the initial fixed distribution e on initial state-action pairs $(\\mathcal{S}_{0},\\mathcal{A}_{0})$ . A larger difference leads to a higher $\\phi_{e,f}$ . ", "page_idx": 5}, {"type": "text", "text": "Remarks. The complete proof is given in the Appendix B along with a justification to ensure all the assumptions hold in our setting. First, the upper bound on the r.h.s. consists of two types of errors: statistical (first term) and algorithmic (second term), where the latter decreases exponentially because our reward is upper bounded. As a result, the bound is dominated by the former term after sufficient rounds of iterations. Second, the Ho\u00a8lder smoothness assumption on the Bellman optimality operator implies that the optimal action-value function $Q^{*}$ is close to the functional classes constituting the evidential Q-network and that functional classes are approximately closed under the Bellman operator. This completeness assumption ensures the finite sample guarantee for the proposed AIRS. In particular, the term $\\tau(\\eta,v)\\stackrel{.}{\\propto}\\ n^{-f(\\eta,v)}$ decays quickly with respect to the sample size $n$ making the bound even tighter. Third, thanks to the specially designed hierarchical search strategy, the action space in our setting is very small (i.e., $D=5$ ) making the $|{\\mathcal{A}}|$ small, leading to a tighter bound. Finally, the $\\phi_{e,f}$ term essentially provides the upper bound on the similarity between sampling distribution and actual distribution of the state-action space. By performing epistemic uncertainty guided exploration, our collected state-action samples are likely to be representative of the actual distribution. This makes $\\phi_{e,f}$ small that further tightens the bound. ", "page_idx": 5}, {"type": "text", "text": "3.4 Training and Testing Procedures ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "The detailed training process is presented in Algorithm 1 and illustrated in 5 of Appendix C.2, where the search always starts from the top-most layer i.e., $L$ . It should be noted that, we create the RL environment by leveraging the FPN structure of the pre-trained backbones (i.e., ResNet-50). Based on the masked evidential Q-value estimate, the agent selects the next action, which would be either a downward or upward movement. Then, the agent moves to the next patch and continues the process until receiving an upward movement in layer $L$ or reaches the maximum time step i.e., $T$ . After every $K$ such iterations, training tuples are sampled from the replay buffer for off-policy learning. For inference, we leverage the same pre-trained FPN as training, and run the trained RL agent on the test image\u2019s FPN to generate RL mask for its FPN structure, illustrated as Figure 2b. These binary RL masks are then used for patch selection in the test phase to generate more precise anchors from a large magnitude of candidate positive anchor pool to facilitate a more calibrated training (see Figure 4 of Appendix C.2). As can be seen, the training is more efficient comparing to other RL based methods, and the inference speed is also competitive w.r.t. the latest baselines (see Appendix D.6). ", "page_idx": 5}, {"type": "text", "text": "4 Experiments ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "We conduct extensive experimentation to evaluate the effectiveness of AIRS. We first describe three real-world object detection datasets. For each dataset, we also construct a subset of images with more complex scenes. These challenging subsets can provide direct evidence of reducing false positive predictions using AIRS. We then present the experimental setting consisting of evaluation metrics and experimental setup (such as network backbones used). We show the comparison results with competitive baselines in terms of object detection performance as well as inference cost in a quantitative study. Additionally, we conduct a qualitative analysis and ablation study to uncover deeper insights on performance advantage of AIRS. Finally, in Appendix D.4, we introduce the detailed training configurations to guarantee the success of our off-policy Q-learning. ", "page_idx": 5}, {"type": "text", "text": "4.1 Datasets ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "\u2022 MS COCO [27]: It contains 91 categories. Following [38, 26], we use the COCO trainval35k split containing 115K images for training and minival split containing 5K images for testing. \u2022 PASCAL Visual Object Classes (VOC) 2012 [12]: It contains 20 categories and is partitioned into three subsets: 5,717 images for training, 5,823 images for validation, and 10,991 images for testing. \u2022 Google Open Images V4 [20]: It contains 9M (million) image with 600 object categories, where training set contains $1.74\\;\\mathrm{M}$ images, validation set contains 125K images, and testing contains 41K images. It is worth noting that images in this dataset are very diverse and often contain complex scenes with several objects i.e., on average 8.4 objects per image. \u2022 Challenging subset: From each dataset, we construct a subset (denoted as \u2018CH\u2019) to include most challenging images using the following criteria: (a) images where the ratio of large and medium objects (area $\\geq\\bar{3}2^{2}$ ) to small objects (area $<32^{2}$ ) ranging from 1 to $1/2$ to ensure smaller objects coexist and embedd within large objects making detection task much more challenging, (b) images where multiple objects overlap with each other, and (c) images where multiple small objects are embedded into the bigger one. Appendix D.7 show examples of selected images. ", "page_idx": 6}, {"type": "text", "text": "4.2 Experimental Settings ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Evaluation Metrics. Following evaluation performed in the benchmark COCO dataset [27], we assess the performance using Average Precision (AP). Additionally, we separately report the AP performance for small, medium, and large objects named as $\\mathbf{A}\\mathbf{P}^{S}$ , $\\dot{\\mathbf{A}}\\mathbf{P}^{M}$ , $\\mathrm{AP}^{\\tilde{L}}$ respectively. For the challenging subsets, we report the AP score named as $\\operatorname{AP}^{C H}$ . It should be noted that small objects and constructed subsets correspond to the more challenging detection tasks and therefore we would expect a more significant performance gap compared with the baselines. ", "page_idx": 6}, {"type": "text", "text": "Experimental setup. For the FPN, we follow the same experiment setting as GFocal, which uses its pre-trained ResNet-50 as backbone, and applies a 3-layer FPN with patch size defined as a quarter of the area of the layer $L-1$ (the top layer $L$ in our case is a virtual layer as the root node in the tree structure), but instead use DIoU as positive anchor criterion. For the feature extractor, we use a three-layer Multi-Layer Perceptron (MLP) structure. Through grid based hyper-parameter search using a validation dataset, we set the total training epochs $N_{e p o c h}\\,=\\,12$ , action space $D\\ =\\ 5$ , maximum time step $T\\,=\\,60$ , discount factor $\\gamma\\;=\\;0.9$ , learning rate $=0.001$ , and $\\lambda\\,=\\,1$ . We gradually shrink $\\lambda$ to balance exploitation and exploration. For the penalty term $P_{s_{t},a_{t}}^{l}$ set up, we choose (0.3,0.6,0.9) for layers (P5, P4, P3) after hyper-parameter searching. For other baselines, we train them until convergence and test in the same data sets for fair comparison. ", "page_idx": 6}, {"type": "text", "text": "4.3 Quantitative Study ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Comparison baselines. In our quantitative study, we include baselines that are most relevant to our model, including representative or latest two-stage detectors: Faster R-CNN [33], Cascade RCNN [7], Reppoints [41], TridentNet [24], DETR [9], Co-DETR [49], EVA [14], and DINO [44], as well as most recent one stage detectors: RetinaNet [26], FCOS [38], ATSS [45], SAPD [48], SpineNet [11] and GFocal [23]. Faster R-CNN and Cascade R-CNN use an ROI pooling layer to extract candidate ROI regions first then regress from those regions, while Reppoints and TridentNet apply deformable convolution technique or scale-specific feature maps to handle scale and perspective variations in images. DETR leverages a set-based global loss that forces unique predictions via bipartite matching, and a transformer encoder-decoder architecture to effectively remove the need for Non maximal suppression and anchor generations. Co-DETR further applies a novel collaborative hybrid assignments training scheme on top of it. DINO improves DETR on de-noising the anchor boxes for end-to-end training. All one-stage methods use FPN, but the difference resides in the training loss (GFocal), and positive anchor criterion choices (RetinaNet, FCOS, ATSS, SAPD). Instead, EVA is a vanilla ViT pre-trained to reconstruct the masked out image-text aligned vision features conditioned on visible image patches for exploring the limits of visual representation at scale. For fair comparison, all baselines apply the same pre-trained backbone (i.e., ResNet-50) to extract image features. For YOLO series comparison, since they are different from other one-stage detectors based on FPN, we separately compare with them in Appendix D.1. ", "page_idx": 6}, {"type": "text", "text": "Comparison results. Table 1 shows the performance in terms of AP for multiple datasets compared to competitive baselines. As shown, our approach has achieved better detection performance in general. Comparing to those RPN based two-stage frameworks which suffer from a low recall given limited candidate object predictions, our approach leverages abundant positive anchors provided by the underlying one-stage framework. Additionally, our approach can more effectively avoid false positive predictions benefiting from the learned RL masks that precisely detect positive anchors. This is clearly demonstrated through improved performance on small object detection $(i.e.,\\;\\mathrm{AP}^{S})$ and the challenging subset (i.e., $\\mathsf{A}\\bar{\\mathsf{P}}^{C H}$ ). As can be seen, the performance improvement compared to its base detector GFocal (without RL augmentation) is as high as around $4\\%$ in certain cases. It is noted that the performance advantage is not as prominent in the medium and large object detection as these are relatively easy cases and can be adequately handled by commonly used models. Our proposed technique is designed to focus on difficult images while remaining competitive on easier detection tasks. ", "page_idx": 6}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/a8e3e2a558d773b42e72261b39c65ac91b20a09186d933d692fb8c37d343b3c8.jpg", "table_caption": ["Table 1: Detection performance comparison on all three datasets along with their challenging subsets "], "table_footnote": [], "page_idx": 7}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/0ce764616f534c429de9209206d53d9070a55ffd6c5bd2a02f0465801c11bf2f.jpg", "table_caption": ["Table 2: Detection performance using different backbone architectures "], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "", "page_idx": 7}, {"type": "text", "text": "Results on different backbones. We also test our model\u2019s performance on multiple latest backbones such as Swin-T [28], Efficientnet-b3 [37] and ConvNeXt [29], and compare with the most competitive baselines of each category with the same backbone setting as shown in Table 2. The results show a highly consistent trend as in Table 1. ", "page_idx": 7}, {"type": "text", "text": "Inference speed comparison. Finally, we compare the parameter size as well as inference speed of our model with representative baselines. As the results shown in Table 3, the inference speed of AIRS does not bring extra detection burden compared to those latest baselines. ", "page_idx": 7}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/7f76539f06ec32f7b808649d776234ca4585f88e80db7c9f67fc3a3b98797849.jpg", "table_caption": ["Table 3: Inference speed comparison "], "table_footnote": [], "page_idx": 7}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/c28cc1d60117aaf929c83e6b387bc21d29199742b8d6a2bc81ae934c1f04f3bf.jpg", "table_caption": ["Table 4: RL baseline comparison "], "table_footnote": [], "page_idx": 7}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/db13d319612ec19d3fc3afc91a15827c9f829bae6f7b24e782a40fe9a8ae4c24.jpg", "img_caption": ["Figure 3: (a)-(b) Average number of detections per test image based on the bounding box area on MS COCO and OpenImages V4. (c) Ablative study on epistemic uncertainty to deep Q-evaluation. "], "img_footnote": [], "page_idx": 8}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/6d117e1016884f29fd4a5950c99c5ec03f5f7d910a9c464f6286c0b68057a61a.jpg", "table_caption": ["Table 5: Ablation study on model design choices "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "Results on RL baselines. We also compare AIRS with existing RL based object detectors [47, 4, 3, 8, 43] in Table 4. It is worth to note that these works either focus on active object localization which can only detect limited objects or leverage CNN and recurrent networks to detect multiple objects step by step that lacks the flexibility to conduct dense detection from complex background. In [43], ReinforceNet leverages a hierarchical DRL framework for visual object tracking, which predicts target object\u2019s movement locations in the next frame given the last frame\u2019s state information. Since the primary goal is different from ours, their policy network is for mode switch among four modes (search, stop, update, re-initialization) given the last state. In contrast, our policy network gives directional movement actions given the current state (i.e., patch location in the feature pyramid network) to support hierarchical search of objects. We ignore the specific $A P^{S},A P^{M}$ , $A P^{L}$ metrics and only report the mAP performance averaged over all categories, which is also the most commonly used metric on the Pascal VOC dataset. The result demonstrates the superiority of AIRS in dense scenarios with a large performance gap comparing to existing RL baselines. ", "page_idx": 8}, {"type": "text", "text": "4.4 Qualitative Analysis ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "Accurately selecting positive anchors via the generated RL masks has a strong impact on the final detection performance. For the more difficult images from the COCO and OpenImage V4 data sets, GFocal produces many false positive bounding boxes since it focuses on achieving a high recall on even small objects. In contrast, AIRS has precisely identified the true objects (high recall) while avoiding the unnecessary small bounding boxes (high precision). This phenomenon is supported by statistical counts in Figure 3 (a)-(b). This clearly justifies its effectiveness especially in those challenging images. Appendix D.7 shows more results in the even more challenging subsets. ", "page_idx": 8}, {"type": "text", "text": "4.5 Ablation Study ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We demonstrate the effectiveness of each proposed component through ablation study on MS COCO dataset. Specifically, we analyze the impact of different model design choices, such as positive anchor criterion choices and the epistemic uncertainty design in evidential Q-learning. As shown in Table 5, among all positive anchor criterion choices, DIoU is the most effective positive anchor criterion as it considers both overlapping area ratio and the centerness relativity between the prediction and target. Furthermore, without epistemic uncertainty, there is a significant drop in detection performance. This justifies the importance of exploring the unknown patches by leveraging epistemic uncertainty in our proposed framework. In particular, for the challenging and small objects, it is more critical to conduct a deep exploration to identify various types of objects. The deeper reason justifying the importance of epistemic uncertainty can be explained using Figure 3c, where we use one image\u2019s Q-learning curve in the search process as an example. The figure shows the Q-value (Q), evidential Q-value (Evi Q), epistemic uncertainty (EU) of the selected patch in each step, and the corresponding reward (Reward) as a supervision signal. We also include the Q-value and the corresponding reward in each step if we train the model without epistemic uncertainty, denoted as Q w/o EL (i.e., evidential learning) and Reward w/o EL. Without epistemic uncertainty, at the early phase of training, the RL agent tends to select the patches with a high immediate reward and therefore abandons patches with a low estimated Q-value (with low immediate reward). As many patches that require a deep exploration to find objects may be missed, the agent only selects those regions with a high Q-value (shown in brown color) in the current step. Due to the top-down search strategy, the RL agent may never search the skipped region again, including all patches in the lower layers. This results in a significant reward drop (shown in the purple color) in the later steps along with an early termination (in step 40), resulting into a low cumulative reward in the long run. However, AIRS chooses regions based on the evidential Q-value (green curve) and therefore patches with even a low estimated Q-value (black curve) but high epistemic uncertainty (blue curve) may still have a chance to be selected. In this way, AIRS can explore patches with objects requiring deep exploration resulting into high cumulative rewards shown in red. ", "page_idx": 8}, {"type": "text", "text": "", "page_idx": 9}, {"type": "text", "text": "4.6 Discussion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "Performance of AIRS on large objects in MS COCO. In this work, we aim to improve the detection performance by having a good balance between objects of different sizes and the $A P$ metric is designed to assess the overall effectiveness in terms of detecting objects in all granularities. Compared to competitive baselines, AIRS is superior on all datasets. We observe that by placing more focus on smaller and more difficult objects, AIRS achieves lower performance on $A P^{L}$ and $\\bar{A P}^{M}$ in MS COCO. However, this is an expected behavior as MS COCO has most of the objects being very large and therefore, the cost of missing smaller objects in the existing two-stage detectors seem to be low. As such, many two-stage detectors have superior performance (see Table 1). In contrast, as our technique leverages a one-stage detector to better cover dense objects, it is relatively less effective to detect very large objects (which is evidenced by the lower performance by all one-stage detectors in Table 1). It is worth mentioning that in other datasets, AIRS outperforms all baselines even on the large objects. In the case of Pascal VOC 2012, it is relatively easier and does not contain very large objects. As such, one-stage detectors perform comparable or even better than the two-stage detectors. As for Open Image V4, despite being challenging, it contains a good amount of training samples with larger objects, which provides enough supervision for models to detect these large objects. As such, all single-detectors including our technique perform comparable or even better compared to two-stage detectors. ", "page_idx": 9}, {"type": "text", "text": "Comparison with two stage detectors like RPN. There are key differences between two stage detectors and AIRS. The former usually relies on a Region Proposal Network (RPN), which is less effective to capture all targeted objects especially in a dense scenario. This is because, RPN selects anchors from the candidate anchors provided by the RPN based on the confidence score resulting into missing many true positive object anchors with a low confidence. In contrast, FPN in AIRS is based on multi-scale feature representations. Thus, the number of selected anchors in all layers is far more than the ones proposed by the RPN, which avoids missing important object anchors. To tackle the many false positive anchors in the FPN based approaches, we propose a novel hierarchical search mechanism coupled with an effective exploration-exploitation strategy leveraging evidential Q-learning. As a result, AIRS effectively removes the false positive bounding boxes without removing the less confident true positive objects. This phenomenon is also demonstrated in Table 1, where two-stage detectors result in a lower performance compared to AIRS in dense object detection. ", "page_idx": 9}, {"type": "text", "text": "5 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We propose a novel Adaptive Important Region Selection (referred to as AIRS) framework guided by evidential Q-learning built upon a uniquely designed reward function. AIRS encourages object search in a hierarchical, top-down fashion, where the RL agent moves down to a fine-grained level only when it is likely to contain an object of interest. In addition, to facilitate detection of unknown patches, evidential Q-learning leverages the epistemic uncertainty to guide the exploration process. Our proposed technique dynamically balances exploration-exploitation where in the early phase the priority is given to the highly uncertain patches and in the latter phase priority is dynamically shifted to the potentially positive patches. Both theoretical analysis and empirical results on challenging object detection datasets demonstrate the effectiveness of our proposed framework. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgments ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "This research was supported in part by an NSF IIS award IIS-1814450. The views and conclusions contained in this paper are those of the authors and should not be interpreted as representing any funding agency. We would like to thank the anonymous reviewers for their constructive comments. ", "page_idx": 10}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[1] Alexander Amini, Wilko Schwarting, Ava Soleimany, and Daniela Rus. Deep evidential regression. In H. Larochelle, M. Ranzato, R. Hadsell, M.F. Balcan, and H. Lin, editors, Advances in Neural Information Processing Systems, volume 33, pages 14927\u201314937, 2020.   \n[2] Martin Anthony and Peter L. Bartlett. Neural Network Learning: Theoretical Foundations. Cambridge University Press, 1999.   \n[3] Jimmy Ba, Volodymyr Mnih, and Koray Kavukcuoglu. Multiple object recognition with visual attention. arXiv preprint arXiv:1412.7755, 2014.   \n[4] Miriam Bellver, Xavier Giro-i Nieto, Ferran Marques, and Jordi Torres. Hierarchical object detection with deep reinforcement learning. In Deep Reinforcement Learning Workshop, NIPS, December 2016.   \n[5] Christopher M Bishop. Pattern recognition and machine learning. Springer, 2006. [6] Yuanqiang Cai, Longyin Wen, Libo Zhang, Dawei Du, Weiqiang Wang, and Pengfei Zhu. Rethinking object detection in retail stores. ArXiv, abs/2003.08230, 2021.   \n[7] Zhaowei Cai and Nuno Vasconcelos. Cascade r-cnn: Delving into high quality object detection. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 6154\u20136162, 2018.   \n[8] Juan C. Caicedo and Svetlana Lazebnik. Active object localization with deep reinforcement learning. CoRR, abs/1511.06015, 2015.   \n[9] Nicolas Carion, Francisco Massa, Gabriel Synnaeve, Nicolas Usunier, Alexander Kirillov, and Sergey Zagoruyko. End-to-end object detection with transformers. In European conference on computer vision, pages 213\u2013229. Springer, 2020.   \n[10] S. Chen, Z. Li, F. Huang, C. Zhang, and H. Ma. Improving object detection with relation mining network. In 2020 IEEE International Conference on Data Mining (ICDM), pages 52\u2013 61, Los Alamitos, CA, USA, nov 2020. IEEE Computer Society.   \n[11] Xianzhi Du, Tsung-Yi Lin, Pengchong Jin, Golnaz Ghiasi, Mingxing Tan, Yin Cui, Quoc V Le, and Xiaodan Song. Spinenet: Learning scale-permuted backbone for recognition and localization. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 11592\u201311601, 2020.   \n[12] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn, and A. Zisserman. The PASCAL Visual Object Classes Challenge 2012 (VOC2012) Results. http://www.pascalnetwork.org/challenges/VOC/voc2012/workshop/index.html, 2012.   \n[13] Jianqing Fan, Zhaoran Wang, Yuchen Xie, and Zhuoran Yang. A theoretical analysis of deep q-learning. In Learning for Dynamics and Control, pages 486\u2013489. PMLR, 2020.   \n[14] Yuxin Fang, Wen Wang, Binhui Xie, Quan Sun, Ledell Wu, Xinggang Wang, Tiejun Huang, Xinlong Wang, and Yue Cao. Eva: Exploring the limits of masked visual representation learning at scale. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 19358\u201319369, 2023.   \n[15] Ross B. Girshick, Jeff Donahue, Trevor Darrell, and Jitendra Malik. Rich feature hierarchies for accurate object detection and semantic segmentation. 2014 IEEE Conference on Computer Vision and Pattern Recognition, pages 580\u2013587, 2014.   \n[16] Nisim Hurst-Tarrab, Leonardo Chang, Miguel Gonzalez-Mendoza, and Neil Hernandez-Gress. Robust parking block segmentation from a surveillance camera perspective. Applied Sciences, 10(15):5364, 2020.   \n[17] Zequn Jie, Xiaodan Liang, Jiashi Feng, Xiaojie Jin, Wen Lu, and Shuicheng Yan. Treestructured reinforcement learning for sequential object localization. In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 29. Curran Associates, Inc., 2016.   \n[18] Audun J\u00f8sang. Subjective logic. Springer, 2016.   \n[19] Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint arXiv:1312.6114, 2013.   \n[20] Alina Kuznetsova, Hassan Rom, Neil Alldrin, Jasper Uijlings, Ivan Krasin, Jordi Pont-Tuset, Shahab Kamali, Stefan Popov, Matteo Malloci, Alexander Kolesnikov, et al. The open images dataset v4. International Journal of Computer Vision, 128(7):1956\u20131981, 2020.   \n[21] Sang-gil Lee, Jae Seok Bae, Hyunjae Kim, Jung Hoon Kim, and Sungroh Yoon. Liver lesion detection from weakly-labeled multi-phase ct volumes with a grouped single shot multibox detector, 2018.   \n[22] Xiang Li, Wenhai Wang, Xiaolin Hu, Jun Li, Jinhui Tang, and Jian Yang. Generalized focal loss v2: Learning reliable localization quality estimation for dense object detection. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pages 11632\u201311641, June 2021.   \n[23] Xiang Li, Wenhai Wang, Lijun Wu, Shuo Chen, Xiaolin Hu, Jun Li, Jinhui Tang, and Jian Yang. Generalized focal loss: Learning qualified and distributed bounding boxes for dense object detection. In NeurIPS, 2020.   \n[24] Yanghao Li, Yuntao Chen, Naiyan Wang, and Zhaoxiang Zhang. Scale-aware trident networks for object detection. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 6054\u20136063, 2019.   \n[25] Tsung-Yi Lin, Piotr Dollar, Ross Girshick, Kaiming He, Bharath Hariharan, and Serge Belongie. Feature pyramid networks for object detection. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), July 2017.   \n[26] Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, and Piotr Dollar. Focal loss for dense object detection. In Proceedings of the IEEE International Conference on Computer Vision (ICCV), Oct 2017.   \n[27] Tsung-Yi Lin, Michael Maire, Serge Belongie, Lubomir Bourdev, Ross Girshick, James Hays, Pietro Perona, Deva Ramanan, C. Lawrence Zitnick, and Piotr Doll\u00e1r. Microsoft coco: Common objects in context, 2014.   \n[28] Ze Liu, Yutong Lin, Yue Cao, Han Hu, Yixuan Wei, Zheng Zhang, Stephen Lin, and Baining Guo. Swin transformer: Hierarchical vision transformer using shifted windows. arXiv preprint arXiv:2103.14030, 2021.   \n[29] Zhuang Liu, Hanzi Mao, Chao-Yuan Wu, Christoph Feichtenhofer, Trevor Darrell, and Saining Xie. A convnet for the 2020s. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), 2022.   \n[30] Andrey Malinin and Mark Gales. Predictive uncertainty estimation via prior networks. In S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 31. Curran Associates, Inc., 2018.   \n[31] R\u00e9mi Munos and Csaba Szepesv\u00e1ri. Finite-time bounds for fitted value iteration. Journal of Machine Learning Research, 9(27):815\u2013857, 2008.   \n[32] Joseph Redmon and Ali Farhadi. Yolo9000: Better, faster, stronger. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), July 2017.   \n[33] Shaoqing Ren, Kaiming He, Ross Girshick, and Jian Sun. Faster r-cnn: Towards real-time object detection with region proposal networks. In Proceedings of the 28th International Conference on Neural Information Processing Systems - Volume 1, NIPS\u201915, page 91\u201399, Cambridge, MA, USA, 2015. MIT Press.   \n[34] Hamid Rezatofighi, Nathan Tsoi, JunYoung Gwak, Amir Sadeghian, Ian Reid, and Silvio Savarese. Generalized intersection over union: A metric and a loss for bounding box regression. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 658\u2013666, 2019.   \n[35] Johannes Schmidt-Hieber. Nonparametric regression using deep neural networks with relu activation function. Annals of Statistics, Volume 48, Number 4, 1875-1897, 2020, 2020.   \n[36] Murat Sensoy, Lance Kaplan, and Melih Kandemir. Evidential deep learning to quantify classification uncertainty. In Advances in Neural Information Processing Systems, volume 31. Curran Associates, Inc., 2018.   \n[37] Mingxing Tan and Quoc V Le. Efficientnet: Rethinking model scaling for convolutional neural networks. arXiv preprint arXiv:1905.11946, 2019.   \n[38] Zhi Tian, Chunhua Shen, Hao Chen, and Tong He. FCOS: Fully convolutional one-stage object detection. In Proc. Int. Conf. Computer Vision (ICCV), 2019.   \n[39] Alexandre B. Tsybakov. Introduction to Nonparametric Estimation. Anonymous, 2008.   \n[40] Artur Wilkowski, W\u0142odzimierz Kasprzak, and Maciej Stefan\u00b4czyk. Object detection in the police surveillance scenario. In 2019 Federated Conference on Computer Science and Information Systems (FedCSIS), pages 363\u2013372, 2019.   \n[41] Ze Yang, Shaohui Liu, Han Hu, Liwei Wang, and Stephen Lin. Reppoints: Point set representation for object detection. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 9657\u20139666, 2019.   \n[42] Mengyao Zhai, Lei Chen, Jinling Li, Mehran Khodabandeh, and Greg Mori. Object detection in surveillance video from dense trajectories. In 2015 14th IAPR International Conference on Machine Vision Applications (MVA), pages 535\u2013538, 2015.   \n[43] Dawei Zhang, Zhonglong Zheng, Riheng Jia, and Minglu Li. Visual tracking via hierarchical deep reinforcement learning. Proceedings of the AAAI Conference on Artificial Intelligence, 35(4):3315\u20133323, May 2021.   \n[44] Hao Zhang, Feng Li, Shilong Liu, Lei Zhang, Hang Su, Jun Zhu, Lionel M Ni, and HeungYeung Shum. Dino: Detr with improved denoising anchor boxes for end-to-end object detection. arXiv preprint arXiv:2203.03605, 2022.   \n[45] Shifeng Zhang, Cheng Chi, Yongqiang Yao, Zhen Lei, and Stan Z. Li. Bridging the gap between anchor-based and anchor-free detection via adaptive training sample selection. In CVPR, 2020.   \n[46] Zhaohui Zheng, Ping Wang, Wei Liu, Jinze Li, Rongguang Ye, and Dongwei Ren. Distanceiou loss: Faster and better learning for bounding box regression. In Proceedings of the AAAI conference on artificial intelligence, volume 34, pages 12993\u201313000, 2020.   \n[47] Man Zhou, Rujing Wang, Chengjun Xie, Liu Liu, Rui Li, Fangyuan Wang, and Dengshan Li. Reinforcenet: A reinforcement learning embedded object detection framework with region selection network. Neurocomputing, 443:369\u2013379, 2021.   \n[48] Chenchen Zhu, Fangyi Chen, Zhiqiang Shen, and Marios Savvides. Soft anchor-point object detection. In ECCV, 2020.   \n[49] Zhuofan Zong, Guanglu Song, and Yu Liu. Detrs with collaborative hybrid assignments training. In Proceedings of the IEEE/CVF international conference on computer vision, pages 6748\u20136758, 2023. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "Supplementary Material ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Appendix ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Table of Contents ", "page_idx": 13}, {"type": "text", "text": "A Summary of Notations 15 ", "page_idx": 13}, {"type": "text", "text": "B Proof of Theoretical Results 15 ", "page_idx": 13}, {"type": "text", "text": "B.1 Definitions and Assumptions . 16   \nRemark about Assumption 1. 17   \nRemark about Assumption 2. 17   \nB.2 Proof of Theorem 1 . 17 ", "page_idx": 13}, {"type": "text", "text": "C Additional Details of AIRS 19 ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "C.1 Reward Design 19   \nC.2 Training/Test process . . 19   \nC.3 Action Interaction Details . . 20   \nExamples Demonstrating Action Interaction Process: 21   \nCase 1: Downward movement. . . 21   \nCase 2: Upward movement. . 21   \nCase 3: Search termination. 22   \nC.4 Clarification on RL masks. 22 ", "page_idx": 13}, {"type": "text", "text": "D Additional Experiments 23 ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "D.1 Comparison with the Latest YOLO Series 23   \nD.2 Balancing Hyper-parameter Search . . 23   \nD.3 Datasets with a Large Amount of Small Objects 24   \nD.4 RL Agent Training Configurations . . . 24   \nD.5 Ablation Study on Base Detectors . . 25   \nD.6 Train efficiency . . 25   \nD.7 Subset Generation Illustration . 26 ", "page_idx": 13}, {"type": "text", "text": "E Limitation and Broader Impact 26 ", "page_idx": 13}, {"type": "text", "text": "F Link to Source Code 26 ", "page_idx": 13}, {"type": "text", "text": "Organization of the Appendix: ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "\u2022 In Appendix A, we summarize major notations used throughout the paper.   \n\u2022 In Appendix B, we provide detailed proof of the main theoretical result.   \n\u2022 In Appendix C, we provide more detailed information about our AIRS framework including reward design and action interaction.   \n\u2022 In Appendix D, we provide details related to experimentation along with additional results.   \n\u2022 In Appendix E, we discuss the limitation of our work and its broader impact.   \n\u2022 In Appendix F, we provide the link to the source code. ", "page_idx": 14}, {"type": "text", "text": "A Summary of Notations ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "The major notations and their descriptions are summarized in Table 6. ", "page_idx": 14}, {"type": "text", "text": "Table 6: Symbols with Descriptions ", "page_idx": 14}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/282810df94dd68d9697198058045d647af589d686ac0e8b0d818949c1f8120a5.jpg", "table_caption": [], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "B Proof of Theoretical Results ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "We aim to obtain an upper bound for $\\|Q^{\\pi_{K}}-Q^{*}\\|_{1}$ . We start by providing formal definitions of several key components used in our proof, including sparse ReLU network, Ho\u00a8lder smooth functions, ", "page_idx": 14}, {"type": "text", "text": "their compositions, and functional classes. We then provide two assumptions related to Bellman optimality smoothness and concentration coefficient bound. Finally, we provide the proof for Theorem 1. It should be noted that our proof is developed based upon some key results in [35, 2, 13]. ", "page_idx": 15}, {"type": "text", "text": "B.1 Definitions and Assumptions ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Definition B.1 (Sparse ReLU Network). Let $L$ be the number of hidden layers, $V$ be the upper bound for the neural network outputs, $d_{l}$ be the number of nodes in the $l^{t h}$ layer, $f_{l}$ be the output of the $l$ -th layer, and $w_{m a x}$ be the total number of non-zero weights. The sparse ReLU networks can be formally defined as ", "page_idx": 15}, {"type": "text", "text": "1 $\\mathcal{\\tau}\\left(L,\\{d_{l}\\}_{l=0}^{L+1},w_{m a x},V\\right)=\\left\\{f:\\operatorname*{max}_{l\\in[L+1]}\\|\\widetilde{\\mathbf{W}}_{l}\\|_{\\infty}\\leq1,\\sum_{l=1}^{L+1}\\|\\widetilde{\\mathbf{W}}_{l}\\|_{0}\\leq w_{m a x},\\operatorname*{max}_{l\\in[d_{L+1}]}\\|f_{l}\\|_{\\infty}\\leq V\\right\\}$ (10) In our case, since $\\mathrm{{Q}}.$ -values are always bounded and therefore, we can replace $V$ by $\\begin{array}{r}{V_{m a x}=\\frac{R_{m a x}}{1-\\gamma}}\\end{array}$ To simplify the notations, we can simply omit the $V$ term and use notation $F(L,\\{d_{l}\\}_{l=0}^{L+1},w_{\\underline{{{m a x}}}})$ . In the above equation, $\\widetilde{\\mathbf{W}}_{l}$ denotes the weights of the $l^{t h}$ layer of the neural network, i.e.,, $\\widetilde{\\mathbf{W}}_{l}=$ $(\\mathbf{W}_{l},b_{l})$ and the final output $f$ of the network is given by ", "page_idx": 15}, {"type": "equation", "text": "$$\nf(\\mathbf{x})=\\mathbf{W}_{L+1}\\sigma(\\mathbf{W}_{L}\\sigma(\\mathbf{W}_{L-1}.....\\sigma(\\mathbf{W}_{2}\\sigma(\\mathbf{W}_{1}\\mathbf{x}+b_{1})+b_{2})...b_{L-1})+b_{L})\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "where $\\sigma$ is the ReLU function. In our case, we can have a ReLU activation in each output layer except for the last layer to make the network sparse, which is required to prove the theorem. In the later part of our proof given by Equation 31, we show that the number of samples and network sparsity are directly related (more sparse, less samples) and therefore, to get the given convergence result, having a sparse network will reduce the number of samples. ", "page_idx": 15}, {"type": "text", "text": "Definition B.2 (Ho\u00a8lder Function). Let $\\mathcal{D}$ be a compact subset of $\\mathcal{R}^{r}$ . Then, the set of Ho\u00a8lder functions on $\\mathcal{D}$ is defined as ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathcal{C}_{r}(\\mathcal{D},\\nu,H)=\\left\\{f:\\mathcal{D}\\to\\mathcal{R}:\\sum_{\\alpha:|\\alpha|<\\nu}\\|\\delta^{\\alpha}f\\|_{\\infty}+\\sum_{\\alpha:|\\alpha|\\leq\\nu}\\operatorname*{sup}_{\\mathbf{x},\\mathbf{y}\\in\\mathcal{D},\\mathbf{x}\\neq\\mathbf{y}}\\frac{\\left|\\delta^{\\alpha}f(\\mathbf{x})-\\delta^{\\alpha}f(\\mathbf{y})\\right|}{\\|\\mathbf{x}-\\mathbf{y}\\|_{\\infty}^{\\nu-\\nu_{0}}}\\right\\}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "where $\\nu\\,>\\,0,H\\,>\\,0$ are function parameters, $\\nu_{0}$ is the largest integer no greater than $\\nu$ , $\\alpha=$ $(\\alpha_{1},...,\\alpha_{r})^{\\top}$ , $\\delta^{\\alpha}=\\left(\\delta^{\\alpha_{1}},...\\delta^{\\delta_{r}}\\right)$ , and $r$ is the dimensionality of the state space $\\boldsymbol{S}$ . ", "page_idx": 15}, {"type": "text", "text": "Definition B.3 (Compositions of Ho\u00a8lder Function). Let $q$ and $\\{p_{j}\\}_{j\\in[q]}$ be integers and $\\mathbf{g}_{j}$ be a function with $\\mathbf{g}_{j k}$ being a Ho\u00a8lder smooth function that depends on at most $\\eta_{j}$ components of its input, i.e.,, $\\mathbf{g}_{j k}\\in{\\mathcal{C}}_{\\eta_{j}}(D_{j},\\nu_{j},H_{j})$ . With $G(\\{p_{j},\\eta_{j},\\nu_{j},H_{j}\\}_{j\\in[q]})$ being the family of functions that can be expressed as compositions of $\\{g_{j}\\}_{j\\in[q]}$ then for any $\\overrightharpoon{f}^{'}\\in\\,G(\\{p_{j},\\eta_{j},\\nu_{j},H_{j}\\}_{j\\in[q]})$ , we can write the following ", "page_idx": 15}, {"type": "equation", "text": "$$\nf=\\mathbf{g}_{q}\\cdot\\mathbf{g}_{q-1}\\cdot\\ldots\\cdot\\mathbf{g}_{2}\\cdot\\mathbf{g}_{1}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Definition B.4 (Functional Clas s). Let $F(L,\\{d_{l}\\}_{l=1}^{L+1},w_{m a x})$ be the family of sparse ReLU networks defined on the state space $\\boldsymbol{S}$ with $d_{0}=r$ and $d_{L+1}=1$ , then can be defined as ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathcal{F}_{0}=\\{f:S\\times\\mathcal{A}\\to\\mathcal{R}:f(.,\\mathbf{a})\\in F(L,\\{d_{l}\\}_{l=0}^{L+1},w_{m a x});\\;\\forall\\mathbf{a}\\in\\mathcal{A}\\}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "In addition, let $G(\\{p_{j},\\eta_{j},\\nu_{j},H_{j}\\}_{j\\in[q]})$ be a set of compositions of the Ho\u00a8lder smooth functions defined on $\\mathcal{S}\\in\\mathcal{R}^{r}$ . Similar to ${\\mathcal{F}}_{0}$ , we define functional class $\\mathcal{G}_{0}$ as ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathcal{G}_{0}=\\{f:\\mathcal{S}\\times\\mathcal{A}\\to\\mathcal{R};f(.,\\mathbf{a})\\in G(\\{p_{j},\\eta_{j},\\nu_{j},H_{j}\\}_{j\\in[q]});\\forall\\mathbf{a}\\in\\mathcal{A}\\}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Based on these definitions, we introduce two assumptions about the Ho\u00a8lder smoothness on the Bellman optimality and concentration coefficient bound, which are given below. ", "page_idx": 15}, {"type": "text", "text": "Assumption B.5 (Bellman Optimality Smoothness). For any sparse ReLU network function $f\\in F$ with $F$ being the family of functions, $(T f)(\\mathbf{s},\\mathbf{a})$ with $T$ being the Bellman optimality operator can be written as the composition of the Ho\u00a8lder smooth functions. ", "page_idx": 15}, {"type": "equation", "text": "$$\n(T f)(\\mathbf{s},\\mathbf{a})=\\mathbf{g}_{q}\\cdot\\mathbf{g}_{q-1}....\\cdot\\mathbf{g}_{1}\\cdot\\mathbf{g}_{0}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "In the above equation, $\\mathbf{g}_{j}$ has $p_{j+1}$ components, where each component $g_{j k}$ is a Ho\u00a8lder smooth function as defined above. ", "page_idx": 15}, {"type": "text", "text": "Remark about Assumption 1. It should be noted that Bellman Optimality Smoothness assumption holds whenever the reward function is smooth [13]. As our reward function is based on existing metrics (e.g., IoU, GIoU), we can easily convert to a smooth variant [34]. This will make the Assumption 1 true in our proposed framework. ", "page_idx": 16}, {"type": "text", "text": "Assumption B.6 (Concentration Coefficient Bound). Let $u_{1},u_{2}\\in\\mathcal{P}(S,\\mathcal{A})$ be two probability measures absolutely continuous with respect to the Lebesgue measure on $S\\times A$ . Also consider $\\{\\pi_{t}\\}_{t\\ge1}$ to be a sequence of policies and for any integer $m$ , let us denote the distribution of $\\{\\mathcal{S}_{t},\\mathcal{A}_{t}\\}_{t=0}^{m}$ by $P^{\\pi_{m}}P^{\\pi_{m-1}}....P^{\\pi_{1}}u_{1}$ . Then, the $m^{t h}$ concentration coefficient is given as ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\kappa(m;u_{1},u_{2})=\\operatorname*{sup}_{\\pi_{1},\\ldots,\\pi_{m}}\\left[\\mathbb{E}_{u_{2}}\\left|\\frac{d(P^{\\pi_{m}}P^{\\pi_{m-1}}....P^{\\pi_{1}}u_{1})}{d u_{2}}\\right|\\right]\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "We assume that there exists a constant $\\phi_{e,f}\\leq\\infty$ that bounds the concentration coefficient, given as ", "page_idx": 16}, {"type": "equation", "text": "$$\n(1-\\gamma^{2})\\sum_{m\\geq1}\\gamma^{m-1}m\\kappa(m;e,f)\\leq\\phi_{e,f}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where $e$ is the fixed distribution of ${\\mathcal{S}}\\times{\\mathcal{A}}$ and $f$ is the sampling distribution. ", "page_idx": 16}, {"type": "text", "text": "Remark about Assumption 2. The Concentration Coefficient Bound assumption is commonly used in a large class of MDP systems [31]. It requires sampling distribution $f$ to have sufficient coverage over $s\\times A$ . In our context, because of the novel exploration strategy coupled with hierarchical searching strategy, our sampling distribution will likely to have a sufficient coverage on ${\\mathcal{S}}\\times{\\mathcal{A}}$ , implying that this assumption holds. ", "page_idx": 16}, {"type": "text", "text": "B.2 Proof of Theorem 1 ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Based on the above assumptions, we proceed to prove Theorem 1, which is restated as: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\|Q^{*}-Q^{\\pi\\kappa}\\|_{1}\\leq C\\phi_{e,f}\\frac{\\gamma}{1-\\gamma^{2}}|\\mathcal{A}|\\tau(\\eta,\\nu)+\\frac{4\\gamma^{K+1}}{1-\\gamma^{2}}R_{m a x}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Proof. In the proposed AIRS algorithm, $\\pi_{k}$ is the policy with respect to $Q^{\\pi_{k}}$ and let $Q^{\\pi_{K}}$ be the action-value function associated with $\\pi_{K}$ . Since, $\\bar{\\{Q^{\\pi_{k}}\\}}_{k\\in[K]}$ is constructed by an iterative algorithm, it is helpful to relate $\\|Q^{*}-Q^{\\pi_{K}}\\|_{1}$ to the errors that occur in the previous steps in AIRS, i.e., $\\{Q^{\\pi_{k}}-T Q^{\\pi_{k-1}}\\}_{k\\in[K]}$ . Therefore, in the first step, we provide the upper bound for $\\|Q^{*}-Q^{\\pi_{K}}\\|_{1}$ as a function of error introduced in each step, which is given by the following theorem. ", "page_idx": 16}, {"type": "text", "text": "Theorem B.7. The relationship between $\\|Q^{*}-Q^{\\pi_{K}}\\|_{1}$ and $\\|Q^{\\pi_{k}}\\-{\\cal T}Q^{\\pi_{k-1}}\\|_{f}$ with $f$ being the sampling distribution is ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\|Q^{*}-Q^{\\pi\\kappa}\\|_{1}\\leq\\frac{2\\phi_{e,f}\\gamma}{1-\\gamma^{2}}\\operatorname*{max}_{k\\in[K]}\\|Q^{\\pi_{k}}-T Q^{\\pi_{k-1}}\\|_{f}+\\frac{4\\gamma^{K+1}}{(1-\\gamma^{2})}R_{m a x}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Please refer to Section C.1 of [13] for a detailed proof of the above theorem. It should be noted that the first term (specifically $\\begin{array}{r}{\\operatorname*{max}_{k\\in[K]}\\|Q^{\\pi_{k}}-Q^{\\bar{\\pi}_{k-1}}\\|_{f})}\\end{array}$ is a statistical error and the second term is an algorithmic error. In the later part of our proof, we show that the statistical error diminishes as the sample size $n$ in each iteration grows whereas the algorithmic error decays to zero geometrically with $K$ . In the above equation, to get the upper bound, we need to bound $\\|Q^{\\pi_{k}}\\ {\\overset{*}{-}}\\ T Q^{\\pi_{k-1}}\\|{\\overset{*}{f}}$ . In order to do this, we use the nonparametric regression. Specifically, we provide the following theorem to bound that error. ", "page_idx": 16}, {"type": "text", "text": "Theorem B.8. Under the assumption of the Bellman optimality smoothness in Assumption $^{\\,l}$ , for any $k\\in[K]$ , we have ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\|Q^{\\pi_{k+1}}-T Q^{\\pi_{k}}\\|_{f}^{2}\\leq4[d i s t_{\\infty}(\\mathcal{F}_{0},\\mathcal{G}_{0})]^{2}+\\frac{C R_{m a x}^{2}}{n(1-\\gamma)^{2}}\\log N_{\\delta}+\\frac{C R_{m a x}}{1-\\gamma}\\delta\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "For any $\\delta>0$ and $C>0$ being a constant. ", "page_idx": 16}, {"type": "text", "text": "Please refer to the Section C.2 of [13] for a detailed proof for the above theorem. There are two terms that play a major role in the bound. The first term indicates the bias, which is given as ", "page_idx": 17}, {"type": "equation", "text": "$$\nd i s t_{\\infty}(\\mathcal{F}_{0},\\mathcal{G}_{0})=\\operatorname*{sup}_{f^{\\prime}\\in\\mathcal{G}_{0},\\,f\\in\\mathcal{F}_{0}}\\|f-f^{\\prime}\\|_{\\infty}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "This term reflects the $l_{\\infty}$ error of estimating the function in $\\mathcal{G}_{0}$ using the sparse ReLU defined in ${\\mathcal{F}}_{0}$ . It also indicates the bias in estimating the functions in $\\mathcal{G}_{\\mathrm{0}}$ . The second term $N_{\\delta}$ indicates the minimum cardinality of the balls required to cover function ${\\mathcal{F}}_{0}$ with respect to the $l_{\\infty}$ -norm. This term indicates the variance associated with estimating the action-value function using a sparse ReLU network. Substituting $\\begin{array}{r}{\\delta=\\frac{1}{n}}\\end{array}$ , we can rewrite the above equation as ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\|Q^{\\pi_{k+1}}-T Q^{\\pi_{k}}\\|_{f}^{2}\\leq4d i s t_{\\infty}^{2}(\\mathcal{F}_{0},\\mathcal{G}_{0})+\\frac{C R_{m a x}^{2}}{n(1-\\gamma^{2})}\\log N_{\\delta}+\\frac{C R_{m a x}}{(1-\\gamma)n}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "In the Above Equation, in the right hand side, the last term is constant for a given $\\mathbf{n}$ . Then there exists absolute constant $C^{\\prime}>0$ such that following Equation holds ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\frac{C R_{m a x}^{2}}{n(1-\\gamma^{2})}\\log N_{\\delta}+\\frac{C R_{m a x}}{(1-\\gamma)n}\\leq C^{\\prime}\\frac{R_{m a x}^{2}}{n(1-\\gamma)^{2}}\\log N_{\\delta}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Using this inequality, we have the following ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\|Q^{\\pi_{k+1}}-T Q^{\\pi_{k}}\\|_{f}^{2}\\leq4d i s t_{\\infty}^{2}(\\mathcal{F}_{0},\\mathcal{G}_{0})+\\frac{C^{\\prime}R_{m a x}^{2}}{n(1-\\gamma)^{2}}\\log N_{\\delta},\\ C^{\\prime}>0\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Now, if we establish a bound for $d i s t_{\\infty}(\\mathcal{F}_{0},\\mathcal{G}_{0})$ and $\\log N_{\\delta}$ , we will be able to get the bound for the $\\|Q^{\\pi_{k}}-T Q^{\\pi_{k-1}}\\|_{f}$ as well. So let us find out the bound for each term. ", "page_idx": 17}, {"type": "text", "text": "(1) Bound for $d i s t_{\\infty}(\\mathcal{F}_{0},\\mathcal{G}_{0});$ : To get the bound for $d i s t_{\\infty}(\\mathcal{F}_{0},\\mathcal{G}_{0})$ , we first show that ReLU network $\\overline{{f(.,\\mathbf{a})}}$ can be reformulated as a composition of Ho\u00a8lder functions defined on the hypercube. Next, we show that using Lemma 6.3 in [35], we can construct the ReLU network to approximate the hypercube components yielding a function close to $f(.,\\mathbf{a})$ in the $l_{\\infty}$ norm. Thus, $f(.,\\mathbf{a})$ can be reformulated as a compositions of Ho\u00a8lder functions defined on the hypercube. Considering, $\\begin{array}{r}{\\mathbf{h}_{1}=\\frac{\\mathbf{g}_{1}}{2H_{1}}}\\end{array}$ $\\mathbf{\\sigma},\\mathbf{h}_{q}(u)=\\mathbf{g}_{q}(2H_{q-1}u-H_{q-1})$ and $\\begin{array}{r}{\\mathbf{h}_{j}(u)=\\frac{\\mathbf{g}_{j}(2H_{j-1}u-H_{j-1})}{2H_{j}}+\\frac{1}{2};\\forall j\\in[2,q-1]}\\end{array}$ , we can write ", "page_idx": 17}, {"type": "equation", "text": "$$\nf(.,\\mathbf{a})=\\mathbf{g}_{q}\\cdot\\ldots\\cdot\\mathbf{g}_{1}=\\mathbf{h}_{q}\\cdot\\ldots\\cdot\\mathbf{h}_{1}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "where we can write $h_{j k}\\in\\mathcal{C}_{\\eta_{j}}([0,1]^{\\eta_{j}},W)$ with $W>0$ and given as ", "page_idx": 17}, {"type": "equation", "text": "$$\nW=\\operatorname*{max}\\left\\{\\operatorname*{max}_{1\\leq j\\leq q-1}(2H_{j}-1)^{\\nu_{j}},H_{q}(2H_{q}-1)^{\\nu_{q}}\\right\\}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Now we can use Lemma 6.3 from [35] to construct a ReLU network to approximate $h_{j k}$ , which can be combined with Equation 24 to show that a ReLU network can be used to approximate $f(.,\\mathbf{a})$ in the $l_{\\infty}$ norm. According to Lemma 6.3 from [35], there exists a ReLU network $\\bar{\\tilde{h}}_{j k}$ which is Ho\u00a8lder smooth such that $\\|\\tilde{h}_{j k}-h_{j k}\\|_{\\infty}\\le N^{-\\frac{\\nu_{j}}{\\eta_{j}}}$ . When $N$ is large, it can be written as ", "page_idx": 17}, {"type": "equation", "text": "$$\nN=\\left\\lceil\\operatorname*{max}_{1\\leq j\\leq q}C n^{\\frac{\\eta_{j}}{2(\\nu_{j}^{*}+\\eta_{j})}}\\right\\rceil\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "where $\\begin{array}{r}{\\nu_{j}^{*}=\\nu_{j}\\prod_{l=j+1}\\operatorname*{min}(\\nu_{l},1)}\\end{array}$ with $\\nu_{j}^{*}=1$ . For the large $N$ , we can approximate $f(.,\\mathbf{a})$ by $\\tilde{f}$ belonging to the ReLU class $F(L^{*},\\{d_{j}^{*}\\}_{j=1}^{L^{*}+1},w_{m a x}^{*})$ . Specifically, we have the following bound for the approximation. ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\|f(.,\\mathbf{a})-\\tilde{f}\\|_{\\infty}\\leq\\sum_{j=1}^{q}\\|\\tilde{h}_{j}-h_{j}\\|_{\\infty}^{\\lambda_{j}}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "where, $\\begin{array}{r}{\\lambda_{j}\\,=\\,\\prod_{l=j+1}^{q}(\\eta_{l}\\wedge1)\\forall j\\,\\in\\,[q-1]}\\end{array}$ with $\\lambda_{q}\\,=\\,1$ . Now using above inequality along with definition of $N$ and $\\|\\tilde{h}_{j k}-h_{j k}\\|_{\\infty}\\le N^{-\\frac{\\nu_{j}}{\\eta_{j}}}$ , we get the following ", "page_idx": 17}, {"type": "equation", "text": "$$\n[d i s t_{\\infty}(\\mathcal{F}_{0},\\mathcal{G}_{0})]^{2}\\leq n^{\\alpha^{*}-1}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "$\\alpha^{*}=\\operatorname*{max}_{j\\in[q]}\\frac{\\eta_{j}}{2\\nu_{j}^{*}\\!+\\!\\eta_{j}}$ and $\\begin{array}{r}{\\nu_{j}^{*}=\\nu_{j}\\prod_{l=j+1}\\operatorname*{min}(\\nu_{l},1)}\\end{array}$ . ", "page_idx": 18}, {"type": "text", "text": "(2) Bound for $\\log N_{\\delta}$ : Using classical results on the covering number of neural networks in [2], we have the following ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\log N_{\\delta}\\leq|A|w_{m a x}^{*}L^{*}\\operatorname*{max}_{j\\in[L^{*}]}\\log(d_{j}^{*})\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Let us consider that there exists $\\zeta$ with $\\zeta^{*}=1+2\\zeta$ such that ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\operatorname*{max}\\left\\{\\sum_{j=1}^{q}(\\eta_{j}+\\nu_{j}+1)^{3+\\eta_{j}},\\sum_{j\\in[q]}\\log(\\eta_{j}+\\nu_{j}),\\operatorname*{max}_{j\\in[q]}p_{j}\\right\\}\\leq(\\log n)^{\\zeta}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "We further assume that ", "page_idx": 18}, {"type": "equation", "text": "$$\nL^{*}\\leq(\\log n)^{\\zeta^{*}},r\\leq\\operatorname*{min}_{j\\in[L^{*}]}d_{j}^{*}\\leq\\operatorname*{max}_{j\\in[L^{*}]}d_{j}^{*}\\leq n^{\\zeta^{*}},w_{m a x}^{*}\\approx n^{\\alpha^{*}}(\\log n)^{\\zeta^{*}}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Then we can rewrite Equation 29 as ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\log N_{\\delta}\\leq|A|n^{\\alpha^{*}}(\\log n)^{1+2\\zeta^{*}}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Now substituting Eq. 32 and 28 into Eq. 23 and replacing it into Eq. 20, we obtain the following ", "page_idx": 18}, {"type": "equation", "text": "$$\nQ^{*}-Q^{\\pi\\kappa}\\|_{1}\\leq\\frac{C\\phi_{e,f}\\gamma}{1-\\gamma^{2}}|A|(\\log n)^{1+2\\zeta^{*}}n^{\\frac{\\alpha^{*}-1}{2}}+\\frac{4\\gamma^{K+1}}{(1-\\gamma^{2})}R_{m a x}=\\frac{C\\phi_{e,f}\\gamma}{1-\\gamma^{2}}|A|\\tau(\\nu,\\eta)+\\frac{4\\gamma^{K+1}}{(1-\\gamma_{-}^{2})}R_{m a x},\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "This completes the proof of our theorem. ", "page_idx": 18}, {"type": "text", "text": "C Additional Details of AIRS ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "In this section, first we introduce the reward design in detail. Then we explain the overall detailed training and test process through the complementary diagram and pseudo code. Next, we explain different actions defined and their interactions with the RL environment (i.e., FPN tree-structure) under AIRS framework with some illustrative examples. ", "page_idx": 18}, {"type": "text", "text": "C.1 Reward Design ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "For the reward design, first we need to get positive anchor by using IoU, GIoU, DIoU, etc as selection criterion, along with the corresponding thresholds following RetinaNet [26], we did an ablation study for these choices in Table 5. Then we calculate the number of positive anchors for each patch and rank those patches in the same layer to form $L$ ranking lists. If the action directed next patch in any list resides on 0-25th percentile, the quality score $g$ is up-scaled to 0.25, or if it resides on 75th percentile to 100th percentile, the quality score is up-scaled to 1, etc. In this way, the quality score and the penalty term have an alignment and perform exploitation-exploration balance in the reward design besides evidential Q-learning. ", "page_idx": 18}, {"type": "text", "text": "C.2 Training/Test process ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Fig 5 shows the detailed workflow of AIRS. It also captures important steps of the training process along with the major symbols and parameters used in the actual implementation. For RL training, we leverage the FPN from the backbone model (e.g., pre-trained GFocal) to set up the RL environment. Training starts from the initial patch $p_{i,t}^{l}$ on the virtual top-most layer $L$ , where state embedding representation $s_{t}$ is generated after passing through the feature extractor $\\operatorname{f}(\\cdot;\\theta_{f})$ and the RNN network. Next, the state is passed into the evidential Q-network to get hyper-parameters governing the evidential distribution, where Q-value is sampled. After getting the Q-value $q_{d,t}$ and epistemic uncertainty $u_{d,t}$ generated from the same distribution, we evaluate the evidential $\\mathrm{^Q}$ -value $q_{d,t}^{e}$ . Then, by imposing environment constraints through masking distribution, the RL agent selects the next action $a_{t}$ based on maximum masked evidential Q-value $\\widetilde{\\mathbf{q}_{d,t}^{e}}$ . Finally, the RL agent moves to next step\u2019s patch $p_{i^{*},t+1}^{l^{*}}$ , calculates reward $r_{t}$ , and collects training tuples $(s_{t},a_{t},r_{t},s_{t+1})$ along this process. ", "page_idx": 18}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/86b02c1b7cbb9993d3194e028570b3a474bc4ae61d59152e7f0194a35a11e013.jpg", "img_caption": ["Figure 4: RL-augmented detection process "], "img_footnote": [], "page_idx": 19}, {"type": "text", "text": "It keeps searching in a given image until the upward movement action is selected in the highest $L$ layer or maximum time step $T$ is reached. After every $K$ such iterations, AIRS samples one batch of training tuples from the replay buffer $\\mathcal{D}$ and conducts off-policy Q-learning to train all network parameters $\\Theta$ . The overall training process is shown in Algorithm 1, where we use $\\boldsymbol{\\Theta}=\\{\\pmb{\\theta}_{e},\\pmb{\\theta}_{f},\\pmb{\\bar{\\theta}}_{r}\\}$ to denote all network parameters. In test phase, as shown in Fig. 4, those aforementioned binary RL masks will be used to mask out unnecessary patches across different levels in the FPN structure so that those low-value false positive anchors (candidate regions) will be filtered out and never passed to the head blocks for the bounding box prediction. ", "page_idx": 19}, {"type": "text", "text": "Algorithm 1 AIRS Training ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Require: Hyperparameters: $N_{e p o c h},T,K,\\eta,\\gamma,\\lambda,l r$   \n1: Initialize network parameters $\\left(\\Theta\\right)$ , epoch $n_{e p o c h}=0$ , stack $S=[]$ , current selected patch $p_{i,t}^{l}=$   \n$p_{*,t}^{L}$ , action $\\mathbf{a}_{t}=\\mathbf{0}$ , count of training tuple $k=0$   \n2: repeat   \n3: repeat   \n4: time step $t=0$ ,   \n5: repeat   \n6: Generate embedding $\\mathbf{e}_{t}\\leftarrow\\mathbf{f}(p_{i,t}^{l};\\pmb{\\theta}_{f})$   \n7: Compute state $\\mathbf{s}_{t}$ per ${\\bf s}_{t}=\\mathrm{RNN}({\\bf e}_{t},{\\bf s}_{t-1};\\pmb{\\theta}_{r})$   \n8: Compute evidential Q-value estimate $\\mathbf{q}_{d,t}^{e}$ per Eq. (4)   \n9: Compute masked evidential $\\mathrm{^Q}$ -value per Eq. (5)   \n10: Update action ${\\mathbf a}_{t}$ per Eq. (6)   \n11: Select next patch $p_{i^{*},t+1}^{l^{*}}$ from RL environment given current patch and new action   \n${\\bf a}_{t}$   \n12: Add last patch $p_{i,t}^{l}$ to the stack $S$ recording visited patches   \n13: Compute RL reward $r_{t}$ based on Eq. (8)   \n14: Collect the training tuple $s_{t},a_{t},r_{t},s_{t+1}$ into replay buffer $\\mathcal{D}$   \n15: $t=t+1,k=k+1$   \n16: until $t>T$ or $(p_{i,t}^{l}==p_{*,t}^{L}$ and $a_{D-1,t}=1\\,\\!$ )   \n17: if $k\\%K=0$ then   \n18: Compute total loss $\\scriptstyle{\\mathcal{L}}_{\\Theta}$ using Eq. (7)   \n19: Update $\\begin{array}{r}{\\Theta\\leftarrow\\Theta-l r\\times\\frac{\\delta\\mathcal{L}_{\\Theta}}{\\delta\\Theta}}\\end{array}$   \n20: end if   \n21: until One Epoch Ended   \n22: $n_{e p o c h}=n_{e p o c h}+1$   \n23: until $n_{e p o c h}>N_{e p o c h}$ ", "page_idx": 19}, {"type": "text", "text": "C.3 Action Interaction Details ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Given the current selected patch $p_{i,t}^{l}$ and an action space with size $D$ , the first $D-1$ actions $a_{d,t},d\\in$ $[0,\\cdot\\cdot\\cdot\\,,D-2]$ denote the downward movements directing into one of the sub-patches $p_{d,t+1}^{l-1}$ when $a_{d,t}~=~1$ ; the last action ${a_{D-1,t}}$ denotes an upward movement into the mother patch from the immediate upper layer. An upward movement in the initial patch $p_{*,t}^{L}$ of highest level $L$ indicates the termination of RL searching for one image input. The Action Interaction module determines the constraint mask by considering the constraints from RL environment, i.e., we mask the evidential Q-value of any downward movement, which directs to an already visited sub-patch or void space (e.g., downward movements on bottom layer 0) to zero. Specifically, we generate a mask ${\\bf m}_{l,t}$ of length $D$ , where $\\mathbf{m}_{l,t}^{d}$ is the individual unit contained in the mask. For downward movements $\\mathbf{m}_{0,t}^{i},i\\in[0,1,2,3]$ on the bottom layer or directing to visited patches before, we set the mask value tgoi vzeenr ob yt op aevrfooird msiuncgh  eillleemgealn ta-cwtiiosen s mpuelrt iaplbiocvatei ionns tbreutcwtieoenns $\\mathbf{q}_{d,t}^{e}$ eann, dt $\\mathbf{m}_{l,t}^{d}$ .asked evidential $\\mathrm{^Q}$ -value is ", "page_idx": 19}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/6adcd4f4a42512e77fc54c68627b549d19b78c67e1e062d3b1516b0a9eae6d20.jpg", "img_caption": ["Figure 5: Detailed Workflow of AIRS "], "img_footnote": [], "page_idx": 20}, {"type": "text", "text": "", "page_idx": 20}, {"type": "text", "text": "Examples Demonstrating Action Interaction Process: We follow a depth-first-search (DFS) rule to conduct the hierarchical search in the FPN tree-structure and further include several case studies as examples to illustrate the interaction protocol under different selected actions. Let $(x_{i,t}^{l},y_{i,t}^{l})$ be the center (also an alias) of the $i^{t h}$ region in the $l^{t h}$ layer at time step $t$ . In the beginning (i.e., step $t=0$ ), we pass all the regions present in the $L$ -layer to obtain the masked evidential Q-value $\\widetilde{\\mathbf{q}_{d,t}^{e}}$ for each action $a_{d,t}$ using Eq. (5) and then select the next action corresponding to the maximum masked evidential Q-value estimation. Depending on the action selected, we define the -following three cases that describe the corresponding behavior of the agent to form the interaction protocol. ", "page_idx": 20}, {"type": "text", "text": "Case 1: Downward movement. It happens when dD=\u221202 $\\begin{array}{r}{\\sum_{d=0}^{D-2}a_{d,t}=1}\\end{array}$ . The RL agent will go down to one of the lower-level regions from the current region. For example, in time step $t=0$ , assuming the uppermost virtual layer as the current region (i.e., root of the hierarchy), the above condition directs the agent to go into one of the sub-patches from the P5 layer. Out of $D-1$ regions, which $\\mathbf{a}_{t=0}=(1,0,0,0,0)^{\\top}$ ,c  hEw qem upeaataisnoss nt  thh6e. en  aeFgwoelrny t e sxwealielmlc tpmeledo  vriene g ttiioo mnt hea ess  ttaoenpp - $t\\,=\\,0$ itoohfne $(\\bar{x_{0,t=1}^{L-1}},y_{0,t=1}^{L-1})$ a viinne $t=1$   \n$(x_{1,t=2}^{L-2},y_{1,t=2}^{L-2})$ n i nv aPlu4 e $\\mathbf{a}_{t=1}=(\\bar{0},1,0,0,0)^{\\top}$ ,l tehf o nR $(x_{0,t=1}^{L-1},y_{0,t=1}^{L-1})$ ift rtohme  tPo5p.- riWgeh tt hcehnil dp arsesg itohne top-right region from P4 as an input in time step $t=2$ . This process continues until the agent needs to move upwards or stop the search. ", "page_idx": 20}, {"type": "text", "text": "Case 2: Upward movement. It happens when $a_{D-1,t}=1$ . The RL agent will stop going further down in the hierarchy as the evidential Q-value indicates that no valuable information is available in the finer level of granularity to cover the searching cost. Thus, the agent will go back to the parent region which allows the agent to search other sibling patches. For example, in time step $t=2$ of Figure 6, we have $\\mathbf{a}_{t=2}\\,\\doteq\\,(0,0,0,0,1)^{\\top}$ and the agent goes back to the parent region, which is top-left region in P5. It should be noted that we have used the mask generator to avoid the action choices directing to already visited and out-of-boundary regions. Next in time step $t=3$ , the topright region in P4 is already visited and therefore, masked evidential Q-value estimate $\\widetilde{\\mathbf{q}}_{d=1,t=3}^{e}$ is made zero. As shown in time step $t\\,=\\,3$ of Figure 7, while this region has the highest evidential Q-value among P4 patches, we select the second best region, which is the top-left one from P4. In time step $t=4$ of Figure 7, the input region becomes the top-left region from P4 associated with the top-left region from P5 and the search process continues. ", "page_idx": 20}, {"type": "text", "text": "", "page_idx": 21}, {"type": "text", "text": "Case 3: Search termination. It happens when upward movement $a_{D-1,t}\\,=\\,1$ happens in the uppermost virtual layer which is the root node of the FPN tree-structure or when maximum time step $T\\,=\\,60$ has been reached. In such cases, the RL agent is given the stop signal to terminate the entire search process, which implies that a sufficient number of high quality regions have been detected. ", "page_idx": 21}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/75325c324e1851b810ea48e10b751e62472044a622639b86032491f1dfbecbc2.jpg", "img_caption": ["Figure 6: Action interaction process: time steps $t=0,1,2$ "], "img_footnote": [], "page_idx": 21}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/5b7c858e2cd3a439592dd86faa7826547571185d1adff4f4a3188fc2552d48e4.jpg", "img_caption": ["Figure 7: Action interaction process: time steps $t=3,4$ "], "img_footnote": [], "page_idx": 21}, {"type": "text", "text": "C.4 Clarification on RL masks. ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Clarification on use of masks to generate final bounding boxes. We run the trained RL agent on the test image\u2019s FPN to generate RL masks. Based on the masked evidential Q-value estimate, the agent selects the next action, which would be either a downward or upward movement. Then, the agent moves to the next patch and continues the process until receiving an upward movement in layer $L$ or reaches the maximum time step i.e. $T$ . After the hierarchical searching process, we can have a binary RL mask by recording which patches are visited by RL agent through it actions (denoted as 1 in RL mask), and which are not visited by the RL agent (denoted as 0 in RL mask). Given the RL mask, which is a three-level binary mask covering the feature pyramid network (FPN), each pixel in the FPN will be assigned a confidence score in the quality evaluation branch to decide if it is a positive anchor or not by (comparing with a threshold). Those pixels covered by the zero RL masks will have their confidence score reset to 0, and other pixels will maintain the same confidence score. In that way, RL masks serve as an additional filter to further eliminate the \u201cfalse positive\" bounding boxes. ", "page_idx": 21}, {"type": "text", "text": "", "page_idx": 22}, {"type": "text", "text": "How the binary RL mask helps reduce unnecessary bounding boxes in inference step. We are handling two different types of false positive bounding boxes. The first category involves bounding boxes that capture only background with no targeted object. To remove those patches, our novel exploration-exploitation strategy plays a major role. Specifically, during the adaptive hierarchical search in the top-down fashion, exploration of the higher layer quickly discovers that there is no object in the lower-level granularity. Specifically, both Q-value as well as epistemic uncertainty (see Eq. 4) remains low, leading to removing bounding boxes on backgrounds. The second category involves bounding boxes that cover only a part of a given object and are embedded in the larger bounding box that covers the whole object. As our approach works in the top-down fashion, once the RL agent explores the bigger bounding box covering the full object, the model assigns a very low epistemic uncertainty for partially covering bounding boxes. As such, the model avoids going downward in a lower level granularity in the action space resulting in removing unnecessary partially covered bounding boxes. ", "page_idx": 22}, {"type": "text", "text": "D Additional Experiments ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "In this section, we first present the additional comparison results with YOLO series. After that, we show additional ablation study results that investigate the impact of the underlying base detectors and balancing hyper-parameters. We also test the transferred performance of the RL masks trained from the proposed AIRS and apply them to other base detectors. Finally, we show some additional quantitative and qualitative results on the challenging datasets (aerial park lot [16]) or subsets chosen from all three data sets, containing difficult images with a large amount of small objects. ", "page_idx": 22}, {"type": "text", "text": "D.1 Comparison with the Latest YOLO Series ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "In this set of experiments, we include the latest YOLO series for comparison. We run the experiments for three times with different random seeds to verify the performance and provide the strongest YOLO-V7 comparison results with statistical significance in Table 7. Note that we use the same hyper-parameters reported in the original paper, including the image augmentation, learning rate, momentum decay, etc. For a fair comparison, we train all the baselines until convergence and test the models on the same test splits from different datasets, and we align all the weight initialization to be Xavier initialization. As can be seen, comparing to these SOTA models, for the overall AP, AIRS is better than any YOLO series below medium parameter size scale and only slightly lower than yolo V6-L, yolo V7 on MS COCO (but significantly better than them on Open Image V4). It shows a clear advantage in images with small objects and with difficult dense scenarios, which is achieved by a good balance of recall and precision thanks to the FPN with RL selected mask augmentation. The good AP performance from yolo V6, V7 on MS COCO is likely due to the special architectural design optimization targeting this dataset, where medium and large objects form the majority of image labels. These include extended efficient layer aggregation networks, model scaling for concatenation-based models, and a bunch of trainable bag-of-freebies designs highly optimized for the MS COCO dataset. We also provide the comparison results on Open Image V4 to show that yolo V6-L, V7 cannot beat our model in a more complex dataset which contains more dense scenario images with small objects and difficult background. ", "page_idx": 22}, {"type": "text", "text": "D.2 Balancing Hyper-parameter Search ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "$\\lambda$ is changed dynamically. In the early stage, it is set to be high ( $\\lambda=1$ ) so the focus is on exploring the unknown patches. As training progresses, it decreases as $\\begin{array}{r}{\\lambda\\:=\\:\\left(1-\\frac{N_{c}}{N_{e p o c h}}\\right)}\\end{array}$ , where $N_{c}$ is the current epoch. Exact exploration-exploitation balancing also depends on complexity of dataset. ", "page_idx": 22}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/e9a200e4564794b67221deea37430de150fdc416959173d869b9736fd6fcd8f5.jpg", "table_caption": ["Table 7: SOTA YOLO baseline comparison on MS COCO test-dev and Open Image V4 test set "], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "For instance, for easy dataset, the model may quickly focus on the exploitation part as epistemic uncertainty may reduce quickly whereas for difficult dataset, the model may stay longer to explore the patches. We also conduct an additional experiment to test sensitivity of $\\lambda$ . As shown in the Table 8, the performance is relatively robust for different $\\lambda$ values. However, the adaptive $\\lambda$ achieves a better performance. ", "page_idx": 23}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/97aa9b5e8a855d0e7fc1fb1b60ec756a32378e5452bf35fcb0046d5c28d1d5ac.jpg", "table_caption": ["Table 8: Impact of hyper-parameter $\\lambda$ "], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "D.3 Datasets with a Large Amount of Small Objects ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "We clarify that COCO, Pascal VOC, and Open Images V4 are commonly used benchmark datasets to evaluate dense object detection models such as GFocal, DINO, FCOS etc. Therefore, we choose same set of datasets in our evaluation. To explicitly show the effectiveness of our technique, we further create a challenging subset, where large, medium and small objects are mixed and embedded with each other. This mixing strategy makes the detection highly challenging because such scenarios require a good balance of exploitation and exploration in RL training to achieve high precision and recall for all large, medium and small objects. Second, following the reviewer\u2019s suggestion for using datasets with more smaller objects, we redefine our criteria to select subsets that contain those images where the ratio of large and medium objects (area $\\geq322$ ) to small objects (area $<322\\rangle$ ) $\\leq1/2$ . We additionally conduct experiments on an aerial park lot dataset with a large amount of small objects in each image [16]. The quantitative results on the new challenging subset and an aerial dataset are summarized in Table 9. We also provide detection visualization of these two new challenge data sets in Figure 8. ", "page_idx": 23}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/5104a2cb44aee1fb65c6b332418e10f261e6558582d296ce208bb424ece9e873.jpg", "table_caption": ["Table 9: AP performance of AIRS on the aerial parking lot dataset [16] and newly created MSCOCO challenging subset, both containing a large number of cluttered small objects in one image, besides few medium or large objects. "], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "D.4 RL Agent Training Configurations ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "As compared with existing Q-learning models, our model is less computationally expensive to train due to two reasons: 1) The maximum time step $T$ is around 60 and in most cases the reward is positive (between 0 and 1), so it does not suffer from reward vanishing. 2) Training samples in our datasets are sufficient to train the RL agent. Given such potential advantages for RL training brought by AIRS, a Double-DQN target network is sufficient to stabilize the training. To further guarantee the training success and avoid early termination, we don\u2019t allow model to move upwards in Layer $L,L-1$ in the first 40 time steps of each RL training episode. Figures 9a, 9b, and 9c show the Q-learning loss with respect to training epochs, where the loss gradually decreases towards convergence. Furthermore, Figures 9d, 9e, and 9f show the average cumulative rewards, which exhibit a non-decreasing trend over all three datasets. This justifies that our approach achieves stable model training and the minimization in the loss which is also reflected by the cumulative reward. ", "page_idx": 23}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/55d9a2c2b98ae6a9db5b6a2bad6ed251bda41897fcf6c9cecd4a30ab195f02bf.jpg", "img_caption": ["Figure 8: Results w/ and w/o AIRS generated masks on an aerial dataset [16] and a new challenging MSCOCO subset, both of which contain many small objects: (a) and (c) are the GFocal detection results while (b) and (d) are the results from AIRS after applying the RL masks. As can be seen, those grey boxes are the false positive bounding boxes, most of which possess irrelevant backgrounds or partial objects, masked out by the RL agent (i.e., 0 masks), while the red boxes are the remaining true positive boxes, which are kept the by the RL agent (i.e., 1 masks). "], "img_footnote": [], "page_idx": 24}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/ad15a765750d06d5e126092735927fc0352898b3ab497ec42e72a3a598098c49.jpg", "table_caption": ["Table 10: Ablation on RL masks trained on Different Detector Backbones "], "table_footnote": [], "page_idx": 24}, {"type": "text", "text": "D.5 Ablation Study on Base Detectors ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "To study the impact of base detectors, we select a set of representative one-stage detectors, including RetinaNet, FCOS and ATSS. For a fair comparison, we use ResNet-50 as the common backbone for all the methods. We first train our RL agent on the FPN of these pre-trained one-stage detectors. After training, we run the RL agent of each base detector and predict the binary masks for every test image. Finally, the RL masks are used to obtain the RL-augmented prediction results by training the underlying base detector again on the precise RL designated anchors. We apply the \u2018RL\u2019 suffix to these results. Meanwhile, we directly apply the RL masks generated from AIRS to the other detectors training phase and apply the \u2018Trans\u2019 suffix to these results. As Figure 10 shows, the RL masks independently trained on each base detector further improve the $\\check{A}P,A P^{S},A P^{C H}$ performance comparing to original baseline without any RL augmentations. Furthermore, we observe that the transferred RL masks trained from AIRS could also achieve performance improvement. We attribute such good transfer performance to the similar feature maps in the pre-train FPNs across different one-stage detectors. ", "page_idx": 24}, {"type": "text", "text": "D.6 Train efficiency ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "The training time of AIRS is around 12 hours, which is far less than those one-stage detector\u2019s training time: 23h (RetinaNet), 24h (FCOS), 27h (ATSS), 27h (GFocal) with one A100 GPU of memory 40G. It is worth to note that we move the RL training to the pre-computing phase and apply RL learned masks onto the pre-trained FPN of GFocal to get the inference detection results. The comparison of AIRS training cost with other RL baselines is provided in Table 11. ", "page_idx": 24}, {"type": "table", "img_path": "f8MrWxlnRz/tmp/eba0cbefb81bd42abe2eecb99084474d24fdfc39a2f216e4823d77d7f345ad04.jpg", "table_caption": ["Table 11: RL baseline training efficiency comparison "], "table_footnote": [], "page_idx": 24}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/0f843d9329f64dc6282766913dce9b5a6f1d1f15fa8269b62f2d84db0b696f59.jpg", "img_caption": ["Figure 9: Q-learning loss (top row) and cumulative reward (bottom row) of the RL agent "], "img_footnote": [], "page_idx": 25}, {"type": "text", "text": "D.7 Subset Generation Illustration ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Figure 10 provides additional examples to compare the detection results from GFocal v.s. AIRS on the subsets of three public datasets, respectively. As can be seen, AIRS is highly effective in reducing false positive detections as compared to one of the most competitive baselines, GFocal. A close look at the example images reveals that most false positive detections come from small duplicate bounding boxes that focus on local texture, which is usually unnecessary. ", "page_idx": 25}, {"type": "text", "text": "E Limitation and Broader Impact ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "We identify two additional limitations of the proposed AIRS model. First, the evidential Q-value integrates the epistemic uncertainty predicted by the model. If the model is poorly calibrated, its uncertainty quantification becomes less trustworthy that can negatively impacts the exploration effectiveness of the RL agent. We plan to investigate effective network calibration methods and integrate them into the proposed model. The second limitation is that AIRS relies on the feature pyramid network (FPN), which leverages ResNet as its backbones. A systematic extension to the transformer based backbone may have the potential to further improve the detection performance. ", "page_idx": 25}, {"type": "text", "text": "AIRS is designed to be integrated and applied on top of one-stage detector\u2019s FPNs for object detection. For other domains, we believe there is potential for similar technique to be applied on them as well. For example, video tracking requires accurate object localization, which could be achieved by defining large-medium-small image patch hierarchy and conducting object detection on each patch to collect reward. Note that it is different from ours because we conduct a hierarchical patch search on pre-trained FPN, and then regress bounding boxes for every positive anchor on top of the selected patches. Leveraging FPN guarantees a high recall, which helps in dense scenarios while not in (single) accurate object detection. As for segmentation, it is a pixel-level classification, how to select foreground pixels (positive anchors) residing in interested object area (patches) could be achieved by one-stage detector\u2019s FPN with AIRS augmentation. ", "page_idx": 25}, {"type": "text", "text": "F Link to Source Code ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "For the source code, please check https://github.com/ritmininglab/AIRS. ", "page_idx": 25}, {"type": "image", "img_path": "f8MrWxlnRz/tmp/54249d8eee370184241cf5f64d35b8592d1cb4a9cdb6b001953f293b768f2199.jpg", "img_caption": ["Figure 10: Qualitative comparisons between GFocal (Left) and AIRS (Right) detection results on three datasets: COCO 10a-10d, PASCAL VOC 2012 10e-10h and OpenImages V4 10i-10l "], "img_footnote": [], "page_idx": 26}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: Please check Introduction Section 1 in the main paper for scope and contribution of our work. ", "page_idx": 27}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We provide the limitation discussion in Appendix E. ", "page_idx": 27}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We provide the complete proof with a full set of definition and assumption in Appendix B. ", "page_idx": 27}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We fully disclose the dataset, metrics, and experiment settings in Section 4 of main paper. ", "page_idx": 27}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We provide data open access with source code anonymous link in Appendix F. ", "page_idx": 27}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We fully disclose the hyper-parameter settings in Section 4.2 of main paper and detailed RL training configurations in Appendix D.4 of Appendix. ", "page_idx": 27}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: We include the statistical errors in the latest YOLO series baseline comparison in Appendix D.1. For other baselines comparison, we ignore the statistical errors given the evident performance advantage achieved by our model. ", "page_idx": 27}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: We provide the computation resource, memory and training efficiency in Appendix D.6. ", "page_idx": 28}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: We confirm that we follow the NeurIPS Code of Ethics in the whole paper range. ", "page_idx": 28}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: We discuss our broader societal impacts in Appendix E. ", "page_idx": 28}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 28}, {"type": "text", "text": "Justification: Justification: We only use public data and release our models for advancing the research in dense object detection. ", "page_idx": 28}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: We cite all the used open-source baselines and public data sets as references for acknowledgement of these asset works. ", "page_idx": 28}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 28}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 28}, {"type": "text", "text": "Justification: We provide a well documented code asset via an anonymized URL in Appendix F. ", "page_idx": 28}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 28}, {"type": "text", "text": "Justification: In our experiments, we don\u2019t interact with human subjects and use public data sets with open access. ", "page_idx": 28}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 28}, {"type": "text", "text": "Justification: In our experiments, we don\u2019t interact with human subjects and use public data sets with open access. ", "page_idx": 29}]