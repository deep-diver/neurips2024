[{"figure_path": "8ZLL6mu2qC/figures/figures_2_1.jpg", "caption": "Figure 1: An experiment with dimension d = 10M and s = 10 quantization values. Figure 1(a) shows the empirical MSE of quantizing a single vector with i.i.d. LogNormal(0, \u03c32) entries. It shows that adaptive methods are more accurate than non-adaptive and that the optimal biased method is more accurate than the optimal unbiased one. However, as shown in Figure 1(b), for distributed mean estimation, the bias may not cancel out when averaging quantized inputs (here, we used a standard setup where all vectors are identical, e.g., see [17], with i.i.d. LogNormal(0, 1/2) distributed entries) and the advantage of unbiased methods accordingly increases with the number of inputs. Each data point is averaged over ten runs with the standard deviation reported.", "description": "This figure compares the performance of adaptive and non-adaptive quantization methods for both single vector and distributed mean estimation tasks. It demonstrates that adaptive methods achieve lower mean squared error (MSE) than non-adaptive ones, and that the benefits of unbiased quantization are amplified in distributed settings.", "section": "2 Background"}, {"figure_path": "8ZLL6mu2qC/figures/figures_8_1.jpg", "caption": "Figure 2: Comparing exact solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of ZipML and Accelerated QUIVER in terms of both runtime and normalized mean squared error (vNMSE) for different dimensions (d) and numbers of quantization values (s).  The plots show that Accelerated QUIVER significantly outperforms ZipML in terms of speed, especially as the dimension and the number of quantization values increase.  The vNMSE values show that both algorithms achieve similar accuracy, indicating that the speedup of Accelerated QUIVER comes without significant loss in quantization quality.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_8_2.jpg", "caption": "Figure 3: Comparing approximate solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of several approximate adaptive stochastic quantization methods against the optimal solution for a LogNormal(0,1) distributed input. It shows the vNMSE (vertical normalized mean squared error) and runtime for different dimensions (d), numbers of quantization values (s), and discretization levels (m).  The figure highlights the tradeoff between accuracy and speed for different approximate methods, and shows that Apx. QUIVER provides a good balance.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_16_1.jpg", "caption": "Figure 4: Comparing exact solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of QUIVER and Accelerated QUIVER against ZipML for exact adaptive stochastic quantization.  The plots show the runtime (in milliseconds) and vNMSE (vertical normalized mean squared error) for various input vector dimensions (d) and numbers of quantization values (s).  It demonstrates the superior speed of QUIVER and Accelerated QUIVER compared to ZipML, especially as the problem size increases.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_17_1.jpg", "caption": "Figure 2: Comparing exact solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of ZipML and QUIVER algorithms in terms of both vNMSE (vector normalized mean squared error) and runtime.  Subfigures (a), (b), and (c) show results varying dimension (d), the number of quantization values (s), and the dimension (d), respectively. The results demonstrate that QUIVER is significantly faster than ZipML while achieving comparable accuracy.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_17_2.jpg", "caption": "Figure 2: Comparing exact solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of ZipML and Accelerated QUIVER in terms of both runtime (in milliseconds) and vNMSE (vector-normalized mean squared error) across different dimensions (d) and numbers of quantization values (s).  Subplots (a), (b), and (c) show the results when varying one parameter while holding others constant, providing a detailed analysis of the algorithms' scaling behavior in different settings.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_17_3.jpg", "caption": "Figure 2: Comparing exact solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of ZipML and Accelerated QUIVER in terms of both vNMSE (vertical normalized mean squared error) and runtime.  Subfigure (a) shows the results for different dimensions (d) and a fixed number of quantization values (s). Subfigures (b) and (c) show the results for a fixed dimension and varying numbers of quantization values.  The results demonstrate that Accelerated QUIVER is significantly faster than ZipML while achieving comparable accuracy.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_18_1.jpg", "caption": "Figure 2: Comparing exact solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of ZipML and Accelerated QUIVER algorithms for exact adaptive stochastic quantization.  Panel (a) shows the vNMSE and runtime for different dimensions (d) and a fixed number of quantization values (s). Panel (b) presents the vNMSE and runtime for varying 's' with a fixed 'd' = 2<sup>12</sup>. Panel (c) displays the vNMSE and runtime for varying 's' with a fixed 'd' = 2<sup>16</sup>. The results demonstrate that Accelerated QUIVER is significantly faster than ZipML while achieving comparable accuracy, especially as the dimension and number of quantization values increase.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_18_2.jpg", "caption": "Figure 3: Comparing approximate solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of several approximate adaptive stochastic quantization algorithms against the optimal solution for a LogNormal(0,1) distributed input.  It shows vNMSE (vertical normalized mean squared error) and runtime (in milliseconds) across different dimensions (d), numbers of quantization values (s), and discretization levels (m) for Apx. QUIVER and several baselines (ZipML-CP Unif, ZipML-CP Quant, ZipML 2-Apx, ALQ).  The results demonstrate Apx. QUIVER's speed and accuracy advantages, especially as the problem size increases.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_19_1.jpg", "caption": "Figure 3: Comparing approximate solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of various approximate adaptive stochastic quantization methods against the optimal solution for LogNormal(0,1) distributed input.  It demonstrates the runtime and vNMSE (vector normalized mean squared error) for different dimensions (d), numbers of quantization values (s), and discretization levels (m).  The results showcase the tradeoff between speed and accuracy of approximate methods, highlighting the efficiency of Apx. QUIVER (Approximate QUIVER) in achieving near-optimal results with significantly faster computation.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_19_2.jpg", "caption": "Figure 3: Comparing approximate solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of several approximate adaptive stochastic quantization algorithms against the optimal solution for a LogNormal(0, 1) distributed input.  It shows the vNMSE (vertical normalized mean squared error) and runtime (in milliseconds) for different dimensions (d), numbers of quantization values (s), and discretization levels (m). The algorithms compared are ZipML-CP Unif., ZipML-CP Quant., ZipML 2-Apx, ALQ, and Apx. QUIVER. The figure helps to illustrate the trade-offs between accuracy and speed for different approximate methods and the effectiveness of the proposed Apx. QUIVER algorithm.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_20_1.jpg", "caption": "Figure 3: Comparing approximate solutions with LogNormal(0, 1) distributed input.", "description": "This figure compares the performance of various approximate adaptive stochastic quantization algorithms against the optimal solution.  Subfigures (a), (b), and (c) show the results with respect to varying dimensions of the input vector, number of quantization values, and the discretization level (number of bins) of the search space, respectively.  The algorithms being compared include ZipML-CP Quantiles, ZipML-CP Uniform, ZipML 2-Approximation, ALQ, and the proposed Approximate QUIVER algorithm.  It demonstrates the tradeoffs between accuracy and speed and shows that Approximate QUIVER provides a good balance by offering near-optimal accuracy and the fastest runtime.", "section": "7 Evaluation"}, {"figure_path": "8ZLL6mu2qC/figures/figures_20_2.jpg", "caption": "Figure 13: Sort and quantization times (s = 16) vs. d on a T4 GPU.", "description": "The figure shows the time taken for sorting and quantization operations using a T4 GPU, with the number of quantization values fixed at 16. The x-axis represents the dimension (d) of the input vector, and the y-axis represents the time in milliseconds.  The plot shows that the time for both operations increases with the dimension of the input vector, with quantization taking significantly longer than sorting, especially for larger dimensions. Error bars show standard deviation across multiple runs.", "section": "7 Evaluation"}]