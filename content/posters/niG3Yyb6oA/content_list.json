[{"type": "text", "text": "A Layer-Wise Natural Gradient Optimizer for Training Deep Neural Networks ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Xiaolei Liu\u2217 Ant Group Hangzhou, China liuxiaolei.lxl@mybank.cn ", "page_idx": 0}, {"type": "text", "text": "Shaoshuai Li\u2217 Ant Group Hangzhou, China lishaoshuai.lss@mybank.cn ", "page_idx": 0}, {"type": "text", "text": "Kaixin Gao\u2020   \nOcean University of China   \nQingdao, China   \ngaokaixin06@163.com ", "page_idx": 0}, {"type": "text", "text": "Binfeng Wang Ant Group Hangzhou, China wangbinfeng.wbf@mybank.cn ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Second-order optimization algorithms, such as the Newton method and the natural gradient descent (NGD) method exhibit excellent convergence properties for training deep neural networks, but the high computational cost limits its practical application. In this paper, we focus on the NGD method and propose a novel layerwise natural gradient descent (LNGD) method to further reduce computational costs and accelerate the training process. Specifically, based on the block diagonal approximation of the Fisher information matrix, we first propose the layer-wise sample method to compute each block matrix without performing a complete backpropagation. Then, each block matrix is approximated as a Kronecker product of two smaller matrices, one of which is a diagonal matrix, while keeping the traces equal before and after approximation. By these two steps, we provide a new approximation for the Fisher information matrix, which can effectively reduce the computational cost while preserving the main information of each block matrix. Moreover, we propose a new adaptive layer-wise learning rate to further accelerate training. Based on these new approaches, we propose the LNGD optimizer. The global convergence analysis of LNGD is established under some assumptions. Experiments on image classification and machine translation tasks show that our method is quite competitive compared to the state-of-the-art methods. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "With the rapid increase in the size of deep neural networks (DNNs) models in both areas of computer vision (CV) and natural language processing (NLP), there have been remarkable attentions given to optimizing algorithms. An effective optimizer can significantly improve the training speed of models while ensuring high prediction performance. First-order gradient descent methods are workhorses of training DNNs, which can be broadly divided into two categories: methods use a same learning rate, such as stochastic gradient descent (SGD) [1] and its accelerations [2, 3], and methods use adaptive learning rate, such as AdaDelta [4], RMSProp [5], ADAM [6] and Adabelief [7]. Although first-order gradient descent methods enjoy low computational cost and ease of implementation, they might suffer from sensitivity to hyperparameters and slow convergence. It is challenging to reduce the number of iterations and computational time of these methods. ", "page_idx": 0}, {"type": "text", "text": "Some work has considered introducing curvature information when updating parameters of DNNs to improve the convergence speed and overcome the above shortcomings of the first-order methods. However, second-order optimization methods need to store and compute the inverse of curvature matrix, which brings expensive storage and computation costs and limits the application of secondorder methods in training large-scale DNNs. Therefore, many approximate second-order methods have been proposed for training large-scale models. For example, Keskar and Berahas [8] proposed a stochastic quasi-Newton algorithm for training recurrent neural networks. Yao et al. [9] approximated the Hessian matrix as a diagonal operator, which is achieved by applying Hutchinson\u2019s method, and proposed the AdaHessian method. Goldfarb, Ren and Bahamou [10] developed Kroneckerfactored block-diagonal BFGS and its limited-memory variants L-BFGS methods for training DNNs. Generalized Gauss-Newton methods, such as the Hessian-free method [11] and the Krylov subspace method [12], also have been proposed to approximate the Hessian matrix. ", "page_idx": 1}, {"type": "text", "text": "The natural gradient descent (NGD) method [13], which preconditions the gradient by the Fisher information matrix instead of the Hessian matrix, also has shown effectiveness in training DNNs [14, 15, 16, 17]. NGD explores the steepest direction of the objective function when the parameter space has a Riemannian metric structure and has a faster convergence speed. In particular, NGD can also be seen as an approximation of the Netwon method when the objective function and the manifold metric are compatible [18]. However, it is still impossible to directly compute the inverse of the Fisher information matrix for DNNs with millions or even billions parameters. Quite a few approximate approaches have been proposed. Under some independency assumptions, Martens and Grosse [14] proposed the Kronecker-factored approximate curvature (KFAC) method, in which the Fisher information matrix is approximated as a block diagonal matrix and each block matrix is further approximated as the Kronecker product of two smaller matrices. Then, KFAC was extended to convolutional neural networks [19], recurrent neural networks [20] and variational Bayesian neural networks [21] and showed significant speedup during training. In addition, George et al. [22] proposed the eigenvalue-corrected Kronecker factorization (EKFAC) method. Gao et al. [15, 23] proposed the trace-restricted Kronecker-factored approximate (TKFAC) method. These approaches all focus on the Kronecker-factored approximations of the Fisher information matrix. What\u2019s more, some works have also considered large-scale distributed computing using NGD for training DNNs and shows excellent experimental performance [16, 24, 25]. ", "page_idx": 1}, {"type": "text", "text": "In this paper, our main focus is on the NGD method. Motivated by the effectiveness of diagonal approximations and the significance of diagonal elements in the curvature matrix, we prioritize the diagonal information and integrate it into our approximation and introduce a novel method, namely Layer-wise Natural Gradient Descent (LNGD). Our contributions can be given as follows: ", "page_idx": 1}, {"type": "text", "text": "\u2022 Based on the block diagonal approximation of the Fisher information matrix, we propose a layer-wise sample method to more efficiently compute each block matrix corresponding to each layer. By assuming that the predictive distribution of the output after the activation function for each layer follows a Gaussian distribution, each block matrix can be directly computed using the inputs and the outputs separately, without having to perform a complete back-propagation. \u2022 For each block matrix corresponding to each layer, we further approximate it as a Kronecker product of two smaller matrices, one of which is a diagonal matrix, while keeping the traces equal before and after approximation. With this operation, we further reduce the cost of computing inverse matrices while still preserving the main information of each block matrix. \u2022 In order to further accelerate the training, we propose an adaptive layer-wise learning rate by optimizing a quadratic model, in which parameters in the same layer share the same adaptive learning rate. Moreover, a faster approach of computing the adaptive layer-wise learning rate is also provided, making it speed up training while maintaining computationally efficient. \u2022 Based on the novel approximation mentioned above of the Fisher information matrix and the adaptive layer-wise learning rate, we propose the LNGD optimizer for training DNNs. The global convergence analysis are also established under some assumptions. \u2022 We perform experiments on image classification and machine translation tasks. Numerical results show that LNGD converges faster than SGD, ADAM and KFAC, and LNGD provides an significant improvement in computational time savings when achieves convergence. ", "page_idx": 1}, {"type": "text", "text": "The rest of this paper is organized as follows. Section 2 gives the notations and introduces the NGD method. In Section 3, we propose a novel approximation of the Fisher information matrix and the adaptive layer-wise learning rate. Furthermore, we give the framework of LNGD and establish the convergence analysis. Section 4 presents the results of experiments on image classification and machine translation tasks. The conclusion is drawn in Section 5. ", "page_idx": 1}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "2 Notations and Preliminaries ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this paper, for a matrix A, we use $\\mathbf{A}_{i j}$ to denote its $(i,j)$ th entry, $\\operatorname{tr}(\\mathbf{A})$ to denote its trace and $\\|\\mathbf{A}\\|_{\\mathbf{F}}$ to denote its Frobenius norm. We use $\\circ$ and $\\otimes$ to denote the Hadamard and Kronecker product of two matrices. In the following, we briefly introduce the NGD method for training DNNs. During the training process of neural networks, the purpose is to find the vector of parameters $\\pmb{\\theta}$ which minimizes the loss function $h(\\theta)$ . If the loss function $h(\\theta)$ is chosen as the the cross-entropy loss function, $h(\\pmb\\theta)$ can be given as $\\boldsymbol{h}(\\pmb\\theta)=\\mathbb{E}[-\\log p(\\mathbf{y}|\\mathbf{x},\\pmb\\theta)]$ , where $p(\\mathbf{y}|\\mathbf{x},\\pmb{\\theta})$ is the density function of a predictive distribution $P_{\\mathbf{y}\\mid\\mathbf{x}}(\\pmb{\\theta})$ , and $\\mathbf x,\\mathbf y$ are the training inputs and labels, respectively. Next, we give the definition of natural gradient, which gives the steepest direction of the objective function when the parameter space has a Riemannian metric structure. The natural gradient is defined as $\\mathbf{F}^{-1}\\nabla_{\\theta}\\mathbf{h}(\\theta)$ , where $\\mathbf{F}$ is the Fisher information matrix given by ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\mathbf{F}=\\underset{\\mathbf{x}\\sim q(\\mathbf{x}),\\mathbf{y}\\sim p(\\mathbf{y}|\\mathbf{x},\\theta)}{\\mathbb{E}}[\\nabla_{\\theta}\\log p(\\mathbf{y}|\\mathbf{x},\\theta)\\nabla_{\\theta}\\log p(\\mathbf{y}|\\mathbf{x},\\theta)^{\\top}].\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "In Eq. (1), the input $\\mathbf{x}$ is independently sampled from a distribution $Q_{\\mathbf{x}}$ with density function being $q(\\mathbf{x})$ and the label $\\mathbf{y}$ is sampled from the predictive distribution $P_{\\mathbf{y}\\mid\\mathbf{x}}(\\pmb{\\theta})$ . In the following pages, we abbreviate $\\mathbb{E}_{\\mathbf{x}\\sim q(\\mathbf{x}),\\mathbf{y}\\sim p(\\mathbf{y}|\\mathbf{x},\\pmb{\\theta})}$ as $\\mathbb{E}$ unless otherwise specified. Consider a neural network with $L$ layers, for each layer $l\\in[L]$ with $[L]=\\{1,2,\\ldots,L\\}$ , we denote ${\\bf a}_{l-1}$ and $\\mathbf{W}_{l}$ as the input (the activation from the previous layer) and the matrix of weights of this layer, respectively. What\u2019s more, $\\pmb\\theta_{l}\\;=\\;\\mathrm{vec}(\\mathbf W_{l})$ and $\\pmb{\\theta}\\,\\stackrel{,}{=}\\,(\\pmb{\\theta}_{1},\\ldots,\\pmb{\\theta}_{L})^{\\top}\\,=\\,(\\mathrm{vec}(\\breve{\\mathbf{W}}_{1})^{\\top},\\ldots,\\mathrm{vec}(\\breve{\\mathbf{W}}_{L})^{\\top})^{\\top}$ , where $\\operatorname{vec}({\\cdot})$ indicates vectorization of a matrix. For convenience, we denote the derivative of the loss function with respect to $\\pmb{\\theta}$ as $\\mathcal{D}\\pmb{\\theta}=-\\nabla_{\\pmb{\\theta}}\\log p(\\mathbf{y}|\\mathbf{x},\\pmb{\\theta})$ . Then the Fisher information matrix can be expressed as $\\mathbf{F}=\\mathbb{E}[\\mathcal{D}\\pmb{\\theta}\\mathcal{D}\\pmb{\\theta}^{\\top}]$ . ", "page_idx": 2}, {"type": "text", "text": "Due to the high computational and storage costs caused by the inverse operation of high-dimensional matrices, it is impractical to directly compute ${\\bf F}^{-1}$ in the training of DNNs. The family of Kroneckerfactored approximations provides an effective approach for computing ${\\bf F}^{-1}$ of parameters in highdimensional space, which is usually achieved by two steps. In the first step, by assuming that the parameters between different layers are independent, these methods approximate the entire Fisher information matrix as a block diagonal matrix, i.e., ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\mathbf{F}\\approx\\operatorname{diag}(\\mathbf{F}_{1},\\mathbf{F}_{2},\\ldots,\\mathbf{F}_{L}),\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $\\mathbf{F}_{l}\\,=\\,\\mathbb{E}[\\mathcal{D}\\pmb{\\theta}_{l}\\mathcal{D}\\pmb{\\theta}_{l}^{\\top}]$ for any $l~\\in~[L]$ . By this way, the Fisher information matrix can be approximated by $L$ block matrices. This step transforms the inverse of the entire Fisher information matrix into the inverse of a series of small block matrices. In the second step, these methods further approximate each block matrix as the Kronecker product of some smaller factors. This approximation can transform the inverse of each block matrix into the inverse of some smaller factors combining the properties of the Kronecker product. ", "page_idx": 2}, {"type": "text", "text": "3 LNGD: A Layer-Wise Second-Order Optimizer ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this section, we first introduce the layer-wise sample approximation strategy. Then, we present the details of adaptive layer-wise learning rate mechanism and give the specific framework of LNGD. Finally, elaborate theoretical analysis of LNGD\u2019s convergence is also provided. ", "page_idx": 2}, {"type": "text", "text": "3.1 Layer-Wise Sample Approximation ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "For NGD methods to train DNNs, the Fisher information matrix can be approximated by a block diagonal one according to different layers as given by Eq. (2), this approximation can be found in [14, 15, 19, 22] and references therein. We call such a block diagonal approximate Fisher information matrix the layer Fisher information matrix, which is computed based on a distribution $Q_{\\mathbf{x}}$ and a predictive distribution $P_{\\mathbf{y}\\mid\\mathbf{x}}(\\pmb{\\theta})$ as given in Eq. (1). To obtain the layer Fisher information matrix, we need perform a complete back-propagation to sequentially compute $\\mathbf{F}_{L},\\mathbf{F}_{L-1},\\ldots,\\mathbf{F}_{1}$ , which still consumes much computing time. ", "page_idx": 2}, {"type": "image", "img_path": "niG3Yyb6oA/tmp/8ac670e216febc13e30a60a168bac567d2d3d073313998029d79aa07b38862f2.jpg", "img_caption": ["Figure 1: Comparison of the exact Fisher information matrix $\\mathbf{F}$ and our approximation $\\mathbf{F}_{\\mathrm{LNGD}}$ . We use LNGD to train MNIST on a fully-connected neural network, whose architecture is 196-20-20-20- 20-10. We show the results of the Fisher information matrix of the first layer with 20 units in top, which is a $400\\times400$ matrix. The bottom portion displays partially enlarged parts of the top marked with red square, which is a $40\\times40$ matrix. Within both the top and bottom sections, on the left is the exact Fisher information matrix $\\mathbf{F}$ , in the middle is our approximation $\\mathbf{F}_{\\mathrm{LNGD}}$ , and on the right is the absolute error between them. The brightness levels correspond to the sizes of the absolute values. "], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "", "page_idx": 3}, {"type": "text", "text": "In this subsection, we propose a layer-wise sample approximation of the Fisher information matrix, in which each block matrix $\\mathbf{F}_{l}$ is computed based on the $l$ th layer\u2019s prediction distribution $P_{\\mathbf{a}_{l}|\\mathbf{a}_{l-1}}(\\pmb{\\theta}_{l})$ with the input $\\mathbf{a}_{l-1}\\in\\mathbb{R}^{d_{l}}$ of this layer and the input $\\mathbf{a}_{l}\\in\\mathbb{R}^{d_{l+1}}$ of the $(l+1)$ th layer instead of using the same predictive distribution $P_{\\mathbf{y}\\mid\\mathbf{x}}(\\pmb{\\theta})$ for all layers. Specifically, for $\\mathbf{a}_{l}$ , we assume that the predictive distribution $P_{\\mathbf{a}_{l}|\\mathbf{a}_{l-1}}(\\pmb{\\theta}_{l})$ follows Gaussian distribution, which is usual used as prior by variational auto-encoder [26], so $\\mathbf{F}_{l}$ can be computed by sampling from a normal distribution with expectation being ${\\bf a}_{l}$ and variance being I. Similar assumption can also be found in [27], in which the normality is also supported by a central limit theorem under the independence assumption. By this layer-wise sample approximation, we can compute the layer Fisher information matrix without having to perform a complete back-propagation and thus improve the computational efficiency. ", "page_idx": 3}, {"type": "text", "text": "Next, we can give the formula of each block $\\mathbf{F}_{l}$ in the layer Fisher information matrix as ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{F}_{l}=\\mathbb{E}[\\tilde{\\mathcal{D}}\\pmb{\\theta}_{l}\\tilde{\\mathcal{D}}\\pmb{\\theta}_{l}^{\\top}]=\\mathbb{E}[\\mathrm{vec}(\\tilde{\\mathcal{D}}\\mathbf{W}_{l})\\mathrm{vec}(\\tilde{\\mathcal{D}}\\mathbf{W}_{l})^{\\top}]=\\mathbb{E}[\\mathrm{vec}(\\mathbf{g}_{l}\\mathbf{a}_{l-1}^{\\top})\\mathrm{vec}(\\mathbf{g}_{l}\\mathbf{a}_{l-1}^{\\top})^{\\top}]}\\\\ &{\\quad=\\mathbb{E}[(\\mathbf{a}_{l-1}\\mathbf{a}_{l-1}^{\\top})\\otimes(\\mathbf{g}_{l}\\mathbf{g}_{l}^{\\top})]\\in\\mathbb{R}^{m_{l}d_{l}\\times m_{l}d_{l}},}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\tilde{\\mathcal{D}}\\pmb{\\theta}_{l}=-\\nabla_{\\theta}\\log p(\\mathbf{a}_{l}|\\mathbf{a}_{l-1},\\pmb{\\theta}_{l})$ , $\\begin{array}{r}{\\mathbf{g}_{l}=-\\nabla_{\\mathbf{s}_{l}}\\log p(\\mathbf{a}_{l}|\\mathbf{a}_{l-1},\\pmb{\\theta}_{l})\\in\\mathbb{R}^{m_{l}}}\\end{array}$ with $\\mathbf{s}_{l}=\\mathbf{W}_{l}\\mathbf{a}_{l-1}$ , and $p(\\mathbf{a}_{l}|\\mathbf{a}_{l-1},\\pmb{\\theta}_{l})$ is the density function of the distribution $P_{\\mathbf{a}_{l}|\\mathbf{a}_{l-1}}(\\pmb{\\theta}_{l})$ . ", "page_idx": 3}, {"type": "text", "text": "In practice, the dimension of each block matrix $\\mathbf{F}_{l}$ is often still too large to directly compute its inverse matrix. Therefore, additional approximation methods are required to handle this computational difficulty. Suppose that the predictive distribution of ${\\bf a}_{l}$ follows Gaussian distribution with expectation being ${\\bf a}_{l}$ and variance being $\\mathbf{I}$ , and each element of activation output ${\\bf a}_{l}$ is independent and identically distributed random number, then each element of partial derivative ${\\bf g}_{l}$ is also independent and identically distributed. It is easy to show that $\\mathbf{F}_{l}$ can be seen as a matrix with $d_{l}\\times d_{l}$ block matrices, in which each block is an $m_{l}\\times m_{l}$ matrix and the off-diagonal elements are zero. Therefore, $\\mathbf{F}_{l}$ can be approximated as ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathbf{F}_{l}\\approx\\mathbb{E}[(\\mathbf{a}_{l-1}\\mathbf{a}_{l-1}^{\\top})\\otimes\\mathrm{diag}(\\mathbf{g}_{l}\\mathbf{g}_{l}^{\\top})].\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Combining the property that $(\\mathbf{A}\\otimes\\mathbf{B})^{-1}=\\mathbf{A}^{-1}\\otimes\\mathbf{B}^{-1}$ for any two invertible matrices $\\mathbf{A}$ and B, we can significantly reduces the computational complexity. Thus, some approaches have considered approximating the Fisher information matrix as the Kronecker product of two factors [14, 15, 19, 20, 22]. Inspired by these works, we also approximate $\\mathbf{F}_{l}$ as the Kronecker product of two factor matrices $\\bar{\\Phi_{l}}\\in\\mathbb{R}^{\\dot{d}_{l}\\times d_{l}}$ and $\\Psi_{l}\\in\\mathbb{R}^{d_{l}\\times d_{l}}$ . To get factor matrices $\\Phi_{l}$ and $\\Psi_{l}$ , we first replace diag $(\\mathbf{g}_{l}\\mathbf{g}_{l}^{\\top})$ in Eq. (3) by its trace and obtain $\\Phi_{l}$ . Then we compute $\\Psi_{l}$ while keeping that $\\operatorname{tr}\\!\\big(\\mathbf{F}_{l}\\big)=\\operatorname{tr}\\!\\big(\\dot{\\Phi_{l}}\\otimes\\dot{\\Psi}_{l}\\big)$ . Specifically, $\\Phi_{l}$ is given by ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\Phi_{l}=\\mathbb{E}[(\\mathbf{a}_{l-1}\\mathbf{a}_{l-1}^{\\top})\\otimes\\mathrm{tr}(\\mathrm{diag}(\\mathbf{g}_{l}\\mathbf{g}_{l}^{\\top}))]=\\mathbb{E}[(\\mathbf{a}_{l-1}\\mathbf{a}_{l-1}^{\\top})\\times\\mathbf{g}_{l}^{\\top}\\mathbf{g}_{l}],\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "On the other hand, $\\Psi_{l}$ can be computed by ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\Psi_{l}=\\frac{\\mathbb{E}[(\\mathbf{a}_{l-1}^{\\top}\\mathbf{a}_{l-1})\\times\\operatorname{diag}(\\mathbf{g}_{l}\\mathbf{g}_{l}^{\\top})]}{\\mathbb{E}[(\\mathbf{a}_{l-1}^{\\top}\\mathbf{a}_{l-1})(\\mathbf{g}_{l}^{\\top}\\mathbf{g}_{l})]}.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Based on Eq. (4) and Eq. (5), we can show that $\\operatorname{tr}(\\mathbf{F}_{l})=\\operatorname{tr}(\\Phi_{l}\\otimes\\Psi_{l})$ ", "page_idx": 4}, {"type": "text", "text": "Fig. 1 presents the visualization results of the exact Fisher information matrix $\\mathbf{F}$ , our approximation $\\mathbf{F}_{\\mathrm{LNGD}}$ , and the absolute error between them. Brighter pixels indicate higher values. From the left column in the top row, we observe the elements in the principal diagonal exhibit quite higher values, indicating their significance with rich information. Similarly, $\\mathbf{F}_{\\mathrm{LNGD}}$ can also emphasize the importance of the diagonal elements. The error figure reveals that the errors of the diagonal elements are small, which indicates that $\\mathbf{F}_{\\mathrm{LNGD}}$ provides a good approximation effect for the diagonal elements. Furthermore, to achieve a clearer visualization, we show the results of the partially enlarged area marked with red square in the bottom row. Here, we can observe more clearly that $\\mathbf{F}_{\\mathrm{LNGD}}$ achieves a favorable approximation effect on the diagonal elements. What\u2019s more, $\\mathbf{F}_{\\mathrm{LNGD}}$ can also provide an effective approximation of the elements in the auxiliary diagonals. These visualizations demonstrate the effectiveness of our proposed approximation in capturing the main elements of the Fisher information matrix. Therefore, our proposed approximation $\\mathbf{F}_{\\mathrm{LNGD}}$ is efficient and $\\mathbf{F}_{\\mathrm{LNGD}}$ can retain most of information. ", "page_idx": 4}, {"type": "text", "text": "3.2 Adaptive Layer-Wise Learning Rate ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "In this subsection, we propose an adaptive layer-wise learning rate to accelerate training DNNs. We first consider the cases that use the same learning rate for all elements and the adaptive element-wise learning rate. Then we present the adaptive layer-wise learning rate scheme. ", "page_idx": 4}, {"type": "text", "text": "Suppose that $\\mathbf{d}^{k}$ is the update direction of the function $h:\\mathbb{R}^{n}\\rightarrow\\mathbb{R}$ at the iteration point $\\pmb{\\theta}^{k}$ . We first recall the gradient descent methods for getting the minimization of $h$ , in which the update rule can be given as ${\\check{\\theta}}^{k+1}=\\theta^{k}-\\alpha^{k}\\mathbf{d}^{k}$ , where $\\alpha^{\\check{k}}$ is the learning rate, which can be chosen according to the value of the quadratic model ", "page_idx": 4}, {"type": "equation", "text": "$$\nh(\\theta^{k}-\\alpha^{k}\\mathbf{d}^{k})\\approx h(\\theta^{k})-\\alpha^{k}\\langle\\mathbf{d}^{k},\\nabla_{\\theta}h(\\theta^{k})\\rangle+\\frac{(\\alpha^{k})^{2}}{2}(\\mathbf{d}^{k})^{\\top}\\nabla_{\\theta}^{2}h(\\theta^{k})\\mathbf{d}^{k}.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Once the update direction is chosen, the minimizer of $\\alpha^{k}$ can be given by ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\alpha^{k}=\\frac{\\langle\\mathbf{d}^{k},\\nabla_{\\theta}h(\\pmb{\\theta}^{k})\\rangle}{(\\mathbf{d}^{k})^{\\top}\\nabla_{\\theta}^{2}h(\\pmb{\\theta}^{k})\\mathbf{d}^{k}}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "if $(\\mathbf{d}^{k})^{\\top}\\nabla_{\\theta}^{2}h(\\pmb{\\theta}^{k})\\mathbf{d}^{k}$ is nonzero. If $\\nabla_{\\theta}^{2}h(\\pmb{\\theta}^{k})$ is positive definite and $\\mathbf{d}^{k}=(\\nabla_{\\theta}^{2}h(\\theta^{k}))^{-1}\\nabla_{\\theta}h(\\theta^{k})$ , then $\\alpha^{k}=1$ , which leads to the classical Netwon method. In gradient decent methods, the learning rate is often regarded as the most important hyperparameter that highly influences model training. A fixed learning rate may lead to slow convergence or suboptimal performance in some cases. Therefore, many works have considered using adaptive learning rate in gradient decent methods [5, 6, 28]. In the following, we consider giving an adaptive element-wise learning rate automatically scaled by the direction $\\mathbf{d}^{k}$ . In this case, the update rule of parameters is given by $\\pmb{\\theta}^{\\bar{k}+1}=\\pmb{\\theta}^{k}-\\pmb{\\alpha}^{k}\\cdot\\mathbf{d}^{k}=\\pmb{\\theta}^{k}-\\pmb{\\mathrm{D}^{k}}\\pmb{\\alpha}^{k}$ , where $\\pmb{\\alpha}^{k}\\,\\in\\,\\mathbb{R}^{n}$ is the learning rate, $\\mathbf{D}^{k}\\in\\mathbb{R}^{n\\times n}$ is a diagonal matrix with $(\\mathbf{D}^{k})_{i i}\\,=\\,(\\mathbf{d}^{k})_{i}$ and $(\\mathbf{D}^{k})_{i j}=0$ when $i\\neq j$ for $i,j\\in[n]$ and \u201c\u00b7\u201d denotes the element-wise product. The second Taylor expansion of $h(\\pmb{\\theta}-\\mathbf{D}\\alpha)$ at iteration $k$ is ", "page_idx": 4}, {"type": "equation", "text": "$$\nh(\\theta^{k}-{\\bf D}^{k}\\alpha^{k})\\approx\\!h(\\theta^{k})-\\langle{\\bf D}^{k}\\alpha^{k},\\nabla_{\\theta}h(\\theta^{k})\\rangle+\\frac{1}{2}({\\bf D}^{k}\\alpha^{k})^{\\top}\\nabla_{\\theta}^{2}h(\\theta^{k}){\\bf D}^{k}\\alpha^{k}.\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Taking the derivative of $h$ with respect to $\\alpha^{k}$ and letting it equal to 0, we get ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r}{2\\mathbf{D}^{k}\\nabla_{\\theta}^{2}h(\\theta^{k})\\mathbf{D}^{k}\\alpha^{k}-\\mathbf{D}^{k}\\nabla_{\\theta}h(\\theta^{k})=\\mathbf{0},}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "which yields that ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\pmb{\\alpha}^{k}=(\\nabla_{\\pmb{\\theta}}^{2}h(\\pmb{\\theta}^{k})\\mathbf{D}^{k})^{-1}\\nabla_{\\pmb{\\theta}}h(\\pmb{\\theta}^{k})\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "if $\\mathbf{D}^{k}$ and $\\nabla_{\\theta}^{2}h(\\pmb{\\theta}^{k})$ are positive definite. ", "page_idx": 5}, {"type": "text", "text": "Note that in Eq. (7), it is impractical to compute the inverse of $\\nabla_{\\theta}^{2}h(\\theta^{k})\\mathbf{D}^{k}$ directly for largescale models due to high computational and storage costs. For second-order optimization methods in deep learning, some methods have considered approximating the curvature matrix by a block diagonal one according to different layers [10, 14, 15, 19, 24]. What\u2019s more, some works have observed that parameters in the same layer have gradients of similar magnitudes. Therefore, a common learning rate can be efficiently shared by these parameters [29, 30]. Inspired by these works, we propose a novel adaptive layer-wise learning method as follows. Suppose that $\\mathbf{d}^{k}=$ $((\\mathbf{d}_{1}^{k})^{\\top},(\\mathbf{d}_{2}^{k})^{\\top},\\ldots,(\\mathbf{d}_{L}^{k})^{\\top})^{\\top}$ is the update direction of a $L$ layers neural network at the iteration point $\\pmb{\\theta}^{k}=((\\pmb{\\theta}_{1}^{k})^{\\top},(\\pmb{\\theta}_{2}^{k})^{\\top},\\dots,(\\pmb{\\theta}_{L}^{k})^{\\top})^{\\top}$ , the update rule of $\\pmb{\\theta}^{k}$ is given as $\\pmb{\\theta}^{k+1}=\\pmb{\\theta}^{k}-\\tilde{\\mathbf{D}}^{k}\\tilde{\\pmb{\\alpha}}^{k}$ , where ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\tilde{\\mathbf{D}}^{k}=\\mathrm{diag}(\\mathbf{d}_{1}^{k},\\mathbf{d}_{2}^{k},\\ldots,\\mathbf{d}_{L}^{k})\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "is a block diagonal matrix and $\\tilde{\\alpha}^{k}\\,\\in\\,\\mathbb{R}^{L}$ is the learning rate. The approximate second Taylor expansion of $\\bar{h(\\pmb{\\theta}-\\tilde{\\mathbf{D}}\\tilde{\\alpha})}$ at iteration $k$ is ", "page_idx": 5}, {"type": "equation", "text": "$$\nh(\\theta^{k}-\\tilde{\\bf D}^{k}\\tilde{\\alpha}^{k})\\approx\\!h(\\theta^{k})-\\langle\\tilde{\\bf D}^{k}\\tilde{\\alpha}^{k},\\nabla_{\\theta}h(\\theta^{k})\\rangle+\\frac{1}{2}(\\tilde{\\bf D}^{k}\\tilde{\\alpha}^{k})^{\\top}{\\bf H}^{k}\\tilde{\\bf D}^{k}\\tilde{\\alpha}^{k},\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\mathbf{H}^{k}=\\operatorname{diag}(\\mathbf{H}_{1}^{k},\\mathbf{H}_{2}^{k},\\dots,\\mathbf{H}_{L}^{k})$ and $\\mathbf{H}_{l}^{k}=\\nabla_{\\pmb{\\theta}_{l}}^{2}h(\\pmb{\\theta}^{k})$ for $l\\in[L]$ and the Hessian matrix is approximated by the block diagonal matrix $\\mathbf{H}^{k}$ . Taking the derivative of $h$ with respect to $\\tilde{\\alpha}^{k}$ and letting it equal to 0, we get $(\\tilde{\\mathbf{D}}^{\\bar{k}})^{\\top}\\nabla_{\\theta}h(\\pmb{\\theta}^{k})=(\\tilde{\\mathbf{D}}^{k})^{\\top}\\bar{\\mathbf{H}}^{\\top}\\tilde{\\mathbf{D}}^{k}\\tilde{\\alpha}^{k}$ , which yields that ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\alpha^{k}=\\mathrm{diag}(\\Theta_{1},\\Theta_{2},\\ldots,\\Theta_{L})^{-1}((\\mathbf{d}_{1}^{k})^{\\top}\\nabla_{\\theta_{1}}h(\\theta^{k}),(\\mathbf{d}_{2}^{k})^{\\top}\\nabla_{\\theta_{2}}h(\\theta^{k}),\\ldots(\\mathbf{d}_{L}^{k})^{\\top}\\nabla_{\\theta_{L}}h(\\theta^{k}))^{\\top}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "if $\\Theta_{l}$ is nonzero, where $\\Theta_{l}=(\\mathbf{d}_{1}^{k})^{\\top}\\mathbf{H}_{1}^{k}(\\mathbf{d}_{1}^{k})$ for $l\\in[L]$ . ", "page_idx": 5}, {"type": "text", "text": "If a same learning rate is used for all layers, as the same way of computing the adaptive layer-wise learning rate, we can get ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\alpha=\\frac{(\\mathbf{d}^{k})^{\\top}\\nabla_{\\theta}h(\\pmb{\\theta}^{k})}{(\\mathbf{d}^{k})^{\\top}\\mathbf{H}^{k}\\mathbf{d}^{k}}.\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "Theorem 1. Let $g(\\pmb\\theta)$ and $g_{L}(\\pmb\\theta)$ be the approximate second Taylor expansions of $h(\\pmb\\theta-\\alpha\\mathbf d)$ and $h(\\pmb{\\theta}-\\tilde{\\mathbf{D}}\\tilde{\\alpha})$ as given in (9), where $\\tilde{\\mathbf{D}}\\in\\mathbb{R}^{n\\times L}$ , $\\tilde{\\mathbf{\\alpha}}\\tilde{\\mathbf{\\alpha}}\\in\\mathbb{R}^{L}$ and $\\alpha\\in\\mathbb{R}$ are given by (8), $(I O)$ and $(I I)$ respectively, then we have $g_{L}(\\pmb\\theta)\\leq g(\\pmb\\theta)$ . ", "page_idx": 5}, {"type": "text", "text": "Proof. The proof is given in the appendix. ", "page_idx": 5}, {"type": "text", "text": "By Theorem 1, we know that the adaptive layer-wise learning rate may lead to a faster decline in terms of function values. In our proposed algorithm, we choose $\\mathbf{\\check{d}}^{k}=(\\mathbf{\\check{F}}^{k})^{-1}\\nabla_{\\theta}h(\\pmb{\\theta}^{k})$ , where $\\mathbf{F}^{k}$ is the Fisher information matrix and can be seen as a approximation of the Hessian matrix. Then, the Fisher information matrix is approximated by a block diagonal matrix each block matrix is approximated by the Kronecker product of two factor matrices. In each layer, the update direction $\\mathbf{d}_{l}^{\\hat{k}}$ is scaled by a layer-wise damping learning rate $\\alpha_{l}^{k}$ according to (10), which is given by ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\alpha_{l}^{k}=\\frac{(\\mathbf{d}_{l}^{k})^{\\top}\\nabla_{\\theta}h(\\pmb{\\theta}_{l}^{k})}{(\\mathbf{d}_{l}^{k})^{\\top}\\mathbf{F}_{l}^{k}\\mathbf{d}_{l}^{k}+\\mu},\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\mu\\,>\\,0$ is a parameter. Using this adaptive layer-wise learning rate can accelerate layers with smaller gradients. Moreover, this approach can also avoid computing the inverse matrix in element-wise learning rate (13) and remain computationally efficient. ", "page_idx": 5}, {"type": "text", "text": "3.3 Algorithm Schema ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "To effectively apply LNGD in training DNNs, several certain techniques need to be employed. In this section, we primarily focus on introducing the damping technique, which is a commonly used in second-order methods. Meanwhile, a simple method can be used to compute the adaptive layer-wise learning rate according to Eq. (12) since the cost of computing $(\\mathbf{d}_{l}^{k})^{\\top}\\mathbf{F}_{l}^{k}\\mathbf{d}_{l}^{k}$ is relatively expensive. Finally, we discuss the utilization of exponential moving averages to enhance the training process. ", "page_idx": 6}, {"type": "text", "text": "A new damping technique: Damping plays a crucial role in second-order optimization methods. Large damping can weaken the effect of curvature matrix, while small damping may cause computational difficulty and inaccuracy since most eigenvalues of the Fisher information matrix are close to zero and only a small number of eigenvalues take on large values. To make training stable, we propose the following damping for the lth layer: $\\lambda_{l}=\\operatorname*{min}\\bar{(}\\operatorname*{max}(\\mathrm{tr}(\\mathbf{F}_{l})/d_{l},\\nu_{1}),\\nu_{2})$ , where $\\nu_{1}$ and $\\nu_{2}$ are two constants to constrain the minimum and maximum of damping, and $d_{l}$ is the number of weight parameters. In our method, $\\mathbf{F}_{l}$ is approximated as the Kronecker product of two factors $\\Phi_{l}$ and $\\Psi_{l}$ , so we add the damping to each factors by $\\hat{\\Phi}_{l}=\\Phi_{l}+\\lambda_{l}^{\\Phi}$ and $\\bar{\\hat{\\Psi}}_{l}=\\Psi_{l}+\\lambda_{l}^{\\Psi}$ , where $\\lambda_{l}^{\\Phi}=\\operatorname*{min}(\\operatorname*{max}(\\mathrm{tr}(\\Phi_{l})/n,\\nu_{1}),\\nu_{2})$ and $\\lambda_{l}^{\\Psi}=\\operatorname*{min}(\\operatorname*{max}(\\mathrm{tr}(\\Psi_{l})/n,\\nu_{1}),\\nu_{2})$ . ", "page_idx": 6}, {"type": "text", "text": "Compute the learning rate the faster: In order to compute the adaptive layer-wise learning rate given in Eq. (12) more quickly, we turn matrix computation into vector computation. Specifically, ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{(\\mathbf{d}_{l}^{k})^{\\top}\\mathbf{F}_{l}^{k}\\mathbf{d}_{l}^{k}=(\\mathbf{d}_{l}^{k})^{\\top}\\underset{(x,y\\sim p(x,y))}{\\mathbb{E}}[\\mathcal{D}\\theta_{l}\\mathcal{D}\\theta_{l}^{\\top}]\\mathbf{d}_{l}^{k}=\\underset{(x,y\\sim p(x,y))}{\\mathbb{E}}[(\\mathbf{d}_{l}^{k})^{\\top}\\mathcal{D}\\theta_{l}\\mathcal{D}\\theta_{l}^{\\top}\\mathbf{d}_{l}^{k}]}\\\\ &{\\qquad\\qquad=\\underset{(x,y\\sim p(x,y))}{\\mathbb{E}}[((\\mathbf{d}_{l}^{k})^{\\top}\\mathcal{D}\\theta_{l})^{2}]\\approx\\frac{1}{N}[((\\mathbf{d}_{l}^{k})^{\\top}\\mathcal{D}\\theta_{l})^{2}],}\\end{array}\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "where $\\mathbf{F}_{l}^{k}$ is the empirical Fisher information matrix and $N$ is the number of samples. The empirical version of Fisher information matrix with no need for sampling from the model\u2019s prediction distribution, making it more computationally efficient. ", "page_idx": 6}, {"type": "text", "text": "Exponential moving averages: In line with previous studies, we incorporate exponential moving averages into our approach. This involves updating the estimate by combining the previous estimate, weighted by $\\epsilon$ , with the estimate calculated from the new mini-batch, weighted by $1-\\epsilon$ . That is ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\hat{\\Phi}_{l}^{k+1}\\gets\\epsilon\\hat{\\Phi}_{l}^{k+1}+(1-\\epsilon)\\hat{\\Phi}^{k}\\mathrm{~and~}\\hat{\\Psi}_{l}^{k+1}\\gets\\epsilon\\hat{\\Psi}_{l}^{k+1}+(1-\\epsilon)\\hat{\\Psi}_{l}^{k}.\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "In summary, our proposed algorithm is shown in Algorithm1. ", "page_idx": 6}, {"type": "text", "text": "3.4 Convergence Analysis ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "In this subsection, we give the convergence analysis of LNGD. Following the model used in previous works about analysing the gradient descent [31, 32, 33] and NGD [34, 35], we consider a two-layer neural network activated by the ReLU function with $m$ neurons in the hidden layer as follows: ", "page_idx": 6}, {"type": "equation", "text": "$$\nf(\\pmb\\theta,a,\\mathbf x)=\\frac{1}{\\sqrt{m}}\\sum_{r=1}^{m}a_{r}\\varphi(\\pmb\\theta_{r}^{\\top}\\mathbf x),\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "where $\\pmb{\\theta}_{1},\\pmb{\\theta}_{2},\\dots,\\pmb{\\theta}_{m}\\in\\mathbb{R}^{d}$ are the weight vectors of the first layer, $\\mathbf{x}\\in\\mathbb{R}^{d}$ is the input, $a_{r}\\in\\mathbb{R}$ is the weight of unit $r$ in the second layer and $\\varphi(\\cdot)$ is the ReLU activation function, i.e., $\\varphi(x)=\\operatorname*{max}\\{0,x\\}$ . Let $\\mathbf{v}\\,=\\,[f(\\pmb{\\theta},a,\\mathbf{x}_{i}),f(\\pmb{\\theta},a,\\mathbf{x}_{2}),\\dots,f(\\pmb{\\theta},a,\\mathbf{x}_{n})]^{\\intercal}$ . In the following, we only give the result of convergence of Algorithm 1, the specific proof, which uses some conclusions in [36, 37, 38, 39], is given in the appendix. ", "page_idx": 6}, {"type": "text", "text": "Theorem 2. (Convergence rate of LNGD) Under the Assumption $^{\\,l}$ and the assumption that $r a n k(\\mathbf{X})\\ =\\ d.$ . If we set the number of hidden units $m~=~\\bar{\\Omega}\\left(\\frac{n^{4}\\kappa_{\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}^{8}}{\\nu^{2}\\varepsilon^{3}\\lambda_{\\mathbf{G}}^{4}}\\right)$ , we i.i.d initialize $\\pmb\\theta_{r}\\,\\sim\\,\\mathcal{N}(0,\\nu\\mathbf I)$ , $a_{r}\\,\\sim\\,\\mathrm{unif}[\\{-1,+1\\}]$ for any $r\\,\\in\\,[m]$ , and we set the step size $\\begin{array}{r}{\\alpha\\,\\leq\\,\\frac{(1-2c)}{(1+c)^{2}}}\\end{array}$ Then with probability at least $1-\\varepsilon$ over the random initialization, we have for $k=0,1,2,\\dots$ . ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}^{2}\\leq\\left(1-\\alpha\\right)^{k}\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}^{2}.\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "Proof. The proof is given in the appendix. ", "page_idx": 6}, {"type": "text", "text": "Require: learning rate $\\alpha$ , learning rate parameter $\\mu$ , damping parameter $\\lambda$ , damping constraints   \n$\\nu_{1},\\nu_{2}$ , momentum parameter $\\tau$ , exponential moving average parameter $\\epsilon$ , Fisher information   \nmatrix and its inverse update intervals $\\mathrm{T}_{\\mathrm{FIM}}$ and $\\mathrm{T_{INV}}$ .   \n1: $k\\leftarrow0$ , $m\\gets0$ . Initialize $\\hat{\\Phi}_{l}$ and $\\hat{\\Psi}_{l}$ for any $l\\in[L]$ .   \n2: while convergence is not reached do   \n3: Select a new mini-batch   \n4: for all $l\\in[L]$ do   \n5: if $k\\equiv0$ (mod $\\mathrm{T}_{\\mathrm{FIM}}$ ) then   \n6: Update the factors $\\hat{\\Phi}_{l}$ and $\\hat{\\Psi}_{l}$ using Eq. (14)   \n7: end if   \n8: if $k\\equiv0$ (mod $\\mathrm{T_{INV}}$ ) then   \n9: Compute the inverses of $\\hat{\\Phi}_{l}$ and $\\hat{\\Psi}_{l}$   \n10: end if   \n11: Compute $\\nabla_{\\pmb{\\theta}_{l}}h(\\pmb{\\theta})$ using backpropagation   \n12: Compute the approximated natural gradient $(\\hat{\\Phi}_{l}^{-1}\\otimes\\hat{\\Psi}_{l}^{-1})\\nabla_{\\pmb{\\theta}_{l}}h(\\pmb{\\theta})$   \n13: Compute the adaptive learning rate $\\alpha_{l}$ using Eq. (12)   \n14: $\\zeta\\gets-\\alpha\\alpha_{l}(\\hat{\\Phi}_{l}^{-1}\\otimes\\hat{\\Psi}_{l}^{-1})\\nabla_{\\pmb{\\theta}_{l}}\\bar{h}(\\pmb{\\theta})$   \n15: $m\\gets\\tau m+\\zeta$ (Update momentum)   \n16: $\\pmb{\\theta}_{l}\\leftarrow\\pmb{\\theta}_{l}+\\pmb{m}$ (Update parameters)   \n17: end for   \n18: $k\\gets k+1$   \n19: end while   \n20: return \u03b8 ", "page_idx": 7}, {"type": "text", "text": "4 Experiments ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "In order to verify the effectiveness of the proposed optimizer, we apply the optimizer to both image classification and machine translation tasks. We first present the optimization performance of our optimizer by comparing with several baselines. Then, we pay attention to the contribution of different modules of our optimizer by conducting elaborate ablation analysis, which is given in the appendix. Unless otherwise stated, the batch size for all experiments in the following is set to 256. The initial learning rate hyperparameters for all optimizers are tuned using a grid search with values $\\alpha\\in\\{1e-4,3e-4,\\ldots,1,3\\}$ . The damping parameter $\\lambda$ in KFAC[14] are tuned using a grid search with values $\\lambda\\in\\left\\{1e-6,1e-4,3e-4,1e-3,\\ldots,1e-1,3e-1\\right\\}$ . The minimum and maximum of damping parameters $\\nu_{1}$ and $\\nu_{2}$ in LNGD are set to $1e\\mathrm{~-~}5$ and $1e\\mathrm{~-~}2$ . The moving average parameter and the momentum correlating with KFAC and LNGD are set to 0.95 and 0.9, respectively. Furthermore, a weight decay of 0.004 is applied in all optimizers. All experiments run on a single A100 GPU using TensorFlow. We average the results of 5 runs and the hyper-parameter settings for these optimizers are the best values randomly searched for many times. ", "page_idx": 7}, {"type": "text", "text": "4.1 CIFAR-10 Training ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "We first report the optimizing performance on CIFAR-10 [40], which is a standard task used to benchmark optimization methods [6, 41, 42, 43, 44]. Following these previous works, the changes of testing accuracy and training loss versus time as well as epoch are reported in Fig. 2, and detailed statistics are shown in Table6. From Fig. 2, it can be observed that LNGD exhibits the most rapid decline in training loss during the initial epochs and seconds. This suggests that LNGD is effective in quickly reducing the training loss and reaching convergence. All optimization methods convergent at around 200 epochs. However, it is observed that second-order optimization methods, such as KFAC and LNGD, achieve a lower training loss compared to first-order optimization methods like SGD and Adam. In terms of testing accuracy, as depicted in Fig. 2 (b) and (d), LNGD achieves a top-1 accuracy of $91\\%$ at the fastest rate. It only requires 36 epochs and 189.69 seconds to achieve this accuracy level. In comparison, as presented in Table6, SGD and ADAM require at least $100\\%$ and $30\\%$ more epochs and time, respectively, to achieve similar accuracy. Relative to KFAC, LNGD reduces the number of epochs and time by around $20\\%$ and $21\\%$ , respectively. Furthermore, as shown in Table6, LNGD gets the highest final testing accuracy after convergence. ", "page_idx": 7}, {"type": "image", "img_path": "niG3Yyb6oA/tmp/ba5e6610158edf23ae03e6fb876cd21f0554f392ac9e65822a0e8064ee68a2d4.jpg", "img_caption": ["Figure 2: Numerical performance on ResNet-18 with CIFAR-10. "], "img_footnote": [], "page_idx": 8}, {"type": "image", "img_path": "niG3Yyb6oA/tmp/4e5b3435581c5773ab1689e2e72f3dab22ac7567a9d5c53ef0440af109d3372a.jpg", "img_caption": ["Figure 3: Numerical performance on ResNet-50 with ImageNet. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "4.2 ImageNet Training ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We extend our examination of optimizer efficacy to a larger image classification dataset, ImageNet-1K [45]. The changes of testing accuracy and training loss versus time and epoch are reported in Fig.3 and Table2. The results show that the LNGD optimizer is highly efficient in training large image datasets in terms of both speed and accuracy. LNGD, which requires only 36 epochs and 6.46 hours, is much faster in achieving the top-1 testing accuracy of $75.9\\%$ than other baselines. This is a significant improvement over SGD, which takes $\\bar{100\\%}$ more epochs and $75\\%$ more time to reach the same accuracy level. As for Adam, it exhibits a rapid decrease in loss during training and reaches convergence at a fast rate. However, the best achieved testing accuracy is only $74.05\\%$ , indicating that when training large-scale image tasks, a trade-off between efficiency and effectiveness needs to be considered. Compared to KFAC, although LNGD is better for only 3 epochs, it leads to $19\\%$ reduction in terms of the computing time. The training loss results further support the efficiency of LNGD, as it maintains the fastest rate of decline during the initial stages of training and ultimately yields the lowest training loss upon convergence. Overall, the results suggest that LNGD is a highly efficient optimizer for large-scale image classification tasks, providing faster convergence and better accuracy than other commonly used optimizers. ", "page_idx": 8}, {"type": "text", "text": "4.3 Transformer Training ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "In this experiment, we apply LNGD to the Transformer-Big model [46] with 213.7M parameters. The training datasets is WMT English-German machine translation corpus [46]. We use Bleu [47] as the evaluation metrics, which is frequently used in machine translation tasks. The setting of learning rate updating strategy for SGD, Adam, KFAC and LNGD are the same as in ImageNet training. ", "page_idx": 8}, {"type": "text", "text": "In Fig.4 and Table3, we present the comparative evaluation of the performance of LNGD against SGD, Adam, and KFAC in terms of testing accuracy and training loss. ADAM demonstrates superior performance over SGD, as evidenced by a more rapid decrease in training loss and a lower converged loss value. This observation aligns with previous empirical findings that ADAM is highly effective for transformer models. KFAC exhibits further enhancements in performance compared to Adam, yet it does not surpass the efficacy of LNGD. LNGD outperforms its counterparts with the swiftest reduction in training loss and the highest convergence rates. In terms of testing accuracy, measured by the Bleu score, LNGD achieves a top-1 Bleu score of $32\\%$ with remarkable efficiency, which is able to reduce the required steps by approximately $24\\%$ and computing time by $16\\%$ compared to Adam. When compared to KFAC, LNGD still shows significant improvements, reducing the steps by around $14\\%$ and computing time by $24\\%$ . As for SGD, it cannot reach the top-1 Bleu score of $32\\%$ and the best testing accuracy is only $31.8\\%$ , which indicates that SGD is not a good choice for large language processing tasks. In summary, the results provide strong evidences for the effectiveness of LNGD as an optimization algorithm for transformer models and shed light for large practical NLP tasks where time and computational resources are quite limited. ", "page_idx": 8}, {"type": "table", "img_path": "niG3Yyb6oA/tmp/2c6790a54fae5cf36bc09a3a7d1c6cdf32f6fa411068a6a96a25dd58456e5595.jpg", "table_caption": ["Table 2: Detailed statistics on ImageNet when top-1 testing accuracy achieves $75.9\\%$ "], "table_footnote": [], "page_idx": 9}, {"type": "image", "img_path": "niG3Yyb6oA/tmp/93a7dd17c4a59ed71f42dd866b167180803518492d47b5f8d1d3f954da23647c.jpg", "img_caption": ["Figure 4: Numerical performance on Transformer with WMT. "], "img_footnote": [], "page_idx": 9}, {"type": "text", "text": "", "page_idx": 9}, {"type": "table", "img_path": "niG3Yyb6oA/tmp/6cfc1509d78327eb2194c815cc3b586b1cdd5057db4e51165c92542e8fb2da7d.jpg", "table_caption": ["Table 3: Detailed statistics on WMT when Bleu achieves $32\\%$ "], "table_footnote": [], "page_idx": 9}, {"type": "text", "text": "5 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In summary, we propose a novel NGD optimizer named as LNGD for training DNNs, specifically targeting the computational inefficiencies that impede the practical application of conventional natural gradient techniques in large-scale neural networks. Our approach strategically computes Fisher information matrices for each individual layers using sample approximation and dynamically adjusts learning rates leveraging curvature information. This method facilitates a more refined representation of the optimization landscape at the layer level. Besides, we provide convergence analysis of LNGD. Experimental evaluations indicate its competitive performance relative to existing state-of-the-art optimizers. This work hold significant potential for enhancing the efficiency and scalability of training processes in deep learning frameworks. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Herbert Robbins and Sutton Monro. A stochastic approximation method. The Annals of Mathematical Statistics, pages 400\u2013407, 1951.   \n[2] Yu E Nesterov. A method for solving the convex programming problem with convergence rate $O\\!\\left(\\frac{1}{k^{2}}\\right)$ . In Doklady Akademii Nauk SSSR, volume 269, pages 543\u2013547, 1983.   \n[3] Ning Qian. On the momentum term in gradient descent learning algorithms. Neural networks, 12(1):145\u2013151, 1999.   \n[4] Matthew D Zeiler. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701, 2012.   \n[5] Tijmen Tieleman and Geoffrey Hinton. Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude. COURSERA: Neural networks for machine learning, 4(2):26\u2013 31, 2012.   \n[6] Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. In International Conference on Learning Representations, 2014.   \n[7] Juntang Zhuang, Tommy Tang, Yifan Ding, Sekhar C Tatikonda, Nicha Dvornek, Xenophon Papademetris, and James Duncan. Adabelief optimizer: Adapting stepsizes by the belief in observed gradients. Advances in neural information processing systems, 33:18795\u201318806, 2020.   \n[8] Nitish Shirish Keskar and Albert S Berahas. ADAQN: An adaptive quasi-Newton algorithm for training rnns. In Joint European Conference on Machine Learning and Knowledge Discovery in Databases, pages 1\u201316, 2016.   \n[9] Zhewei Yao, Amir Gholami, Sheng Shen, Mustafa Mustafa, Kurt Keutzer, and Michael Mahoney. AdaHessian: An adaptive second order optimizer for machine learning. In proceedings of the AAAI conference on artificial intelligence, volume 35, pages 10665\u201310673, 2021.   \n[10] Donald Goldfarb, Yi Ren, and Achraf Bahamou. Practical quasi-Newton methods for training deep neural networks. Advances in Neural Information Processing Systems, 33:2386\u20132396, 2020.   \n[11] James Martens. Deep learning via Hessian-free optimization. In International Conference on Learning Representations, volume 27, pages 735\u2013742, 2010.   \n[12] Oriol Vinyals and Daniel Povey. Krylov subspace descent for deep learning. In Artificial Intelligence and Statistics, pages 1261\u20131268. PMLR, 2012.   \n[13] Shun-Ichi Amari. Natural gradient works efficiently in learning. Neural computation, 10(2):251\u2013 276, 1998.   \n[14] James Martens and Roger Grosse. Optimizing neural networks with Kronecker-factored approximate curvature. In International conference on machine learning, pages 2408\u20132417, 2015.   \n[15] Kaixin Gao, Xiaolei Liu, Zhenghai Huang, Min Wang, Zidong Wang, Dachuan Xu, and Fan Yu. A trace-restricted Kronecker-factored approximation to natural gradient. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 35, pages 7519\u20137527, 2021.   \n[16] Kazuki Osawa, Yohei Tsuji, Yuichiro Ueno, Akira Naruse, Chuan-Sheng Foo, and Rio Yokota. Scalable and practical natural gradient for large-scale deep learning. IEEE Transactions on Pattern Analysis and Machine Intelligence, 44(1):404\u2013415, 2020.   \n[17] Minghan Yang, Dong Xu, Qiwen Cui, Zaiwen Wen, and Pengxiang Xu. An efficient Fisher matrix approximation method for large-scale neural network optimization. IEEE Transactions on Pattern Analysis and Machine Intelligence, 45(5):5391\u20135403, 2022.   \n[18] James Martens. New insights and perspectives on the natural gradient method. Journal of Machine Learning Research, 21:1\u201376, 2020.   \n[19] Roger Grosse and James Martens. A Kronecker-factored approximate Fisher matrix for convolution layers. In International Conference on Machine Learning, pages 573\u2013582, 2016.   \n[20] James Martens, Jimmy Ba, and Matt Johnson. Kronecker-factored curvature approximations for recurrent neural networks. In International Conference on Learning Representations, 2018.   \n[21] Guodong Zhang, Shengyang Sun, David Duvenaud, and Roger Grosse. Noisy natural gradient as variational inference. In International conference on machine learning, pages 5847\u20135856, 2018.   \n[22] Thomas George, C\u00e9sar Laurent, Xavier Bouthillier, Nicolas Ballas, and Pascal Vincent. Fast approximate natural gradient descent in a Kronecker factored eigenbasis. In Advances in Neural Information Processing Systems, pages 9550\u20139560, 2018.   \n[23] Kaixin Gao, Zheng-Hai Huang, Xiaolei Liu, Min Wang, Shuangling Wang, Zidong Wang, Dachuan Xu, and Fan Yu. Eigenvalue-corrected natural gradient based on a new approximation. Asia-Pacific Journal of Operational Research, 40(01):2340005, 2023.   \n[24] Mengyun Chen, Kaixin Gao, Xiaolei Liu, Zidong Wang, Ningxi Ni, Qian Zhang, Lei Chen, Chao Ding, Zhenghai Huang, Min Wang, et al. THOR, trace-based hardware-driven layeroriented natural gradient descent computation. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 35, pages 7046\u20137054, 2021.   \n[25] Lin Zhang, Shaohuai Shi, Wei Wang, and Bo Li. Scalable K-FAC training for deep neural networks with distributed preconditioning. IEEE Transactions on Cloud Computing, 11(3):2365\u2013 2378, 2023.   \n[26] Diederik P Kingma and Max Welling. Auto-encoding variational bayes. arXiv preprint arXiv:1312.6114, 2013.   \n[27] Krishnakumar Balasubramanian, Pinar Donmez, and Guy Lebanon. Unsupervised supervised learning ii: Margin-based classification without labels. In Proceedings of the Fourteenth International Conference on Artificial Intelligence and Statistics, pages 137\u2013145. JMLR Workshop and Conference Proceedings, 2011.   \n[28] Fr\u00e9d\u00e9ric de Gournay and Alban Gossard. Adaptive scaling of the learning rate by second order automatic differentiation. arXiv preprint arXiv:2210.14520, 2022.   \n[29] Bharat Singh, Soham De, Yangmuzi Zhang, Thomas Goldstein, and Gavin Taylor. Layerspecific adaptive learning rates for deep networks. In 2015 IEEE 14th International Conference on Machine Learning and Applications (ICMLA), pages 364\u2013368. IEEE, 2015.   \n[30] Boris Ginsburg, Patrice Castonguay, Oleksii Hrinchuk, Oleksii Kuchaiev, Vitaly Lavrukhin, Ryan Leary, Jason Li, Huyen Nguyen, Yang Zhang, and Jonathan M Cohen. Training deep networks with stochastic gradient normalized by layerwise adaptive second moments. 2019.   \n[31] Simon S. Du, Xiyu Zhai, Barnab\u00e1s P\u00f3czos, and Aarti Singh. Gradient descent provably optimizes over-parameterized neural networks. In 7th International Conference on Learning Representations, 2019.   \n[32] Simon S. Du, Jason D. Lee, Haochuan Li, Liwei Wang, and Xiyu Zhai. Gradient descent finds global minima of deep neural networks. In Proceedings of the 36th International Conference on Machine Learning, volume 97, pages 1675\u20131685, 2019.   \n[33] Sanjeev Arora, Simon S. Du, Wei Hu, Zhiyuan Li, and Ruosong Wang. Fine-grained analysis of optimization and generalization for overparameterized two-layer neural networks. In Proceedings of the 36th International Conference on Machine Learning, volume 97, pages 322\u2013332, 2019.   \n[34] Guodong Zhang, James Martens, and Roger Grosse. Fast convergence of natural gradient descent for over-parameterized neural networks. In Advances in Neural Information Processing Systems, volume 32, 2019.   \n[35] Ryo Karakida and Kazuki Osawa. Understanding approximate Fisher information for fast convergence of natural gradient descent in wide neural networks. In Advances in Neural Information Processing Systems, volume 33, pages 10891\u201310901, 2020.   \n[36] Alberto Bernacchia, M\u00e1t\u00e9 Lengyel, and Guillaume Hennequin. Exact natural gradient in deep linear networks and its application to the nonlinear case. In Advances in Neural Information Processing Systems, pages 5945\u20135954, 2018.   \n[37] Joel A Tropp. An introduction to matrix concentration inequalities. arXiv preprint arXiv:1501.01571, 2015.   \n[38] Jssai Schur. Bemerkungen zur theorie der beschr\u00e4nkten bilinearformen mit unendlich vielen ver\u00e4nderlichen. Journal f\u00fcr die reine und angewandte Mathematik, 1911(140):1\u201328, 1911.   \n[39] Shuangzhe Liu and Gotz Trenkler. Hadamard, Khatri-Rao, Kronecker and other matrix products. International Journal of Information and Systems Sciences, 4(1):160\u2013177, 2008.   \n[40] Alex Krizhevsky, Geoffrey Hinton, et al. Learning multiple layers of features from tiny images. 2009.   \n[41] Priya Goyal, Piotr Doll\u00e1r, Ross Girshick, Pieter Noordhuis, Lukasz Wesolowski, Aapo Kyrola, Andrew Tulloch, Yangqing Jia, and Kaiming He. Accurate, large minibatch sgd: Training imagenet in 1 hour. arXiv preprint arXiv:1706.02677, 2017.   \n[42] Peng Xu, Fred Roosta, and Michael W Mahoney. Second-order optimization for non-convex machine learning: An empirical study. In Proceedings of the 2020 SIAM International Conference on Data Mining, pages 199\u2013207. SIAM, 2020.   \n[43] Yuchao Li, Shaohui Lin, Jianzhuang Liu, Qixiang Ye, Mengdi Wang, Fei Chao, Fan Yang, Jincheng Ma, Qi Tian, and Rongrong Ji. Towards compact cnns via collaborative compression. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 6438\u20136447, 2021.   \n[44] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 770\u2013778, 2016.   \n[45] Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. ImageNet: A largescale hierarchical image database. In 2009 IEEE conference on computer vision and pattern recognition, pages 248\u2013255. Ieee, 2009.   \n[46] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, \u0141ukasz Kaiser, and Illia Polosukhin. Attention is all you need. Advances in neural information processing systems, 30, 2017.   \n[47] Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu. Bleu: a method for automatic evaluation of machine translation. In Proceedings of the 40th annual meeting of the Association for Computational Linguistics, pages 311\u2013318, 2002. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "A Notations ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "In this paper, we denote $[n]\\,=\\,\\{1,2,.\\,.\\,.\\,,n\\}$ . For a matrix A, we use $\\mathbf{A}_{i j}$ to denote its $(i,j)$ -th entry, $\\operatorname{tr}(\\mathbf{A})$ to denote its trace, $\\sigma_{\\mathrm{min}}(\\mathbf{A})$ and $\\sigma_{\\mathrm{max}}(\\mathbf{A})$ to denote its smallest and largest singular value, $\\|\\mathbf{A}\\|_{\\mathbf{F}}$ to denote its Frobenius norm and $||\\mathbf{A}||_{2}$ to denote its spectral norm. If $\\mathbf{A}$ is positive semi-definite, $\\lambda_{\\mathrm{min}}(\\mathbf{A})$ and $\\lambda_{\\operatorname*{max}}(\\mathbf{A})$ denote its smallest and largest eigenvalue, and define $\\kappa_{\\mathbf{A}}=$ $\\lambda_{\\operatorname*{max}}(\\mathbf{A})/\\lambda_{\\operatorname*{min}}(\\mathbf{A}),$ , respectively. The identity matrix is denoted as I. For a vector a, $\\lVert\\mathbf{a}\\rVert_{2}$ denotes the Euclidean norm. We use $\\mathcal{N}(\\pmb{\\mu},\\pmb{\\Sigma})$ to denote the Gaussian distribution with mean $\\pmb{\\mu}$ and covariance $\\Sigma$ . For two matrices ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\mathbf{A}=[\\mathbf{a}_{1},\\mathbf{a}_{2},\\ldots,\\mathbf{a}_{n}]\\in\\mathbb{R}^{p\\times q},\\ \\ \\ \\mathbf{B}=[\\mathbf{b}_{1},\\mathbf{b}_{2},\\ldots,\\mathbf{b}_{n}]\\in\\mathbb{R}^{p\\times q},\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "we use $\\circ$ and $\\otimes$ to denote the Hadamard and Kronecker product, respectively. The column-wise Khatri-Rao product $^*$ is defines as ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\mathbf{A}*\\mathbf{B}=[\\mathbf{a}_{1}\\otimes\\mathbf{b}_{1},\\mathbf{a}_{2}\\otimes\\mathbf{b}_{2},\\ldots,\\mathbf{a}_{n}\\otimes\\mathbf{b}_{n}]\\in\\mathbb{R}^{p^{2}\\times q}.\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "Similarly, we can define the row-wise Khatri-Rao product $\\star$ and we have $(\\mathbf{A}\\star\\mathbf{B})^{\\top}=(\\mathbf{A}^{\\top}*\\mathbf{B}^{\\top})$ . Given an event $E,\\mathbb{I}\\{E\\}$ denotes its indicator function, i.e., ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\mathbb{I}\\{E\\}={\\left\\{\\begin{array}{l l}{1,}&{{\\mathrm{if~}}E{\\mathrm{~happens}},}\\\\ {0,}&{{\\mathrm{otherwise.}}}\\end{array}\\right.}\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "B Comparisons and Explanations ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "B.1 Comparisons with Related Works ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "There have been some works to utilize the NGD or its approximations for training DNNs. One of the primary computational challenges lie in the storage and computing the inverse of the Fisher information matrix during NGD optimization. Recently, several studies have explored the adoption of the efficient Kronecker-factored approximation to the Fisher information matrix to address this computational challenge. The most related approaches to this work are the KFAC, EKFAC and TKFAC[15]. These works and LNGD all start with a block-diagonal approximation of the Fisher information matrix. The differences among them are the approximations of the block matrix $\\mathbf{F}_{l}$ . By approximating the expectation of the Kronecker product as the Kronecker product of expectations, KFAC approximates $\\mathbf{F}_{l}$ as the Kronecker product of $\\mathbf{A}=\\mathbb{E}[(\\mathbf{a}_{l-1}\\mathbf{a}_{l-1}^{\\top})]$ and $\\mathbf{B}=\\mathbb{E}[(\\hat{\\mathbf{g}}_{l}^{\\star}\\hat{\\mathbf{g}}_{l}^{\\top})]$ with $\\hat{\\bf g}_{l}\\,=\\,-\\nabla_{\\bf s}_{l}\\log p({\\bf y}|{\\bf x})$ . By tracking the diagonal variance in the Kronecker-factored eigenbasis, EKFAC performs eigenvalue decomposition of the Fisher information matrix and re-scales the eigenvalues by $\\mathbf{S}^{\\ast}$ to achieve a better approximation, where $\\mathbf{S}^{\\ast}$ is a diagonal matrix defined by $\\mathbf{S}_{i i}^{\\breve{*}}=\\mathbb{E}[(\\mathbf{U}_{\\mathbf{B}}^{\\top}\\mathbf{\\dot{V}}_{\\theta}h(\\pmb{\\theta})^{2})_{i}]$ , and $\\mathbf{U_{A}},\\mathbf{U_{B}}$ are eigenvectors of $\\mathbf{A},\\mathbf{B}$ . TKFAC approximates $\\mathbf{F}_{l}$ as a Kronecker product of two factors $\\mathbf{P}$ and $\\mathbf{Q}$ scaled by a coefficient $\\delta$ and keep the traces of each block equal. In this paper, we propose the LNGD, which approximates $\\mathbf{F}_{l}$ as a Kronecker product of a matrix $\\Phi_{l}$ and a diagonal matrix $\\Psi_{l}$ , which is computed by sampling from each layer. We summarize the above approximations of $\\mathbf{F}_{l}$ in Table 4. ", "page_idx": 13}, {"type": "table", "img_path": "niG3Yyb6oA/tmp/96199e1bed63caa09d60c5d1d0e57377a8f20a59da460856baca4698900a2f82.jpg", "table_caption": ["Table 4: Summary of some NGD optimizers "], "table_footnote": [], "page_idx": 13}, {"type": "text", "text": "When these methods have the same update frequency, KFAC needs to compute two factor matrices A and B, and then invert them. However, B can only be computed after completely performing backpropagation. On the other hand, EKFAC modifies KFAC by incorporating eigenvalue decomposition to scale the eigenvalue during the inversion process. TKFAC, another variant of KFAC, maintains the equality of traces of matrices before and after approximation. Both EKFAC and TKFAC involve increased computational requirements compared to KFAC. Our proposed LNGD also requires computation and inversion of two factors $\\Phi$ and $\\Psi$ . However, the advantage of LNGD is that the matrix $\\Psi$ is diagonal, and due to the use of hierarchical sampling, $\\Psi$ can be directly inverse during the forward propagation phase, without the need to wait for the completion of the back-propagation process. This feature significantly reduces computational time. ", "page_idx": 13}, {"type": "image", "img_path": "niG3Yyb6oA/tmp/cc8d87bfc8dbe85e6089d0d63bb8b7be7bef2d23b60663a5309f73a668d0fbea.jpg", "img_caption": ["Figure 5: Comparison of the exact Fisher information matrix and the approximated Fisher information matrix of KFAC and LNGD. On the left is the exact Fisher information matrix, in the middle is the approximated Fisher information matrix, and on the right is the absolute error of these. The first row shows the result of KFAC, and the second row shows the results of LNGD. "], "img_footnote": [], "page_idx": 14}, {"type": "text", "text": "", "page_idx": 14}, {"type": "text", "text": "In addition, THOR proposed in [24] also provides an optimizer using NGD for training DNNs. THOR mainly considers reducing the computational cost of NGD through two aspects. On the one hand, THOR gradually increases the updating frequency of the inverse matrix of Fisher information matrix and proposes a trace-based updating rule for the Fisher information matrix of each layer. On the other hand, THOR approximates the approximated Fisher information matrix obtained by KFAC as some smaller matrices by splitting matrix dimensions. Our proposed LNGD first gives a layer-wise sample method to more efficiently compute each block matrix corresponding to each layer and proposes a novel approximate scheme of the Fisher information matrix. Furthermore, LNGD also adopts an adaptive layer-wise learning rate to speed up training. The contributions and ideas of our proposed LNGD are different from THOR. ", "page_idx": 14}, {"type": "text", "text": "B.2 Comparisons Between KFAC and LNGD ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "Fig. 5 shows the visualization results of KFAC and LNGD. From Fig. 5 (b) and (e), we can see that KFAC and LNGD can all emphasize the importance of the diagonal elements in the exact Fisher information matrix. In addition, it can also be seen clearly that KFAC still retains some elements near the main diagonal, while LNGD does not, which also reflects that LNGD provides an efficient approximation of Fisher information matrix with less computational cost in comparison with KFAC. ", "page_idx": 14}, {"type": "text", "text": "B.3 Illustration of the Gaussian Distribution Assumption ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "In Subsection 3.1, we assume that the predictive distribution $P_{\\mathbf{a}_{l}|\\mathbf{a}_{l-1}}(\\pmb{\\theta}_{l})$ follows Gaussian distribution. To illustrate the validity of the Gaussian distribution assumption, we collect the output of two layers of the ResNet-18 network on CIFAR-10 and show the results in Fig. 6. Fig. 6 (a) and (b) show the distributions of sample representation vectors\u2019 values in some dimension. Since we use the ReLU activation function, the obtained distributions are in accord with the Gaussian distribution in the positive quadrant. Fig. 6 (c) and (d) show the distributions of values of sample representation vectors\u2019 Euclidean norm, from which we can see that the two distributions can also be approximated as Gaussian distributions. ", "page_idx": 14}, {"type": "image", "img_path": "niG3Yyb6oA/tmp/f71b2f0117f3f6be21a6cc940af385ca7f29064e986f3c135ed1a0453c6e6c2e.jpg", "img_caption": ["Figure 6: Illustration of Gaussian distribution. "], "img_footnote": [], "page_idx": 15}, {"type": "text", "text": "C Proof of Theorem 1 ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Proof. Since $g(\\pmb\\theta)$ and $g_{L}(\\pmb\\theta)$ are the approximate second Taylor expansions of $h(\\pmb\\theta-\\alpha\\mathbf d)$ and $h(\\pmb{\\theta}-\\tilde{\\mathbf{D}}\\tilde{\\alpha})$ , we have ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\displaystyle g_{L}(\\theta)-g(\\theta)=h(\\theta)-\\alpha\\langle\\mathbf{d},\\nabla_{\\theta}h(\\theta)\\rangle+\\frac{1}{2}\\alpha^{2}\\mathbf{d}^{\\top}\\mathbf{H}\\mathbf{d}-h(\\theta)+\\displaystyle\\sum_{l=1}^{L}\\tilde{\\alpha}_{l}\\langle\\mathbf{d}_{l},\\nabla_{\\theta_{l}}h(\\theta)\\rangle}\\\\ &{\\displaystyle-\\sum_{l=1}^{L}\\frac{1}{2}\\tilde{\\alpha}_{l}^{2}\\mathbf{d}_{l}^{\\top}\\mathbf{H}_{l}\\mathbf{d}_{l}=\\frac{1}{2}\\left(\\displaystyle\\sum_{l=1}^{L}\\frac{(\\mathbf{d}_{l}^{\\top}\\nabla_{\\theta_{l}}h(\\theta))^{2}}{\\mathbf{d}_{l}^{\\top}\\mathbf{H}_{l}\\mathbf{d}_{l}}-\\frac{(\\mathbf{d}^{\\top}\\nabla_{\\theta}h(\\theta))^{2}}{\\mathbf{d}^{\\top}\\mathbf{H}\\mathbf{d}}\\right)\\leq0.}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "This completes the proof. ", "page_idx": 15}, {"type": "text", "text": "D Convergence of LNGD ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "In this section, we give the convergence analysis of LNGD. Following the model used in previous works about analysing the gradient descent [31, 32, 33] and NGD [34, 35], we consider a two-layer neural network activated by the ReLU function with $m$ neurons in the hidden layer as follows: ", "page_idx": 15}, {"type": "equation", "text": "$$\nf(\\pmb\\theta,a,\\mathbf x)=\\frac{1}{\\sqrt{m}}\\sum_{r=1}^{m}a_{r}\\varphi(\\pmb\\theta_{r}^{\\top}\\mathbf x),\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "where $\\pmb{\\theta}_{1},\\pmb{\\theta}_{2},\\dots,\\pmb{\\theta}_{m}\\in\\mathbb{R}^{d}$ are the weight vectors of the first layer, $\\mathbf{x}\\in\\mathbb{R}^{d}$ is the input, $a_{r}\\in\\mathbb{R}$ is the weight of unit $r$ in the second layer and $\\varphi(\\cdot)$ is the ReLU activation function, i.e., $\\varphi(x)=\\operatorname*{max}\\{0,x\\}$ . For convenience, we define $\\pmb{\\theta}\\,=\\,[\\pmb{\\theta}_{1}^{\\top},\\pmb{\\theta}_{2}^{\\top},\\dots,\\pmb{\\theta}_{m}^{\\top}]^{\\top}\\,\\in\\,\\mathbb{R}^{m d}$ . We first initialize the parameters randomly by ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\pmb{\\theta}_{r}\\sim\\mathcal{N}(\\mathbf{0},\\nu^{2}\\mathbf{I}),\\quad a_{r}\\sim\\mathrm{unif}[\\{-1,+1\\}],\\quad\\forall r\\in[m],\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "where $0<\\nu\\leq1$ controls the magnitude of initialization. ", "page_idx": 15}, {"type": "text", "text": "Given the training dataset ${\\cal{S}}=\\{({\\bf x}_{i},y_{i})\\}_{i=1}^{n}$ containing (input, target) examples $\\left({{\\bf{x}}_{i}},{y_{i}}\\right)$ . Following [31, 33, 34], we make the following assumption for the data. ", "page_idx": 15}, {"type": "text", "text": "Assumption 1. For all $i$ , $\\|\\mathbf{x}_{i}\\|_{2}^{2}=1$ and $|y_{i}|=\\mathcal{O}(1)$ . For any $i\\neq j,\\,{\\bf x}_{i}\\nmid\\!\\!\\!\\!\\slash\\;{\\bf x}_{j}.$ . ", "page_idx": 15}, {"type": "text", "text": "In this subsection, we mainly focus on the mean squared error loss (MSE) function ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{l}{\\displaystyle\\mathcal{L}(\\pmb{\\theta})=\\frac{1}{2n}\\sum_{i=1}^{n}(f(\\pmb{\\theta},a,\\mathbf{x}_{i})-y_{i})^{2}}\\\\ {\\displaystyle=\\frac{1}{2n}\\sum_{i=1}^{n}(\\frac{1}{\\sqrt{m}}\\sum_{r=1}^{m}a_{r}\\varphi(\\pmb{\\theta}_{r}^{\\top}\\mathbf{x})-y_{i})^{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Following [31, 33, 34], we fix the weights of second layer and only optimize the weights of first layer. Then the update rule of NGD can be written as ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\pmb{\\theta}^{k+1}=\\pmb{\\theta}^{k}-\\alpha(\\mathbf{F}^{k})^{-1}\\nabla_{\\theta}\\mathcal{L}(\\pmb{\\theta}^{k}).\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "As shown in [18], if the network\u2019s predictive distribution is in the exponential family, the Fisher information matrix is equivalent to the generalized Gauss-Newton matrix, which is defined by ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbb{E}_{(\\mathbf{x}_{i},y_{i})\\in S}[\\mathbf{J}_{i}^{\\top}\\mathbf{H}_{\\mathcal{L}}\\mathbf{J}_{i}],\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where $\\mathbf{H}_{\\mathcal{L}}$ is the Hessian matrix of the loss function ${\\mathcal{L}}(\\theta)$ with respect to the prediction $f(\\pmb\\theta,a,\\mathbf x_{i})$ and $\\mathbf{J}_{i}$ is the Jacobian matrix of $f(\\pmb\\theta,a,\\mathbf x_{i})$ with respect to the parameters $\\pmb{\\theta}$ . Under our setting that ${\\mathcal{L}}(\\theta)$ is the MSE loss function, the Hessian matrix $\\mathbf{H}_{\\mathcal{L}}$ is the identity matrix I. $\\mathbf{J}_{i}$ can be computed by ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{J}_{i}=\\left(\\nabla_{\\theta_{1}}f(\\pmb{\\theta},a,\\mathbf{x}_{i})^{\\top},\\dots,\\nabla_{\\theta_{m}}f(\\pmb{\\theta},a,\\mathbf{x}_{i})^{\\top}\\right)^{\\top},\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\nabla_{\\theta_{r}}f(\\theta,a,\\mathbf{x}_{i})=\\frac{a_{r}}{\\sqrt{m}}\\mathbb{I}\\{\\theta_{r}^{\\top}\\mathbf{x}_{i}\\geq0\\}\\mathbf{x}_{i},\\quad\\forall\\:r\\in[m].\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Let $\\mathbf{J}=(\\mathbf{J}_{1},\\mathbf{J}_{2},\\ldots,\\mathbf{J}_{n})^{\\top}\\in\\mathbb{R}^{n\\times m d}$ , then the Fisher information matrix can be written as ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{F}=\\mathbb{E}_{(\\mathbf{x}_{i},y_{i})\\in{\\cal S}}[\\mathbf{J}_{i}^{\\top}\\mathbf{H}_{\\mathcal{L}}\\mathbf{J}_{i}]=\\mathbb{E}_{(\\mathbf{x}_{i},y_{i})\\in{\\cal S}}[\\mathbf{J}_{i}^{\\top}\\mathbf{J}_{i}]=\\frac{1}{n}\\mathbf{J}^{\\top}\\mathbf{J}.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "As discussed in [34], when $m>n$ , the Fisher information matrix is singular. So in this case, we use the generalized inverse given in [36] ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{F}^{\\dagger}=n\\mathbf{J}^{\\top}(\\mathbf{J}\\mathbf{J}^{\\top})^{-1}(\\mathbf{J}\\mathbf{J}^{\\top})^{-1}\\mathbf{J}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "and the update rule of NGD can be written as ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\theta^{k+1}=\\theta^{k}-\\frac{\\alpha}{n}(\\mathbf{F}^{k})^{\\dagger}(\\mathbf{J}^{k})^{\\top}({\\mathbf v}^{k}-{\\mathbf y}),\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where $\\begin{array}{r l r l}{\\mathbf{y}}&{{}}&{=}&{{}\\quad\\left[y_{1},y_{2},\\ldots,y_{n}\\right]^{\\intercal}}\\end{array}$ and v = [v1, v2, . . . , vn]\u22a4 $[f(\\pmb\\theta,a,\\mathbf x_{i}),f(\\pmb\\theta,a,\\mathbf x_{2}),\\dots,f(\\pmb\\theta,a,\\mathbf x_{n})]^{\\intercal}$ . Consider the two-layer neural network described in this subsection, since we fixed the weights in second layer, and the Fisher information matrix of this model is approximated by ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{F}\\approx\\Phi\\otimes\\Psi.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "For simplicity, we ignore the index of layer. Define ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{X}=[\\mathbf{x}_{1},\\mathbf{x}_{2},\\ldots,\\mathbf{x}_{n}]^{\\top}\\in\\mathbb{R}^{n\\times d}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "and ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{G}=[\\varphi^{'}(\\mathbf{X}\\pmb{\\theta}_{1}),\\varphi^{'}(\\mathbf{X}\\pmb{\\theta}_{2}),\\dots,\\varphi^{'}(\\mathbf{X}\\pmb{\\theta}_{m})]\\in\\mathbb{R}^{n\\times m},\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where $\\mathbf{X}$ is the input matrix formed by $n$ input vectors and $\\mathbf{G}$ is the pre-activation derivatives matrix whose entry is given by ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{G}_{i r}=\\frac{1}{\\sqrt{m}}\\mathbb{I}\\{\\mathbf{x}_{i}^{\\top}\\pmb{\\theta}_{r}\\geq0\\},\\quad\\forall\\,i\\in[n],r\\in[m].\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Then we have ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{J}=\\nabla_{\\theta}f(\\theta,a,\\mathbf{x}_{i})=\\mathbf{X}\\star\\mathbf{G}\\in\\mathbb{R}^{n\\times m d}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "and ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{F}={\\frac{1}{n}}\\mathbf{J}^{\\top}\\mathbf{J}={\\frac{1}{n}}(\\mathbf{X}\\star\\mathbf{G})^{\\top}(\\mathbf{X}\\star\\mathbf{G})\\in\\mathbb{R}^{m d\\times m d}.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "The formulas of $\\Phi$ and $\\Psi$ can be given as ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\Phi=\\mathbf{X}^{\\top}(\\mathbf{G}\\mathbf{G}^{\\top}\\circ\\mathbf{I})\\mathbf{X}\\in\\mathbb{R}^{d\\times d},}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "equation", "text": "$$\n\\pmb{\\Psi}=\\frac{1}{n}\\frac{\\mathbf{G}^{\\top}(\\mathbf{X}\\mathbf{X}^{\\top}\\circ\\mathbf{I})\\mathbf{G}}{\\operatorname{tr}((\\mathbf{X}\\mathbf{X}^{\\top}\\circ\\mathbf{I})\\circ(\\mathbf{G}\\mathbf{G}^{\\top}\\circ\\mathbf{I}))}\\in\\mathbb{R}^{m\\times m}.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Under the Assumption 1, we have $(\\mathbf{X}\\mathbf{X}^{\\top})_{i i}=1,i\\in[d]$ . Therefore, Eq. (18) and Eq. (19) can be simplified to ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\Phi=\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}},\\quad\\Psi=\\frac{\\mathbf{G}^{\\top}\\mathbf{G}}{n\\eta},\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "where $\\eta=\\operatorname{tr}((\\mathbf{X}\\mathbf{X}^{\\top}\\circ\\mathbf{I})\\circ(\\mathbf{G}\\mathbf{G}^{\\top}\\circ\\mathbf{I}))$ and $\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}=\\mathbf{X}^{\\top}(\\mathbf{G}\\mathbf{G}^{\\top}\\circ\\mathbf{I})\\mathbf{X}$ . Finally, the update rule of LNGD can be given by ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\pmb{\\theta}^{k+1}=\\pmb{\\theta}^{k}-\\alpha[\\eta(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{k})^{-1}\\otimes((\\mathbf{G}^{k})^{\\top}\\mathbf{G}^{k})^{-1}](\\mathbf{J}^{k})^{\\top}(\\mathbf{v}^{k}-\\mathbf{y}).\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "To analyze the global convergence of LNGD, we need the following two conditions as given in [34]. ", "page_idx": 16}, {"type": "text", "text": "Condition 1. The matrix $\\mathbf{G}^{0}(\\mathbf{G}^{0})^{\\top}$ is positive definite. ", "page_idx": 17}, {"type": "text", "text": "To verify this condition, we need the following two lemmas. ", "page_idx": 17}, {"type": "text", "text": "Lemma 1. Define $\\mathbf{K}_{i,j}^{\\infty}=\\mathbb{E}_{\\pmb{\\theta}\\sim\\mathcal{N}(\\mathbf{0},\\nu^{2}\\mathbf{I})}[\\mathbb{I}\\{\\pmb{\\theta}^{\\top}\\mathbf{x}_{i}\\ge0,\\pmb{\\theta}^{\\top}\\mathbf{x}_{j}\\ge0\\}].$ , $i,j\\in[n]$ , then we have the matrix ${\\bf K}^{\\infty}$ is strictly positive definite. ", "page_idx": 17}, {"type": "text", "text": "The result of this lemma has been given and discussed in [34]. We define $\\lambda_{\\mathbf{K}}=\\lambda_{\\operatorname*{min}}(\\mathbf{K}^{\\infty})\\geq0$ and matrix $\\mathbf{K}$ whose entry is given by ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\mathbf{K}_{i j}=\\frac{1}{m}\\sum_{r=1}^{m}\\mathbb{I}\\{\\pmb{\\theta}_{r}^{\\top}\\mathbf{x}_{i}\\geq0,\\pmb{\\theta}_{r}^{\\top}\\mathbf{x}_{j}\\geq0\\}=(\\mathbf{G}\\mathbf{G}^{\\top})_{i j},\\;\\forall\\;i,j\\in[n].\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Then we can show Condition 1 holds by the following lemma. ", "page_idx": 17}, {"type": "text", "text": "Lemma 2. If $\\begin{array}{r}{m=\\Omega\\left(\\frac{n}{\\lambda_{\\bf K}}\\log\\frac{n}{\\varepsilon}\\right)}\\end{array}$ , we have with probability at least $1-\\varepsilon$ that $\\begin{array}{r}{\\lambda_{\\mathrm{min}}({\\bf K}(0))\\geq\\frac{3}{4}\\lambda_{\\bf K}}\\end{array}$ . ", "page_idx": 17}, {"type": "text", "text": "Proof. Note that $\\mathbf K(0)$ can be written as the sum of random symmetric matrices ", "page_idx": 17}, {"type": "equation", "text": "$$\n{\\bf K}(0)=\\sum_{r=1}^{m}{\\bf K}(\\pmb{\\theta}_{r}),\\quad{\\bf K}_{i j}(\\pmb{\\theta}_{r})=\\frac{1}{m}\\mathbb{I}\\{\\pmb{\\theta}_{r}^{\\top}{\\bf x}_{i}\\geq0,\\pmb{\\theta}_{r}^{\\top}{\\bf x}_{j}\\geq0\\}.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Furthermore, we have ${\\bf K}(\\pmb\\theta_{r})$ are positive semi-definite and $\\begin{array}{r}{\\|\\mathbf{K}(\\pmb{\\theta}_{r})\\|_{2}\\leq\\mathrm{tr}(\\mathbf{K}(\\pmb{\\theta}_{r}))\\leq\\frac{n}{m}}\\end{array}$ . Thus, by the matrix Chernoff bound [37], we can obtain ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\operatorname{\\mathbb{P}}\\left[\\lambda_{\\operatorname*{min}}(\\mathbf{K}(0))\\leq(1-{\\frac{1}{4}})\\lambda_{\\mathbf{K}}\\right)\\right]\\leq n\\exp\\left(-{\\frac{1}{4^{2}}}{\\frac{\\lambda_{\\mathbf{K}}m}{n}}\\right).\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Let $\\begin{array}{r}{\\varepsilon=n\\,\\exp\\left(-\\frac{1}{4^{2}}\\frac{\\lambda_{\\bf K}m}{n}\\right)}\\end{array}$ , we have $\\begin{array}{r}{m=\\Omega\\left(\\frac{n}{\\lambda_{\\bf K}}\\log\\frac{n}{\\varepsilon}\\right)}\\end{array}$ . Proof complete. ", "page_idx": 17}, {"type": "text", "text": "This proof is similar to the Lemma 6 in [34], the difference is the definition of $\\mathbf{K}$ . For completeness of the proof, we also give the detailed proof here. By this lemma, we have $\\lambda_{\\operatorname*{min}}(\\mathbf{G}(0)\\dot{\\mathbf{G}}(0)^{\\top})=$ $\\begin{array}{r}{\\lambda_{\\mathrm{min}}(\\dot{\\bf K}(0))\\geq\\frac{3}{4}\\lambda_{\\bf K}>0}\\end{array}$ , which implies that Condition 1 holds. Next, we give the other condition. ", "page_idx": 17}, {"type": "text", "text": "Condition 2. For all parameters $\\pmb{\\theta}$ that satisfy $\\begin{array}{r}{\\|\\theta-\\theta^{0}\\|_{2}\\le\\frac{2\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}}{\\sqrt{\\lambda_{\\mathbf{K}}/2}}\\kappa\\mathbf{z}_{\\mathbf{x},\\mathbf{G}}}\\end{array}$ , there exists $0\\leq c<\\frac{1}{2}$ such that ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\|\\mathbf{J}-\\mathbf{J}^{0}\\|_{2}\\leq\\frac{\\sqrt{2}c}{4}\\frac{\\sqrt{\\lambda_{\\mathbf{K}}}}{\\kappa\\mathbf{z}_{\\mathbf{x},\\mathbf{G}}}.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "To show this condition holds, we need the following lemma. ", "page_idx": 17}, {"type": "text", "text": "Lemma 3. [34] For all weight vectors $\\pmb{\\theta}$ that satisfy $\\lVert\\pmb{\\theta}-\\pmb{\\theta}^{0}\\rVert_{2}\\leq R_{*}$ , we have probability at least $1-\\varepsilon$ that ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\|\\mathbf{J}-\\mathbf{J}^{0}\\|_{2}^{2}\\leq\\|\\mathbf{J}-\\mathbf{J}^{0}\\|_{\\mathbf{F}}^{2}\\leq\\frac{2n R^{2/3}}{\\nu^{2/3}\\varepsilon^{2/3}m^{1/3}}.\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "By taking R = 2\u2225\u221ay\u2212v0\u22252 $\\begin{array}{r}{R=\\frac{2\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}}{\\sqrt{\\lambda_{\\mathbf{K}}/2}}\\kappa\\mathbf{z}_{\\mathbf{x},\\mathbf{G}}}\\end{array}$ , we have $\\begin{array}{r}{\\|\\mathbf{J}-\\mathbf{J}^{0}\\|_{2}^{2}\\leq\\frac{64^{1/3}n\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}^{2/3}\\kappa_{\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}^{2/3}}{\\nu^{2/3}\\varepsilon^{2/3}m^{1/3}\\lambda_{\\mathbf{K}}^{1/3}}}\\end{array}$ 641/3n\u2225y\u2212v0\u222522/3\u03ba12/Z/3X3,G. Therefore, if we let $\\begin{array}{r}{m=\\Omega\\left(\\frac{n^{3}\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}^{2}\\kappa_{\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}^{8}}{\\nu^{2}\\varepsilon^{2}\\lambda_{\\mathbf{K}}^{4}}\\right)}\\end{array}$ the Condition 2 holds. What\u2019s more, we have probability at least $1-\\varepsilon$ that $\\begin{array}{r}{\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}^{2}=\\mathcal{O}\\left(\\frac{n}{\\varepsilon}\\right)}\\end{array}$ , which has been given in [31]. Thus we can write the condition of $m$ as $\\begin{array}{r}{m=\\Omega\\left(\\frac{n^{4}\\kappa_{\\mathbf{z}_{\\mathbf{X},\\mathbf{G}}}^{8}}{\\nu^{2}\\varepsilon^{3}\\lambda_{\\mathbf{K}}^{4}}\\right)}\\end{array}$ ", "page_idx": 17}, {"type": "text", "text": "Before giving the main result, we first give some necessary lemmas. ", "page_idx": 17}, {"type": "text", "text": "Lemma 4. If $\\begin{array}{r}{m=\\Omega\\left(\\frac{n^{4}\\kappa_{\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}^{8}}{\\nu^{2}\\varepsilon^{3}\\lambda_{\\mathbf{K}}^{4}}\\right)}\\end{array}$ , for all parameters $\\pmb{\\theta}$ that satisfy $\\begin{array}{r}{\\|\\theta-\\theta^{0}\\|_{2}\\leq\\frac{2\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}}{\\sqrt{\\lambda_{\\mathbf{G}}/2}}\\kappa\\mathbf{z}_{\\mathbf{x},\\mathbf{G}}}\\end{array}$ we have probability at least $1-\\varepsilon$ that $\\lambda_{\\operatorname*{min}}(\\mathbf{K})\\geq\\sqrt{\\lambda\\mathbf{\\kappa}/2}$ . ", "page_idx": 17}, {"type": "text", "text": "Proof. Combine Eq. (15), Eq. (17) and Assumption 1, we have $\\lVert\\mathbf{G}-\\mathbf{G}(0)\\rVert_{\\mathbf{F}}^{2}\\leq\\lVert\\mathbf{J}-\\mathbf{J}^{0}\\rVert_{\\mathbf{F}}^{2}$ . Let $\\begin{array}{r}{m=\\Omega\\left(\\frac{n^{4}\\kappa_{\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}^{8}}{\\nu^{2}\\varepsilon^{3}\\lambda_{\\mathbf{K}}^{4}}\\right)}\\end{array}$ and $\\begin{array}{r}{R=\\frac{2\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}}{\\sqrt{\\lambda_{\\mathbf{K}}/2}}\\kappa\\mathbf{z}_{\\mathbf{x},\\mathbf{G}}}\\end{array}$ , by Condition 2 and Lemma 3 we have ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\|{\\bf G}-{\\bf G}(0)\\|_{2}^{2}\\leq\\|{\\bf G}-{\\bf G}(0)\\|_{\\bf F}^{2}\\leq\\|{\\bf J}-{\\bf J}^{0}\\|_{\\bf F}^{2}}\\\\ &{\\qquad\\qquad\\qquad\\leq\\frac{c}{8}\\frac{\\lambda_{\\bf K}}{\\kappa_{{\\bf Z}_{{\\bf X},{\\bf G}}}^{2}}\\leq\\frac{c}{8}\\lambda_{\\bf K}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Therefore, ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\sigma_{\\mathrm{min}}(\\mathbf{G})\\geq\\sigma_{\\mathrm{min}}(\\mathbf{G}(0))-\\|\\mathbf{G}-\\mathbf{G}(0)\\|_{2}}\\\\ &{\\qquad\\qquad\\geq\\sqrt{\\frac{3}{4}}\\sqrt{\\lambda_{\\mathbf{K}}}-\\sqrt{\\frac{c}{8}}\\sqrt{\\lambda_{\\mathbf{K}}}\\geq\\frac{\\sqrt{2}}{2}\\sqrt{\\lambda_{\\mathbf{K}}},}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Note that the large $m$ is, the smaller $c$ is. Therefore, we can choose a slight larger $m$ satisfying this inequality. So we have ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\lambda_{\\operatorname*{min}}(\\mathbf{K})=\\lambda_{\\operatorname*{min}}(\\mathbf{G}\\mathbf{G}^{\\top})\\geq\\sqrt{\\frac{\\lambda_{\\mathbf{K}}}{2}}.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Proof complete. ", "page_idx": 18}, {"type": "text", "text": "Lemma 5. [38] Let A and $\\mathbf{B}$ be two positive define matrices, we have ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\lambda_{\\operatorname*{max}}(\\mathbf{A}\\circ\\mathbf{B})\\leq\\left(\\operatorname*{max}_{i}\\mathbf{A}_{i i}\\right)\\lambda_{\\operatorname*{max}}(\\mathbf{B}),\n$$", "text_format": "latex", "page_idx": 18}, {"type": "equation", "text": "$$\n\\lambda_{\\operatorname*{min}}(\\mathbf{A}\\circ\\mathbf{B})\\geq\\left(\\operatorname*{min}_{i}\\mathbf{A}_{i i}\\right)\\lambda_{\\operatorname*{min}}(\\mathbf{B}).\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Lemma 6. [39] Let $\\otimes$ denote the Kronecker product and $^*$ denote the column-wise Khatri-Rao product, we have ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{~~~(\\mathbf{A}\\otimes\\mathbf{B})(\\mathbf{C}*\\mathbf{D})=\\mathbf{AC}*\\mathbf{BD},}\\\\ &{(\\mathbf{A}*\\mathbf{B})^{\\top}(\\mathbf{A}*\\mathbf{B})=\\mathbf{A}^{\\top}\\mathbf{A}\\circ\\mathbf{B}^{\\top}\\mathbf{B}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Now, we give the convergence analysis of LNGD. ", "page_idx": 18}, {"type": "text", "text": "Theorem 3. (Convergence rate of LNGD) Under the Assumption $^{\\,l}$ and the assumption that $r a n k(\\mathbf{X})\\ =\\ d.$ . If we set the number of hidden units $m~=~\\dot{\\Omega}\\left(\\frac{n^{4}\\kappa_{\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}^{8}}{\\nu^{2}\\varepsilon^{3}\\lambda_{\\mathbf{G}}^{4}}\\right)$ , we i.i.d initialize \u03b8r \u223c N(0, \u03bdI), ar \u223c unif[{\u22121, +1}] for any r \u2208 [m], and we set the step size \u03b1 \u2264 ((11\u2212+c2)c2) . Then with probability at least $1-\\varepsilon$ over the random initialization, we have for $k=0,1,2,\\dots$ . ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}^{2}\\leq\\left(1-\\alpha\\right)^{k}\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}^{2}.\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Proof. Consider the predictive error at the $(k+1)$ -th iteration, we have ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\|\\mathbf{y}-\\mathbf{v}^{k+1}\\|_{2}^{2}=\\|\\mathbf{y}-\\mathbf{v}^{k}+\\mathbf{v}^{k}-\\mathbf{v}^{k+1}\\|_{2}^{2}}\\\\ &{=\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}^{2}-2(\\mathbf{y}-\\mathbf{v}^{k})^{\\top}(\\mathbf{v}^{k+1}-\\mathbf{v}^{k})+\\|\\mathbf{v}^{k+1}-\\mathbf{v}^{k}\\|_{2}^{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Next, we need to estimate the bound of prediction ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{v}^{k+1}-\\mathbf{v}^{k}=\\mathbf{v}(\\theta^{k}-\\alpha(\\mathbf{F}^{k})^{-1}(\\mathbf{J}^{k})^{\\top}(\\mathbf{v}^{k}-\\mathbf{y}))-\\mathbf{v}^{k}}\\\\ &{=-\\int_{\\xi=0}^{1}\\mathbf{a}\\mathbf{J}^{\\xi}(\\mathbf{F}^{k})^{-1}(\\mathbf{J}^{k})^{\\top}(\\mathbf{v}^{k}-\\mathbf{y})\\xi}\\\\ &{=-\\int_{\\xi=0}^{1}\\mathbf{a}^{k}(\\mathbf{F}^{k})^{-1}(\\mathbf{J}^{k})^{\\top}(\\mathbf{v}^{k}-\\mathbf{y})\\xi}\\\\ &{\\quad+\\int_{\\xi=0}^{1}(\\mathbf{2}^{k}-\\mathbf{2}^{\\xi})(\\mathbf{F}^{k})^{-1}(\\mathbf{J}^{k}-\\mathbf{y})\\xi}\\\\ &{=-\\underbrace{\\alpha\\mathbf{a}^{k}(\\mathbf{F}^{k})^{-1}(\\mathbf{J}^{k})^{\\top}(\\mathbf{v}^{k}-\\mathbf{y})}_{\\mathrm{Term~1}}}\\\\ &{\\quad+\\underbrace{\\alpha\\left(\\int_{\\xi=0}^{1}(\\mathbf{2}^{k}-\\mathbf{J}^{\\xi})\\xi\\right)(\\mathbf{F}^{k})^{-1}(\\mathbf{J}^{k})^{\\top}(\\mathbf{v}^{k}-\\mathbf{y})}_{\\mathrm{Term~0}},}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "where J\u03be = \u2202v(\u03b8\u03be ), \u2202\u03b8\u03be and $\\pmb{\\theta}^{\\xi}=\\xi\\pmb{\\theta}^{k}+(1-\\xi)\\pmb{\\theta}^{k+1}=\\pmb{\\theta}^{k}-\\xi\\alpha(\\mathbf{F}^{k})^{-1}(\\mathbf{J}^{k})^{\\top}(\\mathbf{v}^{k}-\\mathbf{y}).$ We first analyse Term 1. We omit the index $k$ in $\\mathbf{J}$ , $\\mathbf{G}$ and $\\mathbf{F}$ for simplicity. ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\mathrm{Term~}1=-\\alpha\\mathbf{J}\\mathbf{F}^{-1}\\mathbf{J}^{\\top}(\\mathbf{v}^{k}-\\mathbf{y})}\\\\ &{=\\alpha(\\mathbf{X}\\star\\mathbf{G})[\\eta\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\otimes(\\mathbf{G}^{\\top}\\mathbf{G})^{-1}](\\mathbf{X}^{\\top}\\ast\\mathbf{G}^{\\top})(\\mathbf{y}-\\mathbf{v}^{k})}\\\\ &{=\\alpha(\\eta\\mathbf{X}\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top}\\circ\\mathbf{G}(\\mathbf{G}^{\\top}\\mathbf{G})^{-1}\\mathbf{G}^{\\top})(\\mathbf{y}-\\mathbf{v}^{k})}\\\\ &{=\\alpha(\\eta\\mathbf{X}\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top}\\circ\\mathbf{I})(\\mathbf{y}-\\mathbf{v}^{k}),}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "The second equation follows the update rule of LNGD. The third equation is obtained according to the properties of Kronecker, Hadamard and Khatri-Rao products given in Lemma 6. The last equation uses the definition of generalized inverse as given by Eq. (16). By Lemma 5, we have ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\lambda_{\\operatorname*{max}}(\\mathbf{XZ}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top}\\circ\\mathbf{I})\\leq\\underset{i}{\\operatorname*{max}}(\\mathbf{XZ}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top})_{i i}\\lambda_{\\operatorname*{max}}(\\mathbf{I})}\\\\ &{\\qquad\\qquad\\qquad\\leq\\lambda_{\\operatorname*{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1})\\underset{i}{\\operatorname*{max}}(\\mathbf{XX}^{\\top})_{i i}=\\frac{1}{\\lambda_{\\operatorname*{min}}\\left(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}\\right)}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Therefore, we can bound Term 1 by ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\|\\mathrm{Term}_{1}\\|_{2}=\\|\\alpha(\\eta\\mathbf{X}\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top}\\circ\\mathbf{I})(\\mathbf{y}-\\mathbf{v}^{k})\\|_{2}}\\\\ &{\\qquad\\qquad\\leq\\alpha\\eta\\|\\mathbf{X}\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top}\\circ\\mathbf{I}\\|_{2}\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}\\leq\\frac{\\alpha\\eta}{\\lambda_{\\operatorname*{min}}\\left(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}\\right)}\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Based on the Condition 2, we have the following inequality ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\left\\|\\displaystyle\\int_{\\xi=0}^{1}(\\mathbf{J}^{k}-\\mathbf{J}^{\\xi})\\xi\\right\\|_{2}\\le\\displaystyle\\int_{\\xi=0}^{1}\\|\\mathbf{J}^{k}-\\mathbf{J}^{\\xi}\\|_{2}\\xi\\le\\|\\mathbf{J}^{k+1}-\\mathbf{J}^{k}\\|_{2}}\\\\ &{\\le\\|\\mathbf{J}^{k+1}-\\mathbf{J}^{0}\\|_{2}+\\|\\mathbf{J}^{k}-\\mathbf{J}^{0}\\|_{2}}\\\\ &{\\le\\displaystyle\\frac{\\sqrt{2}c}{2}\\frac{\\sqrt{\\lambda_{\\mathbf{K}}}}{\\kappa\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}\\le\\frac{c}{\\kappa\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}\\sqrt{\\lambda_{\\operatorname*{min}}(\\mathbf{G}\\mathbf{G}^{\\top})}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Next, we bound Term 2. By Eq. (23), we have ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\|\\mathrm{Term~}2\\|_{2}=\\bigg\\|\\alpha\\left(\\int_{\\xi=0}^{1}({\\bf J}^{k}-{\\bf J}^{\\xi})\\xi\\right)({\\bf F}^{k})^{-1}({\\bf J}^{k})^{\\top}({\\bf v}^{k}-{\\bf y})\\bigg\\|_{2}}\\\\ &{\\le\\frac{C\\alpha}{K_{2K,\\alpha}}\\sqrt{\\lambda_{\\operatorname*{min}}({\\bf G}{\\bf G}^{\\top})}\\|({\\bf F}^{k})^{-1}({\\bf J}^{k})^{\\top}\\|_{2}\\|{\\bf J}-{\\bf v}^{k}\\|_{2}}\\\\ &{=\\frac{C\\alpha}{K_{2K,\\alpha}}\\sqrt{\\lambda_{\\operatorname*{min}}({\\bf G}{\\bf G}^{\\top})}\\|({\\boldsymbol\\eta}{\\bf Z}_{{\\bf X},\\alpha}^{-1}\\otimes({\\bf G}^{\\top}{\\bf G})^{-1})({\\bf X}^{\\top}*{\\bf G}^{\\top})\\|_{2}\\|{\\bf J}-{\\bf v}^{k}\\|_{2}}\\\\ &{=\\frac{C\\alpha}{K_{2K,\\alpha}}\\sqrt{\\lambda_{\\operatorname*{min}}({\\bf G}{\\bf G}^{\\top})}\\|{\\boldsymbol\\eta}{\\bf Z}_{{\\bf X},{\\bf G}}^{-1}{\\bf X}^{\\top}*({\\bf G}^{\\top}{\\bf G})^{-1}{\\bf G}^{\\top}\\|_{2}\\|{\\bf y}-{\\bf v}^{k}\\|_{2}}\\\\ &{=\\frac{C\\alpha}{K_{2K,\\alpha}}\\sqrt{\\lambda_{\\operatorname*{min}}({\\bf G}{\\bf G}^{\\top})}\\|{\\boldsymbol\\eta}{\\bf Z}_{{\\bf X},{\\bf G}}^{-1}{\\bf X}^{\\top}*{\\bf G}^{\\top}({\\bf G}{\\bf G}^{\\top})^{-1}({\\bf G}{\\bf G}^{\\top})^{-1}{\\bf G}{\\bf G}^{\\top}\\|_{2}\\|{\\bf y}-{\\bf v}^{k}\\|_{2}}\\\\ &{=\\frac{C\\alpha}{K_{2K,\\alpha}}\\sqrt{\\lambda_{\\operatorname*{min}}({\\bf G}{\\bf G}^{\\top})}\\|{\\bf Z}_{{\\bf X},{\\bf G}}^{-1}{\\bf X}^{\\top}*{\\bf G}^{\\top}({\\bf G}{\\bf G}^ \n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Define $\\Delta=\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top}*\\mathbf{G}^{\\top}(\\mathbf{G}\\mathbf{G}^{\\top})^{-1}$ , then we have ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\|\\Delta\\|_{2}=\\sigma_{\\operatorname*{max}}(\\Delta)=\\sqrt{\\lambda_{\\operatorname*{max}}(\\Delta^{\\top}\\Delta)}}\\\\ &{\\qquad=\\sqrt{\\lambda_{\\operatorname*{max}}(\\mathbf{X}\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top}\\circ(\\mathbf{G}\\mathbf{G}^{\\top})^{-1})}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Similar to Eq. (21), by Lemma (5) we can prove ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\|\\Delta\\|_{2}\\leq\\frac{1}{\\lambda_{\\operatorname*{min}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}\\frac{1}{\\sqrt{\\lambda_{\\operatorname*{min}}(\\mathbf{G}\\mathbf{G}^{\\top})}}.\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Combine Eq. (24) and Eq. (26), we have ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\|\\mathrm{Term}_{2}\\|_{2}\\leq\\frac{c\\alpha\\eta}{\\kappa_{\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}}\\sqrt{\\lambda_{\\operatorname*{min}}(\\mathbf{G}\\mathbf{G}^{\\top})}\\frac{1}{\\lambda_{\\operatorname*{min}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}\\frac{1}{\\sqrt{\\lambda_{\\operatorname*{min}}(\\mathbf{G}\\mathbf{G}^{\\top})}}\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}}\\\\ &{=\\frac{c\\alpha\\eta}{\\lambda_{\\operatorname*{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Combine Eq. (20), Eq. (27) and Eq. (22), we can obtain ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\|\\mathbf{y}-\\mathbf{v}^{k+1}\\|_{2}^{2}=\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}^{2}-2(\\mathbf{y}-\\mathbf{v}^{k})^{\\top}(\\mathbf{v}^{k+1}-\\mathbf{v}^{k})+\\|\\mathbf{v}^{k+1}-\\mathbf{v}^{k}\\|_{2}^{2}}\\\\ &{\\qquad\\qquad\\qquad=\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}^{2}-2\\alpha(\\mathbf{y}-\\mathbf{v}^{k})^{\\top}\\mathbf{J}^{k}(\\mathbf{F}^{k})^{-1}(\\mathbf{J}^{k})^{\\top}(\\mathbf{y}-\\mathbf{v}^{k})}\\\\ &{\\qquad\\qquad\\qquad+2\\alpha(\\mathbf{y}-\\mathbf{v}^{k})^{\\top}\\left(\\int_{\\xi=0}^{1}(\\mathbf{J}^{k}-\\mathbf{J}^{\\xi})\\xi\\right)(\\mathbf{F}^{k})^{-1}(\\mathbf{J}^{k})^{\\top}(\\mathbf{y}-\\mathbf{v}^{k})}\\\\ &{\\qquad\\qquad+\\|\\mathbf{v}^{k+1}-\\mathbf{v}^{k}\\|_{2}^{2}}\\\\ &{\\qquad\\qquad\\qquad\\leq\\left(1-\\frac{2\\alpha\\eta}{\\lambda_{\\operatorname*{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}+\\frac{2c\\alpha\\eta}{\\lambda_{\\operatorname*{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}+\\frac{\\alpha^{2}\\eta^{2}}{\\lambda_{\\operatorname*{min}}^{2}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}\\right.}\\\\ &{\\qquad\\qquad\\qquad\\left.2c\\alpha^{2}\\eta^{2}\\right.}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\left.\\lambda_{\\operatorname*{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})\\lambda_{\\operatorname*{min}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})+\\frac{c^{2}\\alpha^{2}\\eta^{2}}{\\lambda_{\\operatorname*{max}}^{2}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}\\right)\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}^{2}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "In the last second inequality, we use the fact that $\\begin{array}{r}{\\lambda_{\\operatorname*{min}}(\\mathbf{X}\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top}\\circ\\mathbf{I})\\geq\\frac{1}{\\lambda_{\\operatorname*{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}}\\end{array}$ ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{-\\;\\frac{\\alpha\\eta}{\\lambda_{\\mathrm{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}+\\frac{2c\\alpha\\eta}{\\lambda_{\\mathrm{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}+\\frac{\\alpha^{2}\\eta^{2}}{\\lambda_{\\mathrm{min}}^{2}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}}\\\\ &{+\\,\\frac{2c\\alpha^{2}\\eta^{2}}{\\lambda_{\\mathrm{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})\\lambda_{\\mathrm{min}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}+\\frac{c^{2}\\alpha^{2}\\eta^{2}}{\\lambda_{\\mathrm{max}}^{2}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}\\leq0,}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "we have ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\alpha\\leq\\frac{(1-2c)\\lambda_{\\operatorname*{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}{(1+c)^{2}\\eta}\\leq\\frac{(1-2c)}{(1+c)^{2}},\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "and ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\|\\mathbf{y}-\\mathbf{v}^{k}\\|_{2}^{2}\\leq(1-\\alpha)^{k}\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}^{2}.\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "This completes the proof. ", "page_idx": 20}, {"type": "text", "text": "So far, we have already proved Theorem 3 under the an assumption that the parameters stay close to the initialization point. We now verify this assumption by the following lemma. ", "page_idx": 20}, {"type": "text", "text": "Lemma 7. If Conditions 1 and 2 hold, then as long as $\\begin{array}{r}{\\lambda_{\\mathrm{min}}({\\bf G}{\\bf G}^{\\top})\\geq\\frac{1}{2}\\lambda_{\\bf K}.}\\end{array}$ , we have ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\|\\pmb{\\theta}^{k+1}-\\pmb{\\theta}^{0}\\|_{2}\\leq\\frac{2\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}}{\\sqrt{\\lambda_{\\mathbf{K}}/2}}\\kappa\\mathbf{z}_{\\mathbf{x},\\mathbf{G}}.\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "Proof. By the update rule of LNGD, we have ", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\|\\theta^{k+1}-\\theta^{0}\\|_{2}=\\left\\|\\displaystyle\\sum_{t=0}^{k}\\alpha(\\mathbf{F}^{t})^{-1}(\\mathbf{J}^{t})^{\\top}(\\mathbf{y}-\\mathbf{v}^{t})\\right\\|_{2}}\\\\ &{\\le\\alpha\\displaystyle\\sum_{t=0}^{k}\\|\\|\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}^{-1}\\mathbf{X}^{\\top}\\ast(\\mathbf{G}^{t})^{\\top}(\\mathbf{G}^{t}(\\mathbf{G}^{t})^{\\top})^{-1}\\|_{2}\\|\\mathbf{y}-\\mathbf{v}^{t}\\|_{2}}\\\\ &{\\le\\alpha\\displaystyle\\sum_{t=0}^{k}\\frac{1}{\\lambda_{\\operatorname*{min}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}\\frac{1}{\\sqrt{\\lambda_{\\mathbf{K}}/2}}\\|\\mathbf{y}-\\mathbf{v}^{t}\\|_{2}}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\leq\\alpha\\displaystyle\\sum_{t=0}^{k}\\frac{\\sqrt{2/\\lambda_{\\mathbf{K}}}}{\\lambda_{\\operatorname*{min}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}\\left(1-\\frac{\\alpha}{\\lambda_{\\operatorname*{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}\\right)^{t/2}\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}}\\\\ &{\\leq\\frac{2\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}}{\\sqrt{\\lambda_{\\mathbf{K}}/2}}\\frac{\\lambda_{\\operatorname*{max}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}{\\lambda_{\\operatorname*{min}}(\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}})}=\\frac{2\\|\\mathbf{y}-\\mathbf{v}^{0}\\|_{2}}{\\sqrt{\\lambda_{\\mathbf{K}}/2}}\\kappa_{\\mathbf{Z}_{\\mathbf{X},\\mathbf{G}}}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 20}, {"type": "text", "text": "This completes the proof. ", "page_idx": 20}, {"type": "text", "text": "E Experiments ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "E.1 Setup of CIFAR-10 ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "The training of ResNet-18 [44] on the CIFAR-10 [40] dataset serves as a fundamental experiment in the field of image classification. In this subsection, we present a comparison of LNGD with several established baselines including SGD with momentum (referred to as SGD), ADAM [6], and KFAC. We follow the standard experimental settings and employ a commonly used data augmentation scheme involving random crop and horizontal flip. The initial learning rate is multiplied by 0.1 every 40 epochs. The update intervals for the curvature matrix and inverse matrix correlating with KFAC and LNGD are set to be 100. All experimental runs are conducted over a duration of 200 epochs. ", "page_idx": 21}, {"type": "text", "text": "E.2 Setup of ImageNet ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "The implementation of ResNet50 [44] follows the TensorFlow version which can be found in the website 3. We use the linear warmup strategy [41] in the first 5 epochs for SGD, ADAM and KFAC. The update intervals for the curvature matrix and inverse matrix correlating with KFAC and LNGD are set to be 500. For SGD and Adam, the max epoch is set to be 80, while for KFAC and LNGD, the max epoch is set to be 50. SGD uses the cosine learning rate updating strategy and is set to be $\\alpha_{t}=0.00\\dot{1}+0.5*(\\alpha_{0}-0.001)*(1+\\cos(2*0.47*\\pi*\\dot{t}/m a x\\frac{e p o c\\dot{h})}{e p o c\\dot{h})})$ , where $t$ is the number of epochs. For Adam, KFAC and LNGD, the learning rate uses the exponential updating strategy $\\alpha_{t}=\\alpha_{0}*(1-t/m a x\\_e p o c h)^{E}$ , where $E$ is decay rate $\\in\\{2,3,4,5,6\\}$ . $\\alpha_{0}$ is the initial learning rate tuned using a grid search with values $\\alpha\\in\\{1e-4,1e-\\mathrm{\\dot{3}},\\ldots,1\\}$ . ", "page_idx": 21}, {"type": "text", "text": "E.3 Ablation Analysis ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "E.3.1 Setup ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "In this subsection, to further elucidate the contributions of distinct components within the LNGD, a series of ablation studies are performed. The ablation experiments aim to isolate the effects of adaptive learning rate and sampling optimization on the LNGD\u2019s performance. The variant denoted as LNGD-lr corresponds to the iteration of the algorithm that employs an adaptive learning rate, but does not incorporate sampling optimization. Conversely, LNGD-sample represents the iteration that utilizes sampling optimization, but does not implement an adaptive learning rate. These ablation studies are executed on the ImageNet-1K dataset, All hyperparameters are maintained consistent with those outlined in the ImageNet training section. ", "page_idx": 21}, {"type": "text", "text": "E.3.2 Results ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "The results of the ablation experiments, as shown in Fig.7 and Table5, reveal some interesting findings. Specifically, analyzing the training loss and testing accuracy versus epoch, we observe that LNGD-lr achieves the fastest decrease in training loss and the most rapid initial increase in testing accuracy within the initial few epochs. This can be attributed to the fact that LNGD-lr computes the exact Fisher information matrix at each epoch without using any approximation sampling strategy. However, this advantage comes at the cost of increased computational complexity, leading to a $15\\%$ increase in the time required to reach a top-1 testing accuracy of $75.9\\%$ compared to LNGD, which employs both the sampling approximation strategy and the adaptive learning rate strategy at each layer. Moreover, LNGD-lr also takes $5\\%$ more time compared to LNGD-sample, which only utilizes the sampling approximation strategy. Notably, LNGD-sample exhibits the slowest decrease in training loss and increase in testing accuracy during the initial epochs due to its approximation sampling of the Fisher information matrix at each step. Nevertheless, when considering the time dimension, LNGD-sample still achieves a faster speed compared with LNGD-lr in reaching a final testing accuracy of $75.9\\%$ due to the significant reduction in the computation of the exact Fisher information matrix. In contrast to LNGD, LNGD-sample takes $9\\%$ more time to reach testing accuracy of $75.9\\%$ due to the absence of automatic scaling learning rate. In conclusion, considering the constraints of limited computational resources and time, LNGD demonstrates superior optimizing performance. ", "page_idx": 21}, {"type": "text", "text": "Table 5: Detailed statistics of abalation study when top-1 testing accuracy achieves $75.9\\%$ ", "page_idx": 22}, {"type": "table", "img_path": "niG3Yyb6oA/tmp/abc3f4cc965e55ae00fd732bccaab2141fd899fce80449b26f677aa3016fb675.jpg", "table_caption": [], "table_footnote": [], "page_idx": 22}, {"type": "image", "img_path": "niG3Yyb6oA/tmp/eee6607ae05b96d30ef91e134efb3214ceafe674b366a4857f1ed2fca2dbeeee.jpg", "img_caption": ["Figure 7: The optimization performance of variants of LNGD. "], "img_footnote": [], "page_idx": 22}, {"type": "text", "text": "E.4 Results of More Comparisons ", "text_level": 1, "page_idx": 22}, {"type": "table", "img_path": "niG3Yyb6oA/tmp/c7dd07b04c7d52b0e2af9601eadaab4d27b456234856f81cb414a97e1efda920.jpg", "table_caption": ["Table 6: Detailed statistics on CIFAR-10 when top-1 testing accuracy achieves $91\\%$ . "], "table_footnote": [], "page_idx": 22}, {"type": "text", "text": "In order to further validate the effectiveness of LNGD, we conduct additional experiments on the CIFAR-10 dataset, in which three methods including EKFAC [22], TKFAC [15], and $\\mathrm{NG}+$ [17] are added for comparison. The detailed statistics are presented in Table 6. From this table, we observe that LNGD achieves a testing accuracy of $91\\%$ with the fewest epochs and the shortest total time. Furthermore, LNGD exhibits the smallest computational time per epoch. Additionally, due to the efficient Fisher information matrix approximation strategy adopted by $\\mathrm{NG}+$ , it can significantly reduce the computational time compared to EKFAC and TKFAC. ", "page_idx": 22}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Justification: The main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 23}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Justification: Due to space constraints in the main text, we have not created a separate \"Limitations\" section. However, for each theory presented, we explicitly outline any strong assumptions and provide justification for the validity of these theories. Additionally, a thorough comparison with related work is furnished in the appendix. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 23}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Justification: For each theoretical result, we provide the full set of assumptions and a complete (and correct) proof. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 24}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Justification: We provide every detail of the the methodology and experimental setup to ensure the reproducibility of the main experimental results presented in the paper. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 24}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 25}, {"type": "text", "text": "Answer: [No] ", "page_idx": 25}, {"type": "text", "text": "Justification: Due to the involvement of proprietary code resources, the disclosure of such materials must adhere to the company\u2019s relevant disclosure processes. If necessary, data and code can be made available upon request. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 25}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Justification: We specify all the training and test details necessary to understand the results. Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 25}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: For each experiment, we average the results of 5 runs and the hyper-parameter settings are the best values randomly searched for many times. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 25}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 26}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: We provide sufficient information on the computer resources needed to reproduce the experiments. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 26}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: The research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 26}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] Justification: There is no societal impact of the work performed. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: \u2022 The answer NA means that there is no societal impact of the work performed. ", "page_idx": 26}, {"type": "text", "text": "\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 27}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 27}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 27}, {"type": "text", "text": "Justification: The paper poses no such risks. Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 27}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 27}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 27}, {"type": "text", "text": "Justification: For each relevant work, whether it be code or data, we have provided appropriate citations. ", "page_idx": 27}, {"type": "text", "text": "Guidelines: ", "page_idx": 27}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 27}, {"type": "text", "text": "", "page_idx": 28}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 28}, {"type": "text", "text": "Justification: We present an optimization method, which does not involve the release of new assets. ", "page_idx": 28}, {"type": "text", "text": "Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 28}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 28}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 28}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 28}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 28}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 28}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 28}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 28}, {"type": "text", "text": "", "page_idx": 29}]