[{"type": "text", "text": "Memory-Efficient LLM Training with Online Subspace Descent ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Kaizhao Liang\u2020, Bo Liu\u2020, Lizhang Chen\u2020, Qiang Liu\u2020 \u2020The University of Texas at Austin {kaizhaol,bliu,lzchen,lqiang}@utexas.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Recently, a wide range of memory-efficient LLM training algorithms have gained substantial popularity. These methods leverage the low-rank structure of gradients to project optimizer states into a subspace using projection matrix found by singular value decomposition (SVD). However, convergence of these algorithms is highly dependent on the update rules of their projection matrix. In this work, we provide the first convergence guarantee for arbitrary update rules of projection matrix. This guarantee is generally applicable to optimizers that can be analyzed with Hamiltonian Descent, including most common ones, such as LION, Adam. Inspired by our theoretical understanding, we propose Online Subspace Descent, a new family of subspace descent optimizer without SVD. Instead of updating the projection matrix with eigenvectors, Online Subspace Descent updates the projection matrix with online PCA. Online Subspace Descent is flexible and introduces only minimum overhead to training. We show that for the task of pretraining LLaMA models ranging from 60M to 7B parameters on the C4 dataset, Online Subspace Descent achieves lower perplexity and better downstream tasks performance than state-ofthe-art low-rank training methods across different settings and narrows the gap with full-rank baselines.1 ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "The continual advancement in training large language models (LLMs) presents a compelling challenge in balancing computational efficiency with model performance. As the scope and complexity of these models grow, so does the necessity for innovative strategies that optimize memory usage without compromising the learning capabilities of the model. Recent approaches in low-rank adaptation strategies, including Stochastic Subspace Descent [13], LoRA [11], ReLoRA [15], Gradient LowRank Projection (GaLore) [25] and Sketchy [9] , have paved the way for memory-efficient training by utilizing a periodically updated low-rank projection matrix to manage parameter updates. In particular, GaLore and Sketchy both utilize expensive singular value decomposition to determine the projection matrix, whereas stochastic subspace descent suggests using random matrices as projection matrices and provides convergence analysis on convex functions and objectives. However, to the best of our knowledge, no one has offered any guarantee of convergence for this class of methods on non-convex functions and objectives. ", "page_idx": 0}, {"type": "text", "text": "In this work, we provide the first convergence guarantee for arbitrary update rules of the projection matrix. This guarantee is significant because it is broadly applicable to a wide range of optimizers that can be analyzed within the Hamiltonian descent framework [18]. By establishing this convergence guarantee, we demonstrate that our approach is not limited to specific or narrowly defined update rules, but can be extended to include many commonly used optimizers in the field. In particular, this ", "page_idx": 0}, {"type": "text", "text": "1: Required: Optimizer OptimizerW, learning rate $\\epsilon_{t}^{W}$ , weight decay $\\lambda^{W}$ for model weights $\\mathbf{}W_{t}$ ; and {OptimizerP, $\\epsilon_{t}^{P},\\lambda^{P}\\}$ for the projection matrix $\\mathbf{}P_{t}$ . Proper initialization.   \n2: for iteration $t$ do   \n3: Calculate gradient $\\boldsymbol{G}_{t}=\\nabla L(\\boldsymbol{W}_{t})$ ; Update model weights $\\mathbf{}W_{t}$ by $(\\hat{\\Delta}_{t},\\ \\hat{S}_{t})=0\\mathrm{pt}\\mathrm{i}\\mathrm{mi}z\\mathrm{er}\\mathbb{M}(P_{t}^{\\top}G_{t},\\hat{S}_{t-1}),\\quad W_{t+1}=W_{t}+\\epsilon_{t}^{W}(P_{t}\\hat{\\Delta}_{t+1}-\\lambda^{W}W_{t})$   \n4: Calculate $\\boldsymbol{G}_{t}^{P}=\\nabla L_{\\boldsymbol{G}_{t}}(P_{t})$ for $L_{G_{t}}(\\cdot)$ in Eq (6); Update the projection $\\mathbf{}P_{t}$ by $(\\Delta_{t}^{P},S_{t}^{P})={\\tt O p t i m i z e r P}(G_{t}^{P},\\ \\ S_{t-1}^{P}),\\ \\ \\ \\ \\ \\ \\ \\ P_{t+1}=P_{t}+\\epsilon_{t}^{P}(\\Delta_{t}^{P}-\\lambda^{P}P_{t})$ ", "page_idx": 1}, {"type": "text", "text": "5: end for ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": ": Remark: We added weight decay as a common heuristic. We recommend using Adam for both optimizers, and set $\\epsilon_{t}^{P}=\\alpha\\epsilon_{t}^{W}$ with a constant $\\alpha$ (e.g., $\\alpha=5$ ), and $\\lambda^{W}=\\lambda^{P}$ . 2 ", "page_idx": 1}, {"type": "text", "text": "includes popular algorithms such as LION [4] and Adam [12], which are widely used in various machine learning and optimization tasks. Our results therefore offer a robust theoretical foundation for understanding and analyzing the behavior of these optimizers, ensuring their effectiveness and reliability in diverse applications. ", "page_idx": 1}, {"type": "text", "text": "Inspired by our theoretical understanding, we introduce a novel family of memory-efficient optimizers named Online Subspace Descent, which incorporates a dynamically changing projection matrix, replacing the conventional periodic updating approach (SVD) with online PCA. By allowing the projection matrix to evolve in response to the changing gradient landscape, Online Subspace Descent enhances the model\u2019s ability to navigate the parameter space more effectively. This dynamic adaptation aligns more closely with the natural progression of learning in deep neural networks, which is characterized by changes in the importance of different characteristics and interactions as training progresses. Through extensive experiments and comparative analysis, we demonstrate that our approach presents lower perplexity in pretraining LLaMA models (ranging from 60M to 1B parameters) on the C4 dataset compared to state-of-the-art low-rank training methods, closing the perplexity gap with full-rank baselines on language model pretraining. ", "page_idx": 1}, {"type": "text", "text": "2 Optimization Background ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "The training of deep learning models reduces to an optimization problem ", "page_idx": 1}, {"type": "equation", "text": "$$\n\\operatorname*{min}_{W}L(W),\n$$", "text_format": "latex", "page_idx": 1}, {"type": "text", "text": "where $W$ is the set of weight matrices of the model. For simplicity, we assume $W\\in\\mathbb{R}^{n\\times m}$ is a single matrix of size $(n,m)$ without loss of generality. For notation, we write $\\langle A,B\\rangle=\\operatorname{tr}(A^{\\top}B)$ for inner products of matrices, and $\\left\\|A\\right\\|^{2}=\\operatorname{tr}(A^{\\top}A)$ the Frobenius norm. We use $A\\odot B$ to denote the elementwise product, and $A^{\\odot2}=\\overset{\\cdot}{A}\\odot A$ . ", "page_idx": 1}, {"type": "text", "text": "Example 2.1. Update rules of common optimizers: ", "page_idx": 1}, {"type": "equation", "text": "$$\n\\begin{array}{l l l}{i e n t\\,D e s c e n t:}&{\\pmb{W}_{t+1}=\\pmb{W}_{t}-\\epsilon_{t}\\nabla L(\\pmb{W}_{t}),}&\\\\ {M o m e n t u m:}&{\\pmb{W}_{t+1}=\\pmb{W}_{t}-\\epsilon_{t}\\pmb{M}_{t},}&{M_{t}=(1-\\beta)\\nabla L(\\pmb{W}_{t})+\\beta\\pmb{M}_{t-1},}\\\\ {L i o n\\!\\cdot\\!\\mathcal{K}\\,l^{\\mathcal{I}}\\,j:}&{\\pmb{W}_{t+1}=\\pmb{W}_{t}-\\epsilon_{t}\\nabla K(\\pmb{N}_{t}),}&{\\pmb{N}_{t}=(1-\\beta_{1})\\nabla L(\\pmb{W}_{t})+\\beta_{1}\\pmb{M}_{t}}\\\\ &{\\pmb{M}_{t}=(1-\\beta_{2})\\nabla L(\\pmb{W}_{t})+\\beta_{2}\\pmb{M}_{t-1},}&\\\\ {A d a m\\,[l^{2}]:}&{\\pmb{W}_{t+1}=\\pmb{W}_{t}-\\epsilon_{t}\\frac{M_{t}}{\\sqrt{\\pmb{V}_{t}}+e},}&{M_{t}=(1-\\beta_{1t})\\nabla L(\\pmb{W}_{t})+\\beta_{1t}\\pmb{M}_{t-1},}\\\\ &{\\pmb{V}_{t}=(1-\\beta_{2t})\\nabla L(\\pmb{W}_{t})^{\\odot2}+\\beta_{2t}\\pmb{V}_{t-1},}&\\end{array}\n$$", "text_format": "latex", "page_idx": 1}, {"type": "text", "text": "where $\\epsilon_{t}$ are step sizes, and $M_{t},V_{t}$ are the first and second order momentum, and $\\beta,\\beta_{1},\\beta_{2}$ are momentum coefficients in $(0,1)$ , with $\\begin{array}{r}{\\beta_{i t}=\\frac{\\beta_{i}-\\beta_{i}^{t+1}}{1-\\beta_{i}^{t+1}}}\\end{array}$ \u03b21i\u2212\u2212\u03b2\u03b2ti+1, i = 1, 2 for \u03b21, \u03b22 \u2208(0, 1) in Adam, and K is any convex function with $\\nabla K(\\mathbf{0})=\\mathbf{0}$ for Lion- $\\kappa\\,[4J,$ , and Lion $I5J$ uses $K(\\pmb{X})=\\|\\pmb{X}\\|_{1,1}$ and $\\nabla{\\mathcal{K}}(X)=\\mathrm{sign}(X)$ . ", "page_idx": 1}, {"type": "text", "text": "These optimizers can be unifiedly viewed as updating $\\mathbf{}W_{t}$ together with an optimizer state $S_{t}$ : ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\boldsymbol{W}_{t+1}=\\boldsymbol{W}_{t}+\\phi_{t}(\\boldsymbol{S}_{t}),\n$$", "text_format": "latex", "page_idx": 2}, {"type": "equation", "text": "$$\nS_{t}=\\psi_{t}(S_{t-1},\\nabla L(\\boldsymbol{W}_{t})),\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "with some mapping $\\phi_{t},\\psi_{t}$ . We have $S_{t}\\,=\\,M_{t}$ for momentum and $\\boldsymbol{S}_{t}\\,=\\,\\{\\boldsymbol{M}_{t},\\boldsymbol{V}_{t}\\}$ for Adam. Note that both $M_{t},V_{t}$ are of the same size as the model weights $\\mathbf{}W_{t}$ , resulting in high memory consumption for large models. This issue is particularly pronounced for Adam, which typically yields the best performance for large language models (LLMs) but incurs the highest memory cost due to the need to maintain both $M_{t}$ and $\\mathbf{}V_{t}$ . One key challenge is to retain the high performance of Adam while enhancing its memory efficiency. ", "page_idx": 2}, {"type": "text", "text": "Hamiltonian+Descent One powerful approach to studying the dynamic properties of optimizers is to examine their continuous-time ODE forms in the limit of infinitesimal step size. The continuoustime forms provide clearer insights into the asymptotic convergence of the algorithm, abstracting away the choices of step size, discretization, and stochastic errors. The underlying logic is that a \"sound\" optimizer should be guaranteed to converge to local optima of the loss, at least when using sufficiently small step sizes. ", "page_idx": 2}, {"type": "text", "text": "Inspired by [4, 18], we observe that the continuous-time form of many common optimizers yields a Hamiltian $^{+}$ Descent structure, ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\begin{array}{l}{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}=\\partial_{S}H(W_{t},S_{t})-\\Phi\\big(\\partial_{W}H(W_{t},S_{t})\\big)}\\\\ {\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}S_{t}=-\\partial_{W}H\\big(W_{t},S_{t}\\big)-\\Psi\\big(\\partial_{S}H(W_{t},S_{t})\\big),}\\end{array}\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $H(W,S)$ is a Hamiltonian (or Lyapunov) function that satisfies ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\operatorname*{min}_{\\pmb{S}}H(\\pmb{W},\\pmb{S})=L(\\pmb{W}),\\quad\\forall\\pmb{W},\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "so that minimizing $L(W)$ reduces to minimizing $H(W,S)$ ; and $\\Phi(\\cdot),\\Psi(\\cdot)$ are two monotonic mappings satisfying ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\|X\\|_{\\Phi}^{2}:=\\langle X,\\Phi(X)\\rangle\\geq0,\\qquad\\qquad\\|X\\|_{\\Psi}^{2}:=\\langle X,\\Psi(X)\\rangle\\geq0,\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "With $\\Phi(X)=\\Psi(X)=0$ , the system in (2) reduces to the standard Hamiltonian system that keeps $H(W_{t},S_{t})=c o n s t$ along the trajectory. When adding the descending components with $\\Phi$ and $\\Psi$ , the system then keeps $H(W,S)$ monotonically non-decreasing: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}H(W_{t},S_{t})=\\left<\\partial_{W}H_{t},\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}\\right>+\\left<\\partial_{S}H_{t},\\frac{\\mathrm{d}}{\\mathrm{d}t}S_{t}\\right>}\\\\ &{\\quad\\quad\\quad\\quad=<\\partial_{W}H_{t},\\partial_{S}H_{t}-\\Phi(\\partial_{W}H_{t})\\rangle+\\left<\\partial_{S}H_{t},-\\partial_{W}H_{t}-\\Psi(\\partial_{S}H_{t})\\right>}\\\\ &{\\quad\\quad\\quad\\quad=-\\left\\|\\partial_{W}H_{t}\\right\\|_{\\Phi}^{2}-\\left\\|\\partial_{S}H_{t}\\right\\|_{\\Psi}^{2}\\leq0,}\\end{array}\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where we write $\\partial_{W}H_{t}=\\partial_{W}H(W_{t},S_{t})$ and similarly for $\\partial_{S}H_{t}$ . The main idea is that the cross terms $\\langle\\partial_{W}H_{t},\\partial_{S}H_{t}\\rangle$ are canceled, leaving only the negative terms. ", "page_idx": 2}, {"type": "text", "text": "Example 2.2. The momentum method yields following continuous-time form and Hamiltonian: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}=-M_{t},\\qquad\\frac{\\mathrm{d}}{\\mathrm{d}t}M_{t}=a(\\nabla L(W_{t})-M_{t}),\\qquad\\quad w i t h\\quad\\ H(W,M)=L(W)+\\frac{\\|M\\|^{2}}{2a}.\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "Example 2.3. Adam $[I2J$ yields the following continuous-time form and Hamiltonian, ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\frac{\\mathrm d}{\\mathrm d t}W_{t}=-\\frac{M_{t}}{\\sqrt{V_{t}}+e},\\quad\\frac{\\mathrm d}{\\mathrm d t}M_{t}=a(\\nabla L(W_{t})-M_{t}),\\quad\\frac{\\mathrm d}{\\mathrm d t}V_{t}=b(\\nabla L(W_{t})^{\\odot2}-V_{t}),\n$$", "text_format": "latex", "page_idx": 2}, {"type": "equation", "text": "$$\nw i t h\\ \\ \\ \\ H({\\pmb W},{\\pmb M},{\\pmb V})=L({\\pmb W})+\\frac{1}{2a}\\left\\langle\\frac{\\pmb M}{\\sqrt{{\\pmb V}}+e},\\,{\\pmb M}\\right\\rangle,\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "for which we can show that $\\begin{array}{r}{\\frac{\\mathrm{d}}{\\mathrm{d}t}H(W_{t},M_{t},V_{t})\\leq0}\\end{array}$ when $a\\ge b/4$ . ", "page_idx": 2}, {"type": "text", "text": "Example 2.4. The Lion- $\\mathcal{K}$ optimizer [5, 4] (without weight decay) can be written into ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}=\\nabla\\mathcal{K}((1-b)M_{t}-b\\nabla L(W_{t})),\\qquad\\quad\\frac{\\mathrm{d}}{\\mathrm{d}t}M_{t}=-a(\\nabla L(W_{t})+M_{t}),\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where $a\\geq0$ , $b\\in[0,1]$ and $\\kappa(X)$ is any convex function that attains the minimum at $X=0$ . One of its Hamiltonians that yields the Hamiltonian $^+$ descent structure $(E q\\,(l3)$ in Chen et al. $I^{4J},$ ) is ", "page_idx": 2}, {"type": "equation", "text": "$$\nH({\\cal W},{\\cal M})=a L({\\cal W})+\\frac{1}{1-b}{\\cal K}((1-b){\\cal M}).\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "3 Memory-Efficient Optimizers via Online Subspace Descent ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "We introduce the idea of constructing memory efficient optimzers by descending in the subspaces that dynamically changes across iterations as motivated by GaLore [25] and Sketchy [9]. We first derive static subspace descent by restricting the whole optimization on a subspace (Section 3.1), and then propose to dynamically change the subspace across iterations as a heuristic to attain the optimization in the full space while only using subspace descent (Section 3.2). In particular, we propose to update the subspaces via continuous online PCA like updates to avoids the need of exact SVD like in GaLore and Sketchy (Section 3.2). Finally, we remark in Section 3.3 the heuristic nature of the derivation of the method and highlight the difficulty in theoretical understanding, which motivates our analysis based on Hamiltonian dynamics in Section 4. ", "page_idx": 3}, {"type": "text", "text": "3.1 Static Subspace Descent ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "One popular approach to improving memory efficiency is to confine the optimization to a lowdimensional space. To do this, we impose a low rank structure of $W=P\\hat{W}$ , where $P\\in\\mathbb{R}^{n\\times k}$ is a projection matrix to be determined later and $\\hat{W}\\in\\mathbb{R}^{k\\times m}$ is a dimension-reduced parameter. When $k\\ll n$ , $_{P}$ and $\\hat{W}$ are much smaller in size compared to $W$ . Now consider ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\operatorname*{min}_{\\hat{W}}L(P\\hat{W}).\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Applying the optimizer from (1) to update $\\hat{W}$ along with an optimizer state $\\hat{S}$ , and mapping the update rule $\\bar{\\pmb{W}_{t+1}}=\\hat{\\pmb{W}}_{t}+\\phi_{t}(\\hat{\\pmb{S}}_{t})$ to that of $\\pmb{W}=\\pmb{P}\\pmb{\\hat{W}}_{t}$ , we get ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\pmb{W}_{t+1}=\\pmb{W}_{t}+\\pmb{P}\\phi_{t}(\\hat{\\pmb{S}}_{t}),\\qquad\\qquad\\qquad\\hat{\\pmb{S}}_{t}=\\psi_{t}(\\hat{\\pmb{S}}_{t-1},\\pmb{P}^{\\top}\\nabla L(\\pmb{W}_{t})),}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where we used the fact that $\\nabla_{\\hat{W}}L(P\\hat{W})=P^{\\top}\\nabla_{W}L(W)$ . This yields a more memory-efficient optimizer, as the size of $\\hat{S}_{t}$ is proportional to that of $\\hat{W}_{t}$ , much smaller than $S_{t}$ in (1) when $k\\ll n$ . ", "page_idx": 3}, {"type": "text", "text": "3.2 Online Subspace Descent ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "With a static $_{P}$ , regardless of its values, the parameter $W$ is restricted to have a low rank structure. Although low rank assumption is proved to be useful for fine-tuning with LoRA-like methods [11], it is often too limited for pre-training or when the desirable model weights are not inherently low-rank. ", "page_idx": 3}, {"type": "text", "text": "To address this problem, Zhao et al. [25] suggested to keep the projected updated in (4), but use different $_{P}$ across the iterations: ", "page_idx": 3}, {"type": "equation", "text": "$$\nW_{t+1}=W_{t}+P_{t}\\phi_{t}(\\hat{S}_{t}),\\quad\\hat{S}_{t}=\\psi_{t}(\\hat{S}_{t-1},P_{t}^{\\top}\\nabla L(W_{t})),\\quad P_{t+1}=\\chi_{t}(P_{t},W_{t},\\hat{S}_{t}),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\chi_{t}$ is a update rule of $\\mathbf{}P_{t}$ that will be determined in the sequel. The intuition is to open up different projection directions at different iterations, so that optimization can be conducted in different subspaces across different iterations. This is similar to the update of coordinate descent, except in a continuous fashion. Note that the update of $\\mathbf{}P_{t}$ can be done in parallel with that of $(\\boldsymbol{W}_{t},\\hat{\\boldsymbol{S}}_{t})$ , and incurs no slowdown once it is fast enough to not cause a speed bottleneck. ", "page_idx": 3}, {"type": "text", "text": "Example 3.1. Examples of common optimizers equipped with online subspace descent: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{i e n t\\,D e s c e n t:\\ }&{{\\boldsymbol W}_{t+1}={\\boldsymbol W}_{t}-\\epsilon_{t}P_{t}P_{t}^{\\top}{\\boldsymbol G}_{t},\\qquad{\\boldsymbol G}_{t}=\\nabla L({\\boldsymbol W}_{t}),}\\\\ {M o m e n t u m:\\ }&{{\\boldsymbol W}_{t+1}={\\boldsymbol W}_{t}-\\epsilon_{t}P_{t}\\hat{\\boldsymbol M}_{t},\\qquad\\qquad{\\hat{\\boldsymbol M}}_{t}=(1-\\beta)P_{t}^{\\top}{\\boldsymbol G}_{t}+\\beta\\hat{\\boldsymbol M}_{t-1},}\\\\ {L i o n\\!\\cdot\\!{\\boldsymbol K}:\\ }&{{\\boldsymbol W}_{t+1}={\\boldsymbol W}_{t}-\\epsilon_{t}P_{t}\\nabla K(\\hat{\\boldsymbol N}_{t}),\\quad\\hat{\\boldsymbol G}_{t}=P_{t}^{\\top}{\\boldsymbol G}_{t}}\\\\ &{\\hat{\\boldsymbol N}_{t}=(1-\\beta_{1})\\hat{\\boldsymbol G}_{t}+\\beta_{1}\\hat{\\boldsymbol M}_{t},\\qquad\\hat{\\boldsymbol M}_{t}=(1-\\beta_{2})\\hat{\\boldsymbol G}_{t}+\\beta_{2}\\hat{\\boldsymbol M}_{t-1},}\\\\ {A d a m:\\ }&{{\\boldsymbol W}_{t+1}={\\boldsymbol W}_{t}-\\epsilon_{t}P_{t}\\frac{\\hat{\\boldsymbol M}_{t}}{\\sqrt{\\hat{\\boldsymbol V}_{t}+{\\boldsymbol e}}},\\ \\ \\hat{\\boldsymbol G}_{t}=P_{t}^{\\top}{\\boldsymbol G}_{t},}\\\\ &{\\hat{\\boldsymbol M}_{t}=(1-\\beta_{1t})\\hat{\\boldsymbol G}_{t}+\\beta_{1t}\\hat{\\boldsymbol M}_{t-1},\\ \\ \\hat{\\ \\boldsymbol W}_{t}=(1-\\beta_{2t})\\hat{\\boldsymbol G}_{t}^{\\odot2}+\\beta_{2t}\\hat{\\boldsymbol V}_{t-1}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "How Should $\\mathbf{}P_{t}$ be Updated? It is useful to draw intuition from the projected gradient descent rule ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\boldsymbol{W}_{t+1}=\\boldsymbol{W}_{t}-\\epsilon_{t}\\boldsymbol{P}_{t}\\boldsymbol{P}_{t}^{\\top}\\boldsymbol{G}_{t},\\;\\;\\;\\;\\;\\;\\boldsymbol{G}_{t}=\\nabla L(\\boldsymbol{W}_{t}),\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "in which $\\mathbf{\\boldsymbol{P}}_{t}\\mathbf{\\boldsymbol{P}}_{t}^{\\top}$ can be viewed as a low rank preconditioning of $\\pmb{G}_{t}$ . To make it follow the exact gradient descent, we hope to make $P_{t}P_{t}^{\\top}G_{t}$ approximate $G_{t}$ as much as possible. In Galore, this is achieved by performing singular value decomposition (SVD) on $\\pmb{G}_{t}$ periodically every $T$ iterations: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r}{P_{t},\\mathbf{\\phi}_{-}=\\mathsf{t o r c h.1i n a l g.s v d}(G_{T\\lfloor t/T\\rfloor}),}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $T[t/T]$ is the largest multiple of $T$ less than or equal to $t$ . However, numerical SVD incurs a large computational cost for very large models. Also, since $\\mathbf{}P_{t}$ is fully determined by $G_{T[t/T]}$ calculated from a single mini-batch at the last periodic point, it does not incorporate the gradient information from all data in a timely fashion. ", "page_idx": 4}, {"type": "text", "text": "In this work, we propose to update $\\mathbf{}P_{t}$ in a continuous online fashion that incorporates the most recent gradient information in a timely fashion, without calling torch.linalg.decompositions routines. We view the update of $P_{t}$ as conducting an online principal component analysis (PCA) based on the streaming of $\\{G_{t}\\}$ . In particular, we propose to update $\\mathbf{}P_{t}$ at time $t$ by minimizing the following PCA objective: ", "page_idx": 4}, {"type": "equation", "text": "$$\nL_{G_{t}}(P)=\\left\\|P P^{\\top}\\tilde{G}_{t}-\\tilde{G}_{t}\\right\\|^{2}+\\lambda\\left\\|P^{\\top}P-I_{k\\times k}\\right\\|^{2},\\quad\\tilde{G}_{t}=\\frac{G_{t}}{\\|G_{t}\\|},\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\|A\\|=\\mathrm{tr}(A^{\\top}A)^{1/2}$ and $\\scriptstyle I_{k\\times k}$ is the $k\\times k$ identity matrix; we introduced an auxiliary loss to encourage the columns of $_{P}$ to be orthonormal and normalizes $\\pmb{G}_{t}$ to increase stability. ", "page_idx": 4}, {"type": "text", "text": "The key property of $L_{G_{t}}(P)$ in (6) is that all its stable local minimum is a global minimum, and $_{P}$ is a global minimum iff $P P^{\\top}\\tilde{G}_{t}$ forms the optimal rank- $k$ approximation of $\\tilde{G}_{t}$ [e.g., 3]; moreover, we have $P^{\\top}P=I_{k\\times k}$ at optima when $\\lambda>0$ . ", "page_idx": 4}, {"type": "text", "text": "Instead of minimizing $L_{G_{t}}(P)$ exactly, to retain computational efficiency, we propose to update $\\boldsymbol{P}_{t}$ by only performing one step of optimization on $L_{G_{t}}(P)$ : ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\boldsymbol{P}_{t+1}=0\\mathrm{ptimizerP}\\,.\\,\\mathrm{step}(\\boldsymbol{P}_{t},~~\\nabla_{\\boldsymbol{P}}L_{G_{t}}(\\boldsymbol{P}_{t})),\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where OptimizerP.step can be a favorite optimizer, such as gradient descent or Adam. Note that when using Adam, we introduce a copy of optimizer state $S_{t}^{P}$ for $\\mathbf{}P_{t}$ . See Algorithm 1. Compared to the exact SVD, each online update of $\\boldsymbol{P}_{t}$ here is fast and can be executed in parallel with the $(\\boldsymbol{W}_{t},\\hat{\\boldsymbol{S}}_{t})$ updates to avoid slowdown. ", "page_idx": 4}, {"type": "text", "text": "3.3 Difficulty in Theoretical Understanding ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "The idea above of projecting an arbitrary optimizer with a dynamically changing $\\boldsymbol{P}_{t}$ is heuristically motivated and lacks an immediate rigorous theoretical justification. The main challenge lies in the complex interaction between the update of $\\boldsymbol{U}_{t}$ and the optimization state $\\boldsymbol{S}_{t}$ , which could potentially degrade the convergence and other theoretical properties of the original optimizer. A key question is whether we can develop a theoretical framework to understand how $\\mathbf{}P_{t}$ impacts the optimizer\u2019s convergence behavior and provide guidance for the design of the update rules of $\\mathbf{}P_{t}$ . ", "page_idx": 4}, {"type": "text", "text": "To gain understanding, it is useful to first exam the simple case of projected gradient descent in (5) which does not have an optimizer state ( $\\mathbf{\\boldsymbol{S}}_{t}=\\boldsymbol{\\emptyset}$ ). In this case, since $\\mathbf{\\boldsymbol{P}}_{t}\\mathbf{\\boldsymbol{P}}_{t}^{\\top}$ is positive semi-finite, the update $P_{t}P_{t}^{\\top}G_{t}$ is always non-increasing direction of $L(W)$ for any $\\mathbf{}P_{t}$ . The algorithm is essentially a variant of coordinate or subspace descent, where $\\mathbf{}P_{t}$ defines the subspace on which one step of gradient descent is conduced at iteration $t$ . To ensure that (5) finds a local optimum, we mainly need to ensure that $P_{t}G_{t}=0$ only if $\\pmb{G}_{t}=0$ to prevent the optimizer from stopping prematurely; this is a mild condition that can be satisfied e.g. when $\\mathbf{}P_{t}$ is updated by (online) PCA on $\\pmb{G}_{t}$ . ", "page_idx": 4}, {"type": "text", "text": "Unfortunately, this coordinate-descent-like interpretation does not apply to more advanced optimizers that track a momentum state $\\boldsymbol{S}_{t}$ . This is because $\\boldsymbol{S}_{t}$ accumulates the information from the projected gradient $P_{\\tau}G_{\\tau}$ at all earlier iterations $\\tau\\leq t$ . As $P_{t}$ changes across time, it is unclear whether the gradient projected to different subspaces $P_{\\tau}$ would be coherent with each other, and useful for future updates that are conducted in different subspaces $\\mathbf{}P_{t}$ for $t>\\tau$ . The difficulty is the inertia effect of $S_{t}$ that entangles the different subspaces, making the dynamic behavior fundamentally more complicated than naive coordinate descent where the descent in different subspaces is uncoupled. This is what we address in Section 4 via the Hamiltonian descent framework. ", "page_idx": 4}, {"type": "text", "text": "4 Hamiltonian Descent Meets Subspace Descent: A Lyapunov Analysis ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "In this section, we show a surprising result that the complication outlined above in Section 3.3 is not a problem for optimizers that yields the Hamiltonian+descent structure in (2). Our result is two-fold: ", "page_idx": 5}, {"type": "text", "text": "\u2022 Section 4.1: When applying Online Subspace Descent on systems in (2), the Hamiltonian $^{+}$ descent structure is preserved once the update rule of $\\mathbf{}P_{t}$ has a smooth continuous-time limit. Hence, under very mild conditions, Online Subspace Descent equipped with common optimizers like Adam and Lion automatically yield a Lyapunov function and hence benign continuous-time convergence. Moreover, $\\boldsymbol{P}_{t}$ can, in fact, be generalized to an arbitrary linear operator as shown in Section 4.3. ", "page_idx": 5}, {"type": "text", "text": "\u2022 Section 4.2: For any smooth $\\mathbf{}P_{t}$ update rules that eliminates the degenerate case of $P_{t}^{\\top}G_{t}=0$ while $G_{t}=0$ at convergence, the online subspace optimizer guarantees to converge in continuous time to a stationary point of the loss $L(W)$ . This mild condition is satisfied, for example, when $\\mathbf{}P_{t}$ is updated by a typical optimizer on the online PCA objective $L_{G_{t}}(P)$ . ", "page_idx": 5}, {"type": "text", "text": "4.1 Online Subspace Descent Preserves the Hamiltonian+Descent Structure ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Applying dynamic projection to Hamiltonian descent in (2), we obtain the following systems: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}=P_{t}\\partial_{\\hat{S}}H(W_{t},\\hat{S}_{t})-\\Phi(\\partial_{W}H(W_{t},\\hat{S}_{t}))}\\\\ &{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}\\hat{S}_{t}=-P_{t}^{\\top}\\partial_{W}H(W_{t},\\hat{S}_{t})-\\Psi(\\partial_{\\hat{S}}H(W_{t},\\hat{S}_{t}))}\\\\ &{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}P_{t}=\\Gamma(P_{t},\\nabla L(W_{t})),}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\Gamma$ specifies the update rule of $\\boldsymbol{P}_{t}$ . Following essentially the same derivation as (3), one can show that $H(W,S)$ remains a Lyapunov function of (7), regardless of the choice of $\\Gamma$ : ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\frac{\\mathrm{d}}{\\mathrm{d}t}H(W_{t},\\hat{S}_{t})=-\\left\\lVert\\partial_{W}H_{t}\\right\\rVert_{\\Phi}^{2}-\\left\\lVert\\partial_{S}H_{t}\\right\\rVert_{\\Psi}^{2}+\\left\\langle\\partial_{W}H_{t},P_{t}\\partial_{\\hat{S}}H_{t}\\right\\rangle-\\left\\langle\\partial_{\\hat{S}}H_{t},P_{t}^{\\top}\\partial_{W}H_{t}\\right\\rangle}\\\\ &{\\qquad\\qquad\\qquad=-\\left\\lVert\\partial_{W}H_{t}\\right\\rVert_{\\Phi}^{2}-\\left\\lVert\\partial_{S}H_{t}\\right\\rVert_{\\Psi}^{2}\\le0,}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where the key is to use the adjoint property of $_{P}$ and P \u22a4that $\\langle P_{t}X,Y\\rangle=\\langle X,P_{t}^{\\top}Y\\rangle$ , which cancels the crossing terms, independent of the values of $\\mathbf{}P_{t}$ . There is no requirement on $\\mathbf{T}$ here, besides that the derivative in (8) should exist. As shown in Section 4.3, we can generalize (8) by replacing $\\mathbf{}P_{t}$ and $\\boldsymbol{P}_{t}^{\\top}$ with a general linear operator $\\mathcal{P}_{t}$ and its adjoint $\\mathcal{P}_{t}^{*}$ . ", "page_idx": 5}, {"type": "text", "text": "Please refer to Appendix A for continuous-time Momentum, Lion- $\\mathcal{K}$ and Adam with subspace descent and their Hamiltonian functions. ", "page_idx": 5}, {"type": "text", "text": "4.2 Convergence to Local Optima ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "In addition to the Lyapunov structure, we need an additional mild condition on the update rule of $\\mathbf{}P_{t}$ to ensure the system converges to the local optimum of the loss $L(W)$ . The main idea is to prevent the system from stopping prematurely before reaching zero gradient $\\pmb{G}_{t}=0$ by excluding the degenerate case of $P_{t}G_{t}=0$ while $G_{t}\\neq0$ in the invariant set of the system. ", "page_idx": 5}, {"type": "text", "text": "Assumption 4.1. Assume the functions in system (7) are continuously differentiable and ", "page_idx": 5}, {"type": "text", "text": "i) $\\begin{array}{r}{\\frac{\\mathrm{d}}{\\mathrm{d}t}H(W_{t},\\hat{S}_{t})=0}\\end{array}$ implies $\\hat{G}_{t}=P_{t}^{\\top}\\nabla L(W_{t})=0$ and $\\begin{array}{r}{\\frac{\\mathrm{d}}{\\mathrm{d}t}\\boldsymbol{W}_{t}=0}\\end{array}$ .   \nii) When $G_{t}\\equiv G\\neq0,$ , the set $\\{P\\colon P^{\\top}G=0\\}$ is not a positive invariant set of $\\begin{array}{r}{\\frac{\\mathrm{d}}{\\mathrm{d}t}P_{t}=\\Gamma(P_{t},G_{t})}\\end{array}$ . ", "page_idx": 5}, {"type": "text", "text": "This is a mild condition. Assumption i) says that the optimizer should stop at a point with $\\hat{G}_{t}=0$ , which is easy to verify for the common optimizers like momentum, Adam, Lion- $\\mathcal{K}$ . Assumption ii) ensures $\\hat{G}_{t}=0$ would imply $\\pmb{G}_{t}=0$ in invariance sets, which is satisfied when for example, $\\mathbf{}P_{t}$ is updated by a reasonable optimizer of the online PCA loss that converges to a stable local minimum. ", "page_idx": 5}, {"type": "text", "text": "Theorem 4.2. Assume Assumption 4.1 holds. Let $(\\boldsymbol{W}_{t},\\boldsymbol{S}_{t},P_{t})_{t}$ be a bounded solution of (7), then all the accumulation points $\\{\\boldsymbol{W}_{t}\\}$ as $t\\to+\\infty$ are stationary points of $L(W)$ . ", "page_idx": 5}, {"type": "text", "text": "Proof. By LaSalle\u2019s invariance principle, the positive limit set of $(\\boldsymbol{W}_{t},\\boldsymbol{S}_{t},P_{t})_{t}$ must be contained in $\\mathcal{T}$ , where $\\begin{array}{r}{\\mathcal{T}=\\left\\{\\begin{array}{r l r l}\\end{array}\\right.}\\end{array}$ {the union of complete trajectories satisfying $\\textstyle{\\frac{\\mathrm{d}}{\\mathrm{d}t}}H(W_{t},{\\hat{S}}_{t})=0,\\forall t\\;\\}$ . ", "page_idx": 5}, {"type": "text", "text": "From the Assumption i), the trajectories contained in $\\mathcal{T}$ must satisfy $\\begin{array}{r}{\\frac{\\mathrm{d}}{\\mathrm{d}t}\\boldsymbol{W}_{t}\\,=\\,\\boldsymbol{0}}\\end{array}$ , which implies $\\begin{array}{r}{\\frac{\\mathrm{d}}{\\mathrm{d}t}G_{t}=\\frac{\\mathrm{d}}{\\mathrm{d}t}\\nabla L(W_{t})=0}\\end{array}$ and $\\hat{G}_{t}=0$ and hence $G_{t}\\equiv G$ is a constant with $P_{t}^{\\top}G=0$ . Moreover, from Assumption ii), we must have $\\nabla L(\\boldsymbol{W}_{t})\\,=\\,G_{t}\\,\\equiv\\,0$ , since otherwise the trajectory is not invariant. As a result, all trajectories in the limit set I must have \u2207L(W t) = 0. Because ddt $\\begin{array}{r}{\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}=0}\\end{array}$ , these trajectories are static points of $\\mathbf{}W_{t}$ . \u53e3 ", "page_idx": 6}, {"type": "text", "text": "4.3 Online Subspace Descent with General Linear Projection Operators ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We can generalize the online subspace descent with general linear operators: ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}=\\mathcal{P}_{t}(\\partial_{\\hat{S}}H(W_{t},\\hat{S}_{t}))-\\Phi(\\partial_{W}H(W_{t},\\hat{S}_{t}))}\\\\ &{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}\\hat{S}_{t}=-\\mathcal{P}_{t}^{*}(\\partial_{W}H(W_{t},\\hat{S}_{t}))-\\Psi(\\partial_{\\hat{S}}H(W_{t},\\hat{S}_{t}))}\\\\ &{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathcal{P}_{t}=\\Gamma(\\mathcal{P}_{t},\\nabla L(W_{t})),}\\end{array}\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "where we generalize $\\mathbf{}P_{t}$ to be any linear operator $\\mathcal{P}_{t}$ with an adjoint operator $\\mathcal{P}_{t}^{*}$ , satisfying ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\left\\langle\\boldsymbol{X},\\mathcal{P}_{t}(\\boldsymbol{Y})\\right\\rangle=\\langle\\mathcal{P}_{t}^{*}(\\boldsymbol{X}),\\boldsymbol{Y}\\rangle,\\quad\\forall\\boldsymbol{X},\\boldsymbol{Y}.\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "The derivation of Lyapunov follows a similar way: ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\frac{\\mathrm{d}}{\\mathrm{d}t}H(W_{t},\\hat{S}_{t})=-\\left\\lVert\\partial_{W}H_{t}\\right\\rVert_{\\Phi}^{2}-\\left\\lVert\\partial_{S}H_{t}\\right\\rVert_{\\Psi}^{2}+\\left\\langle\\partial_{W}H_{t},\\mathcal{P}_{t}(\\partial_{\\hat{S}}H_{t})\\right\\rangle-\\left\\langle\\partial_{\\hat{S}}H_{t},\\mathcal{P}_{t}^{*}(\\partial_{W}H_{t})\\right\\rangle}\\\\ &{\\qquad\\qquad\\qquad=-\\left\\lVert\\partial_{W}H_{t}\\right\\rVert_{\\Phi}^{2}-\\left\\lVert\\partial_{S}H_{t}\\right\\rVert_{\\Psi}^{2}\\le0,}\\end{array}\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "where the crossing terms are again canceled due to the adjoint property. ", "page_idx": 6}, {"type": "text", "text": "As an example of the general framework, consider $\\mathcal{P}_{t}(\\boldsymbol{X})=\\boldsymbol{P}_{t}\\boldsymbol{X}\\boldsymbol{Q}_{t}$ , where $Q_{t}$ is another projection matrix applied on the different dimension of $\\mathbf{\\deltaX}$ (see also [25]). The adjoint operator of $\\mathcal{P}_{t}$ is $\\mathcal{P}_{t}^{*}(\\pmb{X})=\\pmb{P}_{t}^{\\top}\\pmb{X}\\pmb{Q}_{t}^{\\top}$ . This can be verified by ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\langle P_{t}X Q_{t},Y\\rangle=\\operatorname{tr}(P_{t}X Q_{t}Y^{\\top})=\\operatorname{tr}(X Q_{t}Y^{\\top}P_{t})=\\operatorname{tr}(X(P_{t}^{\\top}Y Q_{t}^{\\top})^{\\top})=\\langle X,P_{t}^{\\top}Y Q_{t}^{\\top}\\rangle.\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "The subspace descent system of this operator is ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}=P_{t}\\partial_{\\hat{S}}H(W_{t},\\hat{S}_{t})Q_{t}-\\Phi(\\partial_{W}H(W_{t},\\hat{S}_{t}))}\\\\ &{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}\\hat{S}_{t}=-P_{t}^{\\top}\\partial_{W}H(W_{t},\\hat{S}_{t}))Q_{t}^{\\top}-\\Psi(\\partial_{\\hat{S}}H(W_{t},\\hat{S}_{t}))}\\\\ &{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}P_{t}=\\Gamma_{P}(P_{t},Q_{t},\\nabla L(W_{t}))}\\\\ &{\\displaystyle\\frac{\\mathrm{d}}{\\mathrm{d}t}Q_{t}=\\Gamma_{Q}(P_{t},Q_{t},\\nabla L(W_{t})),}\\end{array}\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "where $P_{t},Q_{t}$ can be updated jointly via an online SVD on $G_{t}$ . ", "page_idx": 6}, {"type": "text", "text": "Another linear operator that involves two matrices is $\\mathcal{P}_{t}(\\pmb{X})=\\pmb{P}_{t}\\pmb{X}\\!+\\!\\pmb{X}\\pmb{Q}_{t}$ , which yields $\\mathcal{P}_{t}^{*}(X)=$ $\\pmb{P}_{t}^{\\top}\\pmb{X}+\\pmb{X}\\pmb{Q}_{t}^{\\top}$ . ", "page_idx": 6}, {"type": "text", "text": "5 Experiment ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We answer a number of key questions with pretraining experiments of LLaMA [22] on the C4 dataset [20]. All experiments except for large 7B experiments are conducted on a single NVIDIA A100 GPU. ", "page_idx": 6}, {"type": "text", "text": "5.1 Why do we Need Online Subspace Descent? ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Overall, Online Subspace Descent offers two major advantages over previous methods that rely on SVD, better convergence and lower overhead. In this section, we discuss both in detail. ", "page_idx": 6}, {"type": "text", "text": "First, Online Subspace Descent closes the gap between the state-of-the-art low-rank method and full rank baseline uniformly across different model sizes, as shown in figure 1. A highlight amongst these results is LLaMA 1B (SS 256). As shown in table 1, Online Subspace Descent attains significant improvement over GaLore in perplexity, while consuming a similar amount of GPU memory (8.64 GB v.s 9.01 GB). One additional observation in 1 shows as model size and sequence length grow, Online Subspace Descent becomes more effective. We hypothesize that this is due to the higher intrinsic rank of the underlying optimization problem in larger models. Hence, the positive impact on the convergence of the online update of $\\mathbf{}P_{t}$ becomes more obvious. See more details in Appendix B. ", "page_idx": 7}, {"type": "table", "img_path": "P8rTCT6g45/tmp/ce4abfeb8fc54946a21a55b55e40c1eaca74e97492e89b96406098cca2f47ad3.jpg", "table_caption": [], "table_footnote": [], "page_idx": 7}, {"type": "image", "img_path": "P8rTCT6g45/tmp/06f6d903d2561c2b873909902730fb4fac49f8332f9ae63486d39e7c75dc9a0b.jpg", "img_caption": ["Table 1: Pretraining LLaMA 1B with a sequence length of 256 and for 10K steps, perplexity was reported as the training average of the last 10 steps. AdamW8bit serves as the base optimizer for both. ", "Figure 1: Validation perplexity of LLaMA 1B with sequence length 256, rank 512 for 10K steps. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "Another favorable characteristic of Online Subspace Descent is its minimum overhead. In figure 2, we measure and analyze the execution time of SVD and online PCA on a popular data center GPU (A100) and a consumer GPU (RTX 3090). The typical Pytorch implementation of SVD can be up to 142 times slower than running a single-step online PCA on representative weight tensors from LLaMA architectures. Online PCA is fast because it is implemented as a single optimization step with respect to a simple loss function. Hence, each step of online PCA can be cleverly scheduled and hidden in the weight optimization step when executed in parallel, whereas SVD is too expensive to be hidden. ", "page_idx": 7}, {"type": "image", "img_path": "P8rTCT6g45/tmp/ecc4092e833b5743d7510bd5f4f3b33a8d5731d3996088dd407a0ec172ed39cc.jpg", "img_caption": ["Figure 2: The execution time of torch.svd and that a single-step backward() call for online PCA in PyTorch, on matrices of typical shapes in linear layers in the LLaMA 60M to 7B. Thanks to the high speed of single-step online PCA, $\\pmb{P}_{t}$ updates can be executed in parallel with weight updates, adding no overhead to the training process. In contrast, SVD incurs significant overhead as the model and weight tensor sizes increase. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "5.2 What Rank Should we Pick for Online Subspace Descent? ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "We conduct an ablation study on the rank of Online Subspace Descent. Figure 3 shows that the final perplexity is inversely correlated with rank: higher ranks result in lower convergent perplexity. However, the rate of reduction of perplexity decreases as the rank increases, eventually reaching a saturation point. We propose an intuitive explanation for this phenomenon. In language modeling, high-frequency tokens can be effectively learned with low-rank training. However, learning lowerfrequency tokens requires higher ranks. Once these lower-frequency tokens are adequately learned, further increasing the rank does not significantly decrease perplexity. In conclusion, given sufficient time and resources, higher ranks yield better performance for Online Subspace Descent. It is recommended that the highest rank be selected until the perplexity reduction saturates. ", "page_idx": 7}, {"type": "text", "text": "5.3 What are the Best Hyperparameters? ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "$\\alpha$ and $\\lambda$ : The parameter $\\alpha$ controls the update speed of $\\mathbf{}P_{t}$ , while $\\lambda$ determines the regularization strength on the optimization objective of $\\mathbf{}P_{t}$ . Empirically, we find that the result is not sensitive to $\\lambda$ for small models (60M). and set $\\lambda=0.1$ for all subsequent experiments. We find that $\\alpha$ must be kept small to avoid instability (Figure 3), and we set $\\alpha=5$ for all experiments. ", "page_idx": 7}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "Learning rate: For the small model (60M), learning rate choices are more flexible, producing similar results. However, for larger models (350M, 1B), we recommend using a learning rate that is 10 times smaller, specifically 0.001. Larger learning rates cause unrecoverable spikes and instability, a general characteristic observed across all methods. See additional hyperparameter choices in Appendix B. ", "page_idx": 8}, {"type": "image", "img_path": "P8rTCT6g45/tmp/af6c9a8b14bb23a2efafb8f909c78349b2d4040a730668ef05085605f8dbce1c.jpg", "img_caption": ["Figure 3: From left to right are loss curves of 10K steps on LLaMA 60M: leftmost is the sweep of rank, middle is the sweep of $\\alpha$ and rightmost is the sweep of $\\lambda$ . "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "5.4 Can Online Subspace Descent be Applied to Different Optimizers? ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "One straightforward extension of Online Subspace Descent is to apply it to other base optimizers beyond AdamW8bit. We conduct ablation studies on LION [6] and Adafactor [21], finding that Online Subspace Descent behaves similarly to how it does with AdamW8bit. Despite the initial observation that updating $\\mathbf{}P_{t}$ with AdamW8bit consistently yields better results, we discover that updating $P_{t}$ with simple SGD can achieve similar performance. ", "page_idx": 8}, {"type": "table", "img_path": "P8rTCT6g45/tmp/c84a658dea0a7b645ab923dd52af2bac4a1a5839d6ac7789cd51bb7ec8c93230.jpg", "table_caption": [], "table_footnote": ["Table 2: LLaMA 60M on C4 with sequence length 1024, with optimizers on $\\mathbf{}P_{t}$ and $\\mathbf{}W_{t}$ , denote as \"Ours $\\mathbf{\\{}}W_{t}$ optimizer} $\\mathbf{\\dot{\\omega}}+\\left\\{\\mathbf{\\nabla}P_{t}\\right.$ optimizer}\". Adaf., and Adam refer to Adafactor and 8bit-AdamW, respectively. "], "page_idx": 8}, {"type": "text", "text": "5.5 Can Online Subspace Descent Scale to Larger Model? ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We pretrain from scratch a 7B LLaMA model on the C4 dataset for 10K steps, where the $\\mathbf{}P_{t}$ matrix is updated by SGD. The perplexity is the lower the better. The final perplexity and training wall-clock time are provided in Table 3. We further provide the downstream evaluation of the pretrained checkpoints using Galore and our method on the GLUE benchmark in Table 4. Our method consistently outperforms Galore when the model size scales up. ", "page_idx": 8}, {"type": "table", "img_path": "P8rTCT6g45/tmp/9105d2ae43154645bd98dd9b7d96d8bfdf278fd910ddbff2c4a69bf91b0b43b4.jpg", "table_caption": [], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "Table 3: Perplexity and Wall Clock Time for 7B models pretrained on C4 for 10K steps. Lower perplexity is better. Online Subspace Descent can be upto $1.3\\mathrm{x}$ faster than GaLore. ", "page_idx": 8}, {"type": "text", "text": "6 Related Works ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We discuss related works on memory-efficient optimization and low-rank adaptation techniques. ", "page_idx": 8}, {"type": "table", "img_path": "P8rTCT6g45/tmp/e8b3c5960fd1d1a7f0f243ee6019b7dd370cb0c4ba12da78261fb48d647c0d7f.jpg", "table_caption": ["Table 4: Standardized GLUE evaluation for 7B model checkpoints using eval-harness. Results are reported for various downstream tasks. "], "table_footnote": [], "page_idx": 9}, {"type": "text", "text": "Low-Rank Adaptation Low-Rank Adaptation (LoRA) [11] adds a low-rank adaptor to speficic linear layers in a model, and finetune only the low-rank adaptor. As the adaptors are small, LoRA is widely applied for finetuning large models. Many variants have been proposed since LoRA, including support for multi-task learning Wang et al. [23] and further memory reductions Dettmers et al. [8]. Notably, Lialin et al. [15] proposed ReLoRA for pretraining, requiring a full-rank training warmup to match standard performance levels. It\u2019s important to note that LoRA is fundamentally distinct from subspace descent. While subspace descent optimizes within the original model parameter space, LoRA focuses its optimization efforts within the space of the adaptors. ", "page_idx": 9}, {"type": "text", "text": "Memory-Efficient Optimization Several approaches aim to reduce memory costs associated with gradient statistics in adaptive optimization algorithms [21, 2, 7]. In particular, Adafactor [21] factorizes the second-order statistics by a row-column outer product and update the factorized bases on the fly, hence achieving a sub-linear memory cost. K-Fac [19] presents a factorized approximation of the Fisher information matrix which leads to a sublinear natural gradient method. More recently, Feinberg et al. [9] observes that the spectra of the Kronecker-factored gradient covariance matrix in deep learning (DL) training tasks are concentrated on a small leading eigenspace and propose to maintain a matrix preconditioner using the frequent directions sketch. However, their method requires conducting the eigendecomposition at every step, which can be costly for large models. Other than factorization methods, quantization techniques [7, 1, 24, 16] are also widely used, where the gradient (or the momentum and the preconditioner) are directly quantized to tradeoff performance for memory. Fused gradient computation method [17] have also been used to minimize memory costs during training. GaLore [25] is the most relevant work to ours. GaLore focuses on low-rank gradient structures, reducing memory costs for both first and second-order statistics. Our method can be viewed as a general extension to GaLore where we replace the infrequent SVD by a continuous subspace descent [14, 10]. As a result, our method not only provides a more general framework to study memory-efficient subspace descent, but is also more performant than GaLore in practice. ", "page_idx": 9}, {"type": "text", "text": "7 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In conclusion, we provide the first convergence guarantee for arbitrary update rules of projection matrix, applicable to a range of optimizers that can be analyzed using Hamiltonian Descent, including common ones like LION, AdamW, and Adafactor. Inspired by this theoretical foundation, we introduce Dynamic Subspace Descent, a novel family of subspace descent optimizers that eschews SVD in favor of online PCA for updating projection matrix. Dynamic Subspace Descent is both flexible and minimally intrusive, and our experiments show that it achieves lower perplexity in pretraining LLaMA models (ranging from 60M to 1B parameters) on the C4 dataset compared to state-of-the-art low-rank training methods, while also closing the perplexity gap with full-rank baselines. ", "page_idx": 9}, {"type": "text", "text": "For future research, we propose several open and intriguing questions: (1) Are there alternative methods for updating projection matrix that could accelerate convergence? (2) What is the impact of weight decay on convergence in Dynamic Subspace Descent? (3) Can low-rank gradients and updates be combined with dynamic low-rank weights (e.g., Mixture of Experts) to further enhance training efficiency? (4) Can this method be applied to problems beyond language modeling? We hope that our work provides a strong foundation for exploring these questions. ", "page_idx": 9}, {"type": "text", "text": "8 Acknowledgment ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "The research is conducted in Statistics & AI group at UT Austin, which receives supports in part from NSF CAREER1846421, SenSE2037267, Office of Navy Research, and NSF AI Institute for Foundations of Machine Learning (IFML). ", "page_idx": 10}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 11}, {"type": "text", "text": "[1] Dan Alistarh, Demjan Grubic, Jerry Li, Ryota Tomioka, and Milan Vojnovic. Qsgd: Communication-efficient sgd via gradient quantization and encoding. Advances in neural information processing systems, 30, 2017.   \n[2] Rohan Anil, Vineet Gupta, Tomer Koren, and Yoram Singer. Memory efficient adaptive optimization. Advances in Neural Information Processing Systems, 32, 2019.   \n[3] Pierre Baldi and Kurt Hornik. Neural networks and principal component analysis: Learning from examples without local minima. Neural networks, 2(1):53\u201358, 1989.   \n[4] Lizhang Chen, Bo Liu, Kaizhao Liang, and Qiang Liu. Lion secretly solves constrained optimization: As lyapunov predicts. arXiv preprint arXiv:2310.05898, 2023.   \n[5] Xiangning Chen, Chen Liang, Da Huang, Esteban Real, Kaiyuan Wang, Yao Liu, Hieu Pham, Xuanyi Dong, Thang Luong, Cho-Jui Hsieh, et al. Symbolic discovery of optimization algorithms. arXiv preprint arXiv:2302.06675, 2023.   \n[6] Xiangning Chen, Chen Liang, Da Huang, Esteban Real, Kaiyuan Wang, Hieu Pham, Xuanyi Dong, Thang Luong, Cho-Jui Hsieh, Yifeng Lu, et al. Symbolic discovery of optimization algorithms. Advances in Neural Information Processing Systems, 36, 2024.   \n[7] Tim Dettmers, Mike Lewis, Sam Shleifer, and Luke Zettlemoyer. 8-bit optimizers via block-wise quantization. arXiv preprint arXiv:2110.02861, 2021.   \n[8] Tim Dettmers, Artidoro Pagnoni, Ari Holtzman, and Luke Zettlemoyer. Qlora: Efficient finetuning of quantized llms. Advances in Neural Information Processing Systems, 36, 2024.   \n[9] Vladimir Feinberg, Xinyi Chen, Y Jennifer Sun, Rohan Anil, and Elad Hazan. Sketchy: Memoryefficient adaptive regularization with frequent directions. Advances in Neural Information Processing Systems, 36, 2024.   \n[10] Guy Gur-Ari, Daniel A Roberts, and Ethan Dyer. Gradient descent happens in a tiny subspace. arXiv preprint arXiv:1812.04754, 2018.   \n[11] Edward J Hu, Yelong Shen, Phillip Wallis, Zeyuan Allen-Zhu, Yuanzhi Li, Shean Wang, Lu Wang, and Weizhu Chen. Lora: Low-rank adaptation of large language models. arXiv preprint arXiv:2106.09685, 2021.   \n[12] Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980, 2014.   \n[13] David Kozak, Stephen Becker, Alireza Doostan, and Luis Tenorio. Stochastic subspace descent. arXiv preprint arXiv:1904.01145, 2019.   \n[14] Brett W Larsen, Stanislav Fort, Nic Becker, and Surya Ganguli. How many degrees of freedom do we need to train deep networks: a loss landscape perspective. arXiv preprint arXiv:2107.05802, 2021.   \n[15] Vladislav Lialin, Sherin Muckatira, Namrata Shivagunde, and Anna Rumshisky. Relora: Highrank training through low-rank updates. In Workshop on Advancing Neural Network Training: Computational Efficiency, Scalability, and Resource Optimization (WANT@ NeurIPS 2023), 2023.   \n[16] Bo Liu, Lemeng Wu, Lizhang Chen, Kaizhao Liang, Jiaxu Zhu, Chen Liang, Raghuraman Krishnamoorthi, and Qiang Liu. Communication efficient distributed training with distributed lion. arXiv preprint arXiv:2404.00438, 2024.   \n[17] Kai Lv, Yuqing Yang, Tengxiao Liu, Qinghui Gao, Qipeng Guo, and Xipeng Qiu. Full parameter fine-tuning for large language models with limited resources. arXiv preprint arXiv:2306.09782, 2023.   \n[18] Chris J Maddison, Daniel Paulin, Yee Whye Teh, Brendan O\u2019Donoghue, and Arnaud Doucet. Hamiltonian descent methods. arXiv preprint arXiv:1809.05042, 2018.   \n[19] James Martens and Roger Grosse. Optimizing neural networks with kronecker-factored approximate curvature. In International conference on machine learning, pages 2408\u20132417. PMLR, 2015.   \n[20] Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J. Liu. Exploring the limits of transfer learning with a unified text-to-text transformer. arXiv e-prints, 2019.   \n[21] Noam Shazeer and Mitchell Stern. Adafactor: Adaptive learning rates with sublinear memory cost. In International Conference on Machine Learning, pages 4596\u20134604. PMLR, 2018.   \n[22] Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timoth\u00e9e Lacroix, Baptiste Rozi\u00e8re, Naman Goyal, Eric Hambro, Faisal Azhar, et al. Llama: Open and efficient foundation language models. arXiv preprint arXiv:2302.13971, 2023.   \n[23] Yiming Wang, Yu Lin, Xiaodong Zeng, and Guannan Zhang. Multilora: Democratizing lora for better multi-task learning. arXiv preprint arXiv:2311.11501, 2023.   \n[24] Wei Wen, Cong Xu, Feng Yan, Chunpeng Wu, Yandan Wang, Yiran Chen, and Hai Li. Terngrad: Ternary gradients to reduce communication in distributed deep learning. Advances in neural information processing systems, 30, 2017.   \n[25] Jiawei Zhao, Zhenyu Zhang, Beidi Chen, Zhangyang Wang, Anima Anandkumar, and Yuandong Tian. Galore: Memory-efficient llm training by gradient low-rank projection. arXiv preprint arXiv:2403.03507, 2024. ", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "A Hamiltonian Examples ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "Example A.1. Momentum $^+$ Online Subspace Descent is ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}=-P_{t}\\hat{M}_{t},\\qquad\\quad\\hat{G}_{t}=P_{t}^{\\top}\\nabla L(W_{t}),\\qquad\\quad\\frac{\\mathrm{d}}{\\mathrm{d}t}\\hat{M}_{t}=a(\\hat{G}_{t}-\\hat{M}_{t}),\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "with Lyapunov function $H(W,{\\hat{M}})=L(W)+{\\frac{\\left\\|{\\hat{M}}\\right\\|^{2}}{2a}}$ , for which ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}H(W_{t},\\hat{M}_{t})=-\\nabla L(W_{t})^{\\top}P_{t}\\hat{M}_{t}+\\hat{M}_{t}^{\\top}(P_{t}^{\\top}\\nabla L(W_{t})-\\hat{M}_{t})=-\\left\\|\\hat{M}_{t}\\right\\|_{2}^{2}\\leq0.\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "Example A.2. Adam $^+$ Online Subspace Descent is ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\frac{\\mathrm{d}}{\\mathrm{i}t}W_{t}=P_{t}\\frac{\\hat{M}_{t}}{\\sqrt{\\hat{V}_{t}}+e},\\ \\ \\ \\hat{G}_{t}=P_{t}^{\\top}\\nabla L(W_{t}),\\ \\ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\hat{M}_{t}=a(\\hat{G}_{t}-\\hat{M}_{t}),\\ \\ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\hat{V}_{t}=b(\\hat{G}_{t}^{2}-\\hat{V}_{t}).\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "with Lyapunov function $H(W,M,V)=L(W)+\\frac{1}{2a}\\left\\langle\\frac{\\hat{M}}{\\sqrt{\\hat{V}}+e},\\;\\hat{M}\\right\\rangle,\\;f o r\\;w h i c h$ ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\frac{\\mathrm{d}}{\\mathrm{l}t}H(W_{t},\\hat{M}_{t},\\hat{V}_{t})}\\\\ &{=-\\left\\langle G_{t},P_{t}\\frac{\\hat{M}_{t}}{\\sqrt{\\hat{V}_{t}}+e}\\right\\rangle+\\frac{1}{a}\\left\\langle\\frac{\\hat{M}_{t}}{\\sqrt{\\hat{V}_{t}}+e},\\ a(P_{t}^{\\top}G_{t}-\\hat{M}_{t})\\right\\rangle-\\frac{b}{4a}\\left\\langle\\frac{\\hat{M}_{t}^{\\odot2}}{\\sqrt{\\hat{V}_{t}}\\odot\\left(\\sqrt{\\hat{V}_{t}}+e\\right)^{\\odot2}},}\\\\ &{=-\\left\\langle1-\\frac{b}{4a}\\frac{\\sqrt{\\hat{V}_{t}}}{\\sqrt{\\hat{V}_{t}}+e},\\frac{\\hat{M}_{t}^{\\odot2}}{\\sqrt{\\hat{V}_{t}}+e}\\right\\rangle-\\frac{b}{4a}\\left\\langle\\frac{\\hat{M}_{t}^{\\odot2}}{\\sqrt{\\hat{V}_{t}}\\odot\\left(\\sqrt{\\hat{V}_{t}}+e\\right)^{\\odot2}},\\hat{G}_{t}^{\\odot2}\\right\\rangle}\\\\ &{\\le-\\left(1-\\frac{b}{4a}\\right)\\left\\|\\frac{\\hat{M}_{t}}{\\sqrt{\\sqrt{\\hat{V}_{t}}+e}}\\right\\|^{2}-\\frac{b}{4a}\\left\\|\\frac{\\hat{M}_{t}\\hat{G}_{t}}{\\sqrt{\\hat{V}_{t}}(\\sqrt{\\hat{V}_{t}}+e)}\\right\\|^{2}\\le0,}\\end{array}\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "where we assume $a\\ge b/4$ . ", "page_idx": 13}, {"type": "text", "text": "Example A.3. The Lion- $\\kappa+O\\}$ nline Subspace Descent is ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}W_{t}=P_{t}\\nabla K((1-b)\\hat{M}_{t}-b\\hat{G}_{t}),\\ \\ \\ \\ \\frac{\\mathrm{d}}{\\mathrm{d}t}M_{t}=-a(\\hat{G}_{t}+\\hat{M}_{t}),\\ \\ \\ \\ \\hat{G}_{t}=P_{t}^{\\top}\\nabla L(W_{t})\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "Consider the Hamiltonian function in Eq (13) of [4]: ", "page_idx": 13}, {"type": "equation", "text": "$$\nH(W,\\hat{M})=a L(W)+\\frac{1}{1-b}K((1-b)\\hat{M}).\n$$", "text_format": "latex", "page_idx": 13}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\frac{\\mathrm{d}}{\\mathrm{i}t}H(W_{t},M_{t})=a\\langle G_{t},P_{t}\\nabla K((1-b)\\hat{M}_{t}-b\\hat{G}_{t})\\rangle-a\\langle\\nabla K((1-b)\\hat{M}_{t}),\\hat{G}_{t}+\\hat{M}_{t}\\rangle}\\\\ &{\\quad\\quad\\quad\\quad\\quad=a\\langle\\hat{G}_{t},\\nabla K((1-b)\\hat{M}_{t}-b\\hat{G}_{t})-\\nabla K((1-b)\\hat{M}_{t})\\rangle-a\\langle\\nabla K((1-b)\\hat{M}_{t}),\\hat{M}_{t}\\rangle}\\\\ &{\\quad\\quad\\quad\\quad\\quad=-\\frac{a}{b}[(1-b)\\hat{M}_{t};\\,-b\\hat{G}_{t}]_{\\nabla K}-\\frac{a}{(1-b)}[\\mathbf{0};\\,(1-b)\\hat{M}_{t}]_{\\nabla K}\\leq0}\\end{array}\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "where we defined $[\\boldsymbol{X};\\boldsymbol{Y}]_{\\nabla\\mathcal{K}}=\\langle\\boldsymbol{Y},\\,\\nabla\\mathcal{K}(\\boldsymbol{X}+\\boldsymbol{Y})-\\nabla\\mathcal{K}(\\boldsymbol{X})\\rangle$ and used the fact that $[X;Y]_{\\nabla K}\\ge0$ by the convexity of $\\kappa$ ; we used $\\langle G_{t},P_{t}X_{t}\\rangle=\\langle P_{t}^{\\top}G_{t},X_{t}\\rangle=\\langle\\hat{G}_{t},X_{t}\\rangle$ . ", "page_idx": 13}, {"type": "text", "text": "In all examples above, although the form of Hamiltonian $H(\\boldsymbol{W},\\hat{\\boldsymbol{S}})$ is independent of the update rule of $\\boldsymbol{P}_{t}$ , the decreasing rate $\\textstyle{\\frac{\\mathrm{d}}{\\mathrm{d}t}}H(W_{t},{\\hat{S}}_{t})$ depends on $\\boldsymbol{P}_{t}$ in a complicate way through $\\hat{M}_{t},\\hat{V}_{t}$ , $\\hat{G}_{t}$ . An interesting direction for future investigation is to find optimal rules of $\\mathbf{}P_{t}$ to maximize the decreasing rate as an optimal control problem. ", "page_idx": 13}, {"type": "text", "text": "B Experiments ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "B.1 Hyperparameters ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "We sweep learning rate from [0.01, 0.005, 0.001]. For GaLore as well as Adam8bit, we follow the recommended hyperparameters as much as possible. For instance, GaLore update gap is set to recommended default, 200. Warmup is set to $10\\bar{\\%}$ of the total training steps. Batch size is set to 512 and gradient clipping is set to 1.0. ", "page_idx": 14}, {"type": "text", "text": "B.2 Rank Sweep ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "In the following table, is a sweep on different ranks and their final perplexity of LLaMA 60M $\\mathrm{SS}=$ 1024) on C4. All other hyperparameters are fixed and using recommended default. Notice that as the rank increases, both Dynamic Subspace Descent and GaLore improve. ", "page_idx": 14}, {"type": "table", "img_path": "P8rTCT6g45/tmp/892bded7e5d3ec80d230640f3ec696fd0540c2dd20f3e7d9d01fcc4944f6dc10.jpg", "table_caption": [], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "Table 5: On LLaMA 60M SS 1024, we sweep across different ranks, the trend is clear and intuitive that higher rank is preferred when it\u2019s feasible. ", "page_idx": 14}, {"type": "table", "img_path": "P8rTCT6g45/tmp/8a86ce68bfa70888991e6814558877fde35dc6f4722428e1ec72ec88fd9c8baa.jpg", "table_caption": ["B.3 Optimizer Sweep "], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "Table 6: In this experiment, we train LLaMA 60M on C4 with sequence length of 1024. We combine different base optimizers to update both $P_{t}$ and $W_{t}$ , denote as \"Ours weight optimizer $+\\;P_{t}$ optimizer\". ", "page_idx": 14}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 15}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 15}, {"type": "text", "text": "Justification: Our theoretical and empirical results align with our main claims. ", "page_idx": 15}, {"type": "text", "text": "Guidelines: ", "page_idx": 15}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 15}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 15}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Justification: We discussed the limitation and difficulty in analyzing the class of method theoretically. ", "page_idx": 15}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 15}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 15}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 15}, {"type": "text", "text": "Justification: All assumptions are clearly stated in the body of the paper. Guidelines: ", "page_idx": 16}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 16}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 16}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Justification: Hyperparameters choices are provided and later we will make code publicly available anonymously. ", "page_idx": 16}, {"type": "text", "text": "Guidelines: ", "page_idx": 16}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 16}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 16}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 17}, {"type": "text", "text": "Justification: All dataset and codebase used in the experiments are opensourced. Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 17}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 17}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 17}, {"type": "text", "text": "Justification: All hyperparameters, including learning rate, rank of projectors, sequence length are specified in each experiments. ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 17}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 17}, {"type": "text", "text": "Answer:[No] ", "page_idx": 17}, {"type": "text", "text": "Justification: Training LLM is expensive, we can afford running multiple runs on large models. However, previous empirical studies have shown that variation across seed is generally small in language model pretraining. ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 17}, {"type": "text", "text": "", "page_idx": 18}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 18}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 18}, {"type": "text", "text": "Justification: GPU type used in experiment is specified. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 18}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 18}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 18}, {"type": "text", "text": "Justification: We comply with the Code of Ethnics. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 18}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 18}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 18}, {"type": "text", "text": "Justification: Our paper aims to promote deeper theoretical understanding of a class of method. The algorithm itself is not practical enough to produce powerful enough LLM that could potentially have any negative societal impact. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 18}, {"type": "text", "text": "", "page_idx": 19}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 19}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 19}, {"type": "text", "text": "Justification: same reasoning as above ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 19}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: Everything is opensourced. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided. ", "page_idx": 19}, {"type": "text", "text": "\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 20}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 20}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 20}, {"type": "text", "text": "Justification: No new asset has been introduced. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 20}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 20}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 20}, {"type": "text", "text": "Justification: No human subject has been invovled. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 20}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 20}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 20}, {"type": "text", "text": "Justification: We did not perform any studies involving human subjects. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 20}]