[{"type": "text", "text": "Differentially Private Set Representations ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Sarvar Patel\u2217 Giuseppe Persiano\u2217 Joon Young Seo\u2217 Google Universit\u00e0 di Salerno Google sarvar@google.com giuper@gmail.com jyseo@google.com ", "page_idx": 0}, {"type": "text", "text": "Kevin Yeo\u2217 Columbia University, Google kwlyeo@google.com ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "We study the problem of differentially private (DP) mechanisms for representing sets of size $k$ from a large universe. Our first construction creates $(\\epsilon,\\delta)$ -DP representations with error probability of $1/(e^{\\epsilon}+1)$ using space at most $1.05k\\epsilon$ \u00b7 $\\bar{\\log(e)}$ bits where the time to construct a representation is ${\\cal O}(k\\log(1/\\delta))$ while decoding time is $O(\\log(1/\\delta))$ . We also present a second algorithm for pure $\\epsilon$ -DP representations with the same error using space at most $k\\epsilon\\!\\cdot\\!\\log(e)$ bits, but requiring large decoding times. Our algorithms match our lower bounds on privacy-utility trade-offs (including constants but ignoring $\\delta$ factors) and we also present a new space lower bound matching our constructions up to small constant factors. To obtain our results, we design a new approach embedding sets into random linear systems deviating from most prior approaches that inject noise into non-private solutions. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Consider the problem of releasing a set $S$ of elements from a potentially very large universe $U$ in a differentially privately manner. The goal is to construct a differentially private representation of $S$ , denoted by $\\hat{S}$ . The representation $\\hat{S}$ can be used to try and determine whether an element $u\\in U$ belongs to the original input set $S$ . $\\hat{S}$ may err in two ways. For any $u\\in S$ , $\\hat{S}$ may report a false negative stating that $u$ is not in $S$ . Also, for $u\\not\\in S$ , $\\hat{S}$ may report a false negative claiming $u$ appears in $S$ . Ideally, we should minimize the error probability for maximal utility while obtaining strong privacy for $S$ . This problem is useful for applications where users wish to privately disclose information such as sets of bookmarked websites, visited IP addresses, installed mobile apps, etc. One particularly important application is training machine learning models using the above examples as feature vectors while maintaining user privacy. As some concrete examples, good solutions to our problem could enable privately training models for web traffic forecasting using user\u2019s visited webpages [26], app install predictions with user\u2019s installed apps sets [5] and detecting shared IP addresses from user\u2019s visited IP addresses [17]. ", "page_idx": 0}, {"type": "text", "text": "A naive approach is to interpret the universe $U$ as a bit vector where each element corresponds to a unique entry of the vector $\\mathbf{v}\\in\\{0,1\\}^{|U|}$ . Encoding $S\\subseteq U$ works by setting the corresponding coordinates of $S$ to 1 and the rest to 0. Then, we can apply randomized response [33] to each entry of $\\mathbf{v}$ . The noisy vector $\\mathbf{v}$ is then released as the encoding of $S$ . Accessing an element proceeds by reading the value at the corresponding coordinate of the noisy vector v. With this approach, the encoding size scales linearly with $|U|$ . In most practical applications, the universe $U$ is very large while the input set $S$ is quite small. For example, one can consider $S$ to be set of visited websites. The universe $U$ will be the set of all websites that will be impractically large to store while $S$ will be a much smaller set. Our goal is to design a construction whose size and encoding time depends only on the input set $S$ size while maintaining small error matching randomized response. ", "page_idx": 0}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "To tackle this problem, prior works started non-private solutions for efficiently representing sets such as Bloom filters [8]. First, the input set is encoded using the non-private solution. Afterwards, each entry of the resulting representation is perturbed by injecting noise according to some distribution. This approach was studied in [1] where they showed the encoding was private. However, their work lacked any analysis on the error probability beyond empirical evaluation. To our knowledge, no other work has studied DP representations of sets. ", "page_idx": 1}, {"type": "text", "text": "Another related line of work considers DP mechanisms for releasing sparse histograms. In this problem, each element of the input set $S$ is also associated with some value. The goal of a query is to decode the value associated with the queried element (if it exists in the input set $S$ ). Sparse histograms may also be interpreted as a sparse vector problem where the input vector has at most $k$ non-zero entries. Unlike the private set problem, sparse histograms and vectors have been heavily studied. The majority of these works also take the same approach building on top of (potentially) non-private solution and injecting noise to the resulting representation. For example, several works study count sketch [24, 28, 34, 35] and count min-sketch [27, 21] where each entry of the resulting sketch is perturbed by some DP mechanism. To our knowledge, the only work that slightly deviates from this approach is [2], but they still inject noise using randomized response on bit-level representations (and the Laplacian mechanism in certain settings). ", "page_idx": 1}, {"type": "text", "text": "One could attempt to use sparse histograms (or vectors) to represents sets. We can associate each element in the input set $S$ with the value 1. To decode, we could round the output decoding of the underlying sparse histogram algorithm to either 0 or 1. Unfortunately, the error probability guarantees are unclear directly using prior analysis. For example, many prior works show that the per-entry error is at most $O(1/\\epsilon)$ . That is, the true value and noise value differ by at most $O(1/\\epsilon)$ . However, it is unclear how this can be directly translated into error probability. In particular, the exact constants of the per-entry error would need to be known to derive a probability bound of whether the decoded output is closer to 0 or 1. As an example, the error probabilities would differ greatly if the per-entry error was at most $1/\\epsilon$ as opposed to $100/\\epsilon$ when using rounding. In our work, we present constructions using a completely different approach to avoid this technical obstacle. Our solutions obtain better per-entry error (both theoretically and empirically) than prior sparse histograms. ", "page_idx": 1}, {"type": "text", "text": "1.1 Our results ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Our main contributions are efficient constructions for differentially private representations of sets that achieve optimal privacy-utility trade-offs and optimal space usage. In particular, our constructions exactly match the utility achieved by randomized response (even up to constants). Our work deviates from prior approaches that aim to construct some representation and perturb using noise. Instead, we embed the input set into a random linear system. Most elements in $S$ are guaranteed to satisfy their corresponding linear constraint in the linear system. In contrast, all elements outside of the element set $S$ will be unlikely to satisfy the relevant constraint except with small probability (that is a controllable parameter in our algorithms). Our constructions are inspired by retrieval data structures based on linear systems such as [29, 15, 16, 7]. In particular, one can view our work as generalizations of these techniques for differential privacy. We only consider error probabilities $\\alpha<1/2$ . When error is $\\alpha\\geq1/\\bar{2}$ , the task is trivial. One can encode a random hash function (independent of the set size) that is perfectly private with $\\epsilon=0$ and $\\delta=0$ (see Appendix F). We present two constructions: one for each of approximate and pure differential privacy. ", "page_idx": 1}, {"type": "text", "text": "Theorem 1.1 (Approximate-DP). Let $S\\subseteq U$ be a set of size $k$ from a universe of size n. For any $\\epsilon\\,>\\,0$ and $\\delta\\,>\\,0,$ , there exists an $(\\epsilon,\\delta)$ -DP algorithm for representing $S$ with error probability $\\alpha=1/(e^{\\epsilon}+1)$ and space of $1.05k\\epsilon\\cdot\\log(e)$ bits with three hash functions. The encoding time is $O(k\\log(1/\\delta))$ and the decoding time is ${\\cal O}(\\log(1/\\delta))$ . ", "page_idx": 1}, {"type": "text", "text": "Theorem 1.2 (Pure-DP). Let $S\\subseteq U$ be a set of size $k$ from a universe of size n. For any $\\epsilon>0,$ , there exists an $\\epsilon$ -DP algorithm for representing $S$ with error probability $\\dot{\\alpha_{\\mathrm{\\ell}}}=1/(e^{\\epsilon}+1)$ and space of $k\\epsilon\\cdot\\log(e)$ bits with one hash function. The encoding time is $O(k\\log^{2}k)$ and the decoding time is $O(k)$ . ", "page_idx": 1}, {"type": "text", "text": "We can compare the error probabilities achieved by our DP set mechanisms compared to prior works. For private histograms, per-entry expected error is $\\Omega(1/\\epsilon)$ as shown in [23]. In contrast, our constructions err with probability $\\bar{1}/(e^{\\bar{\\epsilon}}+1)$ . Note, we can convert this into the expected per-entry error as $1/(e^{\\epsilon}+1)$ . So, we obtain exponentially smaller per-entry error of $1/(e^{\\epsilon}+1)$ , which is impossible for private histograms. We also perform experimental evaluation in Section 5 to corroborate our error being exponentially smaller compared to private histograms. ", "page_idx": 2}, {"type": "text", "text": "Lower bounds. We show that our constructions achieve optimality in two important dimensions: trade-offs between privacy and utility as well as privacy and space. First, we present a lower bound on the best possible trade-off between privacy and utility (that is, error probability). Our pure-DP solution matches this lower bound exactly including constants. Similarly, our approximate-DP algorithm matches the lower bound (including constants) if we ignore the $\\delta$ factor. We also present a lower bound showing the best possible trade-off between privacy and space (encoding size). ", "page_idx": 2}, {"type": "text", "text": "Theorem 1.3 (Utility-privacy trade-off). Let $S\\subset U$ be a set of size $k$ . For any $\\epsilon\\geq0$ and $0\\leq\\delta\\leq1$ , any $(\\epsilon,\\delta)$ -DP algorithm for representing $S$ must have error probability $\\alpha\\geq(1-\\delta)/(e^{\\epsilon}+1)$ . ", "page_idx": 2}, {"type": "text", "text": "Theorem 1.4 (Space-privacy trade-off). Let $S\\subset U$ be a set of size $k$ . For any $\\epsilon\\geq0$ and $0\\leq\\delta\\leq1$ , any $(\\epsilon,\\delta)$ -DP algorithm for representing $S$ with error probability $0<\\alpha<1/2$ , the encoding bit size must be $\\operatorname*{min}(\\Omega((1+\\delta/e^{\\epsilon})\\cdot k\\cdot\\log((1/\\alpha)-1)),\\log\\binom{n}{k})$ . ", "page_idx": 2}, {"type": "text", "text": "We can consider the space lower bound restricted to algorithms that obtain the optimal privacy-utility trade-off as well. Therefore, we can set $\\alpha=(1-\\delta)/(\\bar{e}^{\\epsilon}+1)$ into the above lower bound. Assuming standard values of very small $\\delta$ , we can see that the lower bound becomes $\\Omega(k\\log(1/\\alpha))=\\Omega(k\\cdot\\epsilon)$ . Note that our constructions use space of $1.05k\\epsilon\\cdot\\log(e)$ and $k\\epsilon\\cdot\\log(e)$ bits respectively with error probability $\\alpha=1/(e^{\\epsilon}+1)$ . In other words, the space usage asymptotically matches our lower bound for all reasonable parameter choices of $\\delta$ . In our proof, we work out the exact constants and show that the constant in the lower bound approaches $\\log(e)$ for larger values of $\\epsilon$ . In fact, we show that both our constructions exactly match the lower bound up to a very small constant of at most 4 that only occurs when $\\epsilon=0$ . Furthermore, we note our lower bounds also apply to probabilistic filters (such as Bloom filters) that could also emit false negative errors. ", "page_idx": 2}, {"type": "text", "text": "1.2 Related work ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Private filters. Bloom filter [8] is a space efficient, probabilistic data structure that can be used to test whether an element is a member of a set. [1] show that flipping each bit of a Bloom filter with probability $1/(1+e^{\\epsilon/t})$ is $\\epsilon$ -DP where $t$ is the number of hash functions. However, their work only experimentally evaluates the utility without any provable guarantees. Additionally, we note that prior works have attempted to analyze the privacy properties of fliter data structures without modification. For example, this has been studied for Bloom fliters [6], counting Bloom fliters [31] as well as groups of multiple filter data structures [30]. In general, the conclusion is that filter data structures without modification fail to obtain reasonable privacy guarantees. Finally, we note Bloom filters have also been used in other differential privacy contexts such as RAPPOR [20] where the goal is to aggregate discrete value responses from clients with local DP. ", "page_idx": 2}, {"type": "text", "text": "Private sparse histograms and vectors. A histogram is a frequency vector where each coordinate may take on real values. It is known that histograms can be made differentially private by adding Laplacian noise to each coordinate [18]. The expected error of each entry is ${\\cal O}(1/\\epsilon)$ where $\\epsilon$ is the privacy parameter, and it was shown that this privacy-utility trade-off is essentially optimal [23, 4]. ", "page_idx": 2}, {"type": "text", "text": "Several works have considered the setting where the histogram is sparse and at most $k$ out of $d$ coordinates are non-zero. The goal is to release a representation of the histogram whose size does not depend on $d$ . Compared to the Laplacian mechanism, earlier works either suffered from significantly worse privacy-utility trade-offs [25, 13] or incurred very slow access time [3]. More recently, Aumuller et al. [2] proposed an ALP mechanism that achieves expected error of ${\\cal O}(1/\\epsilon)$ (matching the lower bound asymptotically) with access time of $O(1/\\delta)$ . The space usage is also very efficient, obtaining $O(k\\log(d+u))$ bits where $u$ is the upper bound on the value of the entries. ", "page_idx": 2}, {"type": "text", "text": "Another line of work considers private versions of count sketch, introduced in [12], which can be viewed as a generalization of the Bloom filter. Each element in the set has an associated frequency, and the goal is to estimate the frequency of any element in the universe. Viewing the set as a sparse vector of frequencies, the basic idea of the count sketch is to transform the sparse vector $\\mathbf{x}\\in\\mathbb{N}^{d}$ to a lower dimensional vector via an affine transformation $\\mathbf{A}\\mathbf{x}\\in\\mathbb{N}^{D}$ , where $\\mathbf{A}$ is a random matrix from a specific distribution. From Ax, each coordinate $\\mathbf{x}_{i}$ can be estimated with error that depends on $D$ and the norm of $\\mathbf{x}$ . Several works [24, 28, 34, 35] analyze the privacy-utility trade-off of the private count sketch with different noise distributions in the context of estimating the frequencies of the elements. Due to the linearity of count sketch, these works also studied the problem in the local model where the histogram is distributed amongst multiple parties. These works consider a more general problem setting than ours. As discussed earlier, it is not immediately obvious how the error guarantees of private count sketch will translate to our problem setting. ", "page_idx": 2}, {"type": "text", "text": "", "page_idx": 3}, {"type": "text", "text": "2 Preliminaries ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "Notation. Throughout our paper, we will use $\\ln x$ to denote natural (base-e) logarithms and use $\\log x$ to denote base-2 logarithms. We denote $[x]$ as the set $\\{1,\\ldots,x\\}$ for any integer $x\\geq0$ . We denote all vectors in lower case boldface $\\mathbf{x}$ and matrices in capital case boldface $\\mathbf{M}$ . We denote ${\\bf x}[i]$ as the $i$ -th entry of $\\mathbf{x}$ . Similarly, we denote $\\mathbf{M}[i][j]$ as the $j$ -th entry of the $i$ -th row vector of M, $\\dot{\\mathbf{M}}[i]$ as the ith row vector, and $\\mathbf{M}[:][j]$ as the $j$ th column vector. We denote $\\mathbf{x}[a:b]$ as the subvector of $\\mathbf{x}$ in range $[a,b]$ . We use $\\mathbf{x}^{\\mathsf{T}}$ as the transpose of $\\mathbf{x}$ . We use $\\mathbb{F}^{n}$ to denote the set of all column vectors of length $n$ over a field $\\mathbb{F}$ and $\\mathbb{F}^{n\\times m}$ to denote the set of all $n$ by $m$ matrices over a field $\\mathbb{F}$ . We use the notation ${\\bf1}_{x\\in S}$ such that ${\\bf1}_{x\\in S}=1$ if and only if $x\\in S$ and $\\mathbf{1}_{x\\in S}=0$ otherwise when $x\\not\\in S$ . Finally, given a countable set $S$ , we will use $S_{i}$ to denote the $i^{\\th}$ -th element in $S$ (in arbitrary order). The subscript is simply used as a label to distinguish the elements. ", "page_idx": 3}, {"type": "text", "text": "Differential privacy. The notion of differential privacy (DP) was introduced by [18]. DP algorithms guarantee that small changes to the input will not drastically change the output probability distribution. In other words, two similar (or nearby) inputs will result in very similar output distributions. ", "page_idx": 3}, {"type": "text", "text": "Throughout our work, our inputs will be sets $S$ from a universe $U$ , $S\\subseteq U$ . We measure the distance between two sets $S$ and $S^{\\prime}$ as the symmetric set difference that we denote as $S\\Delta S^{\\prime}=|S\\backslash S^{\\prime}|\\!+\\!|S^{\\prime}\\backslash S|$ . This is the number of elements that appear in exactly one of $S$ and $S^{\\prime}$ . One can interpret the symmetric set difference as the minimum number of elements that need to be added or removed to obtain $S^{\\prime}$ from $S$ (or vice versa). We say that two input sets are neighboring when their symmetric set difference is one, that is, $S\\Delta S^{\\prime}=1$ . For convenience, we will denote the distance between two sets $S$ and $S^{\\prime}$ as $|S-S^{\\prime}|=S\\Delta S^{\\prime}$ to conform with standard differential privacy notation. ", "page_idx": 3}, {"type": "text", "text": "We note that one can also interpret the above using $\\ell_{1}$ distances between vectors. For every entry $u~\\in~U$ , we can denote with a unique integer from the set $[|U|]$ . Suppose, we use a function $z:U\\rightarrow[|U|]$ as this mapping. For any set $S\\subseteq U$ , we map $S$ to the vector $\\mathbf{x}_{S}\\in\\{0,1\\}^{|U|}$ such that $\\mathbf{x}_{S}[i]=1$ if and only if there exists $u\\in S$ such that $z(u)=i$ . With this interpretation, we note that the symmetric set difference between two sets $S$ and $S^{\\prime}$ , $S\\Delta S^{\\prime}$ , is identical to the $\\ell_{1}$ distance between the corresponding vectors defined as $\\begin{array}{r}{|{\\bf x}_{S}-{\\bf x}_{S^{\\prime}}|_{1}=\\sum_{i\\in[|U|]}|{\\bf x}_{S}[i]-{\\bf x}_{S^{\\prime}}[i]|}\\end{array}$ . ", "page_idx": 3}, {"type": "text", "text": "We present the definition of differential privacy following standard definitions [19]. ", "page_idx": 3}, {"type": "text", "text": "Definition 2.1. A randomized algorithm $\\mathcal{M}$ with domain $\\mathsf{D}$ is $(\\epsilon,\\delta)$ -differentially private if, for all $R\\subseteq{\\mathsf{R a n g e}}({\\mathcal{M}})$ and for all $x,y\\in\\mathsf{D}$ such that $|x-y|=1$ , then ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathsf{P r}[\\mathcal{M}(x)\\in R]\\leq e^{\\epsilon}\\cdot\\mathsf{P r}[\\mathcal{M}(y)\\in R]+\\delta\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "over the randomness of the algorithm $\\mathcal{M}$ . ", "page_idx": 3}, {"type": "text", "text": "Differentially private set representations. We focus on differentially private algorithms for releasing sets $S$ of size at most $\\hat{k}$ , that is, $S\\subseteq U$ such that $|S|\\leq{\\hat{k}}$ for some input parameter $\\hat{k}$ . We will focus on the case where the universe $U$ is substantially larger than the input set $S$ . ", "page_idx": 3}, {"type": "text", "text": "Definition 2.2. An algorithm \u03a0 = (\u03a0.Encode, \u03a0.Decode) for representing sets consists of: ", "page_idx": 3}, {"type": "text", "text": "\u2022 $\\hat{S}\\gets\\mathsf{E n c o d e}(S)$ : The (randomized) encoding takes set $S\\subseteq U$ and returns encoding $\\hat{S}$ . \u2022 $\\boldsymbol{b}\\gets\\Pi.\\mathsf{D e c o d e}(\\hat{S},\\boldsymbol{u})$ : The decoding takes encoding $\\hat{S}$ and element $u\\,\\in\\,U$ and outputs $b\\in\\{0,1\\}$ . ", "page_idx": 3}, {"type": "text", "text": "The construction (encoding) time is the running time of \u03a0.Encode and the access (decoding) time is the running time of \u03a0.Decode. The space is the size of encoding $\\hat{S}$ . ", "page_idx": 3}, {"type": "text", "text": "In other words, an algorithm for releasing sets creates an encoding $\\hat{S}$ of a set $S\\subseteq U$ . Furthermore, the algorithm enables checking whether any element $u\\in U$ , appears in $S$ using the encoding $\\hat{S}$ . ", "page_idx": 4}, {"type": "text", "text": "Next, we define the utility of the differentially private set problem through its error probability. An error occurs when the decoding algorithm for a query $q\\in U$ returns an answer that is inconsistent with the original input set $S$ . ", "page_idx": 4}, {"type": "text", "text": "Definition 2.3. An algorithm \u03a0 = (\u03a0.Encode, \u03a0.Decode) for representing sets has error probability at most $\\alpha$ if, for any input set $S\\subseteq U$ and any set of queries $Q\\subseteq U$ , ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\mathrm{Pr}[\\forall q\\in Q,\\mathbf{1}_{q\\in S}\\neq\\Pi.\\mathsf{D e c o d e}(\\hat{S},q)]\\leq\\alpha^{|Q|}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\hat{S}\\gets\\Pi.\\mathsf{E n c o d e}(S)$ and the probability is over the randomness of \u03a0.Encode. ", "page_idx": 4}, {"type": "text", "text": "For any set of queries $Q$ , the probability that all $|Q|$ queries are incorrect is at most $p^{|Q|}$ . This is a stronger definition than prior works that consider $|Q|=1$ because it also ensures independence of incorrect answers. For example, consider any two queries $q_{1}\\neq q_{2}\\in U$ . Each of them must be incorrect with probability at most $\\alpha$ by setting $Q=\\{q_{1}\\}$ or $Q=\\{q_{2}\\}$ . Furthermore, they must be independent since the probability that they are both incorrect is at most $\\alpha^{2}$ by setting $Q=\\{q_{1},q_{2}\\}$ . This independence argument may be extended to arbitrary query set with more than two queries. ", "page_idx": 4}, {"type": "text", "text": "We can also interpret this definition as per-entry expected error used in private histograms that bounds the absolute value between the true and decoded value. Our definition may be viewed as privately encoding an $|U|$ -length binary vector such that ${\\bf E}[|{\\bf1}_{q\\in S}-\\Pi.{\\sf D e c o d e}(\\hat{S},q)|]\\leq\\alpha$ for any element $q\\in U$ and encoding $\\hat{S}\\gets\\Pi.\\mathsf{E n c o d e}(S)$ . In other words, the expected per-entry error is at most $\\alpha$ . ", "page_idx": 4}, {"type": "text", "text": "3 Differentially private sets ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "In this section, we present our main two constructions for differentially private sets. Before we present our constructions, we present a framework for building these algorithms using linear systems that satisfy certain properties. In particular, our work is inspired and generalizes prior retrieval data structures based on linear systems such as [29, 15, 16, 7]. Afterwards, we instantiate the linear systems in two different ways to obtain our constructions (although, one could use other linear systems as we will provide some examples later). ", "page_idx": 4}, {"type": "text", "text": "3.1 Framework from linear systems ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "We present a general framework based on linear systems for building DP set mechanisms. We consider linear systems over a finite field $\\mathbb{F}$ with two functions: Row and Solve. ", "page_idx": 4}, {"type": "text", "text": "Recall that our problem is to release differentially private representation of $S\\subseteq U$ such that $|S|\\leq{\\hat{k}}$ , where $\\hat{k}$ is the input to the algorithm. We assume ${\\mathsf{R o w}}:U\\to\\mathbb{F}^{1\\times m}$ is a hash function mapping universe elements to row vectors of length $m$ . Here, the parameter $m$ is a function of k\u02c6 and does not depend on the size of the input set $S$ . Given a set $S=\\{s_{1},\\ldots,s_{k}\\}\\subseteq U$ of $k\\leq\\hat{k}$ elements, one can view Row as hashing $S$ to a $k\\times m$ matrix: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\mathbf{M}=\\left[\\begin{array}{l}{\\mathsf{R o w}(s_{1})}\\\\ {\\phantom{-}\\cdot\\cdot}\\\\ {\\mathsf{R o w}(s_{k})}\\end{array}\\right].\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "The algorithm Solve takes an matrix $\\mathbf{M}\\in\\mathbb{F}^{k\\times m}$ and solution vector $\\mathbf{b}\\in\\mathbb{F}^{k}$ to compute the solution $\\mathbf{x}\\in\\mathbb{F}^{m}$ satisfying $\\mathbf{M}\\mathbf{x}=\\mathbf{b}$ . In particular, Solve will make the assumption that $\\mathbf{M}$ is the generated output of Row for some set $S\\subseteq U$ of size $k$ . For our chosen linear systems, Solve will be faster than the naive application of Gaussian elimination. We also make some additional assumptions about Solve. First, we will exclusively focus on the case where the matrix has more columns than rows, $n\\geq k$ . Secondly, if the input matrix $\\mathbf{M}$ does not have full rank, then Solve will return $\\bot$ . Lastly, all free variables will be set to uniformly random elements from $\\mathbb{F}$ . ", "page_idx": 4}, {"type": "text", "text": "We note that Row will generate rows in some structured way depending on the chosen linear system to ensure Solve successfully outputs a solution with high probability assuming the number of columns $m$ is sufficiently larger compared to the number of rows $k$ . In our work, we focus on two constructions: ", "page_idx": 4}, {"type": "text", "text": "random band [15] and Vandermonde matrices. Although, our framework is compatible with any linear system. ", "page_idx": 5}, {"type": "text", "text": "We will also use a hash function $h:U\\to\\mathbb{F}$ that maps each element in the universe $U$ to elements in $\\mathbb{F}$ . We will use $h$ to generate the solution vector $\\mathbf{b}$ in the above linear system. For some noised input set $S=\\left\\{s_{1},\\ldots,s_{k}\\right\\}\\subseteq U$ , the solution vector will be $\\mathbf{b}=[h(s_{1}),\\ldots,h(s_{k})]^{\\intercal}$ . ", "page_idx": 5}, {"type": "text", "text": "In our work, we will assume that all hash functions are fully random following prior works including [28, 34, 35]. In practical implementations, we use cryptographic hash functions to replace this assumption as done in the past [14, 34]. Specifically, we will assume that $h$ and Row are fully random when necessary (for one of our constructions, Row will be deterministic). ", "page_idx": 5}, {"type": "text", "text": "Encoding. Suppose we are given an input set $S=\\{s_{1},\\ldots,s_{k}\\}\\subseteq U$ of size $|S|=k$ . First, we generate random hash function $h$ and (possibly random) row function Row. Next, we will randomly sample a subset $S^{\\prime}\\subseteq S$ such that each element of $S$ will appear in $S$ except with some exclusion probability $p$ (that we pick later during analysis). For convenience, denote ${\\cal{S}}^{\\prime}\\,=\\,\\{s_{1}^{\\prime},\\ldots,s_{k^{\\prime}}^{\\prime}\\}$ where $k^{\\prime}=|S^{\\prime}|$ . Encoding works by constructing a matrix $\\mathbf{M}$ using Row and noisy input set $S^{\\prime}$ as $\\mathbf{M}=[\\mathsf{R o w}(s_{1}^{\\prime}),\\ldots,\\mathsf{R o w}(s_{k^{\\prime}}^{\\prime})]^{\\mathsf{T}}$ . Next, a solution vector $\\mathbf{b}$ is created by hashing each of the elements in $S^{\\prime}$ using the hash function $h$ . So, $\\mathbf{b}\\,=\\,[h(s_{1}^{\\prime}),\\cdot\\,.\\,.\\,,h(s_{k^{\\prime}}^{\\prime})]^{\\intercal}$ . Finally, we compute encoding $\\mathbf{x}$ using Solve for the following linear system: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathbf{M}\\mathbf{x}=\\left[\\begin{array}{c}{\\mathsf{R o w}(s_{1}^{\\prime})}\\\\ {\\ldots\\cdot}\\\\ {\\mathsf{R o w}(s_{k^{\\prime}}^{\\prime})}\\end{array}\\right]\\cdot\\mathbf{x}=\\left[\\begin{array}{c}{h(s_{1}^{\\prime})}\\\\ {\\ldots\\cdot}\\\\ {h(s_{k^{\\prime}}^{\\prime})}\\end{array}\\right].\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "The final encoding will be $\\hat{S}=({\\bf x},h,{\\sf R o w})$ . See Algorithm 1 for formal pseudocode. ", "page_idx": 5}, {"type": "text", "text": "Algorithm 1 DPSet.Encode algorithm   \nRequire: $S,p,m$ : input, exclusion probability $p$ , output length $m$   \nEnsure: $\\hat{S}:\\mathrm{DP}$ encoding of $S$ Generate random hash function $h:U\\to\\mathbb{F}$ . Generate (random) Row : $U\\rightarrow\\mathbb{F}^{1\\times m}$ . $S^{\\prime}\\gets\\{\\}$ for $s\\in S$ do Add $s$ to $S^{\\prime}$ with probability $1-p$ end for $\\mathbf{M}\\gets|S^{\\prime}|\\times m$ matrix $\\mathbb{F}^{|S^{\\prime}|\\times m}$ $\\mathbf{b}\\gets$ length $\\left|S^{\\prime}\\right|$ column vector. for $i\\in[|S^{\\prime}|]$ do $\\mathbf{M}[i]\\leftarrow\\mathsf{R o w}(S^{\\prime}[i])$ $\\mathbf{b}[i]\\leftarrow h(S^{\\prime}[i])\\ \\ \\$ end for $\\mathbf{x}\\gets\\mathsf{S o l v e}(\\mathbf{M},\\mathbf{b})$ if $b x\\neq\\perp$ then return $\\hat{S}\\gets(\\mathbf{x},\\mathsf{R o w},h,\\bot)$ else return $(\\perp,\\perp,\\perp,S)$ end if ", "page_idx": 5}, {"type": "table", "img_path": "GQNvvQquO0/tmp/0395e9801f6f2f1c5bf37c39be670da7164c874aaf923af6dacaf7982979a690.jpg", "table_caption": [], "table_footnote": [], "page_idx": 5}, {"type": "text", "text": "We can view the above as using the linear system to embed linear constraints that are satisfied by elements of the noisy input set $S^{\\prime}$ . For every $s^{\\prime}\\in S^{\\prime}$ , we know that ${\\sf R o w}(s^{\\prime})\\cdot{\\bf x}=h(s^{\\prime})$ assuming Solve succeeded. In contrast, fix any $u\\not\\in S^{\\prime}$ . Then, we can see that $\\operatorname*{Pr}[h(\\dot{u})=\\mathsf{R o w}(\\dot{u})\\cdot\\dot{\\mathbf{x}}]=|\\mathbb{F}|^{-1}$ since $h$ is a random hash function. So, elements outside of the set $S^{\\prime}$ are unlikely to be satisfy their corresponding linear constraint. We control this probability by picking the field size $\\lvert\\mathbb{F}\\rvert$ accordingly. ", "page_idx": 5}, {"type": "text", "text": "We will capture the event of Solve failing using $\\delta$ . For our pure-DP construction, we guarantee that $\\delta=0$ and Solve never fails. For our approximate-DP algorithm, we rely on the fact that Solve succeeds with high probability assuming Row is randomly generated in a correct manner. If Solve fails, we assume that encode simply returns the input set $S$ . ", "page_idx": 5}, {"type": "text", "text": "Decoding. Suppose we are given an encoding $\\hat{S}=({\\bf x},h,{\\sf R o w})$ and an element $u\\in U$ . Decoding checks whether an element\u2019s corresponding linear system is satisfied by computing $\\mathsf{R o w}(u)\\cdot\\mathbf{x}$ and comparing with $h(u)$ . In other words, the decoding algorithm simply returns $\\mathbf{1}_{\\mathsf{R o w}(u)\\cdot\\mathbf{x}=h(u)}$ . We present the pseudocode in Algorithm 2 ", "page_idx": 6}, {"type": "text", "text": "We start by presenting the error probability (utility) with respect to field size $\\lvert\\mathbb{F}\\rvert$ and the exclusion probability $p$ of removing any element. We defer the proofs to Appendix A. ", "page_idx": 6}, {"type": "text", "text": "Theorem 3.1. If $\\left|\\mathbb{F}\\right|=\\alpha^{-1}$ and $p=\\alpha/(1-\\alpha)$ , then DPSet.Decode has error probability $\\alpha$ . ", "page_idx": 6}, {"type": "text", "text": "For error probability $\\alpha$ , we pick $|\\mathbb{F}|\\ge1/\\alpha$ holds where $\\mathbb{F}$ is a finite field. We note that there is a finite field of size $q^{r}$ for any prime $q$ and positive integer $r\\geq1$ . For practical purposes, we use the smallest integer $q^{r}$ larger than $1/\\alpha$ that gives us slightly smaller error probability. ", "page_idx": 6}, {"type": "text", "text": "Next, we prove privacy of our framework. We defer the full proof to Appendix B. ", "page_idx": 6}, {"type": "text", "text": "Theorem 3.2. If Solve errs with probability at most $\\delta$ , then DPSet is $(\\epsilon,\\delta)$ -DP with error $(e^{\\epsilon}+1)^{-1}$ . ", "page_idx": 6}, {"type": "text", "text": "Our construction\u2019s expected per-entry error of $\\alpha=1/(e^{\\epsilon}\\!+\\!1)$ is exponentially smaller than achievable by private histograms where $\\Omega(1/\\epsilon)$ error is required [23]. ", "page_idx": 6}, {"type": "text", "text": "Next, we analyze the encoding size. In general, these are largely dependent on the underlying linear system. The encoding size depends on the number of variables (columns) $m$ in the linear system. Additionally, it also includes representations of the functions $h$ and Row. ", "page_idx": 6}, {"type": "text", "text": "Theorem 3.3. DPSet.Encode outputs encodings of m field elements and encodings of h and Row. ", "page_idx": 6}, {"type": "text", "text": "In Appendix E, we outline a possible optimization to reduce encoding size by picking $m$ closer to the expected size of the sampled set $S^{\\prime}$ . This turns out to be a more theoretical as we were unable to observe space improvements empirically for reasonable choices of set size $k$ and error probability $\\alpha$ . ", "page_idx": 6}, {"type": "text", "text": "Computational time. For computation, the majority of the work is done by the underlying linear system. In particular, DPSet.Encode requires only ${\\dot{O}}(k)$ time outside of Solve and Row. Similarly, DPSet.Decode requires an execute of Row and the computation will depend on the number of non-zero entries in Row. We analyze the computational costs for our instantiations later. ", "page_idx": 6}, {"type": "text", "text": "Larger error of $\\alpha>1/2$ . Our constructions only consider error probabilities $\\alpha\\leq1/2$ . This is implicit as the smallest field has size at least 2. There are trivial algorithms to obtain mechanisms with $\\epsilon=0$ and $\\delta=0$ for the case of $\\alpha\\geq1/2$ using a random hash function (see Appendix F). ", "page_idx": 6}, {"type": "text", "text": "3.2 Approximate differentially private sets ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "From Section 3.1, our goal essentially boils down to constructing a linear system where a solution exists and may be efficiently computed with high probability. Furthermore, we want to minimize the number of variables required to ensure small encoding sizes. To this end, we will use the random band row vector construction of [15]. ", "page_idx": 6}, {"type": "text", "text": "The random band construction is parameterized by the row length $m$ and the band length $w$ . At a high level, each row consists of a single band of $w$ random field elements. The band\u2019s location is chosen uniformly at random. All $m-w$ entries outside of the band will be zero. Formally, the construction uses hash functions $h_{1}:U\\to[m-w+1]$ and $h_{2}:U\\to\\mathbb{F}^{1\\times w}$ . For $u\\in U$ , $\\dot{h}_{1}(u)$ denotes the band\u2019s starting location and $h_{2}(u)$ is the $w$ elements in the band. Generating a random $\\mathsf{R o w}_{\\mathsf{b a n d}}$ is equivalent to generating the two random hash functions $h_{1}$ and $h_{2}$ . $\\mathsf{S o l v e}_{\\mathsf{b a n d}}$ works by sorting the rows by starting band location and executing Gaussian elimination. See Algorithms 3 and 4. ", "page_idx": 6}, {"type": "table", "img_path": "GQNvvQquO0/tmp/88ca5a537a185e2390c8aaa7b73ec5201e5968b47db483bc26b58ad225bc2f81.jpg", "table_caption": [], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "At a high level, If $k$ is the number of rows of the matrix, Dietzfelbinger and Walzer [15] showed that if $m=(1+\\beta)k$ and $w=O(\\log k)$ for some constant $\\beta>0$ , then the matrix generated using the random band row construction has full rank and $\\mathsf{S o l v e}_{\\mathsf{b a n d}}$ runs in $O(m w)$ time except with probability ${\\cal O}(1/m)$ . Bienstock et al. [7] extended this result to show that, if $w=\\dot{O}(\\log(1/\\delta)+\\log k)$ , then the matrix has full row rank and the linear system can be solved in time $O(m w)$ except with probability $\\delta$ . DPSet.Decode takes $O(w)$ time since computing the dot product scales linearly with $w$ , the length of the band. We obtain the following using random band row vectors: ", "page_idx": 7}, {"type": "text", "text": "Theorem 3.4. For any $\\epsilon>0$ , $\\delta>0$ , $\\beta>0,$ , there is an $(\\epsilon,\\delta)$ -DP set mechanism with error $(e^{\\epsilon}{+}1)^{-1}$ and encodings consisting of $(1+\\beta)k$ field elements and three hash functions. DPSet.Encode takes $O(k w)$ time and DPSet.Decode takes $O(w)$ time where $w=O(\\log(1/\\delta)+\\log k)$ . ", "page_idx": 7}, {"type": "text", "text": "3.3 Pure differentially private sets ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "We consider a pure differentially private construction of the framework in Section 3.1 with $\\delta=0$ . In Section 3.1, the failure probability of solving the constructed linear system corresponds to $\\delta$ in the DP definition. To obtain a pure DP construction, our goal is to construct a linear system that is solvable with probability 1. So, we want to construct a matrix $\\mathbf{M}$ that has full rank with probability 1. To do this, we use the Vandermonde matrix construction (where Row is deterministic) that may be solved in $O(k\\log^{2}k)$ time as shown in [9]. This construction has another advantages over the random band approach beyond obtaining $\\delta=0$ . The resulting encodings are smaller with only $k$ field elements whereas the other construction requires $m=(1\\bar{+}\\beta)k$ field elements with $\\beta>0$ . In contrast, decoding times are larger here. See Appendix C for full description and proof. ", "page_idx": 7}, {"type": "text", "text": "Theorem 3.5. For any $\\epsilon\\mathrm{~\\,~>~\\,~0~}$ , there exists an $\\epsilon{-}D P$ set mechanism with error $(e^{\\epsilon}+1)^{-1}$ .   \nDPSet.Encode takes $O(k\\log^{2}k)$ time and DPSet.Decode takes $O(k)$ time. ", "page_idx": 7}, {"type": "text", "text": "Other Constructions. We present two concrete constructions from specific linear systems, but it is possible to plug in other linear systems. For example, plugging in [22] would result in a pure DP solution with faster encoding times, but larger encoding sizes compared to Theorem 3.5. ", "page_idx": 7}, {"type": "text", "text": "4 Lower bounds ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "Privacy-utility lower bounds. We start by considering the possibility of improving the error probability (utility) with respect to the desired levels of privacy. Our construction achieved error probability at most $1/(e^{\\epsilon}+1)$ for any choice of $\\epsilon\\,\\geq\\,0$ . In other words, for any error $\\alpha$ , our construction achieves privacy $\\epsilon=\\log((1-\\alpha)/\\alpha)$ . We show that this trade-off between $\\epsilon$ and error probability is optimal even up to constants (ignoring $\\delta$ factors). See Appendix D for the proof. ", "page_idx": 7}, {"type": "text", "text": "Theorem 4.1. Consider any $(\\epsilon,\\delta)$ -DP algorithm $\\Pi$ for sets of size $k$ . Suppose that $\\Pi$ has error probability at most $\\alpha\\leq1/2$ . Then, $\\epsilon\\ge\\ln((1-\\alpha-\\delta)/\\alpha)$ . In other words, for a fixed privacy level $\\epsilon\\geq0$ and $\\delta\\geq0$ , the error probability of $\\Pi$ must be $\\alpha\\stackrel{\\cdot}{\\geq}(1-\\delta)(e^{\\epsilon}+1)$ . ", "page_idx": 7}, {"type": "text", "text": "Space lower bounds. Next, we move onto determining the necessary space usage of set representations. There exist space lower bounds for probabilistic membership data structures (such as Bloom filters) that have a false positive probability of $\\alpha$ and no false negatives. It is well known that such data structures require $k\\,{\\bar{\\cdot}}\\log(1/{\\bar{\\alpha}})$ bits of space when given an input of size $k$ . However, these lower bounds only apply when the false negative rate is 0. See Broder and Mitzenmacher [10] for the prior lower bound. We present a space lower bound for DP mechanisms with non-zero false negatives using a proof through compression that deviates from prior counting arguments (see Appendix D). ", "page_idx": 7}, {"type": "text", "text": "Theorem 4.2. Consider any $(\\epsilon,\\delta)$ -DP \u03a0 for sets of size $k$ . If \u03a0 produces $s$ -bit encodings with error probability $0<\\alpha\\leq1/2,$ , then $\\mathbf{E}[s]=\\Omega\\left((1+\\delta/(e^{\\epsilon}))\\cdot k\\cdot\\log(1/\\alpha)\\right)$ . ", "page_idx": 7}, {"type": "text", "text": "5 Experimental evaluation ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "Setup. We implemented DPSet, ALP [2] and DP Count Sketch [34] in $C++$ using 800 lines of code. For DPSet, we use the analysis of Bienstock et al. [7] to choose appropriate parameters for $\\delta\\leq2^{-40}$ with parameter $\\beta=0.05$ . To fit ALP and DP Count Sketch to our problem setting, we round the query results of these mechanisms to the nearest 0 or 1. We target privacy parameter $\\overline{{\\delta}}\\leq2^{-40}$ for all three constructions. To fairly compare utility, we chose parameters to ensure that encoding sizes are approximately equal for all three constructions (see Appendix G for more details on encoding sizes). ", "page_idx": 7}, {"type": "image", "img_path": "GQNvvQquO0/tmp/8331098f795206344c3d31273e9e7807ca631dcbf1ff279c8371afb26772bdbc.jpg", "img_caption": ["Figure 1: Comparisons of of DPSet, ALP, and DP Count Sketch with $\\delta\\leq2^{-40}$ . The $x$ -axis is privacy parameter $\\epsilon$ and the $y$ -axis is error probability, encoding time (ms) or decoding time (ms). "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "We consider experiments for input sets of size $k\\,\\in\\,\\{2^{12},2^{16},2^{20}\\}$ . Each trial picks input sets as $k$ uniformly random 128-bit strings from a universe of all $n\\,=\\,2^{128}$ strings. Although, all three constructions are agnostic to the distribution of the input set. We ran all experiments using a Ubuntu PC with 12 cores, $3.7\\:\\mathrm{GHz}$ Intel Xeon W-2135 and $64\\:\\mathrm{GB}$ of RAM. Our experiments enable AVX2 and AVX-512 instruction sets with SIMD instructions. All reported results use single-thread execution as the average of at least 1,000 trials with standard deviation less than $10\\%$ of the average. The entire experimental evaluations (including setup) took approximately 1 hour of compute time. ", "page_idx": 8}, {"type": "text", "text": "Utility. To measure utility, we query the entire input set of size $k$ as well as a random subset of $k$ elements outside of the set in each trial. We plot our results in Figure 1 along with our lower bound (Theorem 4.1). We see that DPSet has much better utility compared to the prior works. Furthermore, our experiments corroborate our theoretical analysis that error probability exponentially decreases in $\\epsilon$ and essentially matches our lower bound of $\\alpha\\stackrel{.}{>}(1-\\delta)/(e^{\\bar{\\epsilon}}+1)\\geq(1-2^{-40})/(e^{\\bar{\\epsilon}}+1)$ . ", "page_idx": 8}, {"type": "text", "text": "Efficiency. We compare the efficiency of encoding input sets and decoding random elements. For larger input set sizes $k$ and bigger $\\epsilon$ , our constructions have faster encoding times. In contrast, DPSet has slower encoding for smaller $k$ and $\\epsilon$ . For decoding, DPSet has slower times than both prior works. Nevertheless, decoding times of DPSet remain very fast and are less than 0.3 milliseconds. ", "page_idx": 8}, {"type": "text", "text": "6 Conclusions ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In this work, we present constructions of DP sets that are essentially optimal in privacy-utility and space trade-offs nearly matching our lower bounds. The error obtained is exponentially smaller (both theoretically and empirically) than possible for private histograms mostly studied in prior works. Additionally, we experimentally show that our constructions are concretely efficient. ", "page_idx": 9}, {"type": "text", "text": "Limitations. A limitation of our work is that we consider sparse sets (as opposed to the more general sparse histograms). Nevertheless, we believe this specific problem has several important applications with the added benefit of exponentially smaller error. Our constructions assume fully random hash functions (following several prior works) and instantiations are limited to finite field sizes. If we assume pseudorandom hash functions (PRFs), our construction obtains computational DP instead. ", "page_idx": 9}, {"type": "text", "text": "7 Acknowledgements ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "The authors would like to thank Rachel Cummings for feedback on earlier versions of this paper. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "[1] Mohammad Alaggan, S\u00e9bastien Gambs, and Anne-Marie Kermarrec. Blip: Non-interactive differentiallyprivate similarity computation on Bloom filters. In Andr\u00e9a W. Richa and Christian Scheideler, editors, Stabilization, Safety, and Security of Distributed Systems, pages 202\u2013216, Berlin, Heidelberg, 2012. Springer Berlin Heidelberg. [2] Martin Aum\u00fcller, Christian Janos Lebeda, and Rasmus Pagh. Differentially private sparse vectors with low error, optimal space, and fast access. In Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security, pages 1223\u20131236, 2021.   \n[3] Victor Balcer and Salil Vadhan. Differential privacy on finite computers. Journal of Privacy and Confidentiality, 9:2, 2019. [4] Raef Bassily and Adam Smith. Local, private, efficient protocols for succinct histograms. In Proceedings of the forty-seventh annual ACM symposium on Theory of computing, pages 127\u2013135, 2015. [5] Narayan Bhamidipati, Ravi Kant, and Shaunak Mishra. A large scale prediction engine for app install clicks and conversions. In Proceedings of the 2017 ACM on Conference on Information and Knowledge Management, pages 167\u2013175, 2017.   \n[6] Giuseppe Bianchi, Lorenzo Bracciale, and Pierpaolo Loreti. \u201dBetter Than Nothing\u201d Privacy with Bloom Filters: To What Extent? In International Conference on Privacy in Statistical Databases, pages 348\u2013363. Springer, 2012.   \n[7] Alexander Bienstock, Sarvar Patel, Joon Young Seo, and Kevin Yeo. Near-Optimal oblivious Key-Value stores for efficient PSI, PSU and Volume-Hiding Multi-Maps. In 32nd USENIX Security Symposium (USENIX Security 23), pages 301\u2013318, Anaheim, CA, August 2023. USENIX Association. [8] Burton H. Bloom. Space/time trade-offs in hash coding with allowable errors. Commun. ACM, 13(7):422\u2013426, Jul. 1970.   \n[9] Allan Borodin and Robert Moenck. Fast modular transforms. Journal of Computer and System Sciences, 8(3):366\u2013386, 1974.   \n[10] Andrei Broder and Michael Mitzenmacher. Network applications of Bloom filters: A survey. Internet mathematics, 1(4):485\u2013509, 2004.   \n[11] Lynne M Butler. The q-log-concavity of q-binomial coefficients. Journal of Combinatorial Theory, Series A, 54(1):54\u201363, 1990.   \n[12] Moses Charikar, Kevin Chen, and Martin Farach-Colton. Finding frequent items in data streams. In Peter Widmayer, Stephan Eidenbenz, Francisco Triguero, Rafael Morales, Ricardo Conejo, and Matthew Hennessy, editors, Automata, Languages and Programming, pages 693\u2013703, Berlin, Heidelberg, 2002. Springer Berlin Heidelberg.   \n[13] Graham Cormode, Cecilia Procopiuc, Divesh Srivastava, and Thanh T. L. Tran. Differentially private summaries for sparse data. In Proceedings of the 15th International Conference on Database Theory, ICDT \u201912, page 299\u2013311, New York, NY, USA, 2012. Association for Computing Machinery.   \n[14] Charlie Dickens, Justin Thaler, and Daniel Ting. Order-invariant cardinality estimators are differentially private. Advances in Neural Information Processing Systems, 35:15204\u201315216, 2022.   \n[15] Martin Dietzfelbinger and Stefan Walzer. Efficient gauss elimination for near-quadratic matrices with one short random block per row, with applications. In 27th Annual European Symposium on Algorithms (ESA 2019), volume 144, page 39. Schloss Dagstuhl\u2013Leibniz-Zentrum fuer Informatik, 2019.   \n[16] Peter C. Dillinger and Stefan Walzer. Ribbon filter: practically smaller than Bloom and Xor. CoRR, abs/2103.02515, 2021.   \n[17] Chen Doytshman. Akanat: How akamai uses machine learning to detect shared ips, 2024.   \n[18] Cynthia Dwork, Frank McSherry, Kobbi Nissim, and Adam Smith. Calibrating noise to sensitivity in private data analysis. In Theory of Cryptography, pages 265\u2013284, 2006.   \n[19] Cynthia Dwork and Aaron Roth. The algorithmic foundations of differential privacy. Foundations and Trends in Theoretical Computer Science, 9(3\u20134):211\u2013407, 2014.   \n[20] \u00dalfar Erlingsson, Vasyl Pihur, and Aleksandra Korolova. RAPPOR: Randomized aggregatable privacypreserving ordinal response. In Gail-Joon Ahn, Moti Yung, and Ninghui Li, editors, ACM CCS 2014, pages 1054\u20131067. ACM Press, November 2014.   \n[21] Badih Ghazi, Noah Golowich, Ravi Kumar, Rasmus Pagh, and Ameya Velingker. On the power of multiple anonymous messages: Frequency estimation and selection in the shuffle model of differential privacy. In Eurocrypt 2021, pages 463\u2013488, 2021.   \n[22] Anna C Gilbert, Yi Li, Ely Porat, and Martin J Strauss. For-all sparse recovery in near-optimal time. ACM Transactions on Algorithms (TALG), 13(3):1\u201326, 2017.   \n[23] Moritz Hardt and Kunal Talwar. On the geometry of differential privacy. In Proceedings of the forty-second ACM symposium on Theory of computing, pages 705\u2013714, 2010.   \n[24] Ziyue Huang, Yuan Qiu, Ke Yi, and Graham Cormode. Frequency estimation under multiparty differential privacy: one-shot and streaming. Proc. VLDB Endow., 15(10):2058\u20132070, jun 2022.   \n[25] Aleksandra Korolova, Krishnaram Kenthapadi, Nina Mishra, and Alexandros Ntoulas. Releasing search queries and clicks privately. WWW \u201909, page 171\u2013180. Association for Computing Machinery, 2009.   \n[26] Oren Anava Maggie, Vitaly Kuznetsov, and Will Cukierski. Web traffic time series forecasting, 2017.   \n[27] Luca Melis, George Danezis, and Emiliano De Cristofaro. Efficient private statistics with succinct sketches. In 23rd Annual Network and Distributed System Security Symposium, NDSS, 2016.   \n[28] Rasmus Pagh and Mikkel Thorup. Improved utility analysis of private countsketch. In Advances in Neural Information Processing Systems, volume 35, pages 25631\u201325643, 2022.   \n[29] Ely Porat. An optimal Bloom fliter replacement based on matrix solving. In Anna Frid, Andrey Morozov, Andrey Rybalchenko, and Klaus W. Wagner, editors, Computer Science - Theory and Applications, pages 263\u2013273, Berlin, Heidelberg, 2009. Springer Berlin Heidelberg.   \n[30] Pedro Reviriego, Alfonso Sanchez-Macian, Peter C Dillinger, and Stefan Walzer. On the privacy of multi-versioned approximate membership check filters. IEEE Transactions on Dependable and Secure Computing, (01):1\u201313, 2023.   \n[31] Pedro Reviriego, Alfonso S\u00e1nchez-Macian, Stefan Walzer, Elena Merino-G\u00f3mez, Shanshan Liu, and Fabrizio Lombardi. On the privacy of counting Bloom filters. IEEE Transactions on Dependable and Secure Computing, 20(2):1488\u20131499, 2022.   \n[32] Claude Elwood Shannon. A mathematical theory of communication. The Bell system technical journal, 27(3):379\u2013423, 1948.   \n[33] Stanley L. Warner. Randomized response: A survey technique for eliminating evasive answer bias. Journal of the American Statistical Association, 60(309):63\u201369, 1965.   \n[34] Fuheng Zhao, Dan Qiao, Rachel Redberg, Divyakant Agrawal, Amr El Abbadi, and Yu-Xiang Wang. Differentially private linear sketches: Efficient implementations and applications. In Advances in Neural Information Processing Systems, volume 35, pages 12691\u201312704, 2022.   \n[35] Mingxun Zhou, Tianhao Wang, T-H. Hubert Chan, Giulia Fanti, and Elaine Shi. Locally differentially private sparse vector aggregation. In 2022 IEEE Symposium on Security and Privacy (SP), pages 422\u2013439, 2022. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "A Proof of correctness of DPSet ", "text_level": 1, "page_idx": 11}, {"type": "text", "text": "We prove the correctness of our constructions. First, we present a lemma about the false positive and false negative rates. Afterwards, we use this to get a final error probability. ", "page_idx": 11}, {"type": "text", "text": "Lemma A.1. DPSet.Decode has false positive probability of $\\left|\\mathbb{F}\\right|^{-1}$ and false negative probability of $p\\cdot(1-|\\mathbb{F}|^{-1})$ . Also, the probabilities are independent for each $q\\in U$ . ", "page_idx": 11}, {"type": "text", "text": "Proof. First consider false positives. If $u\\not\\in S$ , then $u\\notin S^{\\prime}$ . We know $\\operatorname*{Pr}[\\mathsf{R o w}(u)\\!\\cdot\\!\\mathbf{x}=h(u)]=|\\mathbb{F}|^{-1}$ since $h$ is a fully random hash function. For false negatives, consider any $s\\ \\in\\ S$ . Note, that $\\operatorname*{Pr}[s\\not\\in S^{\\prime}\\mid s\\in\\dot{S}]=(1-p)$ . Since DPSet.Decode only returns 0 if $\\mathbf{x}=\\perp$ , there is no additional error from DPSet.Encode failing. If $s\\notin S^{\\prime}$ , the decoding will return 1 with probability $\\left|\\mathbb{F}\\right|^{-1}$ . So, the false negative probability is $s$ not sampled into $S^{\\prime}$ and the linear constraint being unsatisfied that is $p\\cdot(1-|\\bar{\\mathbb{F}}|^{-1})$ . Finally, these probabilities are independent for every $q\\in U$ following from the fact that sampling each element into $S^{\\prime}$ is independent and that $h$ is a fully random hash function. ", "page_idx": 11}, {"type": "text", "text": "The error probability is the maximum of the false positive and negative probabilities. Suppose we desired a certain error probability $\\alpha$ , we can pick the field size and exclusion probability as follows. ", "page_idx": 11}, {"type": "text", "text": "Proof of Theorem 3.1. First, we see that $\\alpha=|\\mathbb{F}|^{-1}$ for the false positives. Then, we pick $p$ satisfying $\\alpha=p\\cdot(1-\\alpha)$ for false negatives to see that $p=\\alpha/(1-\\alpha)$ . ", "page_idx": 11}, {"type": "text", "text": "B Proof of privacy of DPSet ", "text_level": 1, "page_idx": 11}, {"type": "text", "text": "In this section, we present the full proof of Theorem 3.2. In particular, we show that it follows directly from the following theorem by plugging in $\\epsilon$ accordingly. In our proof, we require the randomness of $h$ only for correctness and not privacy. ", "page_idx": 11}, {"type": "text", "text": "Theorem B.1. Suppose $|\\mathbb{F}|\\,=\\,\\alpha^{-1}$ , $p\\,=\\,\\alpha/(1-\\alpha)$ and Solve fails with probability fSolve for correctly generated Row. Then, DPSet is $\\textstyle(\\ln({\\frac{1-\\alpha}{\\alpha}})$ , fSolve)- $.D P$ ", "page_idx": 11}, {"type": "text", "text": "Proof. Let $S_{1}$ and $S_{2}$ be the two neighboring sets such that $S_{2}\\,=\\,S_{1}\\cup\\{u\\}$ . Let $\\mathbf{Z}_{S_{1}}$ and $\\mathbf{Z}_{S_{2}}$ be the two random variables denoting the representations output by DPSet.Encode for $S_{1}$ and $S_{2}$ , respectively. Let $m$ be the number of variables (length of the encoded vector) in Algorithm 1. Let $\\mathbf{x}\\in\\mathbb{F}^{m}$ , Row and $h$ be arbitrary, and let $\\mathbf{v}=(\\mathbf{x},\\mathsf{R o w},h,\\bot)$ . We first show that ", "page_idx": 11}, {"type": "equation", "text": "$$\n\\mathrm{Pr}[\\mathbf{Z}_{S_{1}}=\\mathbf{v}]\\leq\\left({\\frac{1-\\alpha}{\\alpha}}\\right)\\cdot\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}]\n$$", "text_format": "latex", "page_idx": 11}, {"type": "equation", "text": "$$\n\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}]\\leq\\left({\\frac{1-\\alpha}{\\alpha}}\\right)\\cdot\\mathrm{Pr}[\\mathbf{Z}_{S_{1}}=\\mathbf{v}]\n$$", "text_format": "latex", "page_idx": 11}, {"type": "text", "text": "where the probability is over the random coin tosses performed by DPSet.Encode. ", "page_idx": 11}, {"type": "text", "text": "We first prove Equation 1. Let $R_{u}$ be the event where the element $u$ is removed during DPSet.Encode on $S_{2}$ . Recalling that $\\textstyle\\operatorname*{Pr}[R_{u}]=p={\\frac{\\alpha}{1-\\alpha}}$ from Algorithm 1, we have ", "page_idx": 11}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}]}\\\\ &{\\mathrm{\\=\\Pr}[R_{u}]\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}\\ |\\ R_{u}]+\\mathrm{Pr}[\\overline{{R_{u}}}]\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}\\ |\\ \\overline{{R_{u}}}]}\\\\ &{\\mathrm{\\=\\Pr}[R_{u}]\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{1}}=\\mathbf{v}]+\\mathrm{Pr}[\\overline{{R_{u}}}]\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}\\ |\\ \\overline{{R_{u}}}]}\\\\ &{\\mathrm{\\\\\\\\\\}\\geq\\,\\mathrm{Pr}[R_{u}]\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{1}}=\\mathbf{v}]=\\frac{\\alpha}{1-\\alpha}\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{1}}=\\mathbf{v}]}\\end{array}\n$$", "text_format": "latex", "page_idx": 11}, {"type": "text", "text": "where the second equality follows from the fact that the distribution of $\\mathbf{Z}_{S_{2}}$ is identical to $\\mathbf{Z}_{S_{1}}$ conditioned on the event $R_{u}$ . Rearranging, we get the desired bound. ", "page_idx": 11}, {"type": "text", "text": "Next, we prove Equation 2. By again decomposing $\\mathrm{Pr}[{\\bf Z}_{S_{2}}={\\bf v}]$ conditioned on $R_{u}$ , we have ", "page_idx": 11}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}]}\\\\ &{\\ =\\mathrm{Pr}[R_{u}]\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}\\,\\vert\\,\\,R_{u}]+\\mathrm{Pr}[\\overline{{R_{u}}}]\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}\\,\\vert\\,\\,\\overline{{R_{u}}}]}\\\\ &{\\ =\\mathrm{Pr}[R_{u}]\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{1}}=\\mathbf{v}]+\\mathrm{Pr}[\\overline{{R_{u}}}]\\,\\mathrm{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}\\,\\vert\\,\\,\\overline{{R_{u}}}].}\\end{array}\n$$", "text_format": "latex", "page_idx": 11}, {"type": "text", "text": "Before proceeding with the proof, we claim that ", "page_idx": 12}, {"type": "equation", "text": "$$\n\\operatorname*{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}\\ |\\ \\overline{{R_{u}}}]\\leq\\alpha^{-1}\\operatorname*{Pr}[\\mathbf{Z}_{S_{1}}=\\mathbf{v}].\n$$", "text_format": "latex", "page_idx": 12}, {"type": "text", "text": "Then plugging in Equation 3 to the above equation, we get ", "page_idx": 12}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\ensuremath{\\operatorname*{Pr}}[R_{u}]\\ensuremath{\\operatorname*{Pr}}[\\ensuremath{\\mathbf{Z}}_{S_{1}}=\\ensuremath{\\mathbf{v}}]+\\ensuremath{\\operatorname*{Pr}}[\\ensuremath{\\mathbf{}}{R}_{u}]\\ensuremath{\\operatorname*{Pr}}[\\ensuremath{\\mathbf{Z}}_{S_{2}}=\\ensuremath{\\mathbf{v}}\\mid\\ensuremath{\\overline{{R_{u}}}}]}\\\\ &{\\qquad\\le\\ensuremath{\\operatorname*{Pr}}[R_{u}]\\ensuremath{\\operatorname*{Pr}}[\\ensuremath{\\mathbf{Z}}_{S_{1}}=\\ensuremath{\\mathbf{v}}]+\\ensuremath{\\operatorname*{Pr}}[\\ensuremath{\\overline{{R_{u}}}}](\\alpha^{-1}\\ensuremath{\\operatorname*{Pr}}[\\ensuremath{\\mathbf{Z}}_{S_{1}}=\\ensuremath{\\mathbf{v}}])}\\\\ &{\\qquad\\le(\\frac{\\alpha}{1-\\alpha}+\\frac{1-2\\alpha}{\\alpha-\\alpha^{2}})\\ensuremath{\\operatorname*{Pr}}[\\ensuremath{\\mathbf{Z}}_{S_{1}}=\\ensuremath{\\mathbf{v}}]}\\\\ &{\\qquad=\\frac{1-\\alpha}{\\alpha}\\ensuremath{\\operatorname*{Pr}}[\\ensuremath{\\mathbf{Z}}_{S_{1}}=\\ensuremath{\\mathbf{v}}].}\\end{array}\n$$", "text_format": "latex", "page_idx": 12}, {"type": "text", "text": "We now prove Equation 3 to complete the proof. Let $\\mathbf{S}_{1}^{\\prime}$ and $\\mathbf{S}^{\\prime}\\mathbf{2}$ be random variables denoting the set of elements that survived the removal process in DPSet.Encode for input $S_{1}$ and $S_{2}$ , respectively. Consider an arbitrary subset $S^{\\prime}\\subseteq S_{1}$ . We can see that $\\operatorname*{Pr}[\\mathbf{S^{\\prime}}_{2}=S^{\\prime}\\cup\\{u\\}\\mid\\overline{{R_{u}}}]=\\operatorname*{Pr}[\\mathbf{S^{\\prime}}_{1}=S^{\\prime}]$ , and so if we show that ", "page_idx": 12}, {"type": "equation", "text": "$$\n\\operatorname*{Pr}[\\mathbf{Z}_{S_{2}}=\\mathbf{v}\\ |\\ \\overline{{R_{u}}}\\cap(\\mathbf{S}^{\\prime}{}_{2}=S^{\\prime}\\cup\\{u\\})]\\le\\alpha^{-1}\\operatorname*{Pr}[\\mathbf{Z}_{S_{1}}=\\mathbf{v}\\ |\\ \\mathbf{S}^{\\prime}{}_{1}=S^{\\prime}]\n$$", "text_format": "latex", "page_idx": 12}, {"type": "text", "text": "then we can apply the law of total probability to obtain Equation 3. ", "page_idx": 12}, {"type": "text", "text": "One way to see why Equation 4 holds is as follows. If the left hand side is 0, then the bound trivially holds, so we may assume that the probability is positive. For any choice of hash functions (that also determine Row), the linear systems generated are uniquely determined by the surviving elements. Thus, conditioned on the event that $\\bar{\\mathbf{S}^{\\prime}}_{1}=S^{\\prime}$ and $\\mathbf{S^{\\prime}}_{2}\\doteq S^{\\prime}\\cup\\{u\\}$ , the generated linear systems are deterministic. Let $L_{1}$ and $L_{2}$ be the corresponding linear systems for $S_{1}$ and $S_{2}$ , respectively. From the condition, it must be that $L_{1}\\subset L_{2}$ and $L_{2}$ has exactly one more equation than $L_{1}$ that is linearly independent of the other rows. In other words, $L_{1}$ has exactly one more degree of freedom than $L_{2}$ , which corresponds to an extra free variable. By the construction of Algorithm 1, the free variables are independently and uniformly randomly set to values in $\\mathbb{F}$ . Thus, the probability that this random free variable is set to the corresponding value in $\\mathbf{x}$ (the first component of $\\ensuremath{\\mathbf{v}}$ ) is exactly $1/|\\mathbb{F}|=\\alpha$ . This establishes the inequality (in fact an equality) and completes the proof of Equation 4, from which Equation 2 follows immediately. ", "page_idx": 12}, {"type": "text", "text": "From Equation 1 and Equation 2, the proof of the main theorem follows immediately by applying Definition 2.1 and using the failure probability of Solve is at most $\\delta=f_{\\mathsf{S o l v e}}$ . ", "page_idx": 12}, {"type": "text", "text": "C Pure differentially private subsets ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "As discussed in Section 3.3, to obtain a pure DP construction, our goal is to construct a linear system that is full rank with probability 1. To achieve this goal, we will use the Vandermonde matrix construction. Vandermonde matrix is a $n\\times k$ matrix of the form ", "page_idx": 12}, {"type": "equation", "text": "$$\n\\begin{array}{c c c c c}{{\\left[1\\right.}}&{{u_{1}}}&{{\\ldots}}&{{u_{1}^{k-2}}}&{{u_{1}^{k-1}}}\\\\ {{1\\left.}}&{{u_{2}}}&{{\\ldots}}&{{u_{2}^{k-2}}}&{{u_{2}^{k-1}}}\\\\ {{}}&{{}}&{{\\vdots}}&{{}}&{{}}\\\\ {{1\\left.}}&{{u_{n}}}&{{\\ldots}}&{{u_{n}^{k-2}}}&{{u_{n}^{k-1}}}\\end{array}\\right]}}\\end{array}\n$$", "text_format": "latex", "page_idx": 12}, {"type": "text", "text": "where each $u_{i}\\in\\mathbb{F}$ . If $n\\leq k$ then this matrix is always full rank for any set of distinct $u_{i}$ . ", "page_idx": 12}, {"type": "text", "text": "Suppose that the universe $U=\\mathbb{F}$ for some finite field $\\mathbb{F}$ . Let $S$ be the input set and let $k=|S|$ . Then we can construct the matrix in Algorithm 1 using the Vandermonde matrix construction to obtain a pure differentially private construction. The algorithm for constructing the row vector is presented in Algorithm 5. Using [9], the linear system constructed using the Vandermonde matrix can be solved in ${\\bar{O}}(k\\log^{2}k)$ time. We point to the prior work to find the corresponding SolveVandermonde. Plugging this into the framework of Section 3.1, we immediately obtain Theorem 3.5. ", "page_idx": 12}, {"type": "table", "img_path": "GQNvvQquO0/tmp/ad76bd929680175715e859148a8d9d6fb7b14df62c23de66b922f8f3cd17d284.jpg", "table_caption": [], "table_footnote": [], "page_idx": 13}, {"type": "text", "text": "D Proof of lower bounds ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "We start by proving our lower bound of utility stated in Theorem 4.1. ", "page_idx": 13}, {"type": "text", "text": "Proof of Theorem 4.1. Pick any $\\mathbf{x}$ and $\\mathbf{y}$ that differ in exactly one entry. Without loss of generality, pick the unique index $i\\,\\in\\,[n]$ such that $\\mathbf{x}[i]\\,=\\,0$ and $\\mathbf{y}[i]\\,=\\,1$ . Let $\\mathbf{Z_{x}}$ and $\\mathbf{Z_{y}}$ be the random variables denoting the representations output by $\\Pi$ for $\\mathbf{x}$ and y respectively. We will consider the probability that $\\Pi$ produces a representation such that \u03a0.Decode outputs 1 on index $i$ for each of $\\mathbf{Z_{x}}$ and $\\mathbf{Z_{y}}$ . Note that $\\mathrm{Pr}[\\Pi.\\mathsf{D e c o d e}(\\mathbf{Z}_{y},i)=1]\\geq1-\\alpha$ since $\\mathbf{y}[i]=1$ . Similarly, we note that $\\begin{array}{r}{\\operatorname{Pr}[\\Pi.\\mathsf{D e c o d e}(\\mathbf{Z}_{x},i)=1]\\Big\\{\\leq\\alpha}\\end{array}$ since $\\mathbf{x}[\\dot{i}]=0$ . In other words, we see ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{1-\\alpha\\leq\\operatorname*{Pr}[\\Pi.\\mathsf{D e c o d e}(\\mathbf{Z}_{y},i)=1]}\\\\ &{\\qquad\\leq e^{\\epsilon}\\operatorname*{Pr}[\\Pi.\\mathsf{D e c o d e}(\\mathbf{Z}_{x},i)=1]+\\delta}\\\\ &{\\qquad\\leq e^{\\epsilon}\\alpha+\\delta.}\\end{array}\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "By re-arranging the inequality $1-\\alpha\\leq e^{\\epsilon}\\alpha+\\delta$ , we get the desired theorem. ", "page_idx": 13}, {"type": "text", "text": "To prove our space lower bound stated in Theorem 4.2, we start with proving an intermediate result about the required space for any mechanism (not necessarily differentially private) that has error probability at most $\\alpha$ . In particular, the existence of such a mechanism enables a very efficient compression algorithm to encode random vectors $\\mathbf{x}$ with $k$ non-zero entries. ", "page_idx": 13}, {"type": "text", "text": "Lemma D.1. Consider any mechanism \u03a0 for binary vectors ${\\bf x}\\in\\{0,1\\}^{n}$ with at most $k$ non-zero entries, $|\\mathbf{x}|_{1}\\leq k$ . If \u03a0 produces representations using $s$ bits of space in expectation and has error probability at most $0<\\alpha\\leq1/2$ , then ", "page_idx": 13}, {"type": "equation", "text": "$$\n\\mathbf{E}[s]\\geq(1-2\\alpha)k\\cdot\\log\\left({\\frac{1}{\\alpha}}-1\\right)-2\\log k-\\log\\log(e n/k).\n$$", "text_format": "latex", "page_idx": 13}, {"type": "text", "text": "Proof. We will make the assumption that $\\Pi$ never produces representations larger than $\\log\\left(\\!_{k}^{n}\\!\\right)$ bits on any input and any choice of randomness. Note, this is without loss of generality because a trivial representation of binary vectors with $k$ non-zero entries can be done in $\\bar{\\log}\\left(\\stackrel{n}{k}\\right)$ bits with zero error probability. If $\\Pi$ violates this assumption, we can modify $\\Pi$ to replace any longer encodings with the trivial one that will either maintain or decrease the space usage and error probability. ", "page_idx": 13}, {"type": "text", "text": "We consider the following two-party, one-way compression problem between an encoder (Alice) and a decoder (Bob). As input, Alice receives as input a uniformly random vector $\\mathbf{x}\\,\\in\\,\\{0,1\\}^{n}$ conditioned that exactly $k$ entries are non-zero, $|\\mathbf{x}|_{1}=k$ . Alice\u2019s job is to encode $\\mathbf{x}$ into a single message enabling Bob to correctly decode $\\mathbf{x}$ . In particular, Alice\u2019s goal is to make the message as small as possible. To do this, Alice will utilize the mechanism $\\Pi$ . At a high level, Alice will use $\\Pi$ to construct a representation $\\mathbf{x}$ with error probability $\\alpha$ . Additionally, Alice will send some auxiliary information that will enable Bob to correctly identify the non-zero entries of $\\mathbf{x}$ using the answers of \u03a0. We present the compression algorithm below. ", "page_idx": 13}, {"type": "text", "text": "Alice\u2019s Encoding: Receives $\\mathbf{x}\\in\\{0,1\\}^{n}$ such that $|\\mathbf{x}|_{1}=k$ and shared randomness $\\mathcal{R}$ . ", "page_idx": 13}, {"type": "text", "text": "1. Construct $\\mathbf{Z}\\gets\\Pi.\\mathsf{E n c o d e}(\\mathbf{x};\\mathcal{R})$ using randomness $\\mathcal{R}$ .   \n2. Set $X=\\{i\\in[n]\\mid\\mathbf{x}[i]=1\\}$ .   \n3. Initialize $A\\leftarrow\\emptyset$ and $B\\gets\\emptyset$ .   \n4. For all $i\\in[n]$ : ", "page_idx": 13}, {"type": "text", "text": "(a) If \u03a0.Decode $(\\mathbf{Z},i;\\mathcal{R})=0$ , set $A\\leftarrow A\\cup\\{i\\}$ . (b) Else when \u03a0.Decod $\\mathbf{\\nabla}_{:}(\\mathbf{Z},i;\\mathcal{R})=1$ , set $B\\leftarrow B\\cup\\{i\\}$ .   \n5. Encode $|\\mathbf{Z}|$ using $\\log\\log\\left(\\!\\!{\\binom{n}{k}}\\!\\!\\right)$ bits.   \n6. Encode $|X\\cap A|$ using $\\log k$ bits.   \n7. Encode $X\\cap A$ using $\\log\\left({\\binom{|A|}{|X\\cap A|}}\\right)$ bits.   \n8. Encode $X\\cap B$ using $\\log\\left(|{\\underset{X\\cap B|}{B}}\\right)$ bits.   \n9. Compute encoding $E=(|\\mathbf{Z}|,\\mathbf{Z},|X\\cap A|,X\\cap A,X\\cap B).$ ", "page_idx": 14}, {"type": "text", "text": "Bob\u2019s Decoding: Receives Alice\u2019s encoding and shared randomness $\\mathcal{R}$ . ", "page_idx": 14}, {"type": "text", "text": "1. Decode $|\\mathbf{Z}|$ using the first $\\log\\log\\left(\\!\\!{\\frac{n}{k}}\\!\\right)$ bits and $\\mathbf{Z}$ using the next $|\\mathbf{Z}|$ bits.   \n2. Initialize $A\\leftarrow\\emptyset$ and $B\\gets\\emptyset$ .   \n3. For all $i\\in[n]$ : (a) If \u03a0.Decode $(\\mathbf{Z},i;\\mathcal{R})=0$ , set $A\\leftarrow A\\cup\\{i\\}$ . (b) Else when \u03a0.Decod $\\mathbf{\\nabla}_{:}(\\mathbf{Z},i;\\mathcal{R})=1$ , set $B\\leftarrow B\\cup\\{i\\}$ .   \n4. Decode the size of $|X\\cap A|$ using the next $\\log k$ . Additionally, we know that $\\left|X\\cap B\\right|=$ $k-|X\\cap A|$ .   \n5. Using knowledge of $|A|,|B|,|X\\cap A|$ and $|X\\cap B|$ , decode $X\\cap A$ and $X\\cap B$ .   \n6. Using knowledge of $A$ and $B$ as well as $X\\cap A$ and $X\\cap B$ , we can decode $X$ and, thus, $\\mathbf{x}$ . ", "page_idx": 14}, {"type": "text", "text": "Prefix-freeness. We will later apply Shannon\u2019s source coding theorem. However, to do this, it is required that Alice\u2019s encoding algorithm is prefix-free. That is, any possible encoding cannot be a strict prefix of any other possible encoding. First, we note that the last components $|X\\cap A|$ , $X\\cap A$ and $X\\cap B$ will always be the same length. We use a fixed length to represent $|X\\cap A|$ . The two sets $X\\cap A$ and $X\\cap B$ always encode exactly $k$ elements. Therefore, the encoding length will only be different for various sizes of $\\mathbf{Z}$ . However, we prefix each encoding with the length $|\\mathbf{Z}|$ . Therefore, any encodings of different lengths (meaning different length $|\\mathbf{Z}|)$ will be prefix-free. Finally, it is clear that any set of equal length encodings will be prefix-free. ", "page_idx": 14}, {"type": "text", "text": "Encoding length. The expected length of Alice\u2019s encoding is exactly ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\log\\log\\binom{n}{k}+\\mathbf{E}[s]+\\log k+\\mathbf{E}\\left[\\log\\binom{|A|}{|X\\cap A|}+\\log\\binom{|B|}{|X\\cap B|}\\right]\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "as we consider expected space usage $s$ and all of $A,B,X\\cap A$ and $X\\cap B$ are random variables. Next, we note that the function $\\mathbf{\\bar{{f}}}(a,b)\\;{\\overset{=}{\\to}}\\;{\\binom{a}{b}}$ is log-concave for the relevant range $a\\ge b\\ge0$ (see [11] for example). Therefore, we can apply Jensen\u2019s inequality to obtain ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\mathbf{E}\\left[\\log\\left({\\begin{array}{c}{|A|}\\\\ {|X\\cap A|}\\end{array}}\\right)+\\log\\left({\\binom{|B|}{|X\\cap B|}}\\right)\\right]\\leq\\log\\left(\\mathbf{E}[|X\\cap A|]\\right)+\\log\\left(\\mathbf{E}[|X\\cap B|]\\right).\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "Next, we know that $|X\\cap A|+|X\\cap B|=k$ and $|A|+|B|=n$ . Therefore, we can rewrite ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\log\\left(\\sum_{\\mathbf{E}[\\left|X\\cap A\\right|]}^{\\mathbf{E}[\\left|A\\right|]}\\right)+\\log\\left(\\sum_{\\mathbf{E}[\\left|X\\cap B\\right|]}^{\\mathbf{E}[\\left|B\\right|]}\\right)=\\log\\left(\\sum_{\\mathbf{E}[\\left|X\\cap A\\right|]}^{\\mathbf{E}[\\left|A\\right|]}\\right)+\\log\\left(\\sum_{k=\\mathbf{E}[\\left|X\\cap A\\right|]}^{n-\\mathbf{E}[\\left|A\\right|]}\\right).\n$$", "text_format": "latex", "page_idx": 14}, {"type": "text", "text": "Next, we see that $\\mathbf{E}[|A|]\\leq(1-\\alpha)n$ and $\\mathbf{E}[|X\\cap A|]\\leq\\alpha k$ . Given that $\\alpha\\leq1/2$ , we immediately see that this is maximized when $\\mathbf{E}[|A|]=(1-\\alpha)n$ and $\\mathbf{E}[|X\\cap A|]=\\alpha k$ . So, we see that ", "page_idx": 14}, {"type": "equation", "text": "$$\n\\log\\Big(\\mathbf{{E}}[\\vert A\\vert]\\Big)+\\log\\Big(\\!\\!\\begin{array}{c}{n-\\mathbf{E}[\\vert A\\vert]}\\\\ {k-\\mathbf{E}[\\vert X\\cap A\\vert]}\\end{array}\\!\\!\\Big)\\leq\\log\\Big(\\!\\!\\begin{array}{c}{(1-\\alpha)n}\\\\ {\\alpha k}\\end{array}\\!\\!\\Big)+\\log\\Big(\\!\\!\\begin{array}{c}{\\alpha n}\\\\ {(1-\\alpha)k}\\end{array}\\!\\!\\Big).\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Complete the lower bound. To finally complete the proof of the lower bound, we will apply Shannon\u2019s source coding theorem [32] that states that the expected length of Alice\u2019s prefix-free encoding cannot be smaller than the entropy of Alice\u2019s input conditioned on any shared input. First, we see that ", "page_idx": 15}, {"type": "equation", "text": "$$\nH(\\mathbf{x}\\mid{\\mathcal{R}})=H(\\mathbf{x})=\\log{\\binom{n}{k}}.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Therefore, we get that Alice\u2019s expected encoding length must satisfy ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\log\\log\\binom{n}{k}+\\mathbf{E}[s]+\\log k+\\log\\binom{(1-\\alpha)n}{\\alpha k}+\\log\\binom{\\alpha n}{(1-\\alpha)k}\\geq\\log\\binom{n}{k}.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "By re-arranging, we see that the following is equivalent by applying linearity of expectation and using Stirling\u2019s approximation such that $\\tilde{\\binom{n}{k}}\\leq(\\dot{e}n/k)^{k}$ . ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{E}[s]\\geq\\log\\left(\\frac{{\\binom{n}{k}}}{{\\binom{(1-\\alpha)n}{\\alpha k}}{\\binom{\\alpha n}{(1-\\alpha)k}}}\\right)-2\\log k-\\log\\log(e n/k)}\\\\ &{\\qquad\\geq\\log\\left(\\left(\\frac{1-\\alpha}{\\alpha}\\right)^{(1-2\\alpha)k}\\right)-2\\log k-\\log\\log(e n/k)}\\\\ &{\\qquad\\geq(1-2\\alpha)k\\cdot\\log\\left(\\frac{1-\\alpha}{\\alpha}\\right)-2\\log k-\\log\\log(e n/k).}\\end{array}\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Therefore, we get our desired lower bound. ", "page_idx": 15}, {"type": "text", "text": "To sanity check, we can consider various choices of $\\alpha$ . For example, if we set $\\alpha=1/2$ , we note that the space lower bound becomes trivially 0. In fact, this makes sense as there are simple algorithms to obtain $\\alpha=1/2$ that require essentially no space. For example, we can use any random hash function $h$ that outputs random bits and return positive only when $h(x)=0$ . This obtains $\\alpha=1/2$ and essentially ignores the input set. Therefore, we can see that our lower bound is sensible. ", "page_idx": 15}, {"type": "text", "text": "Finally, we can use the above lemma combined with Theorem 4.1 to obtain our space lower bound for differentially private mechanisms that already require error probability. ", "page_idx": 15}, {"type": "text", "text": "Proof of Theorem 4.2. First, we apply Theorem 4.1 to get that the error probability $\\alpha$ must satisfy ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\alpha\\geq\\frac{1-\\delta}{e^{\\epsilon}+1}.\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "Note, for all choices $\\epsilon\\geq0$ and $\\delta\\geq0$ , we see that $0<\\alpha\\leq1/2$ . Plugging in the error probability $\\alpha\\geq(1-\\delta)/(e^{\\epsilon}+1)$ into Lemma D.1, we get the following ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{E}[s]\\geq\\frac{e^{\\epsilon}-1+2\\delta}{e^{\\epsilon}+1}\\cdot k\\cdot\\log\\left(\\frac{1}{\\alpha}-1\\right)-O(\\log k+\\log\\log n).\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "First, we note that $(e^{\\epsilon}\\mathrm{~-~}1)/(e^{\\epsilon}\\mathrm{~+~}1)\\,=\\,\\Theta(1)$ for all choices of $\\epsilon\\,\\geq\\,0$ . For sufficiently large $k=\\Omega(\\log\\log n)$ , we get that ", "page_idx": 15}, {"type": "equation", "text": "$$\n\\mathbf{E}[s]=\\Omega\\left(\\left(1+{\\frac{\\delta}{e^{\\epsilon}}}\\right)\\cdot k\\cdot\\log(1/\\alpha)\\right)\n$$", "text_format": "latex", "page_idx": 15}, {"type": "text", "text": "completing the proof. ", "page_idx": 15}, {"type": "image", "img_path": "GQNvvQquO0/tmp/11221a52c90f004a8e37c93894ede958639866f63e8cfbc20e81645396b053dc.jpg", "img_caption": ["Figure 2: Comparisons of of DPSet, ALP, and DP Count Sketch with $\\delta\\leq2^{-40}$ . The $x$ -axis is privacy parameter $\\epsilon$ and the $y$ -axis is encoding size in bytes. "], "img_footnote": [], "page_idx": 16}, {"type": "text", "text": "E Space optimization ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "In our construction, we set the encoding size $m\\,=\\,(1+\\beta)k$ in Section 3. This is a worst-case guarantee to ensure that Solve may always be executed with the condition that the number of columns $m$ satisfies $m\\geq(1+\\beta)n$ where $n$ is the number of rows (i.e., sampled set size $S^{\\prime}$ ). Instead, we can pick $m$ closer to the expected size of $S^{\\prime}$ and fail if it goes over. ", "page_idx": 16}, {"type": "text", "text": "For example, we can apply known probability tail bounds (such as Chernoff bounds) and pick $m$ to be closer to $(1-p)k$ that is the expected size of $S^{\\prime}$ . This increases the failure probability of Solve (and $\\delta$ ) by an additive $e^{-O(k)}$ to account for if the number of rows is too large. Let $0<\\gamma\\leq1$ be a fixed constant. Invoking Chernoff bound, we see that the probability that $|S^{\\prime}|\\geq(1+\\gamma)(1-p)k$ is bounded above by $e^{-O(k)}$ . Suppose that we assume that $\\begin{array}{r}{|S^{\\prime}|\\le k^{\\prime}=(1+\\gamma)\\frac{1-2\\alpha}{1-\\alpha}|S|}\\end{array}$ and choose $m=(1+\\beta)k^{\\prime}$ . This increases the failure probability of Solve by an additive $e^{-O(k)}$ , which is very small. As this optimization increases $\\delta$ , it cannot be used for pure differentially private schemes. ", "page_idx": 16}, {"type": "text", "text": "Unfortunately, this ends up being a theoretical improvement as we were unable to empirically observe space efficiency gains in natural settings. ", "page_idx": 16}, {"type": "text", "text": "F Trivial algorithm for large error Probability ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "If we consider the case of large error probabilities $\\alpha\\geq1/2$ , there are trivial algorithms for differentially private subsets that use, essentially, no space and has perfect privacy guarantees of $\\epsilon=\\delta=0$ . In fact, it suffices to simply consider the case with error probability $\\alpha=1/2$ . ", "page_idx": 16}, {"type": "text", "text": "Consider the following construction that completely ignores the input subset $S$ . Pick a random hash function $h:U\\to\\{0,1\\}$ . We represent the input subset $S$ using $h$ . For any element $u\\in U$ , the decoding algorithm returns $\\mathbf{1}_{h(u)=1}$ . In other words, the decoding algorithms returns a uniformly random bit for each element $u\\in U$ . It is not hard to see that the error probability of this construction is exactly $1/2$ . As the hash function $h$ is chosen independent of the input subset $S$ , it is quite clear that this trivial algorithm achieves perfect privacy of $\\epsilon=0$ and $\\delta=0$ . Therefore, all the constructions in our work focus on the case when $\\alpha\\leq1/2$ . ", "page_idx": 16}, {"type": "text", "text": "Theorem F.1. There exists a perfectly secure $(0,0)$ -DP set mechanism with error probability $\\alpha=1/2$ where the encoding consists of a single hash function independent of the input set size. ", "page_idx": 16}, {"type": "text", "text": "G Experimental evaluation of encoding size ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "We present graphs in Figure 2 showing the encoding sizes used in our experimental evaluation in Section 5. Recall that, for the purposes of comparing utility, we chose parameters such that all three constructions have similar encoding sizes. Therefore, the encoding sizes are essentially the same for all three constructions: DPSet from our work, ALP from [2] and DP Count Sketch from [34]. ", "page_idx": 16}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 17}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 17}, {"type": "text", "text": "Justification: Claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope. ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 17}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 17}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Justification: We provide a short section discussing limitations of our work. ", "page_idx": 17}, {"type": "text", "text": "Guidelines: ", "page_idx": 17}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 17}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 17}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 17}, {"type": "text", "text": "Justification: The paper provides full set of assumptions relevant to the asserted claims.   \nHowever, all the proofs are put in the appendix for space. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 18}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 18}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 18}, {"type": "text", "text": "Justification: We provide detailed information on the experimental setup and the parameters used. We plan to open source the code in the near future as well. ", "page_idx": 18}, {"type": "text", "text": "Guidelines: ", "page_idx": 18}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 18}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 19}, {"type": "text", "text": "Answer: [No] ", "page_idx": 19}, {"type": "text", "text": "Justification: We plan to open source the code in the near future, but at the moment they are not ready to be released publicly. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 19}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: Our experimental evaluation provides detailed setup of the experiment and how the relevant parameters were chosen. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 19}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 19}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 19}, {"type": "text", "text": "Justification: While we do not explicitly include error bars or confidence intervals, we report all our numbers averaged over at least 10 trials with standard deviation less than $10\\%$ of the average. ", "page_idx": 19}, {"type": "text", "text": "Guidelines: ", "page_idx": 19}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 19}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 20}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: We provide detailed information on the computer resources used to conduct the experiments. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 20}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: The research conducted in the paper conform with the NeurIPS Code of Ethics. Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 20}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 20}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 20}, {"type": "text", "text": "Justification: We believe our work does not incur negative societal impacts, as the goal of our work is to enhance user privacy. We implicitly discuss how our work may be beneficial to protect user privacy in the introduction. ", "page_idx": 20}, {"type": "text", "text": "Guidelines: ", "page_idx": 20}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 21}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 21}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 21}, {"type": "text", "text": "Justification: We believe our work poses no such risks. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 21}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 21}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 21}, {"type": "text", "text": "Justification: All the code was written by us in $C++$ for a fair comparison (e.g. to not compare with a Python code). The dataset was artificially crafted and no external dataset were used in our experimental evaluations. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 21}, {"type": "text", "text": "", "page_idx": 22}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: We plan to open source our code in the near future, but no new assets are released at the time. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 22}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: Our work does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 22}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: Our work does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects. ", "page_idx": 22}, {"type": "text", "text": "\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 23}]