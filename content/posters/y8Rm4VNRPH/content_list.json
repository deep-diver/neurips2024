[{"type": "text", "text": "Parallelizing Linear Transformers with the Delta Rule over Sequence Length ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Songlin Yang\u22c4 Bailin Wang\u22c4 Yu Zhang\u2020 Yikang Shen\u2021 Yoon Kim\u22c4 \u22c4Massachusetts Institute of Technology \u2020Soochow University \u2021MIT-IBM Watson AI Lab yangsl66@mit.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Transformers with linear attention (i.e., linear transformers) and state-space models have recently been suggested as a viable linear-time alternative to transformers with softmax attention. However, these models still underperform transformers especially on tasks that require in-context retrieval. While more expressive variants of linear transformers which replace the additive update in linear transformers with the delta rule [DeltaNet; 99] have been found to be more effective at associative recall, existing algorithms for training such models do not parallelize over sequence length and are thus inefficient to train on modern hardware. This work describes a hardware-efficient algorithm for training linear transformers with the delta rule, which exploits a memory-efficient representation for computing products of Householder matrices [11]. This algorithm allows us to scale up DeltaNet to standard language modeling settings. We train a 1.3B model for 100B tokens and find that it outperforms recent linear-time baselines such as Mamba [30] and GLA [116] in terms of perplexity and zero-shot performance on downstream tasks. We also experiment with two hybrid models which combine DeltaNet layers with (1) sliding-window attention layers every other layer or (2) two global attention layers, and find that these hybrids outperform strong transformer baselines. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "The attention mechanism [8, 112] has been shown to be an important primitive for accurate sequence modeling. Attention is moreover efficient during training as it is rich in matrix multiplications and can thus take advantage of highly parallel processing capabilities and specialized accelerators on modern GPUs. However, the complexity of attention is quadratic in sequence length, and hence it is a fundamentally expensive primitive. And while recent techniques have made it possible to scale attention to longer sequences through hardware-aware restructuring of the intermediate computations [19, 17, 57, 14], these methods still require storing the key/value vectors of previous elements, and this \u201cKV cache\u201d (whose size grows linearly) can be unwieldy to manage for long sequences. ", "page_idx": 0}, {"type": "text", "text": "Linear attention transformers [47] replace the exponential kernel in softmax attention with a dotproduct over (possibly transformed) key and query vectors. This makes it possible to formulate linear attention as a linear RNN with matrix-valued hidden states, thus obviating the need for a KV cache and enabling constant-memory inference. While initial variants of linear attention generally underperformed softmax attention on language modeling, gated variants of linear attention which incorporate a data-dependent gating factor have recently been shown to be competitive against strong transformer baselines [116, 89, 9, 77]. These gated linear transformers, along with time-varying state space models such as Mamba [30, 18] (which can be reparameterized as a gated linear transformer [116]), have been suggested as a potential alternative to ordinary transformers. However, despite the competitive language modeling performance, these models have been shown to underperform transformers on recall-intensive tasks [6, 7], which is important for many practical downstream tasks of interest (e.g., in retrieval-augmented generation [52]). ", "page_idx": 0}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "To enhance associative recall over long contexts, Schlag et al. [99] propose DeltaNet, a variant of a linear transformer which uses a delta rule-like update [114] to retrieve and update a value vector that is associated with the current key. DeltaNet was found to be effective on synthetic tasks and small scale language modeling/machine translation. However, the original work used a sequential algorithm that did not parallelize across sequence length, thus resulting in hardwareinefficient training, and it has not been clear how to scale DeltaNet to larger models and datasets. ", "page_idx": 1}, {"type": "text", "text": "This work describes a hardware-efficient training algorithm for DeltaNets which parallelizes the forward/backward passes across sequence length. We reparameterize the DeltaNet as a matrix-valued RNN whose recurrence is given by a generalized Householder transformation. This reparameterization enables the use of the compact WY representation [11] for products of Householder matrices, eliminating the need to materialize the hidden states of matrix size at each time step during parallel training, which would otherwise result in high I/O costs. The memory-efficient representation makes it possible to straightforwardly extend the chunkwise parallel strategy for training linear attention models [33, 105, 116] to the DeltaNet case. We scale DeltaNets to moderate-scale language modeling benchmarks (1.3B models trained on 100B tokens), where DeltaNet is found to obtain better language modeling and zero-shot downstream task performance than strong linear recurrent models such as Mamba [30] and GLA [116]. For in-context retrieval and learning evaluation, we evaluate DeltaNet on synthetic and real benchmarks [4, 2, 82, 6], where it is again found to perform well against linear recurrent baselines. Finally, we experiment with a hybrid approach where we combine DeltaNet layers with sliding attention layers or global attention layers, and find that these hybrid models can improve upon ordinary transformers, as well as the pure DeltaNet transformer. ", "page_idx": 1}, {"type": "text", "text": "2 Background ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "2.1 Linear Transformer: Transformers with Linear Attention ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Given a sequence of $d_{\\cdot}$ -dimensional input vectors $\\mathbf{\\Delta}x_{1},\\dots,\\mathbf{\\Delta}x_{L}$ , transformers use the softmax attention mechanism to attend over the entire past, ", "page_idx": 1}, {"type": "equation", "text": "$$\n\\begin{array}{r l r l}&{q_{t},\\ k_{t},\\ v_{t}=W_{Q}x_{t},W_{K}x_{t},W_{V}x_{t},\\qquad}&&{o_{t}=\\sum_{i=1}^{t}\\displaystyle\\frac{\\exp(k_{i}^{\\top}q_{t})}{\\sum_{j=1}^{t}\\exp(k_{j}^{\\top}q_{t})}v_{i},}\\end{array}\n$$", "text_format": "latex", "page_idx": 1}, {"type": "text", "text": "where $\\mathbf{W}_{Q},\\mathbf{W}_{K},\\mathbf{W}_{V}\\,\\in\\,\\mathbb{R}^{d\\times d},\\pmb{q}_{t},\\pmb{k}_{t},\\pmb{v}_{t},\\pmb{o}_{t}\\,\\in\\,\\mathbb{R}^{d}$ . (Here we assume a single attention head for simplicity). Linear attention [47] replaces the exponential kernel $\\exp({k_{i}^{\\top}q_{i}})$ with the dot-product $\\phi(\\pmb{k}_{i})^{\\top}\\phi(\\pmb{q}_{t})$ where $\\phi:\\mathbb{R}^{d}\\rightarrow\\mathbb{R}^{n}$ is a feature map. This makes it possible to rearrange computations to represent linear attention as a linear RNN with matrix-valued hidden states, ", "page_idx": 1}, {"type": "equation", "text": "$$\no_{t}=\\sum_{i=1}^{t}\\frac{\\phi(\\boldsymbol{k}_{i})^{\\top}\\phi(q_{t})}{\\sum_{j=1}^{t}\\phi(\\boldsymbol{k}_{j})^{\\top}\\phi(q_{t})}v_{i}=\\frac{\\left(\\sum_{i=1}^{t}v_{i}\\phi(\\boldsymbol{k}_{i})^{\\top}\\right)\\phi(q_{t})}{\\left(\\sum_{j=1}^{t}\\phi(\\boldsymbol{k}_{j})^{\\top}\\right)\\phi(q_{t})}=\\frac{\\mathbf{S}_{t}\\phi(q_{t})}{\\mathbf{z}_{t}^{\\top}\\phi(q_{t})},\n$$", "text_format": "latex", "page_idx": 1}, {"type": "text", "text": "where $\\begin{array}{r}{\\mathbf{S}_{t}=\\sum_{i=1}^{t}v_{i}\\phi(\\pmb{k}_{i})^{\\top}\\,\\in\\mathbb{R}^{d\\times n}}\\end{array}$ and $\\begin{array}{r}{\\mathbf{z}_{t}=\\sum_{i=1}^{t}\\phi(\\pmb{k}_{i})\\in\\mathbb{R}^{n}}\\end{array}$ . If we allow $n$ to go to infinity, linear attenti o n can use feature maps associated  w ith polynomial kernels to compute a polynomial approximation to the exponential kernel as a dot product, and can thus approximate softmax attention arbitrarily well [6]. The denominator $\\mathbf{z}_{t}^{\\mathsf{T}}\\phi(\\pmb{q}_{t})\\in\\mathbb{R}$ can result in numerical instabilities [84] and is removed in recent works [98, 61]. It is also common to use the identity mapping for $\\phi$ [61, 105], which results in the following simplified linear transformer: $\\mathbf{S}_{t}=\\mathbf{S}_{t-1}+v_{t}\\boldsymbol{k}_{t}^{\\intercal}$ , $\\pmb{o}_{t}=\\mathbf{S}_{t}\\pmb{q}_{t}$ . ", "page_idx": 1}, {"type": "text", "text": "Efficient training. Let $\\mathbf{Q},\\mathbf{K},\\mathbf{V}\\,\\in\\,\\mathbb{R}^{L\\times d}$ be the stacked query, key, value vectors, e.g., $\\mathbf{Q}_{i}\\mathbf{\\Lambda}=$ $\\pmb q_{i}$ . We can then compute the output $\\textbf{O}\\in\\~\\mathbb{R}^{L\\times d}$ in parallel via $\\mathbf{O}\\ {\\stackrel{\\cdot}{=}}\\ \\left(\\mathbf{QK}^{\\mathsf{T}}\\odot\\mathbf{M}_{L}\\right){\\bar{\\mathbf{V}}}$ , where $\\mathbf{M}_{L}\\,\\in\\,\\mathbb{R}^{L\\times L}$ is the causal mask. This fully \u201cparallel form\u201d and the above \u201crecurrent form\u201d have different FLOPs and parallelization tradeoffs. The parallel form takes $O(L^{2}d+L d^{2})$ and thus requires more FLOPs than the recurrent form, which takes $O(L d^{2})$ . However, the parallel form is often much faster in practice for moderate-length sequences as it can be done in $O(1)$ steps. This sequence-level parallellism also enables high GPU occupancy. The recurrent form requires fewer ", "page_idx": 1}, {"type": "text", "text": "FLOPs but cannot be parallelized across sequence length1and the elementwise operations involved in recurrence moreover cannot make use of specialized matmul accelerators (e.g., tensor cores). ", "page_idx": 2}, {"type": "text", "text": "Chunkwise parallel form. The chunkwise parallel form [33, 105, 116] strikes a balance between the parallel and recurrent forms, allowing for fewer FLOPs than the parallel form and more sequencelevel parallelism than the recurrent form. Concretely, suppose the query/key/value vectors are split into $\\frac{\\hbar}{C}$ chunks where each chunk is of length $C$ . Let $\\dot{\\mathbf{Q}}_{[t]}\\,\\in\\,\\mathbb{R}^{C\\times d}$ be all the query vectors for chunk $t$ , and let ${\\pmb q}_{[t]}^{i}={\\pmb q}_{t C+i}$ be the $i$ -th query vector within the $t^{:}$ \u2019th chunk; the key/value chunks are defined similarly. Note that $t\\in[0,L/C)$ , $i\\in[1,C]$ . The state matrices are also re-indexed such that $\\mathbf{S}_{[t]}^{i}=\\mathbf{S}_{t C+i}$ , and we additionally define $\\mathbf{S}_{[t]}^{0^{*}}=\\mathbf{\\bar{S}}_{[t-1]}^{C}$ , i.e., the initial state of a chunk is the last state of the previous chunk. We can then obtain the following identity for the hidden state and output vector for the $r$ -th element within the $t$ -th chunk, ", "page_idx": 2}, {"type": "equation", "text": "$$\n{\\bf S}_{[t]}^{r}={\\bf S}_{[t]}^{0}+\\sum_{i=1}^{r}v_{[t]}^{i}k_{[t]}^{i^{\\top}},\\qquad{\\bf\\sigma}_{[t]}^{r}={\\bf S}_{[t]}^{0}q_{[t]}^{r}+\\sum_{i=1}^{r}v_{[t]}^{i}\\left(k_{[t]}^{i^{\\top}}q_{[t]}^{r}\\right).\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "By further rewriting the intra-chunk computation based on the parallel form, we obtain following, ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{S}_{[t+1]}=\\mathbf{S}_{[t]}+\\mathbf{V}_{[t]}^{\\top}\\mathbf{K}_{[t]}}\\\\ &{\\quad\\mathbf{O}_{[t]}=\\mathbf{Q}_{[t]}\\mathbf{S}_{[t]}^{\\top}+\\left(\\mathbf{Q}_{[t]}\\mathbf{K}_{[t]}^{\\top}\\odot\\mathbf{M}_{C}\\right)\\mathbf{V}_{[t]}}\\end{array}\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "where we let ${\\bf S}_{[t]}={\\bf S}_{[t]}^{0}$ to reduce notational clutter. With this \u201cchunkwise parallel form\u201d, information is propagated chunk-to-chunk through $\\mathbf{S}_{[t]}$ , and the intra-chunk states $\\mathrm{\\bfS}_{[t]}^{i}$ for $i\\in[1,C]$ need not be materialized, thus saving memory. ", "page_idx": 2}, {"type": "text", "text": "The complexity of the chunkwise parallel form is $O(L C d+L d^{2})$ , and the number of steps (without chunk-level parallel scan) is $O(\\frac{L}{C})$ . Hence, $C=L$ recovers the fully parallel form and $C=1$ recovers the recurrent form. The chunkwise parallel form allows us to interpolate between the two forms, in essence trading off the number of sequential computations against sequence-level parallelism. In practice $C$ is set to a small constant (usually 64 or 128), allowing for subquadratic training. This chunkwise form enables practical speed-ups against parallel-form-only softmax attention even on moderate-length sequences, as demonstrated by FLASHLINEARATTENTION [116, 115] ", "page_idx": 2}, {"type": "text", "text": "2.2 DeltaNet: Linear Transformers with the Delta Update Rule ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "The above linear transformer employs a simple linear recurrence: $\\mathbf{S}_{t}\\,=\\,\\mathbf{S}_{t-1}+v_{t}\\mathbf{k}_{t}^{\\top}$ . This can be seen as additively updating the memory $\\mathbf{S}_{t-1}$ with new key-value associations at each time step. However, a purely additive update rule makes it difficult to deallocate past key-value associations, eventually leading to key \u201ccollisions\u201d when $L>d$ , as pointed out by Schlag et al. [98]. A model should ideally learn to remove less important key-value associations to make room for new ones, and this removal should depend on the interaction between the new key and the memory content. ", "page_idx": 2}, {"type": "text", "text": "DeltaNet uses the delta update rule [114] to operationalize this mechanism. Specifically, it first retrieves the old value using the current key, ${\\pmb v}_{t}^{\\mathrm{\\scriptsize{id}}}={\\bf S}_{t-1}{\\pmb k}_{t}$ . It then obtains a new value ${\\pmb v}_{t}^{\\mathrm{new}}$ by interpolating between the old value and the current value $\\pmb{v}_{t}$ , which replaces $\\pmb{v}_{t}^{\\mathrm{{old}}}$ in the memory: ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\begin{array}{r}{v_{t}^{\\mathrm{new}}=\\beta_{t}v_{t}+\\left(1-\\beta_{t}\\right)v_{t}^{\\mathrm{old}},\\qquad\\qquad\\qquad{\\bf S}_{t}={\\bf S}_{t-1}\\underbrace{-v_{t}^{\\mathrm{old}}k_{t}^{\\top}}_{\\mathrm{remove}}\\underbrace{+v_{t}^{\\mathrm{new}}k_{t}^{\\top}}_{\\mathrm{write}}}\\end{array}\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "Here $\\beta_{t}=\\sigma(\\mathbf{W}_{\\beta}\\pmb{x}_{t})\\in(0,1)$ is a soft \u201cwriting strength\u201d: when $\\beta_{t}=1$ , the old value is completely removed and $\\pmb{v}_{t}^{\\mathrm{new}}\\,=\\,\\pmb{v}_{t}$ ; when $\\beta_{t}\\,=\\,0$ , the memory remains unmodified and we have $\\mathbf S_{t}=\\mathbf S_{t-1}$ . The output computation is the same as vanilla linear attention, i.e., $\\pmb{o}_{t}\\,=\\,\\mathbf{S}_{t}\\pmb{q}_{t}$ . The complexity of this recurrent form is the same as that of vanilla linear attention, i.e., $O(L d^{2})$ . This DeltaNet is a special case of fast weight programmers [100], and Schlag et al. [98] and Irie et al. [36] show that this type of linear transformer outperforms ordinary linear transformers on small-scale language modeling and synthetic in-context retrieval tasks. ", "page_idx": 2}, {"type": "text", "text": "Since the old value vector depends on the previous hidden state $\\mathbf{S}_{t-1}$ , it is not possible to straightforwardly apply the above chunkwise parallel strategy for training DeltaNet transformers. While the official implementation from Schlag et al. [98] avoids materializing the $\\mathbf{S}_{t}$ \u2019s (thus minimizing I/O cost) by using the linear-time-constant-memory algorithm from Katharopoulos et al. [47, $\\S3.3.1]$ , it still uses the pure recurrent form and thus does not parallelize across the sequence dimension, which makes it difficult to scale DeltaNet to modern language modeling settings. ", "page_idx": 3}, {"type": "text", "text": "3 Parallelizing DeltaNet Across the Sequence Dimension ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "In the same spirit as the chunkwise form of linear attention, we derive a chunkwise form for DeltaNet that enables hardware-efficient training through parallelizing across the sequence dimension. ", "page_idx": 3}, {"type": "text", "text": "3.1 A Memory-efficient Reparameterization ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "We first observe that $\\mathbf{S}_{t}$ admits a purely additive representation of the form $\\mathbf{S}_{t}\\,=\\,\\sum_{i=1}^{t}{\\pmb{u}}_{i}{\\pmb{k}}_{i}^{\\top}$ for $u_{i},k_{i}\\,\\in\\,\\mathbb{R}^{d}$ , since we can simply set $\\pmb{u}_{i}\\,=\\,\\pmb{v}_{i}^{\\mathrm{new}}\\,-\\,\\pmb{v}_{i}^{\\mathrm{old}}\\,=\\,\\beta_{i}\\big(\\pmb{v}_{i}\\,-\\,\\pmb{v}_{i}^{\\mathrm{old}}\\big)$ . Recal l f rom $\\S2.1$ that simple linear attention has the form $\\begin{array}{r}{{\\bf S}_{t}=\\sum_{i=1}^{t}v_{i}{\\boldsymbol k}_{i}^{\\top}}\\end{array}$ . Thus, DeltaNet simply replaces the value vector $\\pmb{v}_{i}$ in linear attention with the \u201cpseud o\u201d  value vector $\\pmb{u}_{i}$ . Once the $\\pmb{u}_{i}$ \u2019s have been constructed, the rest of computation can proceed as in ordinary linear attention, i.e., $\\mathbf{O}=\\left(\\mathbf{Q}\\mathbf{K}^{\\mathsf{T}}\\odot\\mathbf{M}\\right)\\mathbf{U}$ where $\\mathbf{U}\\in\\mathbb{R}^{L\\times d}$ is the row-wise concatenation of the $\\pmb{u}_{i}$ vectors. ", "page_idx": 3}, {"type": "text", "text": "However, computing $\\pmb{u}_{t}$ na\u00efvely requires explicitly materializing $\\mathbf{S}_{t-1}$ to compute $\\pmb{v}_{t}^{\\mathrm{{old}}}$ , which would require $O(d^{2})$ memory. We now show that we can obtain the $\\pmb{u}_{t}$ \u2019s without explicitly materializing $\\mathbf{S}_{t-1}$ in $O(d)$ memory. Our simple proof (by induction) relies on an application of the WY representation for products of Householder matrices [11]. The base case is clear since we have $\\mathbf{S}_{1}=\\beta_{1}\\pmb{v}_{1}\\pmb{k}_{1}^{\\top}$ , so $\\pmb{u}_{1}=\\beta_{1}\\pmb{v}_{1}$ . For the inductive step, we first observe that the DeltaNet update is given by, ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathfrak{j}_{t}=\\mathbf{S}_{t-1}-v_{t}^{\\mathrm{old}}k_{t}^{\\top}+v_{t}^{\\mathrm{new}}k_{t}^{\\top}=\\mathbf{S}_{t-1}-\\beta_{t}\\left(\\mathbf{S}_{t-1}k_{t}\\right)k_{t}^{\\top}+\\beta_{t}v_{t}k_{t}^{\\top}=\\mathbf{S}_{t-1}(\\mathbf{I}-\\beta_{t}k_{t}k_{t}^{\\top})+\\beta_{t}v_{t}k_{t}^{\\top},}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "which can be seen as applying a generalized Householder transformation (i.e., matmul with an identity plus rank-one matrix) to the previous state. The inductive step is then given by, ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathbf{S}_{t}=\\mathbf{S}_{t-1}(\\mathbf{I}-\\beta_{t}k_{t}k_{t}^{\\top})+\\beta_{t}v_{t}k_{t}^{\\top}=\\sum_{i=1}^{t-1}u_{i}k_{i}^{\\top}+\\underbrace{\\beta_{t}\\left(v_{t}-\\sum_{i=1}^{t-1}u_{i}\\left(k_{i}^{\\top}k_{t}\\right)\\right)}_{u_{t}}k_{t}^{\\top}=\\sum_{i=1}^{t}u_{i}k_{i}^{\\top}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Note that $\\pmb{u}_{t}$ does not require materializing any of the hidden states and requires $O(d)$ memory to compute, thus completing the proof. While we have avoided materializing $\\mathbf{S}_{t}$ \u2019s, computing $\\pmb{u}_{t}$ \u2019s for all $L$ (that is, $\\mathbf{U}$ ) takes $\\bar{O(L^{2}d)}$ and moreover cannot be fully parallelized, unlike in linear attention where we can calculate all the value vectors $\\mathbf{V}$ in parallel in $O(1)$ steps. We now show that the above trick still enables an efficient chunkwise parallel form for DeltaNet. ", "page_idx": 3}, {"type": "text", "text": "3.2 Chunkwise Parallel Form for DeltaNet ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "To derive the chunkwise parallel form, we first unroll the recurrence, ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathbf{S}_{t}=\\mathbf{S}_{t-1}(\\mathbf{I}-\\beta_{t}\\pmb{k}_{t}\\pmb{k}_{t}^{\\top})+\\beta_{t}\\pmb{v}_{t}\\pmb{k}_{t}^{\\top}=\\sum_{i=1}^{t}\\beta_{i}(\\pmb{v}_{i}\\pmb{k}_{i}^{\\top})\\left(\\prod_{j=i+1}^{t}(\\mathbf{I}-\\beta_{j}\\pmb{k}_{j}\\pmb{k}_{j}^{\\top})\\right).\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "We then define the following variables: $\\begin{array}{r l r}{{\\bf P}_{i}^{j}}&{=}&{\\prod_{t=i}^{j}({\\bf I}\\;-\\;\\beta_{t}{\\pmb k}_{t}{\\pmb k}_{t}^{\\top})\\quad\\in\\quad\\mathbb{R}^{d\\times d},}\\end{array}$ , $\\begin{array}{r l}{\\mathbf{H}_{i}^{j}}&{{}=}\\end{array}$ $\\begin{array}{r}{\\sum_{t=i}^{j}\\beta_{t}(\\pmb{v}_{t}\\pmb{k}_{t}^{\\top})\\mathbf{P}_{t+1}^{j}\\in\\mathbb{R}^{d\\times d}}\\end{array}$ , where we let $\\mathbf{P}_{i}^{j}\\,=\\,\\mathbf{I}$ wh enever $i\\,>\\,j$ . Intuitively, $\\mathbf{P}_{i}^{j}$ is the \u201cdecay factor\u201d to be applied to $\\mathbf{S}_{i}$ for obtaining $\\mathbf{S}_{j}$ , and $\\mathbf{H}_{i}^{j}$ represents the contributions to $\\mathbf{S}_{j}$ starting from token $i$ . (Hence $\\mathbf{S}_{t}=\\mathbf{H}_{1}^{t}$ ). The chunkwise recurrence can then be written as, ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathbf{S}_{[t]}^{r}=\\mathbf{S}_{[t]}^{0}\\mathbf{P}_{[t]}^{r}+\\mathbf{H}_{[t]}^{r}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where we define the chunkwise variables $\\mathbf{S}_{[t]}^{i}\\,=\\,\\mathbf{S}_{t C+i}$ , $\\mathbf{P}_{[t]}^{r}=\\mathbf{P}_{t C+1}^{t C+r}$ , ${\\bf H}_{[t]}^{r}={\\bf H}_{t C+1}^{t C+r}$ . Here we have $\\begin{array}{l}{{\\frac{L}{C}}}\\end{array}$ chunks of size $C$ . The trick is to now efficiently represent the $\\mathbf{P}_{[t]}^{r},\\mathbf{H}_{[t]}^{r}\\,\\in\\,\\mathbb{R}^{d\\times d}$ matrices ", "page_idx": 3}, {"type": "text", "text": "using a similar approach described in $\\S3.1$ , so that these matrices can be stored in $O(d)$ memory, ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r l r l}&{\\mathbf{P}_{[t]}^{r}=\\mathbf{I}-\\displaystyle\\sum_{i=1}^{r}w_{[t]}^{i}k_{[t]}^{i^{\\top}},}&{\\mathbf{H}_{[t]}^{r}=\\displaystyle\\sum_{t=1}^{r}u_{[t]}^{i}k_{[t]}^{i^{\\top}}}&{\\in\\mathbb{R}^{d\\times d}}\\\\ &{w_{[t]}^{r}=\\beta_{[t]}^{r}\\left(k_{[t]}^{r}-\\displaystyle\\sum_{i=1}^{r-1}w_{[t]}^{i}(k_{[t]}^{i^{\\top}}k_{[t]}^{r})\\right),}&{u_{[t]}^{r}=\\beta_{[t]}^{r}\\left(w_{[t]}^{r}-\\displaystyle\\sum_{i=1}^{r-1}u_{[t]}^{i}(k_{[t]}^{i^{\\top}}k_{[t]}^{r})\\right)}&{\\in\\mathbb{R}^{d}}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "The derivations for the above can be found in the appendix. Subsequently, based on Eq. 5, we can obtain the chunk-level recurrence for hidden states and outputs as, ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{S}_{[t]}^{r}=\\mathbf{S}_{[t]}^{0}-\\left(\\mathbf{S}_{[t]}^{0}\\displaystyle\\sum_{i=1}^{r}w_{[t]}^{i}\\boldsymbol{k}_{[t]}^{i\\top}\\right)+\\displaystyle\\sum_{i=1}^{r}u_{[t]}^{i}\\boldsymbol{k}_{[t]}^{i\\top}=\\mathbf{S}_{[t]}^{0}+\\displaystyle\\sum_{i=1}^{r}\\left(u_{[t]}^{i}-\\mathbf{S}_{[t]}^{0}w_{[t]}^{i}\\right)\\boldsymbol{k}_{[t]}^{i\\top},}\\\\ &{o_{[t]}^{r}=\\mathbf{S}_{[t]}^{r}q_{[t]}^{r}=\\mathbf{S}_{[t]}^{0}q_{[t]}^{r}+\\displaystyle\\sum_{i=1}^{r}\\left(u_{[t]}^{i}-\\mathbf{S}_{[t]}^{0}w_{[t]}^{i}\\right)\\left(\\boldsymbol{k}_{[t]}^{i\\top}q_{[t]}^{i}\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "Letting ${\\bf S}_{[t]}={\\bf S}_{[t]}^{0}$ , the above can be simplified to matrix notations similarly to Eq.1-2, ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{S}_{[t+1]}=\\mathbf{S}_{[t]}+\\left(\\mathbf{U}_{[t]}-\\mathbf{W}_{[t]}\\mathbf{S}_{[t]}^{\\top}\\right)^{\\top}\\mathbf{K}_{[t]},}\\\\ &{\\quad\\mathbf{O}_{[t]}=\\mathbf{Q}_{[t]}\\mathbf{S}_{[t]}^{\\top}+\\left(\\mathbf{Q}_{[t]}\\mathbf{K}_{[t]}^{\\top}\\odot\\mathbf{M}\\right)\\left(\\mathbf{U}_{[t]}-\\mathbf{W}_{[t]}\\mathbf{S}_{[t]}^{\\top}\\right)}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\boxed{\\Omega_{[t]}=\\boxed{\\Omega_{[t]}^{1:C}\\in\\mathbb{R}^{C\\times d}}}$ for $\\boldsymbol{\\Omega}\\in\\{\\mathbf{Q},\\mathbf{K},\\mathbf{V},\\mathbf{O},\\mathbf{U},\\mathbf{W}\\}$ defines the chunkwise matrices that are formed from stacking the ${\\mathbfit{q}}_{t},k_{t},{\\mathbfit{v}}_{t},{\\mathbfit{o}}_{t},{\\mathbfit{u}}_{t},{\\mathbfit{w}}_{t}$ vectors. ", "page_idx": 4}, {"type": "text", "text": "Practical considerations. In the above, Eq. 7 is fully recurrent and thus cannot use tensor cores written as is. To solve this, we further leverage the $U T$ transform [43, 22]: ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{T}_{[t]}=\\left(\\mathbf{I}-\\mathrm{tril}(\\mathrm{Diag}(\\beta_{[t]})\\mathbf{K}_{[t]}\\mathbf{K}_{[t]}^{\\top},-1)\\right)^{-1}\\mathrm{Diag}\\left(\\beta_{[t]}\\right)}\\\\ &{\\mathbf{W}_{[t]}=\\mathbf{T}_{[t]}\\mathbf{K}_{[t]},\\qquad\\qquad\\mathbf{U}_{[t]}=\\mathbf{T}_{[t]}\\mathbf{V}_{[t]}}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "to rewrite most operations in matmuls. The inverse of lower triangular matrices could be solved efficiently using forward substitution. Once computed, the hidden state updates (Eq. 8) and the output computations (Eq. 9) are largely the same as in vanilla linear attention. We adapt FLASHLINEARATTENTION [116] to implement Eq. 8 and 9 with hidden states recomputed during the backward pass for saving GPU memory. The PyTorch pseudocode for the forward pass is shown in Listing 1. ", "page_idx": 4}, {"type": "text", "text": "Speed comparison. We implement both the pure recurrent form2 and the chunkwise parallel form in Triton [109] and show the speed-ups for various sequence lengths (L) and head dimensions $(d_{\\mathrm{head}})$ in the right figure, where the model dimension $d$ is 2048 and we vary batch size and sequence length so that they multily to 16384.3 Our chunkwise algorithm achieves greater speed-ups as sequence length $L$ and head dimension $d_{\\mathrm{head}}$ increase, where the use of sequence-level parallelism (for high GPU occupancy) and tensor core (for fast matmuls) become more important [116, \u00a73]. ", "page_idx": 4}, {"type": "text", "text": "Fully Parallel Form for DeltaNet. For completeness, we also discuss the fully parallel form of DeltaNet. While we use the concept of a \u201cpseudo\u201d value, it is possible to avoid modifying values. From Eq. 4, it is straightforward to compute the attention matrix A: $\\mathbf{A}_{i j}=k_{j}^{\\mathsf{T}}\\mathbf{P}_{j+1}^{i}\\pmb{q}_{i}$ if $j\\leq i$ and 0 otherwise. Notably, A has the matrix form $\\mathbf{A}=\\left(\\mathbf{Q}\\mathbf{K}^{T}\\odot\\mathbf{M}\\right)\\mathbf{T},$ obtained by combining Eq. 3 and 11. However, computing $\\mathbf{T}$ requires a matrix inverse (Eq. 10), which scales cubically with sequence length without further algorithmic changes. Due to the above we avoid using the fully parallel form for training DeltaNet; however the \u201cattention\u201d matrix derived from this form could be of interest to the interpretability research community studying RNNs, as explored in Ali et al. [3] and Zimerman et al. [123]. ", "page_idx": 4}, {"type": "image", "img_path": "y8Rm4VNRPH/tmp/cc42c40f7bcc1684e5c69ead2e7beaa5d1cae0d2c73dc6b8c6065802506844c8.jpg", "img_caption": ["Figure 1: Speed-up of the chunkwise parallel form vs. the recurrent form. "], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "", "page_idx": 4}, {"type": "text", "text": "3.3 DeltaNet Transformer ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "We describe how the DeltaNet layer primitive is used to build up a transformer-like model using standard modules. We largely follow the LLaMA-architecture [Transformer $^{\\mathrel{\\textstyle\\downarrow}++}$ , 111] and simply replace the self-attention layer with the DeltaNet layer. We also apply normalization before output projection for stable training [84, 66]. As the additional parameters for computing scalar $\\beta_{t}$ terms are negligible, parameter allocation is roughly the same as in Transformer $^{++}$ , i.e., $\\bar{4}d^{2}$ for the DeltaNet layer and $\\bar{8d^{2}}$ for the SwiGLU FFN layer [101]. ", "page_idx": 5}, {"type": "text", "text": "Feature map and normalization. Our key/query vectors are given by kt =\u2225SSiiLLUU((WWKKxxtt))\u22252 , qt = $\\frac{\\mathrm{SiLU}(\\mathbf{W}_{Q}\\pmb{x}_{t})}{\\|\\mathrm{SiLU}(\\mathbf{W}_{Q}\\pmb{x}_{t})\\|_{2}}$ . Schlag et al. [98] originally follow Katharopoulos et al. [47] and apply a $\\mathrm{^{\\bullet}E L U+1^{\\circ}}$ [16] to nonlineary transform the key/query vectors. We instead use the SiLU activation [23], which was found to perform better [86, 18]. For stability, it is crucial to ensure that the norm of each eigenvalue of the transition matrices does not exceed one. The eigenvalues of $\\mathbf{I}-\\beta_{t}\\mathbf{k}_{t}\\mathbf{k}_{t}^{\\mathsf{T}}$ are 1 with multiplicity $d-1$ and $1-\\beta_{t}||k_{t}||_{2}$ with multiplicity 1. Schlag et al. [98] used the $L_{1}$ norm to normalize query/key vectors, ensuring that $0\\leq1\\!-\\!\\bar{\\beta_{t}}\\|k_{t}\\|_{2}\\leq1$ . We instead apply $L_{2}$ normalization, which we found to perform better and offers a more intuitive interpretation: when $\\beta_{t}=1$ , $\\mathbf{I}-{\\boldsymbol{k}}_{t}{\\boldsymbol{k}}_{t}^{\\top}$ becomes a projection matrix, erasing information in one subspace while preserving the other $d-1$ subspaces. This is beneficial for retaining information while enabling more targeted forgetting. ", "page_idx": 5}, {"type": "text", "text": "3.4 Hybrid Models ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Following recent work on combining subquadratic token-mixing layers with existing neural network primitives [6, 20, 53], we also experiment with hybridizing DeltaNet models. ", "page_idx": 5}, {"type": "text", "text": "Convolutional layers. Recent linear recurrent models typically incorporate a lightweight depthwise-separable convolution layer after the query/key/value projections [30, 9, 18]. This \u201cshort convolution\u201d layer [81] generalizes the shift SSM [25], and is efficient in both number of parameters and computational cost. We also add a short convolution layer after the query/key/value projections. ", "page_idx": 5}, {"type": "text", "text": "Local sliding window and global attention. Linear attention largely uses a content-based addressing mechanism [28] and lacks positional information [120]. Arora et al. [6] also argue that linear attention lacks the ability to perform precise local token shifts and comparisons, thus facing difficulties on retrieval-intensive tasks. Motivated by this, we experiment with two different hybrid architectures that incorporate softmax attention. We first explore sliding window attention (SWA) which has been shown to significantly improve linear attention [84, 6, 55, 72]; we follow Griffin [20] and Samba [93] to interleave DeltaNet layers and SWA layers. We also experiment with global attention, which has been found to be helpful [50, 34] even if only few of the recurrent layers are replaced with global attention [53]. We follow $\\mathrm{F}\\mathbf{u}$ et al. [25] to replace only two layers with global attention: the second layer and the $\\textstyle\\left({\\frac{N}{2}}+1\\right)$ -th layer, where $N$ is total number of layers. ", "page_idx": 5}, {"type": "text", "text": "4 Empirical Study ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "We compare the DeltaNet against strong baselines in both synthetic and real-world language modeling settings. Our main baselines include: LLaMA-architecture Transformer $^{++}$ [111]; RetNet [105], a linear attention Transformer with non-data-dependent exponential decay and large head dimension; GLA [116], a linear attention Transformer with data-dependent decay; and Mamba [30], a selective state-space model with data-dependent decay. ", "page_idx": 5}, {"type": "text", "text": "4.1 Synthetic Benchmarks ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "We evaluate on three synthetic benchmarks: Multi-query associative recall [MQAR; 4], Mechanistic Architecture Design [MAD; 82], and in-context language learning [RegBench; 2]. ", "page_idx": 5}, {"type": "image", "img_path": "y8Rm4VNRPH/tmp/f13146408183b328bd9ee0003d9d159d1e0a56a37dcbf13a3eb5a770a04fbb07.jpg", "img_caption": [], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "MQAR evaluates language models\u2019 ability to (in-context) recall information within a context when faced with multipl recall queries. We use Arora et al. [4]\u2019s training setting and for DeltaNet we use 2 heads. We do not use convolutions for these experiments. Figure 2 shows that DeltaNet performs perfectly (even without convolution) in the hardest setting and outperforms Mamba (which uses convolutions) in the low-dimension setting. Next, we consider the MAD benchmark [82], a suite of synthetic token ", "page_idx": 5}, {"type": "text", "text": "", "page_idx": 5}, {"type": "table", "img_path": "y8Rm4VNRPH/tmp/c481c8d1672a0e81f6cad24593186d50c1c9b5c08de544cc38c4a30101fe7de0.jpg", "table_caption": [], "table_footnote": [], "page_idx": 6}, {"type": "table", "img_path": "y8Rm4VNRPH/tmp/c7f35a3aed79c6888ea20dfbb8a34322b55a751be9fec0d06034161f1f66a515.jpg", "table_caption": ["Table 1: Results on the synthetic MAD benchmark. Results other than DeltaNet are directly borrowed from Poli et al. [82]. (Multi-head) Hyena, DeltaNet and Mamba make use of convolutions, whereas GLA does not. "], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "Table 2: Main language modeling results against Transforme $^{++}$ , RetNet [105], Mamba [30], and GLA [116]. All models are trained on the same subset of the SlimPajama dataset with the Mistral tokenizer. The Transformer $^{++}$ , RetNet, Mamba, GLA (w/o. conv) results are taking from Yang et al. [116]. For hybrid models, \u201cSliding Attn\u201d interleaves a sliding window attention every other layer, and \u201cGlobal Attn\u201d uses full global attention on two layers. The 340M/1.3B models are trained for 15B/100B tokens respectively. All results are obtained through lm-evaluation-harness [26]. The last column denotes the expansion ratio of the recurrent state size relative to the product of the number of layers and model dimension (see Zhang et al. [122, App. C]). ", "page_idx": 6}, {"type": "text", "text": "manipulation tasks designed to probe capabilities of model architectures. The results are shown in Table 1. Compared with other architectures, including MHA, DeltaNet is better at recalling tasks, especially on Fuzzy Recall as expected, although it struggles on the \u201cMemorize\u201d task. ", "page_idx": 6}, {"type": "text", "text": "Finally, we consider RegBench [2], a synthetic data set designed to assess the in-context language learning capability of different model architectures. Each input sequence in this benchmark consists of 10 to 20 strings drawn from a distinct language defined by a probabilistic finite automaton (PFA), so that a model needs to infer the underlying language from the context on the fly. During testing, a model is evaluated on predicting the next token of testing sequences generated from held-out PFAs. Here again we find that DeltaNet performs strongly compared to baselines, as shown in Figure 3. ", "page_idx": 6}, {"type": "image", "img_path": "y8Rm4VNRPH/tmp/ea082045341a2edf7e51fe66b5dda5368528181f82dd4c6ed6e68276c3bdc8c1.jpg", "img_caption": ["Figure 3: Accuracy $(\\%)$ on RegBench. "], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "4.2 Language Modeling ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Experimental setup. Following prior work [30, 116], we evaluate on Wikitext perplexity and zero-shot common sense reasoning tasks, including LAMBADA [LMB.; 74], PiQA [12], HellaSwag [Hella.; 118], WinoGrande [Wino.; 96], ARC-easy (ARC-e) and ARC-challenge (Arc-c) [15]. Following Arora et al. [6], we also evaluate the models real-world recall-intensive tasks, including FDA [5], SWDE [58], and SQUAD [91]. Both SWDE and FDA focus on extracting structured information: SWDE from raw HTML to identify semi-structured relationships, and FDA from PDFs to retrieve key-value pairs. SQUAD evaluates language models on reading comprehension by providing a text passage and a related question. See $\\S D$ for hyperparameter settings. ", "page_idx": 6}, {"type": "table", "img_path": "y8Rm4VNRPH/tmp/49cea520d089260f6f1ee91ad1984f9199340c6558104325b1cfa3cb19ca3b1e.jpg", "table_caption": [], "table_footnote": ["Table 3: Zero-shot model performance across selected benchmarks for 3B models. Llama-3.2-3B and PowerLM-3B are Transformer models, while the others are recurrent models.ARC results are averaged over accuracy and normalized accuracy across ARC-Easy and ARC-Challenge. "], "page_idx": 7}, {"type": "text", "text": "Results. Our main language modeling results are shown in Table 2. Since Mamba uses convolutions by default while GLA does not, we retrain the GLA with convolution, and also train DeltaNet without convolution. For the 1.3B setting we only train the DeltaNet with convolution due to limited compute resources. In general we find that DeltaNet outperforms the strong Mamba/GLA baselines in terms of both perplexity and downstream task performance. For recall-intensive tasks (i.e., SWDE, SQuAD, FDA), we find that under the same state size at the 340M scale, DeltaNet outperforms GLA, confirming the effectiveness of the delta rule. However, at the 1.3B scale, DeltaNet underperforms GLA due to its poorer state size scability (see $\\S5.3)$ ), since state size plays an important role in recallintensive tasks. Finally, we confirm the beneftis of hybrid architectures [20, 53]: both the sliding window and global attention hybrids work well, outperforming the strong Transformer $\\mathrel{\\downarrow}+{\\downarrow}$ baselines. ", "page_idx": 7}, {"type": "text", "text": "We also scale DeltaNet to the 3B parameter scale trained with 1T tokens using the same settings as Shen et al. [102]. The results are shown in Table 3, where 3B DeltaNet slightly underperforms a Transformer architecture trained with the same setting (PowerLM-3B), but outperforms other RNN baselines in the 2B\u20133B range (though these are trained for a different number of tokens so are not exactly comparable). ", "page_idx": 7}, {"type": "text", "text": "Ablations. In Table 2 (bottom) we ablate the choice of feature map and normalization. We find that simply replacing the $L_{1}$ -norm with the $L_{2}$ -norm greatly increases performance. For the feature map, we experiment with $\\{\\mathrm{ReLU},1+\\mathrm{ELU},\\mathrm{SiLU}\\}$ and find that SiLU performs the best, consistent with prior work [86]. ", "page_idx": 7}, {"type": "text", "text": "Training throughput. Figure 4 compares the training throughputs of different 1.3B models in different training lengths and batch size settings. The training speed of DeltaNet is close to GLA and significantly faster than Mamba. All linear-time models outperform Transformers for longer-sequence training. ", "page_idx": 7}, {"type": "image", "img_path": "y8Rm4VNRPH/tmp/fbe1d789119c0d237b50d0ec05d41af750ecdb2710ff2699d4e9c9b5d69639a6.jpg", "img_caption": ["Figure 4: Training throughput of 1.3B models on a single H100. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "5 Discussion and Related Work ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "5.1 DeltaNet vs. State Space Models / Linear RNNs ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "To discuss DeltaNet against existing linear RNNs (including state-space models) we first introduce a general class of associative RNNs with matrix-valued hidden states. Given a matrix-valued hidden state $\\mathbf{S}_{t}\\in\\mathbb{R}^{d\\times n}$ and current input $\\pmb{x}_{t}\\in\\mathbb{R}^{d}$ , these models have the following form: ", "page_idx": 7}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{S}_{t}=\\mathbf{S}_{t-1}\\bullet\\mathbf{M}_{t}+v_{t}\\boldsymbol{k}_{t}^{\\intercal},}\\\\ &{\\mathbf{o}_{t}=\\mathbf{S}_{t}\\mathbf{q}_{t},}\\end{array}\n$$", "text_format": "latex", "page_idx": 7}, {"type": "text", "text": "(memory read-out) ", "page_idx": 7}, {"type": "text", "text": "where $\\bullet$ is an associative operator (e.g., Hadamard product, matrix multiplication, etc.). The matrix ${{\\bf{M}}_{t}}$ and vectors $\\pmb{v}_{t},\\pmb{k}_{t},q_{t}$ are (potentially non-linear) functions of the current input $\\pmb{x}_{t}$ . ", "page_idx": 7}, {"type": "text", "text": "As is the case in vector-valued linear RNNs [62, 103], the use of an associative operator enables the use of parallel scan [13] to calculate $\\mathbf{S}_{1},\\ldots,\\mathbf{S}_{L}$ in $O(\\log L)$ steps and $O(L)$ work (ignoring the terms associated with the associative operation) if the inputs $\\mathbf{\\Delta}x_{1},\\dots,\\mathbf{\\Delta}x_{L}$ are given (though see our discussion in footnote 1). Hence, as long as the associative operator is not too expensive, training can be efficient. However, parallel scan by itself is not sufficient for training language models at practical scale due to some associative operator\u2019s being too expensive. Recent models such as such as Mamba [30] and gated linear attention Transformers [105, 116, 89, 77, 9] thus make use of cheap element-wise recurrence updates, in particular the Hadamard product, i.e., $\\bullet=\\odot$ . See Table 4 for how recent models can be cast into this form. ", "page_idx": 7}, {"type": "table", "img_path": "y8Rm4VNRPH/tmp/3caeaebabb7ac77f37932d42831d8980a6441b14c8793ef8e66a00ede6654cac.jpg", "table_caption": [], "table_footnote": ["Table 4: Overview of recent linear recurrent models that have been proposed and applied to autoregressive language modeling (ordered in rough chronological order). These works make use of a matrix-valued hidden state $\\breve{\\mathbf S_{t}}\\in\\mathbb{R}^{d\\times n}$ (or two matrix-valued hidden states $\\mathbf{S}_{t}^{k}$ , $\\mathbf{S}_{t}^{v}$ , e.g., [80, 122]) updated through an associative recurrence followed by an outer-product-based addition. Here $\\odot$ is the Hadamard product. Some models make use of an additional linear RNN with hidden state vector $\\mathscr{z}_{t}$ , which used to normalized the query vector $\\pmb q_{t}$ . Variables with the subscript $t$ (e.g., ${\\pmb v}_{t},{\\pmb\\alpha}_{t},f_{t},\\gamma_{t})$ are (potentially non-linear) functions of the current input $\\pmb{x}_{t}$ . Non-time-varying parameters (e.g., $A,d,\\gamma)$ are denoted without subscripts; these parameters are either learned or set to fixed values. Matrices are denoted with bold upper case letters, vectors with bold lower case, and scalars with italic letters. Many models make use of a kernel $\\phi$ (e.g., [98, 79]) but we subsume them into the key/value vectors to reduce notational clutter. "], "page_idx": 8}, {"type": "text", "text": "", "page_idx": 8}, {"type": "text", "text": "Standard matrix multiplications (i.e., $\\mathbf{S}_{t-1}\\bullet\\mathbf{M}_{t}=\\mathbf{S}_{t-1}\\mathbf{M}_{t})$ on the other hand can model richer interactions that go beyond elementwise recurrence. Without any structural assumptions on ${{\\bf{M}}_{t}}$ however, these operations would take $O(d n^{2})$ for each update (as opposed to $O(d n)$ for elementwise products), which would be prohibitively expensive. Hence, DeltaNet\u2019s use of $\\mathbf{M}_{t}=\\mathbf{I}-\\beta_{t}\\mathbf{k}_{t}\\mathbf{k}_{t}^{\\top}$ can be seen as exploiting structured matrices to efficiently model interactions beyond elementwise recurrences. Our chunkwise algorithm could generalize to a broader class of matrices in the DiagonalPlus-Low-Rank (DPLR) form $\\mathbf{M}_{t}\\,=\\,\\mathbf{D}\\,-\\,a_{t}b_{t}^{\\top}$ , which has been explored in S4 [31], although their DPLR transition matrices are data-independent. We adopt DeltaNet\u2019s parameterization in this work (i.e., $\\mathbf{D}=\\mathbf{I},\\mathbf{a}_{t}=\\beta_{t}\\mathbf{k}_{t},\\mathbf{b}_{t}=\\pmb{k}_{t})$ as we are primarily interested in improving recall (through DeltaNet\u2019s key-value update rule) while maintaining parameter efficiency. We leave the exploration of more generalized parameterizations for future work. ", "page_idx": 8}, {"type": "text", "text": "5.2 Towards a Unifying Framework for Efficient Autoregressive Sequence Transformations ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "While the above class of models makes it possible to unify recent models, we do not claim that it is the \u201cright\u201d level at which view (autoregressive) sequence transformations of the form $\\{\\pmb{x}_{t}\\}_{t=1}^{L}\\ \\mapsto\\ \\{\\pmb{o}_{t}\\}_{t=1}^{L}$ , where $\\scriptstyle\\mathbf{o}_{t}$ cannot depend on any $\\pmb{x}_{j}$ if $j~>~t$ . For example, this framing makes it difficult to (neatly) capture other subquadratic models that have been shown to be effective [117, 48, 95, 81]. An alternative unifying framework might be to view the above sequence transformations as a discretization of a continuous state space model [31, 103, 30], or as a matrix multiplication with a masked structured matrix [73, 85, 45, 18]. What does seem important, however, is that a framework should ideally expose efficient algorithms for training, and the algorithm should be hardware-efficient, which, in the case of modern GPUs, means that it should be rich in matrix multiplications. From this perspective, the state-space duality (SSD) framework recently proposed by Dao and Gu [18], which provides a connection between SSM-based sequence transformations and structured matrix multiplications with a semiseparable matrix, seems a promising candidate. However, this framework may not capture an important class of models, e.g., models where the associative recurrence involves matrix multiplication with an unstructured matrix, or models that make use of more exotic associative operators (e.g., in Peng et al. [78]). ", "page_idx": 8}, {"type": "text", "text": "Finally, we observe that there have been many recent linear-time models that have been proposed which purportedly match or outperform classic transformers. As can be seen in Table 4, the \u201csequence mixing\u201d component of these works are closely related to one another. However, the way in which the token-mixing primitive is used to build up a transformer-like model varies widely. For example, while most recent works make use of depthwise-separable convolution layers (not shown in Table 4) [30, 76, 90, 9, 18], earlier works generally do not [47, 99, 79]. There are also differences in the parameterizations of the feedforward layers used for the \u201cchannel mixing\u201d component. Such variations should be taken into account before declaring a particular model layer superior to another. ", "page_idx": 9}, {"type": "text", "text": "5.3 Limitations and Future Work ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "Our work has several limitations. First, in terms of computation, although we propose a new hardware-efficient algorithm, the training speed still lags behind that of GLA. This is due to the overhead caused by modeling state-to-state dependencies as described above, which requires \u201cmarginalizing\u201d over the head dimension inside the kernel, similar to the case of softmax attention. However, for GLA since there are no intra-state dependencies (everything is elementwise), and thus it is easy to use tiling to support arbitrary size of head dimension, as implemented in Yang and Zhang [115]. This limitation would potentially limit DeltaNet\u2019s memory size, consequently lowering the recallintensive task performance as we observed in $\\S4.2$ . However, it may be feasible to adopt block diagonal generalized Householder transition matrices with block sizes ftiting GPU SRAM (e.g., 128) while maintaining a overall large head dimension (and thus a large recurrent state size). ", "page_idx": 9}, {"type": "text", "text": "We also found that the length generalization of DeltaNet was limited,4 while GLA and RetNet (and Mamba to an extent) have been found to be able to extrapolate beyond the training length [116]. We speculate that this is because DeltaNet lacks explicit decay factors. This could be improved through incorporating a gating term in the recurrence, which we leave for future work. ", "page_idx": 9}, {"type": "text", "text": "6 Related Work ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We briefly discuss related work here and give an extended discussion in Appendix C. ", "page_idx": 9}, {"type": "text", "text": "Linear transformers can be seen as a type of iterated Hopfield networks [69], and this connection can provide perspectives on the limitations and improvements of linear attention transformers. For example, vanilla linear transformers use a Hebbian-like update rule, which has been shown to have limited memory capacity [65]. Later works in Hopfield networks use higher-order polynomials [21] and exponential kernels [92, 49] to enhance the memory capacity, which is also related to attention with polynomial kernels explored in PolysketchFormer [44] and Based Linear Attention [6, 1]. On the other hand, the delta rule has been shown to have better memory capacity [27, 83, 54, 97]. In this sense, given the fixed size recurrent state, using the delta rule is able to achieve a better frontier of the recall-memory tradeoff curve [6], and has recently been applied to enhance real-world retrieval tasks [71, 94]. Moreover, it outperforms the additive rule used in vanilla linear transformers across multiple domains [98, 36, 39, 35, 41]. ", "page_idx": 9}, {"type": "text", "text": "Despite these advantages, Irie et al. [41] revealed theoretical limitations of the delta update rule in terms of expressiveness. Recurrent enhancements of DeltaNet, such as Recurrent DeltaNet [37] and the Modern Self-Referential Weight Matrix [40], were proposed and found to be superior in Irie et al. [41]. However, these models extend beyond linear RNNs and cannot be parallelized across sequence length. This suggests a fundamental trade-off between parallelism and expressiveness [67]. How to further enhance DeltaNet without sacrificing parallelism remains an open question, and the hybrid cross-chunk nonlinear and intra-chunk linear strategy used in TTT [107] might provide a suitable middle ground. Finally, we remark that delta rule is closely related to meta or online learning via gradient descent [70, 38], which has been revisited in recent works like Longhorn [56] and TTT [107]. ", "page_idx": 9}, {"type": "text", "text": "7 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "We describe an algorithm that parallelizes DeltaNet training across the sequence length dimension, achieving significant speed-ups against existing implementations on modern hardware. This makes it possible to scale up DeltaNet to moderate-scale language modeling settings, where we find that it performs well compared to recent linear-recurrent baselines. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgements ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "This study was supported by funding from the MIT-IBM Watson AI Lab. We are grateful to Mayank Mishra for assistance with training and evaluating the 3B models, to Kazuki Irie for valuable feedback on the draft, and to Simran Arora, Liliang Ren and Eric Alcaide for their insightful discussions. We also thank Michael Poli and Armin Thomas for sharing the raw results from the MAD benchmark experiment. ", "page_idx": 10}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[1] Y. Aksenov, N. Balagansky, S. M. L. C. Vaina, B. Shaposhnikov, A. Gorbatovski, and D. Gavrilov. Linear Transformers with Learnable Kernel Functions are Better In-Context Models, June 2024. URL http://arxiv.org/abs/2402.10644. arXiv:2402.10644 [cs].   \n[2] E. Aky\u00fcrek, B. Wang, Y. Kim, and J. Andreas. In-context language learning: Arhitectures and algorithms. arXiv preprint arXiv:2401.12973, 2024.   \n[3] A. Ali, I. Zimerman, and L. Wolf. The hidden attention of mamba models, 2024.   \n[4] S. Arora, S. Eyuboglu, A. Timalsina, I. Johnson, M. Poli, J. Zou, A. Rudra, and C. R\u00e9. Zoology: Measuring and improving recall in efficient language models. CoRR, abs/2312.04927, 2023.   \n[5] S. Arora, B. Yang, S. Eyuboglu, A. Narayan, A. Hojel, I. Trummer, and C. R\u00e9. Language Models Enable Simple Systems for Generating Structured Views of Heterogeneous Data Lakes, Apr. 2023. arXiv:2304.09433 [cs].   \n[6] S. Arora, S. Eyuboglu, M. Zhang, A. Timalsina, S. Alberti, D. Zinsley, J. Zou, A. Rudra, and C. R\u00e9. Simple linear attention language models balance the recall-throughput tradeoff. CoRR, abs/2402.18668, 2024. arXiv: 2402.18668.   \n[7] S. Arora, A. Timalsina, A. Singhal, B. Spector, S. Eyuboglu, X. Zhao, A. Rao, A. Rudra, and C. R\u00e9. Just read twice: closing the recall gap for recurrent language models, 2024. URL https://arxiv.org/abs/2407.05483.   \n[8] D. Bahdanau, K. Cho, and Y. Bengio. Neural machine translation by jointly learning to align and translate. arXiv preprint arXiv:1409.0473, 2014.   \n[9] M. Beck, K. P\u00f6ppel, M. Spanring, A. Auer, O. Prudnikova, M. Kopp, G. Klambauer, J. Brandstetter, and S. Hochreiter. xlstm: Extended long short-term memory. arXiv preprint arXiv:2405.04517, 2024.   \n[10] R. v. d. Berg, L. Hasenclever, J. M. Tomczak, and M. Welling. Sylvester Normalizing Flows for Variational Inference, Feb. 2019. URL http://arxiv.org/abs/1803.05649. arXiv:1803.05649 [cs, stat].   \n[11] C. H. Bischof and C. V. Loan. The WY representation for products of householder matrices. In SIAM Conference on Parallel Processing for Scientific Computing, 1985. URL https:// api.semanticscholar.org/CorpusID:36094006.   \n[12] Y. Bisk, R. Zellers, J. Gao, Y. Choi, et al. Piqa: Reasoning about physical commonsense in natural language. In Proceedings of the AAAI conference on artificial intelligence, volume 34, pages 7432\u20137439, 2020.   \n[13] G. E. Blelloch. Prefix sums and their applications. 1990.   \n[14] W. Brandon, A. Nrusimha, K. Qian, Z. Ankner, T. Jin, Z. Song, and J. Ragan-Kelley. Striped Attention: Faster Ring Attention for Causal Transformers. ArXiv, abs/2311.09431, 2023.   \n[15] P. Clark, I. Cowhey, O. Etzioni, T. Khot, A. Sabharwal, C. Schoenick, and O. Tafjord. Think you have solved question answering? try arc, the ai2 reasoning challenge. arXiv preprint arXiv:1803.05457, 2018.   \n[16] D.-A. Clevert, T. Unterthiner, and S. Hochreiter. Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs), Feb. 2016. URL http://arxiv.org/abs/1511. 07289. arXiv:1511.07289 [cs].   \n[17] T. Dao. FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning. CoRR, abs/2307.08691, 2023. doi: 10.48550/ARXIV.2307.08691. arXiv: 2307.08691.   \n[18] T. Dao and A. Gu. Transformers are ssms: Generalized models and efficient algorithms through structured state space duality. arXiv preprint arXiv: 2405.21060, 2024.   \n[19] T. Dao, D. Y. Fu, S. Ermon, A. Rudra, and C. R\u00e9. FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness. In NeurIPS, 2022.   \n[20] S. De, S. L. Smith, A. Fernando, A. Botev, G. Cristian-Muraru, A. Gu, R. Haroun, L. Berrada, Y. Chen, S. Srinivasan, G. Desjardins, A. Doucet, D. Budden, Y. W. Teh, R. Pascanu, N. De Freitas, and C. Gulcehre. Griffin: Mixing Gated Linear Recurrences with Local Attention for Efficient Language Models, Feb. 2024. URL http://arxiv.org/abs/2402. 19427. arXiv:2402.19427 [cs].   \n[21] M. Demircigil, J. Heusel, M. L\u00f6we, S. Upgang, and F. Vermet. On a model of associative memory with huge storage capacity. Journal of Statistical Physics, 168(2):288\u2013299, July 2017. ISSN 0022-4715, 1572-9613. doi: 10.1007/s10955-017-1806-y. URL http://arxiv. org/abs/1702.01929. arXiv:1702.01929 [math].   \n[22] A. E. T. Dominguez and E. S. Q. Orti. Fast blocking of householder reflectors on graphics processors. 2018 26th Euromicro International Conference on Parallel, Distributed and Networkbased Processing (PDP), pages 385\u2013393, 2018. URL https://api.semanticscholar. org/CorpusID:46960439.   \n[23] S. Elfwing, E. Uchibe, and K. Doya. Sigmoid-Weighted Linear Units for Neural Network Function Approximation in Reinforcement Learning, Nov. 2017. URL http://arxiv.org/ abs/1702.03118. arXiv:1702.03118 [cs].   \n[24] M. Fathi, J. Pilault, P.-L. Bacon, C. Pal, O. Firat, and R. Goroshin. Block-state transformer. arXiv preprint arXiv:2306.09539, 2023.   \n[25] D. Y. Fu, T. Dao, K. K. Saab, A. W. Thomas, A. Rudra, and C. R\u00e9. Hungry Hungry Hippos: Towards Language Modeling with State Space Models. In The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023, 2023.   \n[26] L. Gao, J. Tow, S. Biderman, S. Black, A. DiPof,i C. Foster, L. Golding, J. Hsu, K. McDonell, N. Muennighoff, J. Phang, L. Reynolds, E. Tang, A. Thite, B. Wang, K. Wang, and A. Zou. A framework for few-shot language model evaluation, Sept. 2021.   \n[27] E. Gardner. The space of interactions in neural network models. Journal of Physics A, 21: 257\u2013270, 1988.   \n[28] A. Graves, G. Wayne, and I. Danihelka. Neural Turing Machines, Dec. 2014. URL http:// arxiv.org/abs/1410.5401. arXiv:1410.5401 [cs].   \n[29] R. Griffin and G. Teams. Recurrentgemma: Moving past transformers for efficient open language models. ArXiv, abs/2404.07839, 2024.   \n[30] A. Gu and T. Dao. Mamba: Linear-Time Sequence Modeling with Selective State Spaces. In Proceedings of COLM, 2023.   \n[31] A. Gu, K. Goel, and C. R\u00e9. Efficiently modeling long sequences with structured state spaces. In The Tenth International Conference on Learning Representations, ICLR 2022, Virtual Event, April 25-29, 2022. OpenReview.net, 2022.   \n[32] K. Helfrich, D. Willmott, and Q. Ye. Orthogonal recurrent neural networks with scaled cayley transform. In International Conference on Machine Learning, pages 1969\u20131978. PMLR, 2018.   \n[33] W. Hua, Z. Dai, H. Liu, and Q. V. Le. Transformer Quality in Linear Time. In K. Chaudhuri, S. Jegelka, L. Song, C. Szepesv\u00e1ri, G. Niu, and S. Sabato, editors, International Conference on Machine Learning, ICML 2022, 17-23 July 2022, Baltimore, Maryland, USA, volume 162 of Proceedings of Machine Learning Research, pages 9099\u20139117. PMLR, 2022.   \n[34] F. Huang, K. Lu, C. Yuxi, Z. Qin, Y. Fang, G. Tian, and G. Li. Encoding recurrence into transformers. In The Eleventh International Conference on Learning Representations, 2022.   \n[35] K. Irie and J. Schmidhuber. Images as weight matrices: Sequential image generation through synaptic learning rules. In The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023. OpenReview.net, 2023. URL https:// openreview.net/pdf?id $\\cdot^{=}$ ddad0PNUvV.   \n[36] K. Irie, I. Schlag, R. Csord\u2019as, and J. Schmidhuber. Going beyond linear transformers with recurrent fast weight programmers. ArXiv, abs/2106.06295, 2021. URL https://api. semanticscholar.org/CorpusID:235417174.   \n[37] K. Irie, I. Schlag, R. Csord\u00e1s, and J. Schmidhuber. Going beyond linear transformers with recurrent fast weight programmers. Advances in Neural Information Processing Systems, 34: 7703\u20137717, 2021.   \n[38] K. Irie, R. Csord\u00e1s, and J. Schmidhuber. The dual form of neural networks revisited: Connecting test time predictions to training patterns via spotlights of attention. In Proc. Int. Conf. on Machine Learning (ICML), Baltimore, MD, USA, July 2022.   \n[39] K. Irie, F. Faccio, and J. Schmidhuber. Neural differential equations for learning to program neural nets through continuous learning rules. In S. Koyejo, S. Mohamed, A. Agarwal, D. Belgrave, K. Cho, and A. Oh, editors, Advances in Neural Information Processing Systems 35: Annual Conference on Neural Information Processing Systems 2022, NeurIPS 2022, New Orleans, LA, USA, November 28 - December 9, 2022, 2022. URL http://papers.nips.cc/paper_files/paper/2022/hash/ fc09b26b85ab3abb2832bd555a2e4215-Abstract-Conference.html.   \n[40] K. Irie, I. Schlag, R. Csord\u2019as, and J. Schmidhuber. A modern self-referential weight matrix that learns to modify itself. In International Conference on Machine Learning, 2022.   \n[41] K. Irie, R. Csord\u00e1s, and J. Schmidhuber. Practical computational power of linear transformers and their recurrent and self-referential extensions. In H. Bouamor, J. Pino, and K. Bali, editors, Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing, pages 9455\u20139465, Singapore, Dec. 2023. Association for Computational Linguistics. doi: 10. 18653/v1/2023.emnlp-main.588. URL https://aclanthology.org/2023.emnlp-main. 588.   \n[42] L. Jing, C. Gulcehre, J. Peurifoy, Y. Shen, M. Tegmark, M. Soljacic, and Y. Bengio. Gated Orthogonal Recurrent Units: On Learning to Forget. Neural Computation, 31(4):765\u2013783, Apr. 2019. ISSN 0899-7667, 1530-888X. doi: 10.1162/neco_a_01174. URL https:// direct.mit.edu/neco/article/31/4/765-783/8458.   \n[43] T. Joffrain, T. M. Low, E. S. Quintana-Ort\u00ed, R. A. van de Geijn, and F. G. V. Zee. Accumulating householder transformations, revisited. ACM Trans. Math. Softw., 32:169\u2013179, 2006. URL https://api.semanticscholar.org/CorpusID:15723171.   \n[44] P. Kacham, V. Mirrokni, and P. Zhong. Polysketchformer: Fast transformers via sketches for polynomial kernels. arXiv preprint arXiv:2310.01655, 2023.   \n[45] Y. Kang, G. Tran, and H. De Sterck. Fast multipole attention: A divide-and-conquer attention mechanism for long sequences. arXiv preprint arXiv:2310.11960, 2023.   \n[46] J. Kasai, H. Peng, Y. Zhang, D. Yogatama, G. Ilharco, N. Pappas, Y. Mao, W. Chen, and N. A. Smith. Finetuning Pretrained Transformers into RNNs. In M.-F. Moens, X. Huang, L. Specia, and S. W.-t. Yih, editors, Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing, EMNLP 2021, Virtual Event / Punta Cana, Dominican Republic, 7-11 November, 2021, pages 10630\u201310643. Association for Computational Linguistics, 2021. doi: 10.18653/V1/2021.EMNLP-MAIN.830.   \n[47] A. Katharopoulos, A. Vyas, N. Pappas, and F. Fleuret. Transformers are rnns: Fast autoregressive transformers with linear attention. In International conference on machine learning, pages 5156\u20135165. PMLR, 2020.   \n[48] N. Kitaev, \u0141. Kaiser, and A. Levskaya. Reformer: The efficient transformer. arXiv preprint arXiv:2001.04451, 2020.   \n[49] D. Krotov and J. Hopfield. Large Associative Memory Problem in Neurobiology and Machine Learning, Apr. 2021. URL http://arxiv.org/abs/2008.06996. arXiv:2008.06996 [cond-mat, q-bio, stat].   \n[50] T. Lei. When Attention Meets Fast Recurrence: Training Language Models with Reduced Compute. In M.-F. Moens, X. Huang, L. Specia, and S. W.-t. Yih, editors, Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing, pages 7633\u20137648, Online and Punta Cana, Dominican Republic, Nov. 2021. Association for Computational Linguistics. doi: 10.18653/v1/2021.emnlp-main.602. URL https://aclanthology.org/ 2021.emnlp-main.602.   \n[51] T. Lei, R. Tian, J. Bastings, and A. P. Parikh. Simple recurrence improves masked language models. arXiv preprint arXiv:2205.11588, 2022.   \n[52] P. Lewis, E. Perez, A. Piktus, F. Petroni, V. Karpukhin, N. Goyal, H. K\u00fcttler, M. Lewis, W.-t. Yih, T. Rockt\u00e4schel, S. Riedel, and D. Kiela. Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks, Apr. 2021. URL http://arxiv.org/abs/2005.11401. arXiv:2005.11401 [cs].   \n[53] O. Lieber, B. Lenz, H. Bata, G. Cohen, J. Osin, I. Dalmedigos, E. Safahi, S. Meirom, Y. Belinkov, S. Shalev-Shwartz, et al. Jamba: A hybrid transformer-mamba language model. arXiv preprint arXiv:2403.19887, 2024.   \n[54] K. C. Lingashetty. Delta learning rule for the active sites model. arXiv preprint arXiv:1007.0417, 2010.   \n[55] L. D. Lingle. Transformer-vq: Linear-time transformers via vector quantization. arXiv preprint arXiv:2309.16354, 2023.   \n[56] B. Liu, R. Wang, L. Wu, Y. Feng, P. Stone, and Q. Liu. Longhorn: State space models are amortized online learners. ArXiv, abs/2407.14207, 2024.   \n[57] H. Liu, M. Zaharia, and P. Abbeel. Ring Attention with Blockwise Transformers for NearInfinite Context. ArXiv, abs/2310.01889, 2023.   \n[58] C. Lockard, P. Shiralkar, and X. L. Dong. OpenCeres: When Open Information Extraction Meets the Semi-Structured Web. In J. Burstein, C. Doran, and T. Solorio, editors, Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pages 3047\u2013 3056, Minneapolis, Minnesota, June 2019. Association for Computational Linguistics. doi: 10.18653/v1/N19-1309. URL https://aclanthology.org/N19-1309.   \n[59] X. Ma, C. Zhou, X. Kong, J. He, L. Gui, G. Neubig, J. May, and L. Zettlemoyer. Mega: moving average equipped gated attention. arXiv preprint arXiv:2209.10655, 2022.   \n[60] X. Ma, X. Yang, W. Xiong, B. Chen, L. Yu, H. Zhang, J. May, L. Zettlemoyer, O. Levy, and C. Zhou. Megalodon: Efficient llm pretraining and inference with unlimited context length. arXiv preprint arXiv:2404.08801, 2024.   \n[61] H. H. Mao. Fine-Tuning Pre-trained Transformers into Decaying Fast Weights. In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing, pages 10236\u201310242, Abu Dhabi, United Arab Emirates, Dec. 2022. Association for Computational Linguistics. doi: 10.18653/v1/2022.emnlp-main.697.   \n[62] E. Martin and C. Cundy. Parallelizing Linear Recurrent Neural Nets Over Sequence Length. In 6th International Conference on Learning Representations, ICLR 2018, Vancouver, BC, Canada, April 30 - May 3, 2018, Conference Track Proceedings. OpenReview.net, 2018.   \n[63] S. Massaroli, M. Poli, D. Y. Fu, H. Kumbong, R. N. Parnichkun, A. Timalsina, D. W. Romero, Q. McIntyre, B. Chen, A. Rudra, C. Zhang, C. R\u00e9, S. Ermon, and Y. Bengio. Laughing hyena distillery: Extracting compact recurrences from convolutions. ArXiv, abs/2310.18780, 2023. URL https://api.semanticscholar.org/CorpusID:264590326.   \n[64] A. Mathiasen, F. Hvilsh\u00f8j, J. R. J\u00f8rgensen, A. Nasery, and D. Mottin. Faster orthogonal parameterization with householder matrices. In ICML, Workshop Proceedings, 2020.   \n[65] R. J. McEliece, E. C. Posner, E. R. Rodemich, and S. S. Venkatesh. The capacity of the hopfield associative memory. IEEE Trans. Inf. Theory, 33:461\u2013482, 1987.   \n[66] J. Mercat, I. Vasiljevic, S. Keh, K. Arora, A. Dave, A. Gaidon, and T. Kollar. Linearizing large language models. arXiv preprint arXiv:2405.06640, 2024.   \n[67] W. Merrill, J. Petty, and A. Sabharwal. The Illusion of State in State-Space Models, Apr. 2024. URL http://arxiv.org/abs/2404.08819. arXiv:2404.08819 [cs].   \n[68] Z. Mhammedi, A. Hellicar, A. Rahman, and J. Bailey. Efficient Orthogonal Parametrisation of Recurrent Neural Networks Using Householder Reflections, June 2017. URL http:// arxiv.org/abs/1612.00188. arXiv:1612.00188 [cs].   \n[69] B. Millidge. Linear Attention as Iterated Hopfield Networks. URL http://www.beren.io/ 2024-03-03-Linear-Attention-as-Iterated-Hopfield-Networks/.   \n[70] T. Munkhdalai, A. Sordoni, T. Wang, and A. Trischler. Metalearned Neural Memory. ArXiv, July 2019. URL https://www.semanticscholar.org/paper/ a513bb6e1967f5a31ad4f38954e66d4169b613e5.   \n[71] T. Munkhdalai, M. Faruqui, and S. Gopal. Leave no context behind: Efficient infinite context transformers with infini-attention. arXiv preprint arXiv:2404.07143, 2024.   \n[72] Y. Nahshan, J. Kampeas, and E. Haleva. Linear Log-Normal Attention with Unbiased Concentration, Feb. 2024. URL http://arxiv.org/abs/2311.13541. arXiv:2311.13541 [cs].   \n[73] T. Nguyen, V. Suliafu, S. Osher, L. Chen, and B. Wang. Fmmformer: Efficient and flexible transformer via decomposed near-field and far-field attention. Advances in neural information processing systems, 34:29449\u201329463, 2021.   \n[74] D. Paperno, G. Kruszewski, A. Lazaridou, Q. N. Pham, R. Bernardi, S. Pezzelle, M. Baroni, G. Boleda, and R. Fern\u00e1ndez. The LAMBADA dataset: Word prediction requiring a broad discourse context, June 2016. URL http://arxiv.org/abs/1606.06031. arXiv:1606.06031 [cs].   \n[75] J. Park, J. Park, Z. Xiong, N. Lee, J. Cho, S. Oymak, K. Lee, and D. Papailiopoulos. Can mamba learn how to learn? a comparative study on in-context learning tasks. arXiv preprint arXiv:2402.04248, 2024.   \n[76] B. Peng, E. Alcaide, Q. Anthony, A. Albalak, S. Arcadinho, H. Cao, X. Cheng, M. Chung, M. Grella, K. K. G. V, X. He, H. Hou, P. Kazienko, J. Kocon, J. Kong, B. Koptyra, H. Lau, K. S. I. Mantri, F. Mom, A. Saito, X. Tang, B. Wang, J. S. Wind, S. Wozniak, R. Zhang, Z. Zhang, Q. Zhao, P. Zhou, J. Zhu, and R.-J. Zhu. RWKV: Reinventing RNNs for the Transformer Era. CoRR, abs/2305.13048, 2023. doi: 10.48550/ARXIV.2305.13048. arXiv: 2305.13048.   \n[77] B. Peng, D. Goldstein, Q. Anthony, A. Albalak, E. Alcaide, S. Biderman, E. Cheah, X. Du, T. Ferdinan, H. Hou, P. Kazienko, K. K. GV, J. Kocon\u00b4, B. Koptyra, S. Krishna, R. McClelland Jr., N. Muennighoff, F. Obeid, A. Saito, G. Song, H. Tu, S. Woz\u00b4niak, R. Zhang, B. Zhao, Q. Zhao, P. Zhou, J. Zhu, and R.-J. Zhu. Eagle and Finch: RWKV with Matrix-Valued States and Dynamic Recurrence, Apr. 2024. URL http://arxiv.org/abs/2404.05892. arXiv:2404.05892 [cs].   \n[78] H. Peng, R. Schwartz, S. Thomson, and N. A. Smith. Rational recurrences. ArXiv, abs/1808.09357, 2018.   \n[79] H. Peng, N. Pappas, D. Yogatama, R. Schwartz, N. A. Smith, and L. Kong. Random feature attention. arXiv preprint arXiv:2103.02143, 2021.   \n[80] H. Peng, J. Kasai, N. Pappas, D. Yogatama, Z. Wu, L. Kong, R. Schwartz, and N. A. Smith. ABC: Attention with Bounded-memory Control. In S. Muresan, P. Nakov, and A. Villavicencio, editors, Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), Dublin, Ireland, May 2022. Association for Computational Linguistics.   \n[81] M. Poli, S. Massaroli, E. Nguyen, D. Y. Fu, T. Dao, S. Baccus, Y. Bengio, S. Ermon, and C. R\u00e9. Hyena Hierarchy: Towards Larger Convolutional Language Models. In A. Krause, E. Brunskill, K. Cho, B. Engelhardt, S. Sabato, and J. Scarlett, editors, International Conference on Machine Learning, ICML 2023, 23-29 July 2023, Honolulu, Hawaii, USA, volume 202 of Proceedings of Machine Learning Research, pages 28043\u201328078. PMLR, 2023.   \n[82] M. Poli, A. W. Thomas, E. Nguyen, P. Ponnusamy, B. Deiseroth, K. Kersting, T. Suzuki, B. Hie, S. Ermon, C. R\u00e9, C. Zhang, and S. Massaroli. Mechanistic Design and Scaling of Hybrid Architectures, Mar. 2024. arXiv:2403.17844 [cs].   \n[83] D. Prados and S. Kak. Neural network capacity using delta rule. Electronics Letters, 3(25): 197\u2013199, 1989.   \n[84] Z. Qin, X. Han, W. Sun, D. Li, L. Kong, N. Barnes, and Y. Zhong. The devil in linear transformer. arXiv preprint arXiv:2210.10340, 2022.   \n[85] Z. Qin, X. Han, W. Sun, B. He, D. Li, D. Li, Y. Dai, L. Kong, and Y. Zhong. Toeplitz neural network for sequence modeling. arXiv preprint arXiv:2305.04749, 2023.   \n[86] Z. Qin, D. Li, W. Sun, W. Sun, X. Shen, X. Han, Y. Wei, B. Lv, F. Yuan, X. Luo, et al. Scaling transnormer to 175 billion parameters. arXiv preprint arXiv:2307.14995, 2023.   \n[87] Z. Qin, W. Sun, K. Lu, H. Deng, D. Li, X. Han, Y. Dai, L. Kong, and Y. Zhong. Linearized Relative Positional Encoding, July 2023. URL http://arxiv.org/abs/2307. 09270. arXiv:2307.09270 [cs].   \n[88] Z. Qin, W. Sun, D. Li, X. Shen, W. Sun, and Y. Zhong. Lightning attention-2: A free lunch for handling unlimited sequence lengths in large language models. 2024.   \n[89] Z. Qin, S. Yang, W. Sun, X. Shen, D. Li, W. Sun, and Y. Zhong. HGRN2: Gated Linear RNNs with State Expansion. 2024. URL https://api.semanticscholar.org/ CorpusID:269043328.   \n[90] Z. Qin, S. Yang, and Y. Zhong. Hierarchically gated recurrent neural network for sequence modeling. Advances in Neural Information Processing Systems, 36, 2024.   \n[91] P. Rajpurkar, R. Jia, and P. Liang. Know What You Don\u2019t Know: Unanswerable Questions for SQuAD. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), Melbourne, Australia, 2018. Association for Computational Linguistics.   \n[92] H. Ramsauer, B. Sch\u00e4f,l J. Lehner, P. Seidl, M. Widrich, T. Adler, L. Gruber, M. Holzleitner, M. Pavlovic\u00b4, G. K. Sandve, V. Greiff, D. Kreil, M. Kopp, G. Klambauer, J. Brandstetter, and S. Hochreiter. Hopfield Networks is All You Need, Apr. 2021. URL http://arxiv.org/ abs/2008.02217. arXiv:2008.02217 [cs, stat].   \n[93] L. Ren, Y. Liu, Y. Lu, Y. Shen, C. Liang, and W. Chen. Samba: Simple hybrid state space models for efficient unlimited context language modeling. arXiv preprint arXiv:2406.07522, 2024.   \n[94] I. Rodkin, Y. Kuratov, A. Bulatov, and M. Burtsev. Associative recurrent memory transformer. ArXiv, abs/2407.04841, 2024.   \n[95] A. Roy, M. Saffar, A. Vaswani, and D. Grangier. Efficient content-based sparse attention with routing transformers. Transactions of the Association for Computational Linguistics, 9: 53\u201368, 2021. [96] K. Sakaguchi, R. L. Bras, C. Bhagavatula, and Y. Choi. Winogrande: An adversarial winograd schema challenge at scale. Communications of the ACM, 64(9):99\u2013106, 2021. [97] I. Schlag, K. Irie, and J. Schmidhuber. Linear transformers are secretly fast weight programmers. In M. Meila and T. Zhang, editors, Proceedings of the 38th International Conference on Machine Learning, ICML 2021, 18-24 July 2021, Virtual Event, volume 139 of Proceedings of Machine Learning Research, pages 9355\u20139366. PMLR, 2021. [98] I. Schlag, K. Irie, and J. Schmidhuber. Linear Transformers Are Secretly Fast Weight Programmers. In M. Meila and T. Zhang, editors, Proceedings of the 38th International Conference on Machine Learning, ICML 2021, 18-24 July 2021, Virtual Event, volume 139 of Proceedings of Machine Learning Research, pages 9355\u20139366. PMLR, 2021. [99] I. Schlag, T. Munkhdalai, and J. Schmidhuber. Learning Associative Inference Using Fast Weight Memory, Feb. 2021. URL http://arxiv.org/abs/2011.07831. arXiv:2011.07831 [cs].   \n[100] J. Schmidhuber. Learning to control fast-weight memories: An alternative to dynamic recurrent networks. Neural Computation, 4(1):131\u2013139, 1992.   \n[101] N. Shazeer. Glu variants improve transformer. arXiv preprint arXiv:2002.05202, 2020.   \n[102] Y. Shen, M. Stallone, M. Mishra, G. Zhang, S. Tan, A. Prasad, A. M. Soria, D. D. Cox, and R. Panda. Power scheduler: A batch size and token number agnostic learning rate scheduler. ArXiv, abs/2408.13359, 2024.   \n[103] J. T. H. Smith, A. Warrington, and S. W. Linderman. Simplified State Space Layers for Sequence Modeling. In The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023. OpenReview.net, 2023.   \n[104] W. Sun, Z. Qin, D. Li, X. Shen, Y. Qiao, and Y. Zhong. Linear attention sequence parallelism. arXiv preprint arXiv:2404.02882, 2024.   \n[105] Y. Sun, L. Dong, S. Huang, S. Ma, Y. Xia, J. Xue, J. Wang, and F. Wei. Retentive network: A successor to transformer for large language models. arXiv preprint arXiv:2307.08621, 2023.   \n[106] Y. Sun, L. Dong, Y. Zhu, S. Huang, W. Wang, S. Ma, Q. Zhang, J. Wang, and F. Wei. You only cache once: Decoder-decoder architectures for language models. arXiv preprint arXiv:2405.05254, 2024.   \n[107] Y. Sun, X. Li, K. Dalal, J. Xu, A. Vikram, G. Zhang, Y. Dubois, X. Chen, X. Wang, O. Koyejo, T. Hashimoto, and C. Guestrin. Learning to (learn at test time): Rnns with expressive hidden states. ArXiv, abs/2407.04620, 2024. URL https://api.semanticscholar.org/ CorpusID:271039606.   \n[108] L. Team. The llama 3 herd of models. ArXiv, abs/2407.21783, 2024.   \n[109] P. Tillet, H. Kung, and D. D. Cox. Triton: an intermediate language and compiler for tiled neural network computations. In Proceedings of the 3rd ACM SIGPLAN International Workshop on Machine Learning and Programming Languages, MAPL@PLDI 2019, pages 10\u201319. ACM, 2019. doi: 10.1145/3315508.3329973.   \n[110] J. M. Tomczak and M. Welling. Improving Variational Auto-Encoders using Householder Flow, Jan. 2017. arXiv:1611.09630 [cs, stat].   \n[111] H. Touvron, T. Lavril, G. Izacard, X. Martinet, M.-A. Lachaux, T. Lacroix, B. Rozi\u00e8re, N. Goyal, E. Hambro, F. Azhar, et al. Llama: Open and efficient foundation language models. arXiv preprint arXiv:2302.13971, 2023.   \n[112] A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, L. Kaiser, and I. Polosukhin. Attention is all you need. Advances in neural information processing systems, 30, 2017.   \n[113] E. Vorontsov, C. Trabelsi, S. Kadoury, and C. Pal. On orthogonality and learning recurrent networks with long term dependencies. In International Conference on Machine Learning, pages 3570\u20133578. PMLR, 2017.   \n[114] B. Widrow, M. E. Hoff, et al. Adaptive switching circuits. In IRE WESCON convention record, volume 4, pages 96\u2013104. New York, 1960.   \n[115] S. Yang and Y. Zhang. FLA: A Triton-Based Library for Hardware-Efficient Implementations of Linear Attention Mechanism, Jan. 2024. URL https://github.com/sustcsonglin/ flash-linear-attention. original-date: 2023-12-20T06:50:18Z.   \n[116] S. Yang, B. Wang, Y. Shen, R. Panda, and Y. Kim. Gated linear attention transformers with hardware-efficient training. arXiv preprint arXiv:2312.06635, 2023.   \n[117] M. Zaheer, G. Guruganesh, K. A. Dubey, J. Ainslie, C. Alberti, S. Ontanon, P. Pham, A. Ravula, Q. Wang, L. Yang, et al. Big bird: Transformers for longer sequences. Advances in neural information processing systems, 33:17283\u201317297, 2020.   \n[118] R. Zellers, A. Holtzman, Y. Bisk, A. Farhadi, and Y. Choi. Hellaswag: Can a machine really finish your sentence? arXiv preprint arXiv:1905.07830, 2019.   \n[119] J. Zhang, Q. Lei, and I. S. Dhillon. Stabilizing Gradients for Deep Neural Networks via Efficient SVD Parameterization, Mar. 2018. arXiv:1803.09327 [cs, stat].   \n[120] J. Zhang, S. Jiang, J. Feng, L. Zheng, and L. Kong. Linear Attention via Orthogonal Memory, 2023. arXiv:2312.11135.   \n[121] Q. Zhang, D. Ram, C. Hawkins, S. Zha, and T. Zhao. Efficient long-range transformers: You need to attend more, but not necessarily at every layer. In H. Bouamor, J. Pino, and K. Bali, editors, Findings of the Association for Computational Linguistics: EMNLP 2023, 2023.   \n[122] Y. Zhang, S. Yang, R. Zhu, Y. Zhang, L. Cui, Y. Wang, B. Wang, F. Shi, B. Wang, W. Bi, P. Zhou, and G. Fu. Gated slot attention for efficient linear-time sequence modeling. In The Thirty-eighth Annual Conference on Neural Information Processing Systems, 2024.   \n[123] I. Zimerman, A. Ali, and L. Wolf. A unified implicit attention formulation for gated-linear recurrent sequence models. CoRR, abs/2405.16504, 2024. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "", "page_idx": 14}, {"type": "text", "text": "", "page_idx": 15}, {"type": "text", "text": "", "page_idx": 16}, {"type": "text", "text": "", "page_idx": 17}, {"type": "text", "text": "A Derivation of WY representation ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "To reduce notational clutter, we only discuss the first chunk here. ", "page_idx": 18}, {"type": "text", "text": "We first show $\\begin{array}{r}{{\\bf P}_{n}={\\bf I}-\\sum_{t=1}^{n}{\\bf w}_{t}{\\bf k}_{t}^{\\top}}\\end{array}$ by induction, ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\lefteqn{\\mathrm{P}_{n}=\\prod_{i=1}^{n}(\\mathrm{\\ensuremath{I}-\\beta}_{i}k_{i}k_{i}^{\\top})}}\\\\ &{=\\mathrm{P}_{n-1}(\\mathrm{\\ensuremath{I-\\beta}}_{j}\\mathrm{\\ensuremath{A}}_{\\mathrm{R}},k_{i}^{\\top})}\\\\ &{=(\\mathrm{\\ensuremath{I-\\beta}}_{\\mathrm{C}}^{-1}\\mathrm{\\ensuremath{\\sigma}}_{i}k_{i}^{\\top})(\\mathrm{\\ensuremath{I-\\beta}}_{j}\\mathrm{\\ensuremath{A}}_{\\mathrm{R}},k_{i}^{\\top})}\\\\ &{=(\\mathrm{\\ensuremath{I-\\beta}}_{\\mathrm{C}}^{-1}\\mathrm{\\ensuremath{\\sigma}}_{i}k_{i}^{\\top})(\\mathrm{\\ensuremath{I-\\beta}}_{j}\\mathrm{\\ensuremath{A}}_{\\mathrm{R}},k_{i}^{\\top})}\\\\ &{=\\mathrm{{\\bf{I}-\\sum_{i=1}^{n}\\mathrm{\\bf{\\sigma}}}}w_{i}k_{i}^{\\top}-\\beta_{i}k_{i}\\mathrm{\\bf{\\sigma}}_{i}^{\\top}+(\\sum_{i=1}^{n-1}w_{i}k_{i}^{\\top})\\beta_{i}k_{i}\\mathrm{\\bf{\\sigma}}_{i}^{\\top}}\\\\ &{=\\mathrm{{\\bf{I}-\\sum_{i=1}^{n}\\mathrm{\\bf{\\sigma}}}}w_{i}k_{i}^{\\top}-\\underbrace{\\left(\\beta_{i}k_{i}-\\beta_{i}\\right)_{\\mathrm{\\bf{\\sigma}}}\\sum_{i=1}^{n-1}\\left(w_{i}(k_{i}^{\\top}k_{i}^{\\top})\\right)}_{w_{i}}k_{i}^{\\top}}\\\\ &{=\\mathrm{{\\bf{I}-\\sum_{i=1}^{n}\\mathrm{\\bf{\\sigma}}}}w_{i}k_{i}^{\\top}}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "Similarly, we show $\\begin{array}{r}{{\\bf S}_{n}=\\sum_{t=1}^{n}{\\bf u}_{t}{\\bf k}_{n}^{\\top}}\\end{array}$ by induction, ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{S}_{n}=\\mathbf{S}_{n-1}(\\mathbf{I}-\\beta_{n}k_{n}\\mathbf{k}_{n}^{\\top})+\\beta_{n}v_{n}k_{n}^{\\top}}\\\\ &{\\quad=\\left(\\displaystyle\\sum_{t=1}^{n-1}u_{t}k_{t}^{\\top}\\right)(\\mathbf{I}-\\beta_{n}k_{n}k_{n}^{\\top})+\\beta_{n}v_{n}k_{n}^{\\top}}\\\\ &{\\quad=\\displaystyle\\sum_{t=1}^{n-1}u_{t}k_{t}^{\\top}-\\left(\\displaystyle\\sum_{t=1}^{n-1}u_{t}k_{t}^{\\top}\\right)\\beta_{n}k_{n}k_{n}^{\\top}+\\beta_{n}v_{n}k_{n}^{\\top}}\\\\ &{\\quad=\\displaystyle\\sum_{t=1}^{n-1}u_{t}k_{t}^{\\top}+\\underbrace{\\left(\\beta_{n}v_{n}-\\beta_{n}\\displaystyle\\sum_{t=1}^{n-1}u_{t}\\left(k_{t}^{\\top}k_{n}\\right)\\right)k_{n}^{\\top}}_{u_{t}}}\\\\ &{\\quad=\\displaystyle\\sum_{t=1}^{n}u_{t}k_{n}^{\\top}}\\end{array}\n$$", "text_format": "latex", "page_idx": 18}, {"type": "image", "img_path": "y8Rm4VNRPH/tmp/be294e206b7dfc6ee42daee0e26bafcafa0e662ef4a26bfc514fac37fd97a81e.jpg", "img_caption": [], "img_footnote": [], "page_idx": 19}, {"type": "text", "text": "Listing 1: Pytorch-like code snippet of the forward pass of our chunkwise algorithm for training DeltaNet. We omit the dimensions of batch size and number of heads for clarity. ", "page_idx": 19}, {"type": "text", "text": "C Related Work Continued ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "Chunkwise linear attention. Hua et al. [33] first proposed chunkwise form for linear attention; however, they used a hybrid linear and nonlinear attention model similar to Munkhdalai et al. [71]. It is possible to adapt their algorithm to compute the exact output of the pure linear attention, as shown in Sun et al. [105] and Yang et al. [116]. The chunkwise linear attention algorithm has also been independently discovered in several works [105, 44, 18]. Yang et al. [116] and Qin et al. [88] discuss I/O-aware hardware optimization for chunkwise linear attention and Sun et al. [104] make generalization to multi-node distributed training. Inspired by the chunkwise form, we propose a new algorithm for hardware-efficient DeltaNet training, significantly improving the training efficiency and allowing for large-scale experiments. ", "page_idx": 19}, {"type": "text", "text": "Hybrid models. There has been much recent work on developing hybrid models by combining linear recurrent layers (state-space models, linear recurrent Transformers, linear RNNs) with local chunk attention [59, 121, 24, 60, 71] or sliding window attention [121, 6, 20, 93] or global attention [50, 51, 34, 25, 53, 75, 106]. Poli et al. [82] systematically study the scaling law of hybrid models. We similarly show that combining DeltaNet with classic attention is an effective strategy. ", "page_idx": 20}, {"type": "text", "text": "Householder matrices. Householder matrices, known for preserving norms, are a type of orthogonal matrix extensively used in machine learning [64, 68, 119, 110, 87, 10]. These matrices allow for efficient computation of inverses and their Jacobian determinant of one, making them particularly suitable for applications in normalizing flows [64, 10]. Notably, Mathiasen et al. [64] developed a chunkwise fast algorithm for computing the cumulative product of Householder matrices for normalizing flows, leveraging the WY representation. Our approach, while sharing the same high-level concept, tackles a different problem and is arguably more general. ", "page_idx": 20}, {"type": "text", "text": "There has also been significant interest in using orthogonal matrices to parameterize the transition matrices of RNNs [68, 42, 113, 32] for mitigating vanishing gradients. Mhammedi et al. [68] use the WY representation to reduce the memory footprint when training nonlinear RNNs with Householder transition matrices. ", "page_idx": 20}, {"type": "text", "text": "D Hyperparameters ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "We used $8\\,\\,\\mathrm{H}100$ GPUs for 340M and 1.3B language modeling experiments. Each model uses AdamW for optimization, with a peak learning rate of $3\\times10^{-4}$ . The 340M models are trained using 15 billion tokens and a batch size of $0.5\\mathrm{M}$ tokens, while the 1.3B models are trained with 100 billion tokens and a batch size of 2M tokens. We use a cosine learning rate schedule, starting with a warm-up phase of 0.5 billion tokens for the 340M models and 1 billion tokens for the 1.3B models. Both configurations have initial and final learning rates set at $3\\times10^{-5}$ . We apply a weight decay of 0.01 and use gradient clipping at a maximum of 1.0. The head dimension of DeltaNet is set to 128, and the kernel size for convolution layers is set at 4. ", "page_idx": 20}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: This paper\u2019s contributions and scope are reflected in abstract and introduction part clearly. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 21}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Justification: We discuss the limitations of this work in $\\S5.3$ ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 21}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: This paper does not include theoretical results that require a full proof. Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 22}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Justification: The paper provides sufficient details on hyperparameters and training procedures in $\\S D$ to reproduce the results supporting its main conclusions. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 22}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: Our code is publicly available at https://github.com/sustcsonglin/ flash-linear-attention. Our primary training corpus is Slimpajama, an open-source dataset. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https://nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 23}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: We have detailed all the training and evaluation settings before the main results in the experimental part. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 23}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 23}, {"type": "text", "text": "Answer: [No] ", "page_idx": 23}, {"type": "text", "text": "Justification: We do not have enough resources to obtain error bars as running the experiments multiple times is computationally expensive due to the large model size. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 23}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 24}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: We provide information of GPU type and number of GPUs used for running our experiments. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 24}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: This work follows the NeurIPS Code of Ethics. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 24}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 24}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 24}, {"type": "text", "text": "Justification: We foresee no potential societal impact of this work. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: \u2022 The answer NA means that there is no societal impact of the work performed. ", "page_idx": 24}, {"type": "text", "text": "\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake proflies, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 25}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 25}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 25}, {"type": "text", "text": "Justification: We foresee no such risks posed by this work. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety fliters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 25}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: All of the datasets we use are publicly available at huggingface site, and we have properly cited all the training and evaluation datasets we used. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 25}, {"type": "text", "text": "", "page_idx": 26}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: This work does not release new assets. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip flie. ", "page_idx": 26}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: This work does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 26}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: This work does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 26}, {"type": "text", "text": "", "page_idx": 27}]