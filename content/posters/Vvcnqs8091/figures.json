[{"figure_path": "Vvcnqs8091/figures/figures_1_1.jpg", "caption": "Figure 1: A pipeline can be built by repeating a building block, and then squeezing redundant bubbles.", "description": "This figure illustrates the concept of building a pipeline by repeating a basic building block.  It shows how pipelines, such as 1F1B and Eager 1F1B, can be constructed by repeating these blocks. The figure also demonstrates how squeezing redundant bubbles from the repeated blocks can lead to a more efficient pipeline.  The different shades of gray represent different microbatches in the pipeline. ", "section": "2 How to Build a Pipeline"}, {"figure_path": "Vvcnqs8091/figures/figures_3_1.jpg", "caption": "Figure 2: The V-Shape building block ensures balanced peak memory across all devices, whereas the parallel building block has a memory bottleneck in the first device.", "description": "This figure compares two different building block designs for pipeline parallelism: Parallel and V-Shape. The Parallel design shows an imbalanced memory usage, with the first device having a memory bottleneck.  The V-Shape design, in contrast, achieves a balanced peak memory across all devices, improving memory efficiency.  The lifespans of each stage are represented by the colored blocks.", "section": "3 Memory Efficient Building Blocks"}, {"figure_path": "Vvcnqs8091/figures/figures_4_1.jpg", "caption": "Figure 3: V-Shape building blocks with 4 devices (d = 4), where white text colors represent the first half of model stages and black text colors represent the second half. F, B and W represent the forward, backward (for activation gradients) and backward for weight gradients, respectively.", "description": "This figure shows the building blocks of three different V-shape pipeline schedules (V-Min, V-Half, and V-ZB) with 4 devices. Each block is made of forward (F), backward for activations (B), and backward for weights (W) passes. The arrangement of these passes determines the memory efficiency and the number of pipeline bubbles. White text represents the first half of the model stages, while black text represents the second half. The differences in the arrangement of passes across the three V-shape blocks illustrate how different memory consumption and bubble rates can be achieved by changing the scheduling of forward and backward passes.", "section": "3 Memory Efficient Building Blocks"}, {"figure_path": "Vvcnqs8091/figures/figures_4_2.jpg", "caption": "Figure 3: V-Shape building blocks with 4 devices (d = 4), where white text colors represent the first half of model stages and black text colors represent the second half. F, B and W represent the forward, backward (for activation gradients) and backward for weight gradients, respectively.", "description": "This figure shows four different V-Shape building blocks designed for pipeline parallelism with four devices. Each building block is a sequence of forward (F), backward for activations (B), and backward for weights (W) passes. The blocks differ in the arrangement and offsets of these passes, which affects their memory efficiency and the resulting pipeline schedule. The 'V-Shape' refers to the arrangement of passes, where the first half of stages uses one pattern and the second half mirrors this pattern, aiming for balanced memory consumption across all devices.", "section": "3 Memory Efficient Building Blocks"}, {"figure_path": "Vvcnqs8091/figures/figures_5_1.jpg", "caption": "Figure 3: V-Shape building blocks with 4 devices (d = 4), where white text colors represent the first half of model stages and black text colors represent the second half. F, B and W represent the forward, backward (for activation gradients) and backward for weight gradients, respectively.", "description": "This figure showcases different V-Shape building block variations with 4 devices.  The white text represents the first half of the model's stages, and black text represents the second half.  F, B, and W denote forward, backward (for activation gradients), and backward (for weight gradients) passes, respectively. The variations illustrate how different arrangements of these passes impact memory efficiency and pipeline design.", "section": "3 Memory Efficient Building Blocks"}, {"figure_path": "Vvcnqs8091/figures/figures_6_1.jpg", "caption": "Figure 6: Throughput and activation memory using the same microbatch size.", "description": "This figure compares different pipeline parallel schedules (V-ZB, ZB-1P, V-Half, 1F1B, V-Min, 1F1B-R) across three different model sizes (9.6B, 21B, 38.5B) and varying numbers of microbatches.  The top row shows the throughput (MFU, or FLOPS utilization), while the bottom row shows the activation memory used. The results demonstrate the performance and memory efficiency trade-offs of each schedule.", "section": "4.2 Comparing Pipeline Schedules"}, {"figure_path": "Vvcnqs8091/figures/figures_7_1.jpg", "caption": "Figure 6: Throughput and activation memory using the same microbatch size.", "description": "This figure compares the throughput (measured in FLOPS utilization or MFU) and activation memory consumption across different pipeline parallel schedules.  It shows the results for three different model sizes (9.6B, 21B, and 38.5B parameters) each with varying numbers of microbatches.  The figure demonstrates that V-ZB consistently outperforms other methods in terms of throughput, while V-Min and V-Half significantly reduce activation memory compared to 1F1B.", "section": "4.2 Comparing Pipeline Schedules"}, {"figure_path": "Vvcnqs8091/figures/figures_7_2.jpg", "caption": "Figure 6: Throughput and activation memory using the same microbatch size.", "description": "This figure compares the throughput (measured in FLOPS utilization or MFU) and activation memory consumption of different pipeline schedules (V-ZB, ZB-1P, V-Half, 1F1B, V-Min, and 1F1B-R) under various settings (9.6B, 21B, and 38.5B models) and with different numbers of microbatches.  It visually demonstrates the trade-off between memory and throughput and illustrates the improvements achieved by the proposed methods.", "section": "4.2 Comparing Pipeline Schedules"}, {"figure_path": "Vvcnqs8091/figures/figures_11_1.jpg", "caption": "Figure 9: Bubble rate of V scheduler under various settings.", "description": "This figure shows the bubble rate of the adaptive V-Shape scheduler under various settings and different memory limits. The x-axis represents the memory limit as a fraction of the memory used by the 1F1B baseline. The y-axis represents the bubble rate. Different lines represent different numbers of microbatches. The figure shows that the bubble rate drops significantly as the memory limit increases. There is a sudden drop in the bubble rate when the memory limit is just above approximately 1/2 of 1F1B, indicating that the repeating bubbles observed in Figure 5a disappear.", "section": "B Evaluation of Adaptive Scheduler"}, {"figure_path": "Vvcnqs8091/figures/figures_12_1.jpg", "caption": "Figure 4: V-Shape schedules compared to 1F1B, under the setting of 4 devices and 8 microbatches. The stable phases adhere to the pattern of their building blocks.", "description": "This figure compares different pipeline schedules, namely 1F1B, V-Min, V-Half, and V-ZB, using 4 devices and 8 microbatches.  The visualization shows the sequence of forward (F), backward (B), and weight update (W) passes across the different stages and devices over the 8 microbatches.  The stable phase (the middle section of each schedule) shows the repeating pattern, highlighting the difference between each method's memory usage and scheduling efficiency.", "section": "3.2 V-Shape Pipeline Schedules"}, {"figure_path": "Vvcnqs8091/figures/figures_12_2.jpg", "caption": "Figure 4: V-Shape schedules compared to 1F1B, under the setting of 4 devices and 8 microbatches. The stable phases adhere to the pattern of their building blocks.", "description": "This figure compares different pipeline schedules: 1F1B, V-Min, V-Half, and V-ZB. Each schedule is visualized as a sequence of forward (F), backward for activations (B), and backward for weights (W) passes across 4 devices over 8 microbatches.  The visualization highlights how each schedule arranges these passes to form building blocks that repeat over time. The goal is to reduce memory usage and pipeline bubbles while maintaining high throughput.  The V-shaped schedules (V-Min, V-Half, V-ZB) show different memory optimization strategies compared to the 1F1B baseline.", "section": "3.2 V-Shape Pipeline Schedules"}, {"figure_path": "Vvcnqs8091/figures/figures_16_1.jpg", "caption": "Figure 12: Average single-pass MFU (over FBW) for grid search under different TP degrees.", "description": "This figure shows the results of a grid search experiment that investigated the impact of different tensor parallelism (TP) degrees on the average single-pass FLOPS utilization (MFU) for forward, backward, and weight update passes (FBW). The experiment varied the microbatch size (mbs) and TP degree, demonstrating a decrease in MFU as the TP degree increased.", "section": "4.4 Combining with Existing Techniques"}, {"figure_path": "Vvcnqs8091/figures/figures_17_1.jpg", "caption": "Figure 4: V-Shape schedules compared to 1F1B, under the setting of 4 devices and 8 microbatches. The stable phases adhere to the pattern of their building blocks.", "description": "This figure compares different pipeline schedules, specifically V-Shape schedules (V-Min, V-Half, V-ZB) against the baseline 1F1B schedule.  The comparison is made with 4 devices and 8 microbatches. The visual representation shows the sequence of forward (F), backward (B), and weight update (W) passes across the pipeline stages for each method.  The goal is to illustrate how V-Shape designs lead to more efficient memory usage and reduced bubbles compared to the standard 1F1B approach. The stable phase, representing the repeating pattern in the pipeline, is highlighted to demonstrate the effect of the building block design on pipeline performance.", "section": "3.2 V-Shape Pipeline Schedules"}, {"figure_path": "Vvcnqs8091/figures/figures_18_1.jpg", "caption": "Figure 4: V-Shape schedules compared to 1F1B, under the setting of 4 devices and 8 microbatches. The stable phases adhere to the pattern of their building blocks.", "description": "This figure compares different pipeline schedules (V-Min, V-Half, V-ZB, and 1F1B) under the condition of 4 devices and 8 microbatches. The schedules are represented visually using colored blocks to show the execution order of forward (F), backward (B), and weight update (W) passes for each microbatch.  The stable phase of each pipeline, where the pattern repeats consistently, is clearly illustrated to show the differences in their structures and how this affects the peak memory and efficiency. The figure highlights the efficient memory management achieved by the V-shaped schedules compared to the 1F1B baseline.", "section": "3 Memory Efficient Building Blocks"}, {"figure_path": "Vvcnqs8091/figures/figures_18_2.jpg", "caption": "Figure 5: V-Shape schedules compared to 1F1B, under the setting of 4 devices and 8 microbatches. The stable phases adhere to the pattern of their building blocks.", "description": "This figure compares different pipeline schedules, namely 1F1B, V-Min, V-Half, and V-ZB, under the specific setting of 4 devices and 8 microbatches. It visually represents how these schedules are constructed by repeating basic building blocks.  The \"stable phases\" of the pipeline, where the pattern of the building block repeats consistently, are highlighted.  This visualization helps to understand the memory efficiency and potential bubbles in each pipeline schedule.", "section": "3.2 V-Shape Pipeline Schedules"}, {"figure_path": "Vvcnqs8091/figures/figures_18_3.jpg", "caption": "Figure 5: V-Shape schedules compared to 1F1B, under the setting of 4 devices and 8 microbatches. The stable phases adhere to the pattern of their building blocks.", "description": "This figure compares different pipeline schedules, specifically V-Shape schedules (V-Min, V-Half, and V-ZB) and 1F1B, under a setting of 4 devices and 8 microbatches.  It visually represents the order of forward (F), backward for activations (B), and backward for weights (W) passes for each microbatch across the pipeline stages. The color-coding helps differentiate the phases.  The key takeaway is that the \"stable\" phase of each pipeline (the regularly repeating part) follows the pattern established by its building block. This visual comparison highlights the memory efficiency gains from V-Shape blocks compared to the standard 1F1B approach.", "section": "3.2 V-Shape Pipeline Schedules"}, {"figure_path": "Vvcnqs8091/figures/figures_19_1.jpg", "caption": "Figure 3: V-Shape building blocks with 4 devices (d = 4), where white text colors represent the first half of model stages and black text colors represent the second half. F, B and W represent the forward, backward (for activation gradients) and backward for weight gradients, respectively.", "description": "This figure shows different V-Shape building blocks with 4 devices. Each block is designed to have a balanced memory usage across devices, and it represents a sequence of forward and backward passes for a single microbatch. The white text represents the first half of the model stages, while the black text represents the second half. F, B, and W denote forward, backward (for activation gradients), and backward (for weight gradients), respectively. Each block demonstrates a different strategy for reducing peak activation memory by controlling the offsets between the passes.", "section": "3 Memory Efficient Building Blocks"}, {"figure_path": "Vvcnqs8091/figures/figures_20_1.jpg", "caption": "Figure 1: A pipeline can be built by repeating a building block, and then squeezing redundant bubbles.", "description": "This figure illustrates the concept of building a pipeline by repeating a basic building block.  It shows how a pipeline schedule (a sequence of forward and backward passes) can be constructed by repeating a smaller building block multiple times. The figure also highlights how redundant bubbles (inefficient parts of the pipeline) can be removed through a process called 'squeezing', resulting in a more efficient pipeline. The two examples shown are 1F1B and Eager 1F1B, showcasing different building blocks and the resulting pipelines after squeezing.", "section": "2 How to Build a Pipeline"}]