[{"type": "text", "text": "Pipeline Parallelism with Controllable Memory ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Penghui $\\mathbf{Q}\\mathbf{i}^{*12}$ , Xinyi $\\mathbf{Wan}^{*1}$ , Nyamdavaa Amar\u2020 2, Min Lin1 1Sea AI Lab 2National University of Singapore {qiph,wanxy,linmin}@sea.com amara@u.nus.edu ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Pipeline parallelism has been widely explored, but most existing schedules lack a systematic methodology. In this paper, we propose a framework to decompose pipeline schedules as repeating a building block, and show that the lifespan of the building block decides the peak activation memory of the pipeline schedule. Guided by the observations, we find that almost all existing pipeline schedules, to the best of our knowledge, are memory inefficient. To address this, we introduce a family of memory efficient building blocks with controllable activation memory, which can reduce the peak activation memory to $1/2$ of 1F1B without sacrificing efficiency, and even to 1/3 with comparable throughput. We can also achieve almost zero pipeline bubbles while maintaining the same activation memory as 1F1B. Our evaluations demonstrate that in pure pipeline parallelism settings, our methods outperform 1F1B by from $7\\%$ to $55\\%$ in terms of throughput. When employing a grid search over hybrid parallelism hyperparameters in practical scenarios, our methods demonstrate a $16\\%$ throughput improvement over the 1F1B baseline for large language models. The implementation is open-sourced at this url. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Distributed model training has attracted a lot of attention in recent years, especially after the boom of large language models [Brown et al., 2020]. As the model size becomes larger and larger, data parallelism (DP) [Goyal et al., 2017] is no longer capable to hold all the parameters in a single device. Under this background, model parallelism [Harlap et al., 2018, Huang et al., 2019, Shoeybi et al., 2019, Zheng et al., 2022] is proposed to partition parameters into a set of devices to address the memory constraint. Tensor parallelism (TP) [Shoeybi et al., 2019] is a commonly used model parallel strategy, which partitions weight parameters into several devices and performs matrix multiplication separately. A well-known shortcoming of TP is that, it requires a lot of communication volume, which makes it inefficient when bandwidth becomes the bottleneck Narayanan et al. [2021]. In such situations, pipeline parallelism [Harlap et al., 2018, Huang et al., 2019], which is another model parallel strategy, shows its advantage in low communication cost. The core idea of pipeline parallelism is to split the entire model into several stages, which can be processed by several devices in a streaming way. In a typical large-scale training scenarios such as Narayanan et al. [2021], TP is generally used within one compute node, and PP is used to scale up across nodes. ", "page_idx": 0}, {"type": "text", "text": "Although PP has been widely adopted and developed, it suffers from two prominent disadvantages: pipeline bubbles and large activation memory. To eliminate pipeline bubbles, one line of work focuses on asynchronous PP [Gaunt et al., 2017, Yang et al., 2021], which is theoretically bubble free. However, it sacrifices the exact optimization semantics and may result in lower convergence performance [Lian et al., 2018, Tang et al., 2020]. A parallel line of works revolve around synchronous PP, focusing on reducing pipeline bubbles and/or activation memory. GPipe [Huang et al., 2019] is an early work to reduce the bubble rate by increasing the number of microbatches, at the cost of more activation memory. 1F1B [Fan et al., 2021] avoids the activation memory growth with respect to the number of microbatches by staggering forward pass and backward pass, keeping the same bubble rate with GPipe. Another notable work is GEMS [Jain et al., 2020], which stores activation memory of only one forward pass by scheduling microbatches one after another among two model replicas, thus with a significantly large bubble rate. Chimera [Li and Hoefler, 2021] extends the ideas of GEMS by combining two pipelines in different directions together, which reduces pipeline bubbles when the number of microbatches is small, but with doubled parameter memory. Hanayo [Liu et al., 2023] is introduced to attain the same scheduling efficiency with Chimera without replicated models, but still suffering from scaling to more microbatches. Although its wave-like scheme is kind of similar to our V-shape building blocks, it is not motivated for memory balance, thus resulting in totally different pipeline schedules. In Megatron-LM [Narayanan et al., 2021], an interleaved strategy is proposed to further reduce the bubble rate, at the cost of more communication cost and a portion of extra activation memory. BPipe [Kim et al., 2023] focuses on reducing the activation memory of 1F1B from another perspective, transferring activations across devices based on the memory imbalance of 1F1B. However, it introduces a lot of extra communication and increases the complexity of the system, which makes it inefficient especially in settings with limited bandwidth. Zero Bubble [Qi et al., 2023] splits the backward into activation gradient computation and weight gradient computation, which can either reduce the pipeline bubbles without changing the maximum peak activation memory, or achieve zero bubble at the cost of doubled activation memory compared to 1F1B. ", "page_idx": 0}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "In this paper, we first demonstrate all existing pipelines can be seen as repeating a basic building block in time. We then identify a direct link between the activation memory and the lifespan of each building block, which reveals the core insight of this paper: lifespan decides the activation memory. Based on this insight, we present a family of novel and memory-efficient building blocks and their pipelines. Compared to 1F1B, we reduce the activation memory to 1/2 asymptotically with even higher throughput, and to 1/3 asymptotically with comparable throughput. We can also achieve zero bubble under the same activation memory with 1F1B. Notably, our strategy is almost a pure gain to the existing methods, only at the cost of doubled communication cost between pipeline stages, which is relatively small and can be neglected. ", "page_idx": 1}, {"type": "text", "text": "2 How to Build a Pipeline ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "We propose a four-step framework to design pipeline schedules. ", "page_idx": 1}, {"type": "text", "text": "Building Block: It starts by laying out the passes for a single microbatch, which we call a building block. For example, the building block of 1F1B is made of a sequence of forward passes followed by backward passes in the reverse order. We highlight the building block of 1F1B in color in Figure 1a. ", "page_idx": 1}, {"type": "text", "text": "Repeating: More microbatches are then introduced. The building blocks are repeated and woven together to form a pipeline. In Figure 1 (top), the repeating building blocks are shown in different shades of gray. Notably, legit building blocks are required to repeat without a collision, namely, the passes from two building blocks should not overlap with each other. ", "page_idx": 1}, {"type": "text", "text": "Squeezing: Depending on the building block, there may be redundant bubbles in the pipeline, which can be simply removed by squeezing without changing the order of the passes. For example, Figure 1b shows a case where squeezing produces a more efficient pipeline. ", "page_idx": 1}, {"type": "image", "img_path": "Vvcnqs8091/tmp/b6bf7923ee8e445bf62071a2a1c21e4c30f6adc838f3cc89e1826a7d3800ba1b.jpg", "img_caption": ["Figure 1: A pipeline can be built by repeating a building block, and then squeezing redundant bubbles. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "Reordering (optional): We can reorder the passes in the warm-up and cool-down phase to further improve the computation throughput. Intuitively, the peak of memory happens in the stable phase of the pipeline, while in the warm-up and cool-down phases the RAM is under utilized, leaving some space for improving the computation throughput without changing peak memory. We leave the details in Appendix C. ", "page_idx": 2}, {"type": "text", "text": "Most of existing pipeline schedules can be explained under this framework. Besides the 1F1B and eager 1F1B shown in Figure 1, we show the interleaved 1F1B [Shoeybi et al., 2019], ZB-H1 [Qi et al., 2023] and a series of well-known pipelines in a more extensive gallery (see Appendix I). ", "page_idx": 2}, {"type": "text", "text": "2.1 Building Blocks ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "The computation and memory efficiency of various pipelines can be attributed to their building blocks. The diversity of the building blocks primarily comes from three factors, model partitioning, device placement, and offsets between passes. We follow the idea and notations in zero bubble PP [Qi et al., 2023], using $F$ to denote forward pass, $B$ to denote \u201cbackward for the activations\u201d, and $W$ to denote \u201cbackward for the weights\u201d. Note that such finer granularity can be generalized to previous methods like 1F1B, by always grouping $B$ and $W$ together. ", "page_idx": 2}, {"type": "text", "text": "Model partitioning deals with how the model is divided into pipeline stages. The most common pattern is to equally divide the model to match the number of devices. A prominent example is the 1F1B schedule (Figure 1a). This is extended in interleaved 1F1B where the number of stages can be an integer multiple of the number of devices. ", "page_idx": 2}, {"type": "text", "text": "Device placement is another key factor in the design of building blocks. While conventionally each pipeline stage is sequentially placed on a different device, it is not uncommon to place multiple stages on the same device like in interleaved 1F1B (Figure 18h). Another example of unconventional device placement is Chimera, where two pipelines are placed in reversed device order. ", "page_idx": 2}, {"type": "text", "text": "Last but not least, the offsets between $F{,}B{,}W$ passes play a major role in the computation and memory efficiencies of the pipeline. By simply enlarging the offsets between subsequent $F$ passes in the building block of 1F1B, we obtain the eager 1F1B [Zhuang et al., 2023] (Figure 1b) where more $F$ passes are eagerly scheduled, resulting in higher memory consumption (but better communication overlapping). GPipe can be seen as adding a large offset between the last $F$ and the first $B$ in the 1F1B building block. One more example on the effect of the offset is the comparison of ZB-H1 (Figure 18c) and ZB-H2 (Figure 18d) schedules, one can see that properly chosen offsets result in zero bubble schedules like ZB-H2. In this work, we assume that every $F$ , $B$ or $W$ pass takes equally one unit of computation time, and only consider integer unit of offsets. Although this may limit the number of feasible building blocks, it greatly improves the simplicity of analysis. ", "page_idx": 2}, {"type": "text", "text": "2.2 Calculating the Peak Memory ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Not every pipeline is born equal, researchers are constantly looking for pipelines that are more efficient in computation and/or memory. While efficient pipelines could be discovered by enumerating every possible building block, it is nonetheless prohibitively expensive. We discover that the peak memory consumption of a pipeline can be calculated from its building block via a simple formula. This enables us to design pipelines with a controllable peak memory. ", "page_idx": 2}, {"type": "text", "text": "Two quantities are crucial for the calculation of peak memory, the lifespan of a stage, and the repeating interval of the building blocks, both of which are illustrated in Figure 1. The lifespan of a stage is defined as the amount of time between the starting of the $F$ pass and the ending of $B$ or $W$ pass. A piece of activation memory is allocated at the starting of $F$ , and retained in the RAM throughout the lifespan until it is consumed by both $B$ and $W$ . The peak memory consumption can be calculated by finding the maximum number of microbatches whose lifespans overlap with that of every other microbatch. Using $l$ to denote lifespan, $T$ to denote the repeating interval and $m$ the size of activation memory for a single microbatch, we have the relation. ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\mathrm{peak\\,memory}\\leq\\lceil\\frac{l}{T}\\rceil m\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "When there are multiple stages on one device, e.g. interleaved 1F1B, their contributions to the peak memory are independent, using $S_{i}$ to denote all the stages allocated to device $i$ , we sum the ", "page_idx": 2}, {"type": "text", "text": "contributions from every stage. ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\mathrm{peak\\;memory\\;of\\;device\\;}i\\leq\\sum_{s\\in S_{i}}\\lceil\\frac{l^{s}}{T}\\rceil m^{s}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Another key insight is that the repeating interval $T$ is readily determined from the building block. In an efficient pipeline, $T$ should be equal to the number of units of computation in each stage of the building block. Any $T$ larger than that would cause pipeline bubbles in the stable phase, and $T$ smaller than that would lead to collisions. A subtle exception is the interleaved 1F1B whose repeating interval is not uniform. We leave the discussion to Appendix G. ", "page_idx": 3}, {"type": "text", "text": "2.3 Repeating without Collision ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "One constraint to keep in mind when designing the building blocks is that a legit building block is required to repeat without any collision. It may seem unintuitive how to design building blocks with this constraint. In practice, we design the building block first and perform a post-hoc verification. Another useful observation is that a legit building block usually produces a stable phase in the middle of the pipeline, which contains a repeating $d\\times T$ rectangle, where $d$ is the number of devices and $T$ is the repeating interval. This offers an alternative to constrain the building blocks. We can start by ordering passes within this rectangle and convert it back to a building block. ", "page_idx": 3}, {"type": "text", "text": "3 Memory Efficient Building Blocks ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "With the above framework, we can conveniently analyze the memory consumption pattern of existing pipelines. To our knowledge, all existing pipelines are memory inefficient due to two primary reasons: redundant dependency chain, and imbalanced memory usage. Before Zero Bubble [Qi et al., 2023], the backward is often regarded as a single pass, resulting in unnecessarily longer lifespan thus more memory footprint. In this paper, we leverage the backward splitting strategy to remove these redundant lifespan. The imbalanced memory comes from the innate heterogeneity of the lifespans across stages. From Figure 1a, we can easily see that the lifespan of the stages differs greatly from each other, with the first stage having the longest lifespan. Consequently, it causes a memory bottleneck on the first device and under utilization of memory on all other devices. To resolve this problem, we introduce a family of novel building blocks, which we refer to as V-Shape building blocks. The core insight comes from Equation 1 which says that the peak memory depends on the sum of the lifespans. Therefore, when we place multiple stages on the same device, we should always collocate stages of long lifespans with those of short lifespans. When the total sum of lifespans is fixed, balanced placement always means higher memory efficiency. This can be demonstrated by Figure 2, the parallel schedule (used in interleaved 1F1B) is imbalanced and has a memory bottleneck proportional to $l_{1}+l_{4}$ , while in the V-Shape schedule it is $l_{1}+l_{6}$ . ", "page_idx": 3}, {"type": "text", "text": "The V-Shape schedule requests the model to be partitioned into stages twice the number of devices and the device placement of the second half of stages to be in reverse order as the first half. As the offsets directly determine the lifespan of each stage and therefore the peak memory by Equation 1, we can then further control the offsets between passes to generate building blocks with diverse memory. ", "page_idx": 3}, {"type": "image", "img_path": "Vvcnqs8091/tmp/bae9fef2064f22a2207338ba70a4a9a771d9ba6970515e8d4d775136ab6d492c.jpg", "img_caption": ["Figure 2: The V-Shape building block ensures balanced peak memory across all devices, whereas the parallel building block has a memory bottleneck in the first device. "], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "3.1 Controllable Balanced Memory ", "text_level": 1, "page_idx": 3}, {"type": "text", "text": "We assume the model is uniformly partitioned, namely, both the computation and memory of each stage are identical. For a single microbatch, we denote the activation memory of each stage as $m$ , and the total activation memory of the entire model as $M$ . Note that $M=2d m$ , where $d$ is the number of devices. To make it simple and tractable, we use uniform offsets within each half of $\\pmb{F}$ and $\\textbf{\\emph{B}}$ passes to control the peak memory. Specifically, we apply the same offset $\\delta_{F}^{0}$ between two adjacent $F$ passes within the first $d$ stages (e.g., $\\delta_{F}^{0}=\\dot{2}$ in Figure 3b, $\\delta_{F}^{0}=1$ in Figure 3c and $\\delta_{F}^{0}\\,\\stackrel{=}{=}4$ in Figure 3d). Similar constraints are applied to the other half of the $F$ passes and both halves of the $B$ passes, denoted as $\\delta_{F}^{1},\\delta_{B}^{0},\\delta_{B}^{1}$ , respectively. To guarantee balanced peak memory across devices, we add another two constraints, $\\delta_{F}^{0}=\\delta_{B}^{1}=\\delta^{0}$ and $\\delta_{F}^{1}=\\delta_{B}^{0}=\\delta^{1}$ , where we use notations $\\delta^{0}$ and $\\delta^{1}$ for simplicity. For example, in Figure 3d, we set $\\delta^{0}=4$ and $\\delta^{1}=2$ . Note that we only control the offsets across different devices. For those adjacent passes within the same device (e.g., $F$ and $B$ of the last stage, two $F$ and two $B$ in the last device), we use brute force to find optimal solutions, ensuring their offsets are small (less than the repeating interval). Note that $W$ can always be placed greedily after settling all $F$ and $B$ passes, so we don\u2019t need to search their offsets during brute force. According to Equation 1, we can analyze the asymptotic peak memory with respect to $d$ , ", "page_idx": 3}, {"type": "image", "img_path": "Vvcnqs8091/tmp/4082a8b63f464a7d72af9b25d2f8b35df83ab4f18bf826e2803c774c68d53ee4.jpg", "img_caption": ["Figure 3: V-Shape building blocks with 4 devices $[d=4,$ ), where white text colors represent the first half of model stages and black text colors represent the second half. $F,B$ and $W$ represent the forward, backward (for activation gradients) and backward for weight gradients, respectively. "], "img_footnote": [], "page_idx": 4}, {"type": "image", "img_path": "Vvcnqs8091/tmp/df6eb21a53d5d3efefc7084f57f15e8d2d91ba31857a01c966951607a07dbcc0.jpg", "img_caption": ["Figure 4: V-Shape schedules compared to 1F1B, under the setting of 4 devices and 8 microbatches. The stable phases adhere to the pattern of their building blocks. "], "img_footnote": [], "page_idx": 4}, {"type": "text", "text": "", "page_idx": 4}, {"type": "text", "text": "", "page_idx": 5}, {"type": "equation", "text": "$$\ni\\leq\\frac{2d(\\delta^{0}+\\delta^{1})+O(1)}{6}m\\approx\\frac{\\delta^{0}+\\delta^{1}}{6}M\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "By ignoring the small constant, we can directly control the peak memory by the value of $\\delta^{0}$ and $\\delta^{1}$ . ", "page_idx": 5}, {"type": "text", "text": "Table 1: Small constant values are ignored for bubbles and peak memory of V-Min and V-Half. For 1F1B, $\\delta^{0}/\\delta^{1}$ are redefined as the offsets between adjacent forward/backward passes. $M$ represents the total activation memory of the entire model, and $d$ is the number of devices. ", "page_idx": 5}, {"type": "table", "img_path": "Vvcnqs8091/tmp/64ad297a74ff7b2134d588579cf811009d09482837659b1a048c41075832d162.jpg", "table_caption": [], "table_footnote": [], "page_idx": 5}, {"type": "text", "text": "3.2 V-Shape Pipeline Schedules ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "By varying the values of $\\delta^{0}$ and $\\delta^{1}$ , we come up with 3 novel V-Shape building blocks (Figure 3), and present their final schedules based on our framework in Figure 4. The building block of $V{-}M i n$ (Figure 3c) has the minimum offsets, namely $\\delta^{0}=\\delta^{1}=1$ , thus the minimum memory consumption. With $\\delta^{0}=4$ and $\\delta^{1}=2$ as in Figure 3d, $V{-}Z B$ eliminates the bubble to almost 0 (Figure 4d), pushing to extreme throughput. The building block of $V\\!\\cdot$ -Half (Figure 3b), which uses $\\delta^{0}=2$ and $\\bar{\\delta}^{1}=\\bar{1}$ , sits between the two extremes and consumes about half of the activation memory required by 1F1B. Although both V-Min and V-Half have lower memory footprint than 1F1B, V-Min contains about 2/3 and $V.$ -Half contains about $1/2$ of 1F1B\u2019s bubbles, assuming $F$ , B, W have equal run time. We show the comparison between our proposed V-Shape schedules and 1F1B in Table 1. Notably, the exact peak memory is \u2308d3+2 \u2309Md for $V\\!\\!-\\!\\!M i n$ , and $\\lceil\\frac{d\\bar{+}1}{2}\\rceil\\frac{M}{d}$ for V-Half. To avoid collisions in the building blocks of $V{\\mathrm{.}}$ Min and V-Half, the offsets (within the same device) are slightly different for different values of $d$ . The details are in Appendix F. ", "page_idx": 5}, {"type": "text", "text": "3.3 Repeating Bubbles in V-Min ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "In real-world scenarios where $F,B$ and $W$ have different run times, V-Min suffers from a repeating bubble. As shown in Figure 5, there exists bubbles for every repeating interval $T$ . Consequently, the bubble grows as the number of microbatches increases. Although V-Half may encounter the same issue (when the times of $F,B$ and $W$ differ significantly), it generates patterns that tessellate well in most empirical cases due to its loose dependencies. As illustrated in Figure 5b, the throughput of V-Half is robust to the variation of run times. Additionally, the bubbles of V-ZB will never grow when increasing the number of microbatches. We leave the related discussions in Appendix E. ", "page_idx": 5}, {"type": "image", "img_path": "Vvcnqs8091/tmp/d14a047d662a08a84a9a0ec303061eff1749698c6f079f08fdf280a0795de413.jpg", "img_caption": ["Figure 5: We take a repeating $d\\times T$ grid from V-Min and V-Half schedules, and assign F/B/W with different values. The result shows V-Min has bubbles for every repeating grid, while V-Half does not. "], "img_footnote": [], "page_idx": 5}, {"type": "text", "text": "3.4 Other Building Blocks ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Besides V-Shape building blocks, we also propose some other interesting building blocks in Appendix H, to show the generalization ability of our framework. Some useful examples include a) 1F1B-V achieving 2/3 of 1F1B\u2019s activation memory without doing B-W split; b) a schedule consumes less memory than interleaved 1F1B but with the same bubble rate (Figure 17c). Additionally, we design an adaptive scheduler to control the memory at a finer granularity in Appendix A. ", "page_idx": 6}, {"type": "text", "text": "4 Experiments ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We construct our experiments to show three conclusions: a) The throughput and memory of V-Min, V-Half and V-ZB aligns with the theoretical analysis in Section 3.2; b) Memory-saving methods including V-Min and V-Half can bring accelerations; c) Our methods still perform best when combining with other state-of-the-art techniques. ", "page_idx": 6}, {"type": "text", "text": "4.1 Setup", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "We evaluate our methods using a series of models detailed in Table 2 analogous to GPT-3 [Brown et al., 2020]. Our implementation is based on the open-source Megatron-LM project [Narayanan et al., 2021] and is experimented on up to 40 NVIDIA A100 SXM 80G GPUs distributed across 5 nodes interconnected by a RoCE RDMA network. The running time of each iteration is recorded after several warm-up iterations. Similar to the settings in [Qi et al., 2023], we deduct one transformer layer from both the initial and final pipeline stage to compensate for the embedding and output layer in LM, which can otherwise become the bottleneck of the pipeline and interfere to the efficiency. ", "page_idx": 6}, {"type": "table", "img_path": "Vvcnqs8091/tmp/3cff6eab619cc85d7da34d205cd37e3fef82ba1d585e5e6c21206577b9ebb98e.jpg", "table_caption": ["Table 2: Models used in experiments. "], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "Our experiments majorly focuses on the following pipeline parallel schedules: a) V-Min, V-Half and V-ZB: schedules introduced in Section 3.2; b) 1F1B and Interleaved 1F1B: methods implemented in Megatron-LM; c) 1F1B-R: 1F1B with full activation rematerialization [Chen et al., 2016]; d) ZB-1P and ZB-2P: the adaptive zero-bubble methods introduced in [Qi et al., 2023] with activation memory limit set to the $1\\mathbf{x}/2\\mathbf{x}$ times of 1F1B. ", "page_idx": 6}, {"type": "image", "img_path": "Vvcnqs8091/tmp/ac90f7469f3e39118f759f1afe8cb462667bd461d6ac1720c3405d25f7376f2a.jpg", "img_caption": ["Figure 6: Throughput and activation memory using the same microbatch size. "], "img_footnote": [], "page_idx": 6}, {"type": "text", "text": "4.2 Comparing Pipeline Schedules ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "In Figure 6, we present comparisons of the throughput measured in FLOPS utilization (MFU) and activation memory consumption across different pipeline schedules under various settings. From the results, V-ZB outperforms all other methods in terms of throughput, which aligns with Figure 4. When comparing the activation memory consumption, V-Min and V-Half stand out by significantly reducing activation memory to approximately 1/3 and 1/2, while other methods\u2019 memory is similar except for 1F1B-R. More details of our experiments and definition of metrics can be found in Appendix D.1. ", "page_idx": 7}, {"type": "text", "text": "Notably V-Min has a comparable throughput against 1F1B, but its throughput falls behind 1F1B at a larger number of microbatches due to the aforementioned repeating bubble in Figure 5a, as discussed in Section 3.3. However, it still outperforms 1F1B with full activation rematerialization, providing a strong alternative for saving memory. ", "page_idx": 7}, {"type": "image", "img_path": "Vvcnqs8091/tmp/d85efcbaa177cfd7a91513acb04e12ab42b665383360cdd3104bcc41e375cce0.jpg", "img_caption": ["Figure 7: Pareto frontier of MFU and memory for various setups. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "We also plot both memory and MFU for the various methods in Figure 7 in a typical, but slightly different setting in which we reduced the microbatch size of 9.6B and 21B model to allow ZB-2P and Interleaved 1F1B to run which would otherwise run out of memory (OOM). It shows that the V-Shape pipeline schedules lie at the Pareto frontier. ", "page_idx": 7}, {"type": "text", "text": "4.3 When to Save Memory ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "While V-ZB provides optimal throughput, V-Half and V-Min methods are mainly used when memory budget is tight. Conventionally, rematerialization is used when it runs out of memory (OOM). However, rematerialization leads to repeated computation and consequently decrease the throughput. V-Half and V-Min significantly outperforms rematerialization (1F1B-R) as we show in Table 7. ", "page_idx": 7}, {"type": "image", "img_path": "Vvcnqs8091/tmp/d1d0219ca661ee39b4d99ada2bfb37f5576c27c56dc9c0d10a9a5f0ed71dc1bc.jpg", "img_caption": ["Figure 8: Throughput and activation memory under similar memory limit. "], "img_footnote": [], "page_idx": 7}, {"type": "text", "text": "Another benefit of saving memory is that we can potentially use the extra memory for an increased microbatch size, which leads to a higher arithmetic intensity. We present the results in Figure ", "page_idx": 7}, {"type": "text", "text": "8. On bigger models, where memory pressure is higher and hence microbatch size is smaller, $V_{\\l}$ Half schedule can surpass V-ZB and other baselines because of its arithmetic intensity gain. This observation does not apply for V-Min, implying its arithmetic intensity gain can not compensate for the increased bubble. Doubling/Tripling the microbatch size for V-Half/V-Min results in a slightly higher activation memory than the other methods. This reflects the constant factors we ignored in Section 3.2. The increase is less significant as the number of devices grows. ", "page_idx": 8}, {"type": "text", "text": "4.4 Combining with Existing Techniques ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "We present our methods in the context of LLM training together with various other techniques. The following techniques are considered: a) Flash Attention [Dao et al., 2022, Dao, 2023]; b) Tensor Parallelism [Narayanan et al., 2021] and Sequence Parallelism [Korthikanti et al., 2023]; c) Distributed Optimizer provided in Megatron-LM. The implementations are all from Megatron-LM [Narayanan et al., 2021]. Both our methods and the baseline methods are combined with the above techniques. Similar to the evaluation method in Kim et al. [2023], we perform a grid search on the following parameters: the size of PP; the size of TP; the size of DP; the microbatch size $(m b s)$ . We use 40 GPUs in this experiment. For each method, the best result from the grid search is reported. ", "page_idx": 8}, {"type": "text", "text": "We present the best result for each pipeline parallel schedule in Table 3 and the corresponding parameters. We find that when sequence length is smaller and hence the memory budget is more abundant, V-ZB performs the best due to the elimination of bubbles. When we increase the memory pressure by increasing the sequence length, V-Half performs the best because of its memory efficiency. The detailed data and analysis of grid search can be found in the Appendix D.3 D.4. ", "page_idx": 8}, {"type": "table", "img_path": "Vvcnqs8091/tmp/67ad5590b84702f5887198e9109af7ef84fc5f5fd9bbc51e1723c27c79ac3e24.jpg", "table_caption": ["Table 3: V-Shape schedules combined with other memory saving methods. "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "5 Conclusion And Future Work ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "In this work, we present a framework that constructs pipeline schedules by focusing on their repeating building blocks. This framework enables direct computation of peak memory from the lifespan of the building block. Based on this capability, we design a family of memory-efficient building blocks. We discuss three representative methods from this family, namely V-Min, V-Half and V-ZB, and demonstrate with experiments that our methods advance the Pareto frontier of throughput and memory in large model training. Furthermore, our methodology of designing pipeline schedules through building blocks may inspire the research community to explore more novel pipeline schedules. Notice that repeating a building block is not the only way of building a pipeline, other methods like greedy search could generate a pipeline that has no repeating patterns. ", "page_idx": 8}, {"type": "text", "text": "In the future, we plan to further explore more memory efficient pipeline schedules based on our framework. A major limitation of V-Min is that, it suffers from growing bubbles when increasing the number of microbatches. Although V-Half mitigates this issue, there is still a space to further reduce the memory consumption. Using continuous offsets or finer-granularity discretization is a possible way to solve it. We leave it in our future work. ", "page_idx": 9}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language models are few-shot learners. Advances in neural information processing systems, 33:1877\u20131901, 2020. ", "page_idx": 9}, {"type": "text", "text": "Tianqi Chen, Bing Xu, Chiyuan Zhang, and Carlos Guestrin. Training deep nets with sublinear memory cost. arXiv preprint arXiv:1604.06174, 2016.   \nTri Dao. Flashattention-2: Faster attention with better parallelism and work partitioning. arXiv preprint arXiv:2307.08691, 2023.   \nTri Dao, Dan Fu, Stefano Ermon, Atri Rudra, and Christopher R\u00e9. Flashattention: Fast and memoryefficient exact attention with io-awareness. Advances in Neural Information Processing Systems, 35:16344\u201316359, 2022.   \nShiqing Fan, Yi Rong, Chen Meng, Zongyan Cao, Siyu Wang, Zhen Zheng, Chuan Wu, Guoping Long, Jun Yang, Lixue Xia, et al. Dapple: A pipelined data parallel approach for training large models. In Proceedings of the 26th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, pages 431\u2013445, 2021.   \nAlexander L Gaunt, Matthew A Johnson, Maik Riechert, Daniel Tarlow, Ryota Tomioka, Dimitrios Vytiniotis, and Sam Webster. Ampnet: Asynchronous model-parallel training for dynamic neural networks. arXiv preprint arXiv:1705.09786, 2017.   \nPriya Goyal, Piotr Doll\u00e1r, Ross Girshick, Pieter Noordhuis, Lukasz Wesolowski, Aapo Kyrola, Andrew Tulloch, Yangqing Jia, and Kaiming He. Accurate, large minibatch sgd: Training imagenet in 1 hour. arXiv preprint arXiv:1706.02677, 2017.   \nAaron Harlap, Deepak Narayanan, Amar Phanishayee, Vivek Seshadri, Nikhil Devanur, Greg Ganger, and Phil Gibbons. Pipedream: Fast and efficient pipeline parallel dnn training. arXiv preprint arXiv:1806.03377, 2018.   \nYanping Huang, Youlong Cheng, Ankur Bapna, Orhan Firat, Dehao Chen, Mia Chen, HyoukJoong Lee, Jiquan Ngiam, Quoc V Le, Yonghui Wu, et al. Gpipe: Efficient training of giant neural networks using pipeline parallelism. Advances in neural information processing systems, 32, 2019.   \nArpan Jain, Ammar Ahmad Awan, Asmaa M Aljuhani, Jahanzeb Maqbool Hashmi, Quentin G Anthony, Hari Subramoni, Dhableswar K Panda, Raghu Machiraju, and Anil Parwani. Gems: Gpu-enabled memory-aware model-parallelism system for distributed dnn training. In SC20: International Conference for High Performance Computing, Networking, Storage and Analysis, pages 1\u201315. IEEE, 2020.   \nTaebum Kim, Hyoungjoo Kim, Gyeong-In Yu, and Byung-Gon Chun. Bpipe: Memory-balanced pipeline parallelism for training large language models. In International Conference on Machine Learning, pages 16639\u201316653. PMLR, 2023.   \nVijay Anand Korthikanti, Jared Casper, Sangkug Lym, Lawrence McAfee, Michael Andersch, Mohammad Shoeybi, and Bryan Catanzaro. Reducing activation recomputation in large transformer models. Proceedings of Machine Learning and Systems, 5, 2023.   \nShigang Li and Torsten Hoefler. Chimera: efficiently training large-scale neural networks with bidirectional pipelines. In Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis, pages 1\u201314, 2021.   \nXiangru Lian, Wei Zhang, Ce Zhang, and Ji Liu. Asynchronous decentralized parallel stochastic gradient descent. In International Conference on Machine Learning, pages 3043\u20133052. PMLR, 2018.   \nZiming Liu, Shenggan Cheng, Hao Zhou, and Yang You. Hanayo: Harnessing wave-like pipeline parallelism for enhanced large model training efficiency. The International Conference for High Performance Computing, Networking, Storage, and Analysis, pages 1\u201313, 2023. URL https: //api.semanticscholar.org/CorpusID:261339639.   \nDeepak Narayanan, Mohammad Shoeybi, Jared Casper, Patrick LeGresley, Mostofa Patwary, Vijay Korthikanti, Dmitri Vainbrand, Prethvi Kashinkunti, Julie Bernauer, Bryan Catanzaro, et al. Efficient large-scale language model training on gpu clusters using megatron-lm. In Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis, pages 1\u201315, 2021.   \nPenghui Qi, Xinyi Wan, Guangxing Huang, and Min Lin. Zero bubble pipeline parallelism. In The Twelfth International Conference on Learning Representations, 2023.   \nMohammad Shoeybi, Mostofa Patwary, Raul Puri, Patrick LeGresley, Jared Casper, and Bryan Catanzaro. Megatron-lm: Training multi-billion parameter language models using model parallelism. arXiv preprint arXiv:1909.08053, 2019.   \nZhenheng Tang, Shaohuai Shi, Wei Wang, Bo Li, and Xiaowen Chu. Communication-efficient distributed deep learning: A comprehensive survey. arXiv preprint arXiv:2003.06307, 2020.   \nBowen Yang, Jian Zhang, Jonathan Li, Christopher R\u00e9, Christopher Aberger, and Christopher De Sa. Pipemare: Asynchronous pipeline parallel dnn training. Proceedings of Machine Learning and Systems, 3:269\u2013296, 2021.   \nLianmin Zheng, Zhuohan Li, Hao Zhang, Yonghao Zhuang, Zhifeng Chen, Yanping Huang, Yida Wang, Yuanzhong Xu, Danyang Zhuo, Eric P Xing, et al. Alpa: Automating inter-and {IntraOperator} parallelism for distributed deep learning. In 16th USENIX Symposium on Operating Systems Design and Implementation (OSDI 22), pages 559\u2013578, 2022.   \nYonghao Zhuang, Lianmin Zheng, Zhuohan Li, Eric Xing, Qirong Ho, Joseph Gonzalez, Ion Stoica, Hao Zhang, and Hexu Zhao. On optimizing the communication of model parallelism. Proceedings of Machine Learning and Systems, 5, 2023. ", "page_idx": 9}, {"type": "text", "text": "", "page_idx": 10}, {"type": "text", "text": "A Adaptive Scheduler Based on Search ", "text_level": 1, "page_idx": 11}, {"type": "text", "text": "Now we consider more general scenarios, where we want to minimize the bubbles given an activation memory limit. A straightforward approach should be simply searching over all possible offsets and picking the one with minimal bubbles. However, this naive method cannot work well due to there are exponentially many possible offsets, which makes it intractable to iterate thoroughly. In this section, we propose a more practical searching method to solve this general problem. ", "page_idx": 11}, {"type": "text", "text": "We use superscript $c\\in\\{0,1\\}$ to denote which stage in a device, and use subscript $i\\in\\{1,2,...,d\\}$ to denote the index of the device. For example, $F_{i}^{c}$ represent the forward pass of stage $c d+i$ in the $i$ -th device. We define the offset from $u$ to $v$ as $\\bar{\\delta}(u,v)=t(v)-t(u)$ , where $t(v)$ represent the cell index along time horizon of pass $v$ . To simplify the notations, we define $\\delta F_{i}^{0}=\\delta\\bar{(}F_{i}^{0},F_{i+1}^{0})$ , $\\delta F_{i}^{1}=\\delta(F_{i}^{1},F_{i-1}^{1})$ , $\\delta B_{i}^{1}=\\delta(B_{i}^{1},B_{i+1}^{1})$ and $\\delta B_{i}^{0}=\\delta(B_{i}^{0},B_{i-1}^{0})$ , to denote the offset from a pass to its next pass. ", "page_idx": 11}, {"type": "text", "text": "Instead of all possible offsets, we limit our search space to uniform offsets across devices. We also try to ensure each device has a balanced peak memory. Note that for the uniform offsets introduced in Section 3.1, the peak memory only falls into a small discrete set $\\{\\frac{k}{6}M\\}$ , where $k$ is an integer). To make it work for a finer granularity of memory controlling, we split the repeating module into two parts, containing the first $K$ rows and the last $d-K$ rows respectively. More formally, we use the constraint as follows. ", "page_idx": 11}, {"type": "equation", "text": "$$\n\\begin{array}{r l r l r}&{\\delta F_{i}^{0}=\\delta B_{i}^{1}=\\delta_{<K}^{0},\\forall1\\leq i<K}&&{\\delta F_{i}^{1}=\\delta B_{i}^{0}=\\delta_{\\leq K}^{1},\\forall1<i\\leq K}\\\\ &{\\delta F_{i}^{0}=\\delta B_{i}^{1}=\\delta_{\\geq K}^{0},\\forall K\\leq i<d}&&{\\delta F_{i}^{1}=\\delta B_{i}^{0}=\\delta_{>K}^{1},\\forall K<i\\leq d}\\end{array}\n$$", "text_format": "latex", "page_idx": 11}, {"type": "text", "text": "Note that the above constraints have good properties that the peak memory is balanced across devices. As we can always greedily fill $W_{i}^{0}$ and $\\overline{{W_{i}^{1}}}$ when repeating, we only need to search over the permutation of the first device, the values of $\\delta_{<K}^{0^{^{\\prime}}},\\delta_{\\leq K}^{1},\\delta_{\\geq K}^{\\bar{0}},\\delta_{>K}^{\\bar{1}^{^{\\prime}}}$ and $K$ . The computational complexity is $O(d)$ if we regard repeating interval as a constant. ", "page_idx": 11}, {"type": "text", "text": "For each building block searched, we repeat the building block, check collision, do squeezing and reordering as mentioned in 2.1. After searching over all possible building blocks, we pick the schedule with minimal bubbles. Note that we can use the true run times of $F,B$ and $W$ to calculate the bubbles, which will lead to more efficient schedule in real cases. ", "page_idx": 11}, {"type": "text", "text": "B Evaluation of Adaptive Scheduler ", "text_level": 1, "page_idx": 11}, {"type": "text", "text": "In Figure 9 we plot the bubble rate of adaptive V-Shape schedulers introduced in A under various settings and different memory limit. The run times of $F$ , $B$ and $W$ are from profiled real cases, as in Table 5. We observe that the bubble rate drops as memory limit increases. Notably, there\u2019s a sudden drop in bubble rate when the memory limit just goes above approximately 1/2 of 1F1B, at which point the repeating bubble mentioned in Figure 5a disappears. ", "page_idx": 11}, {"type": "image", "img_path": "Vvcnqs8091/tmp/4ddc2bca95fd0547e1d544f0070a900787e387d5028ba9ae5f4ae11e8330597a.jpg", "img_caption": ["Figure 9: Bubble rate of $\\mathrm{v}$ scheduler under various settings. "], "img_footnote": [], "page_idx": 11}, {"type": "text", "text": "We also compare V scheduler with the adaptive zero bubble scheduler proposed in [Qi et al., 2023] in Figure 10. We find that $\\mathrm{v}$ scheduler has a boarder range of memory configurations and a smaller bubble rate compared to zero bubble scheduler. We also draw the bubble rate of 1F1B as a reference, though 1F1B does not support a configurable memory. ", "page_idx": 11}, {"type": "image", "img_path": "Vvcnqs8091/tmp/f515383b90752ff22f47a1e846394940289deb2eab0f43269abbfbce0e159c16.jpg", "img_caption": ["Figure 10: Comparison of V scheduler and zero bubble scheduler. "], "img_footnote": [], "page_idx": 12}, {"type": "text", "text": "C Reordering ", "text_level": 1, "page_idx": 12}, {"type": "text", "text": "In our framework, we may need to reorder the warm-up and cool-down phase after squeezing. Basically, we employ simple greedy approaches to handle the reordering for warm-up and cool-down, and illustrate how zero bubble schedule is reordered in Figure 11. ", "page_idx": 12}, {"type": "image", "img_path": "Vvcnqs8091/tmp/6a1c72faaaeba44f4f9a3a353b3f95c7a822ff203635964a463d04ca00d67107.jpg", "img_caption": ["Figure 11: Top: the schedule after Squeezing. Bottom: the schedule after Reordering. "], "img_footnote": [], "page_idx": 12}, {"type": "text", "text": "Warm-up In warm-up phase, bubbles mainly happen before the first $B$ . We iterate all the cells from left to right. If a vacant cell (which means a bubble) is encountered, we try to find a computation pass to flil this bubble. We iterate all the following computation passes in the same device, and check whether it is possible to move if we keep all other passes unchanged. If the check succeeds, we move it to the vacant cell, and the bubble is filled. ", "page_idx": 12}, {"type": "text", "text": "Cool-down In cool-down phase, W can be scheduled at any time after its corresponding $B$ . So we utilize a heuristic way to handle the bubbles. Firstly, we delete all the $W$ passes in cool-down phase. Next, we squeeze the schedule to remove the bubbles caused by deleting W. After that, we use $W$ to flil the remaining bubbles, ensuring each W is after its corresponding $B$ . Finally, we schedule all the remaining W passes at the end. ", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "Despite its simplicity, the above heuristics is general and effective. However, it may not achieve the best performance in some cases. We also design other greedy or constructive methods as a complement for some building blocks. We will release all the related code in our repository. ", "page_idx": 13}, {"type": "text", "text": "D Detailed Experiment Data ", "text_level": 1, "page_idx": 13}, {"type": "table", "img_path": "Vvcnqs8091/tmp/37454b13acaf33444b63b0c3957942ed0fef5c7f37627eb47fd0597f86ac5cf2.jpg", "table_caption": ["Table 4: Comparing Pipeline Schedules "], "table_footnote": [], "page_idx": 13}, {"type": "text", "text": "D.1 Comparing Pipeline Schedules ", "text_level": 1, "page_idx": 13}, {"type": "text", "text": "For Section 4.2, we present our detailed experiment data in Table 4. Specifically, the metrics are defined as: ", "page_idx": 13}, {"type": "text", "text": "\u2022 MFU: The FLOPS utilization of the training system. The calculation of FLOPS of a model is following [Narayanan et al., 2021]. ", "page_idx": 13}, {"type": "text", "text": "\u2022 Peak Memory: The maximum peak memory cross all devices. ", "page_idx": 13}, {"type": "text", "text": "\u2022 Activation Memory: Estimated as deducting the iteration-start memory from peak memory on each device. The number presented is the maximum activation memory cross all devices. \u2022 Bubble Rate: The theoretical bubble rate reported by scheduler, using profiled run times of $F$ , $B$ and $W$ at starting iterations. ", "page_idx": 14}, {"type": "text", "text": "D.2 Single-pass MFU Gain When Increasing Microbatch Size ", "text_level": 1, "page_idx": 14}, {"type": "text", "text": "To evaluate how increasing microbatch size increases the arithmetic intensity, we proflie the run time of each single F/B/W pass and calculate their single-pass MFU. We list the results in Table 5. It shows that whether there are significant MFU gain depends on both the model and the microbatch size. ", "page_idx": 14}, {"type": "table", "img_path": "Vvcnqs8091/tmp/aa524dfaf6bc2923e90dd70689d8368b3b778ab23704aa5a79e2a64ae993d543.jpg", "table_caption": ["Table 5: Single-pass MFU gain when increasing microbatch size "], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "D.3 More Details on Grid Search ", "text_level": 1, "page_idx": 14}, {"type": "table", "img_path": "Vvcnqs8091/tmp/c0159c540ad934967b0f5aa6e7b4eb8406c8c06ea0e0989522ee97e7e7ac8506.jpg", "table_caption": ["Table 6: MFU of grid search, with SequenceLength $\\l=1024$ and $B a t c h S i z e=160$ "], "table_footnote": [], "page_idx": 14}, {"type": "text", "text": "We show the MFU of every setup of our grid search in Table 6, 7 and 8 for three groups of experiments: one with SequenceLengt $h=1024$ and $B a t c h S i z e=160$ , one with SequenceLengt $h=3072$ and $B a t c h S i z e=640$ and the other with SequenceLength $\\mathrm{,=16384}$ and $B a t c h S i z e=160.\\$ . ", "page_idx": 14}, {"type": "text", "text": "For the first experiment group, the best setup is $V{-}Z B$ under pure PP because of its bubble elimination. For the second setup, the best setup is $V{\\mathrm{.}}$ -Half because its memory efficiency enables a lower TP ", "page_idx": 14}, {"type": "text", "text": "degree, which is otherwise impossible for V-ZB/ZB-1P/1F1B. For the last setup, due to high memory pressure only V-Min and V-Half can run without checkpointing. A comparison of TP and PP can be found at D.4. ", "page_idx": 15}, {"type": "table", "img_path": "Vvcnqs8091/tmp/7045b7c8e69a00001c47dfb44de7afa536c4abf2325b1c3d01a402c68eaae9d6.jpg", "table_caption": ["Table 7: MFU of grid search, with SequenceLength $\\mathrm{:=3072}$ and $B a t c h S i z e=640$ "], "table_footnote": [], "page_idx": 15}, {"type": "table", "img_path": "Vvcnqs8091/tmp/7ef256ca7c185f0d005e272d893c421c456d272a1d216ce7262eb197a48b8f07.jpg", "table_caption": ["Table 8: MFU of grid search, with SequenceLengt $h=16384$ and $B a t c h S i z e=160$ "], "table_footnote": [], "page_idx": 15}, {"type": "text", "text": "D.4 Model Parallelism: More PP or More TP? ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Our grid search results in Appendix D.3 show a strong favor of Pipeline Parallel (PP) over Tensor Parallel (TP), which might contradict with some existing industry experience where more degree of TP usually accelerates training. To understand the reason, we briefly compare TP and PP in this section. ", "page_idx": 15}, {"type": "text", "text": "Though PP also equally partition the model into $p$ PP shards, it usually needs to cache the activations for $\\Theta(p)$ microbatches, resulting in the total activation memory demand same as the unpartitioned. On the other hand, TP, when used with sequence parallelism [Korthikanti et al., 2023], partitions most activation memory equally to $t$ TP shards, which is one of the most significant benefit of TP over PP. However, this comes at the cost of a collective communication and reducing the size of hidden dimension to $\\frac{1}{t}$ , which can significantly decrease the single-pass (F/B/W) MFU. Though one can argue that the saved memory can be used to increase the microbatch size, our experiment measuring the MFU under different TP setups (Figure 12) demonstrates that a higher-degree of TP even with larger microbatch size still suffers from lower single-pass MFU. ", "page_idx": 15}, {"type": "image", "img_path": "Vvcnqs8091/tmp/7b090bc5a51f9e2d953685c584b8fbb3a08a4d21fb41a9724a11e622db416f23.jpg", "img_caption": ["Figure 12: Average single-pass MFU (over FBW) for grid search under different TP degrees. "], "img_footnote": [], "page_idx": 16}, {"type": "text", "text": "The throughput of PP also decreases as PP degree increases for two major reasons: a) for PP schedules with a fixed global batch size, a higher PP degree usually results in higher pipeline bubbles. For example, 1F1B has a bubble rate o fp+pn\u22121\u22121, which would increase if p grows and n keeps unchanged; b) the first and last pipeline stage for a language model usually have an embedding or output layer which has innegligible additional computations, making the pipeline unbalanced and hurting the efficiency. With higher PP degree, the unbalance would be aggravated. However, theses two issues can be mitigated. For the first issue, a larger number of microbatches or using V-ZB can significantly reduce the pipeline bubble. For the second issue, we can use another standalone stage to handle the embedding or output layer instead to avoid bottleneck. In our experiments, we simply deduct 1 layer from both the first and last pipeline stage to mitigate this problem. As a result, our methods essentially push the preference from TP to PP. ", "page_idx": 16}, {"type": "text", "text": "E Bubble Analysis ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Although we mainly focus on the memory efficiency in this paper, we also need to take care of the bubbles in pipeline parallelism. Typically, there is a trade-off between memory and bubble, where allowing more memory usage can reduce the bubble of a pipeline schedule. In this section, we will discuss how to identify whether the bubble of a schedule will grow with respect to the number of microbatches. Additionally, we illustrate an empirical lower bound of bubble in our methods. We follow the notation in Section 3.1 and Appendix A in this section. ", "page_idx": 16}, {"type": "text", "text": "E.1 Existence of Repeating Bubbles ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "In pipeline parallelism, we usually expect there is no repeating bubbles introduced in Section 3.3, namely, the bubble is only related to the number of pipeline devices $(d)$ , and won\u2019t grow when increasing the number of microbatches $(n)$ . This property guarantees a good scalability with respect to $n$ . We say a pipeline schedule is with $O(d)$ bubble if it satisfies this property, otherwise with $\\bar{O}(n)$ bubble. Note that the conclusion is based on the values of $T_{F},T_{B}$ and $T_{W}$ , which are the run times of $F,B$ and $W$ respectively. For example, the schedule of $V.$ -Min (Figure 4b) is with $O(d)$ bubble when $T_{F}=T_{B}=T_{W}$ , but is with $O(n)$ bubble when $T_{W}$ is significantly smaller than $T_{F}$ and $T_{B}$ . ", "page_idx": 16}, {"type": "text", "text": "If there are no repeating bubbles in a schedule for any values of $T_{F},T_{B},T_{W}$ , the minimal memory is $2d m$ . In a pipeline schedule, there are two types of dependencies, streaming dependency within the same device and computational dependency across devices. We define a dependency path as a sequence of passes $\\boldsymbol{\\tau}=(v_{1},v_{2},...,v_{|\\tau|})$ where for any $1<i\\leq|\\tau|$ , $v_{i}$ is dependent on $v_{i-1}$ (either streaming dependency or computational dependency). We define the time cost of a dependency path as $\\begin{array}{r}{T_{\\tau}=\\dot{\\sum_{1\\leq i\\leq|\\tau|}}\\,T_{v_{i}}}\\end{array}$ where $T_{v_{i}}$ is the time cost of $v_{i}$ . Then the runtime of the whole pipeline should be $T=\\operatorname*{max}_{\\tau}T_{\\tau}$ . ", "page_idx": 16}, {"type": "text", "text": "Obviously, there is a trivial dependency path $\\tau_{1}$ that all the passes are from the same device, and $T_{\\tau_{1}}=2\\dot{n(T_{F}+T_{B}+T_{W})}$ . Note that it is the lower bound of runtime, and any extra runtime would be considered as bubbles. ", "page_idx": 17}, {"type": "text", "text": "Let\u2019s consider another dependency path $\\tau_{2}$ containing only forward passes. To be simple, we denote $\\hat{F}_{j}$ as the forward sequence for the $j$ -th microbatch. Then $\\tau_{2}=c o n c a t e n a t e(\\hat{F_{0}},\\hat{F_{k}},...,\\hat{F_{\\lfloor\\frac{n-1}{k}\\rfloor k}})$ thus $\\begin{array}{r}{T_{\\tau_{2}}=2d\\lfloor\\frac{n+k-1}{k}\\rfloor T_{F}}\\end{array}$ , where $6k>\\delta(F_{1}^{0},F_{1}^{1})>6(k-1)$ (greedily include as many forward passes as possible). Note that if we want to guarantee $O(d)$ bubble for any values of $T_{F},T_{B},T_{W}$ , we should choose $k\\geq d$ to make $\\textstyle2d\\lfloor{\\frac{n+k-1}{k}}\\rfloor\\leq2n$ , otherwise $\\begin{array}{r}{2d\\lfloor\\frac{n+k-1}{k}\\rfloor T_{F}-2n(T_{F}+T_{B}+T_{W})\\in}\\end{array}$ $O(n)$ if we set $T_{B}=T_{W}=0$ . Then we can get $\\delta(F_{1}^{0},F_{1}^{1})>6d-6$ . ", "page_idx": 17}, {"type": "text", "text": "Then we consider a similar dependency path $\\tau_{3}$ containing only backward passes, and we can get $\\delta(B_{1}^{1},B_{1}^{0})>6d-6$ . According to Equation 1, we can get the peak memory in the first device is at least $\\begin{array}{r}{\\big(\\lceil\\frac{\\delta\\bar{(F_{1}^{0},F_{1}^{1})}}{6}\\rceil+\\lceil\\frac{\\delta(B_{1}^{1},B_{1}^{0})}{6}\\rceil\\big)m\\geq2d m.}\\end{array}$ ", "page_idx": 17}, {"type": "text", "text": "For most real cases, V-Half is enough to guarantee there are no repeating bubbles. Although the above proof shows that $2d m$ memory is required to guarantee $O(d)$ bubble for any values of $T_{F},T_{B},T_{W}$ , we don\u2019t need that much memory in practice because the values of $T_{F},T_{B}$ and $T_{W}$ are well constrained. As in Qi et al. [2023], $F,B$ and $W$ have similar total FLOPS, and $T_{F},T_{B},T_{W}$ don\u2019t differ too much in real cases. Based on this insight, we can check the conditions where our methods are with $O(d)$ bubble. ", "page_idx": 17}, {"type": "text", "text": "Because both warm-up phase and cool-down phase have $O(d)$ passes, we only need to consider the stable phase to identify whether a schedule is with $O(d)$ bubble or with $O(n)$ bubble. Obviously, streaming dependency won\u2019t block the device from executing the next pass. So bubble is caused only by the computational dependency. Formally, a schedule is with $\\bar{O}(n)$ bubble if and only if there exist two passes $u$ and $v$ (within the same device) and there are two dependency paths $\\tau$ and $\\tau^{\\prime}$ between them, where $\\tau$ only contains streaming dependencies, $\\tau^{\\prime}$ contains at least two computational dependencies, and $T_{\\tau}<T_{\\tau^{\\prime}}$ . Based on our $\\mathrm{V}.$ -shape building blocks, we only need to check $u$ and $v$ with a small distance $(<6)$ and $\\tau^{\\prime}$ within two adjacent devices. In this way, we can conclude that the schedule in Figure $4\\mathrm{c}$ is with $O(d)$ bubble when $T_{W}+2T_{B}\\geq2T_{F}$ & $T_{W}+2T_{F}\\geq2T_{B}$ , which is satisfied in most real cases. ", "page_idx": 17}, {"type": "text", "text": "E.2 Lower Bound ", "page_idx": 17}, {"type": "image", "img_path": "Vvcnqs8091/tmp/4592c4abf91a2c8a5e5d0d2f6726eacdfbf04a79d3ca2974e7d47eeed36d99cb.jpg", "img_caption": ["Figure 13: A dependency path of pipeline schedule. "], "img_footnote": [], "page_idx": 17}, {"type": "text", "text": "The runtime of a schedule can be bounded by any dependency path. In Figure 13, we present a dependency path which is a non-trivial lower bound for most schedules after squeezing and reordering. Assuming the actual peak memory is $k m$ $(k\\leq2d)$ and $T_{F}=T_{B}=T_{W}=1$ , then the runtime of this dependency path is at least $6n+6d-3k-1$ . Empirically, we find that we can always get close to this lower bound in our adaptive scheduler. ", "page_idx": 17}, {"type": "text", "text": "F Building blocks of V-Min and V-Half for all values of $d$ ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "To avoid collisions when repeating building blocks, we need a slightly different offsets for different number of devices $d$ . We list the details in Table 9 and 10 while continue using the notation defined in A. We do not list the offsets related to $W$ passes because they always flil in the empty grids left by $F$ and $B$ . Some samples can also be found at Figure 14. ", "page_idx": 17}, {"type": "image", "img_path": "Vvcnqs8091/tmp/e3b725d55281c34379f6b9ddaeb0c87247a60d28b76c5535848f2ac5ca6a32c2.jpg", "img_caption": ["Figure 14: Building blocks of V-Min and V-Half on different settings of $d$ "], "img_footnote": [], "page_idx": 18}, {"type": "table", "img_path": "Vvcnqs8091/tmp/cfab8970e0b09864655065fe397af6a2ada7e487f53962ffec7e7ce14fc545f4.jpg", "table_caption": ["Table 9: Offsets for V-Min "], "table_footnote": [], "page_idx": 18}, {"type": "table", "img_path": "Vvcnqs8091/tmp/b3d566199c40ecf1d66471450d38edeaa8f8f2aac0cd0389c22a418da92e668a.jpg", "table_caption": ["Table 10: Offsets for V-Half "], "table_footnote": [], "page_idx": 18}, {"type": "text", "text": "G Non-uniform Repeating Interval of Interleaved 1F1B ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "While most existing schedules (Figure 18) are repeated with uniform interval, interleaved 1F1B [Narayanan et al., 2021] is slightly different in the repeating pattern. The official interleaved 1F1B has a repeating pattern as shown in Figure 15a. If we also employ uniform repeating interval as in Figure 15b, we can obtain another schedule with the same memory footprint and bubble rate as the official interleaved 1F1B, shown in the gallery (Figure 18i). ", "page_idx": 18}, {"type": "image", "img_path": "Vvcnqs8091/tmp/a9e47c5bc86d7e83855f207568db33146defaeb22998600d29780a73095b4c88.jpg", "img_caption": [], "img_footnote": [], "page_idx": 18}, {"type": "text", "text": "(a) The non-uniform repeating interval of interleaved 1F1B. The number in highlighted grids shows the microbatch with that index starts at this cell. ", "page_idx": 18}, {"type": "image", "img_path": "Vvcnqs8091/tmp/ac89a529c18f0306f0509228a837dfb2eb1e54adb9926a22283587b53542d16b.jpg", "img_caption": ["(b) A variation of interleaved 1F1B with uniform repeat. "], "img_footnote": [], "page_idx": 18}, {"type": "text", "text": "Figure 15: Different repeat pattern of the same building block of interleaved 1F1B. ", "page_idx": 18}, {"type": "text", "text": "H Other Memory Efficient Building Blocks ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Under the guidance of lifespan defined in Section 2.2, we also find some other building blocks besides the V-Shape building block family. We show the building blocks in Figure 16 and their full schedules in Figure 17. All these schedules have lower bubble rate than 1F1B. Specifically, 1F1B-V applies V-Shape to the building block of 1F1B but without B-W split, which can reduce the peak memory to asymptotically 2/3 of 1F1B. We also find that utilizing B-W split, the zero bubble pipeline schedules proposed in [Qi et al., 2023] with configurable memory limit can support a minimum of 2/3 activation memory of 1F1B, using the building block shown in Figure 16b. Note that two microbatches are included in a single building block to avoid collision. Using the building block defined in Figure 16c, we can make a schedule with the same bubble rate as interleaved 1F1B but lower memory, shown in Figure 17c. ", "page_idx": 18}, {"type": "image", "img_path": "Vvcnqs8091/tmp/4ad6f6e5cb0350a5117cdeb614cbd4f7dbd0d4d444f97dd30c384b12f9299765.jpg", "img_caption": [], "img_footnote": [], "page_idx": 19}, {"type": "image", "img_path": "", "img_caption": ["Figure 17: Other memory-efficient schedules. "], "img_footnote": [], "page_idx": 19}, {"type": "text", "text": "", "page_idx": 19}, {"type": "text", "text": "I A Gallery of Pipeline Parallel Schedules and Their Building Blocks ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "We show the building blocks and full schedules of some well-known existing methods in Figure 18. ", "page_idx": 19}, {"type": "image", "img_path": "Vvcnqs8091/tmp/45b9ff11080538a8e24f93450b12ac9808ccaf9bab9e0eafe58c706ce159e37a.jpg", "img_caption": ["(i) Interleaved 1F1B with uniform interval (with reordering) "], "img_footnote": [], "page_idx": 20}, {"type": "text", "text": "Figure 18: A gallery of pipeline schedules and their building blocks. The upper row of each schedule shows the building block and how it repeats. The lower row shows the final schedule after squeezing. ", "page_idx": 20}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 21}, {"type": "text", "text": "Justification: Our paper focus on the memory efficiency of pipeline parallelism. Our major contribution contains a framework to design pipeline schedules, which can control the activation memory by adjusting the lifespan, and a family of memory-efficient schedules. These are highlighted in the abstract and introduction. ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 21}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 21}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Justification: The major limitation of our work is that the performance V-Min method degrades when $_{F B}$ and W times are different. We discussed the limitation in Section 3.2 and also reflected them in the evaluation Section 4 ", "page_idx": 21}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 21}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 22}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 22}, {"type": "text", "text": "Justification: We don\u2019t have many theories in our work. The most theory part is the relationship between lifespan and memory, which is quite intuitive. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 22}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 22}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 22}, {"type": "text", "text": "Justification: Our implementation is based on Megatron-LM, which is accessible from everyone and we also disclosed the detailed setup of each schedule. We also plan to open-source our implementation when camera-ready. ", "page_idx": 22}, {"type": "text", "text": "Guidelines: ", "page_idx": 22}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in ", "page_idx": 22}, {"type": "text", "text": "some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 23}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: We\u2019ll opensource the implementation code on camera-ready version. Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 23}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 23}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 23}, {"type": "text", "text": "Justification: The experiment details are shared in Section 4 and Appendix D.1, D.3 ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 23}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 23}, {"type": "text", "text": "Answer: [No] ", "page_idx": 23}, {"type": "text", "text": "Justification: Our stats in experiments are mostly profiled memory and runtime, which are quite stable in our environment. ", "page_idx": 23}, {"type": "text", "text": "Guidelines: ", "page_idx": 23}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper. ", "page_idx": 23}, {"type": "text", "text": "\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 24}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: As mentioned in Section 4, we need at most 40 GPUs to run our experiments. Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 24}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 24}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 24}, {"type": "text", "text": "Justification: We conforms to the NeurIPS code of ethics. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 24}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 24}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 24}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 24}, {"type": "text", "text": "Justification: Our methods are focusing on the training systems only, not on the algorithms.   \nThey should not have any societal impacts. ", "page_idx": 24}, {"type": "text", "text": "Guidelines: ", "page_idx": 24}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed. ", "page_idx": 24}, {"type": "text", "text": "\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 25}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 25}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 25}, {"type": "text", "text": "Justification: Our methods has no risk of being misused. Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 25}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 25}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 25}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 25}, {"type": "text", "text": "Justification: Our implementation is based on Megatron-LM which has a lisence that allow other works to freely work on them. ", "page_idx": 25}, {"type": "text", "text": "Guidelines: ", "page_idx": 25}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 25}, {"type": "text", "text": "", "page_idx": 26}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 26}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 26}, {"type": "text", "text": "Justification: We\u2019ll opensource our code with documentation on usage on camera-ready version. ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 26}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: No crowd sourcing involved ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 26}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "page_idx": 26}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 26}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 26}, {"type": "text", "text": "Justification: No human subjects ", "page_idx": 26}, {"type": "text", "text": "Guidelines: ", "page_idx": 26}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 26}, {"type": "text", "text": "", "page_idx": 27}]