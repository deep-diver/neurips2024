[{"type": "text", "text": "Scale Equivariant Graph Metanetworks ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Ioannis Kalogeropoulos1,2\u2217 Giorgos Bouritsas1,2\u2217 Yannis Panagakis1,2 ", "page_idx": 0}, {"type": "text", "text": "1National and Kapodistrian University of Athens 2Archimedes/Athena RC, Greece ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "This paper pertains to an emerging machine learning paradigm: learning higherorder functions, i.e. functions whose inputs are functions themselves, particularly when these inputs are Neural Networks (NNs). With the growing interest in architectures that process NNs, a recurring design principle has permeated the field: adhering to the permutation symmetries arising from the connectionist structure of NNs. However, are these the sole symmetries present in NN parameterizations? Zooming into most practical activation functions (e.g. sine, ReLU, tanh) answers this question negatively and gives rise to intriguing new symmetries, which we collectively refer to as scaling symmetries, that is, non-zero scalar multiplications and divisions of weights and biases. In this work, we propose Scale Equivariant Graph MetaNetworks - ScaleGMNs, a framework that adapts the Graph Metanetwork (message-passing) paradigm by incorporating scaling symmetries and thus rendering neuron and edge representations equivariant to valid scalings. We introduce novel building blocks, of independent technical interest, that allow for equivariance or invariance with respect to individual scalar multipliers or their product and use them in all components of ScaleGMN. Furthermore, we prove that, under certain expressivity conditions, ScaleGMN can simulate the forward and backward pass of any input feedforward neural network. Experimental results demonstrate that our method advances the state-of-the-art performance for several datasets and activation functions, highlighting the power of scaling symmetries as an inductive bias for NN processing. The source code is publicly available at https://github.com/jkalogero/scalegmn. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Neural networks are becoming the workhorse of problem-solving across various domains. To solve a task, they acquire rich information which is stored in their learnable parameters throughout training. Nonetheless, this information is often opaque and difficult to interpret. This begs the question: How can we efficiently process and extract insights from the information stored in the parameters of trained neural networks, and how to do so in a data-driven manner? In other words, can we devise architectures that learn to process other neural architectures? ", "page_idx": 0}, {"type": "text", "text": "The need to address this question arises in diverse scenarios: NN post-processing, e.g. analysis/interpretation (i.e. inferring NN properties, such as generalisation and robustness [74, 19]), as well as editing (e.g. model pruning [22], merging [75] or adaptation to new data) - or NN synthesis (e.g. for optimisation [12] or more generally parameter prediction/generation [31, 67, 32, 58]). Furthermore, with the advent of Implicit Neural Representations,1 [13, 52, 57, 70, 53] trained NN parameters are increasingly used to represent datapoint signals, such as images or 3D shapes, replacing raw representations, i.e., pixel grids or point clouds [18]. Consequently, many tasks involving such data, across various domains such as computer vision [47] and physics [68], which are currently tackled using domain-specific architectures (e.g. CNNs for grids, PointNets [63] or GNNs [60] for point clouds and meshes), could potentially be solved by NNs that process the parameters of other NNs. ", "page_idx": 0}, {"type": "text", "text": "", "page_idx": 1}, {"type": "text", "text": "The idea of processing/predicting NN parameters per se is not new to the deep learning community, e.g. it has been investigated in hypernetworks [27] or even earlier [65]. However recent advancements, driven by the need for INR processing, leverage a crucial observation: NNs have symmetries. In particular, several works have identified that the function represented by an NN remains intact when applying certain transformations to its parameters [28, 11] with the most well-known transformations being permutations. That is, hidden neurons can be arbitrarily permuted within the same layer, along with their incoming and outgoing weights. Therefore, all the tasks mentioned in the previous paragraph can be considered part of equivariant machine learning [10], as they involve developing models that are invariant or equivariant to the aforementioned transformations of neural networks. Recently Navon et al. [54] and Zhou et al. [86] acknowledged the importance of permutation symmetries and first proposed equivariant architectures for Feedforward NN (FFNN) processing, demonstrating significant performance improvements against non-equivariant baselines. These works, as well as their improvements [85] and extensions to process more intricate and varying architectures [33, 44, 88], are collectively known as weight space networks or metanetworks, with graph metanetworks being a notable subcase (graph neural networks with message-passing). ", "page_idx": 1}, {"type": "text", "text": "Nevertheless, it is known that permutations are not the only applicable symmetries. In particular, theoretical results in various works [11, 61], mainly unified in [25] show that FFNNs exhibit additional symmetries, which we collectively here refer to as scaling symmetries: multiplying the incoming weights and the bias of a hidden neuron with a non-zero scalar $a$ (with certain properties) while dividing its outgoing weights with another scalar $b$ (often $b\\;=\\;a$ ), preserves the NN function. Intuitively, permutation symmetries arise from the graph/connectionist structure of the NN whereas different scaling symmetries originate from its activation functions $\\sigma$ , i.e. when it holds that $\\sigma(a x)=$ $b\\sigma(x)$ . However, equivariance w.r.t. scaling symmetries has not received much attention so far (perhaps with the exception of sign symmetries - $a\\in\\{-1,1\\}$ [41, 40]), and it remains effectively unexplored in the context of metanetworks. ", "page_idx": 1}, {"type": "text", "text": "To address this gap, we introduce in this paper a graph metanetwork framework, dubbed as Scale Equivariant Graph MetaNetworks- ScaleGMN, which guarantees equivariance to permutations and desired scaling symmetries, and can process FFNNs of arbitrary graph structure with a variety of activation functions. At the heart of our method lie novel building blocks with scale invariance/equivariance properties w.r.t. arbitrary families of scaling parameters. We prove that ScaleGMN can simulate the forward and backward pass of an FFNN for arbitrary inputs, enabling it to reconstruct the function represented by any input FFNN and its gradients. ", "page_idx": 1}, {"type": "text", "text": "Our contributions can be summarised as follows: ", "page_idx": 1}, {"type": "text", "text": "\u2022 We extend the scope of metanetwork design from permutation to scaling symmetries. \u2022 We design invariant/equivariant networks to scalar multiplication of individual multipliers or combinations thereof, originating from arbitrary scaling groups. \u2022 We propose scale equivariant message passing, using the above as building blocks, unifying permutation and scale equivariant processing of FFNNs. Additionally, the expressive power of our method is analysed w.r.t. its ability to simulate input FFNNs. \u2022 Our method is evaluated on 3 activations: ReLU (positive scale), tanh (sign) and sine (sign - we first characterise this using a technique from [25]) on several datasets and three tasks (INR classification/editing & generalisation prediction), demonstrating superior performance against common metanetwork baselines. ", "page_idx": 1}, {"type": "text", "text": "2 Related work ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Neural network symmetries. Long preceding the advent of metanetworks, numerous studies delved into the inherent symmetries of neural networks. Hecht-Nielsen [28] studied FFNNs and discovered the existence of permutation symmetries. Chen et al. [11] showed that, in FFNNs with tanh activations, the only function-preserving smooth transformations are permutations and sign filps (multiplication of incoming and outgoing weights with a sign value) - this claim was strengthened in [21]; this was the first identification of scaling symmetries. Follow-up works extended these observations to other activations, such as sigmoid and RBF [37] and ReLU [56, 51, 61, 64, 26], and architectures, such as RNNs [3, 2], characterising other scaling symmetries and providing conditions under which permutations and scalings are the only available function-preserving symmetries or the parameters are identifiable given the input-output mapping. Recently, Godfrey et al. [25] provided a technique to characterise such symmetries for arbitrary activations that respect certain conditions, unifying many previous results. Additionally, symmetries have been found in other layers, e.g. batch norm [6, 14, 16] (scale invariance) or softmax [36] (translation invariance). Prior to metanetworks, symmetries were mainly studied to obtain a deeper understanding of NNs or in the context of optimisation/learning dynamics [56, 71, 4, 17, 36, 5, 83, 84] and/or model merging/ensembling [20, 1, 69, 59, 55]. ", "page_idx": 1}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "Metanetworks. The first solutions proposed for NN processing and learning did not account for NN symmetries. Unterthiner et al. [74] and Eilertsen et al. [19], initially employed standard NNs on vectorised (flattened) CNN weights or some statistics thereof, to predict properties of trained neural networks such as generalization or estimation of a hyperparameter resp.). Similar methods have been proposed to process continuous data represented as INRs. In [78] high-order spatial derivatives are used (suitable only for INRs), in [47] the architecture operates on stacked parameter vectors (but is constrained by the assumption that all INRs are trained from the same initialization), while in [18] and [7] the authors learn low-dimensional INR embeddings (which are further used for downstream tasks) by jointly fitting them with meta-learning. Finally, Sch\u00fcrholt et al. [66] learn representations of NN weights with self-supervised learning and in [67] this is extended to generative models. ", "page_idx": 2}, {"type": "text", "text": "In contrast to the above methods, our work follows a recent stream of research focusing on equivariant metanetworks. Navon et al. [54] and Zhou et al. [85] first characterised all linear equivariant layers to permutation symmetries of MLPs and combined them with non-linearities, while in the latter this was extended to CNNs. These approaches derive intricate weight-sharing patterns but are nonlocal2 and cannot process varying architectures. In follow-up works, Zhou et al. [86] constructed equivariant attention layers and in [87] the above characterisation was generalised to arbitrary input architectures and layers (e.g. RNNs and transformers) introducing an algorithm for automatic linear layer (with weight-sharing) construction. A different route was taken in the very recent works of Kofinas et al. [33] and Lim et al. [44], where input NNs are treated as a special class of graphs and are naturally processed with Graph Neural Networks (GNNs), with appropriate symmetry breaking wherever necessary. This perspective has been adopted several times in the deep learning literature [9, 23, 45, 77, 80] and in a few examples, GNNs were applied on the graph representation for, e.g. neural architecture search ([82, 72, 31]), albeit without mapping parameters to the graph edges. In parallel to our work, [73] extended the framework of [85] to incorporate scaling and sign-flipping symmetries. They construct non-local equivariant layers, resulting in an architecture with fewer trainable parameters. Nevertheless, their method suffers from limited expressive power, while their experimental results showcase limited advancements. In contrast to our method, this approach limits the choice of activation functions to those equivariant to the studied symmetries. Finally, their framework cannot be extended to other activation functions, as the parameter sharing must be re-designed from scratch, while it is not suitable for processing diverse architectures. ", "page_idx": 2}, {"type": "text", "text": "Scale Equivariance Equivariance to vector scaling (or more generally to matrix multiplication with diagonal matrices) remains to date underexplored in the machine learning community. Sign symmetries received attention in the work of Lim et al. [42], where an invariant network (SignNet) was designed, mainly to process eigenvectors, with the theoretical analysis revealing universality under certain conditions. This was extended in [39], where the importance of sign equivariance on several tasks was demonstrated and a sign equivariant network was proposed. In our work, we draw inspiration from these architectures and extend their formulations to arbitrary scaling symmetries. ", "page_idx": 2}, {"type": "text", "text": "3 Notation and Preliminaries ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "Notation. We denote vectors, matrices, and tensors with bold-face letters, e.g., $\\mathbf{x},\\mathbf{X},\\pmb{\\mathsf{X}}$ , respectively and sets with calligraphic letters $\\mathcal{X}$ . A normal font notation will be used for miscellaneous purposes (mostly indices and functions). Datapoint (input) functions/signals will be denoted with $u$ , while higher-order functions (functions of functions) will be denoted with fraktur font $\\mathfrak{F}$ . ", "page_idx": 2}, {"type": "text", "text": "Functions of Neural Networks. Consider functions of the form $u_{G,\\theta}:\\mathcal{X}\\rightarrow\\hat{\\mathcal{X}}$ . Each function is parameterised (1) by a computational graph $G$ , which determines all the mathematical operations that should be performed to evaluate the function $u$ at a datapoint $\\mathbf{x}\\in\\mathcal{X}$ . When $u$ is a neural network, $G$ is determined by the NN architecture. Additionally, $u$ is parameterised by (2), by a tuple of numerical parameters $\\pmb{\\theta}$ , on which the aforementioned mathematical operations are applied (along with the input $\\mathbf{x}$ ) - these are the learnable parameters, which can be arranged into a vector. We are interested in learning unknown higher-order functions $\\mathfrak{F}:\\hat{\\mathcal{X}}^{\\mathcal{X}}\\to\\mathcal{Y}$ of the form $\\Im\\left(u_{G,\\pmb{\\theta}}\\right)$ . In our case, the goal is to learn $\\mathfrak{F}$ by accessing solely the parameters $(G,\\theta)$ of each $u$ , i.e. via functions $\\hat{f}:\\mathcal{G}\\times\\Theta\\to\\mathcal{V}$ of the form $\\hat{f}(G,\\pmb\\theta)$ , where $\\mathcal{G}$ is a space of architectures/computational graphs and $\\Theta$ a space of parameters.3 We are typically interested in learning functionals $(\\mathcal{V}\\subseteq\\mathbb{R}^{d})$ or operators $(\\mathcal{Y}=\\mathcal{G}\\times\\Theta$ or $\\mathcal{V}=\\Theta$ ). To approximate the desired higher-order function, we assume access to a dataset of parameters sampled i.i.d. from an unknown distribution $p$ on $\\mathcal{G}\\times\\Theta$ . For example, in a supervised setup, we aim to optimise the following: $\\begin{array}{r l}&{\\mathrm{argmin}_{\\hat{f}\\in\\mathcal{F}}\\mathbb{E}_{(G,\\pmb{\\theta})\\sim p}L\\Big(\\mathfrak{F}(u_{G,\\pmb{\\theta}}),\\hat{f}(G,\\pmb{\\theta})\\Big)}\\end{array}$ , where $L(\\cdot,\\cdot)$ is a loss function and $\\mathcal{F}$ is an NN processing hypothesis class (e.g. metanetworks). ", "page_idx": 2}, {"type": "text", "text": "", "page_idx": 3}, {"type": "text", "text": "Feedforward Neural Networks (FFNNs). In this paper, we focus our analysis on Feedforward Neural Networks (FFNNs), i.e. linear layers interleaved with non-linearities. Consider NNs of the form $u_{G,\\pmb{\\theta}}:\\mathbb{R}^{d_{\\mathrm{in}}}\\rightarrow\\mathbb{R}^{d_{\\mathrm{out}}}$ of the following form: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{x}_{0}=\\mathbf{x},\\quad\\mathbf{x}_{\\ell}=\\sigma_{\\ell}\\left(\\mathbf{W}_{\\ell}\\mathbf{x}_{\\ell-1}+\\mathbf{b}_{\\ell}\\right),\\quad u_{G,\\pmb{\\theta}}(\\mathbf{x})=\\mathbf{x}_{L}}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $L$ : the number of layers, $\\mathbf{W}_{i}\\in\\mathbb{R}^{d_{\\ell}\\times d_{\\ell-1}}$ : the weights of the NN, $\\mathbf{b}_{i}\\in\\mathbb{R}^{d_{\\ell}}$ : the biases of the NN, $d_{0}\\,=\\,d_{\\mathrm{in}}$ , $d_{L}\\,=\\,d_{\\mathrm{out}}$ , $\\sigma_{\\ell}:\\mathbb{R}\\rightarrow\\mathbb{R}$ activation functions applied element-wise. Here, the learnable parameters are $\\pmb{\\theta}=(\\mathbf{W}_{1},\\dots,\\mathbf{W}_{L},\\mathbf{b}_{1},\\dots,\\mathbf{b}_{L})$ and the computational graph encodes the connections between vertices, but also the type of activations used in each layer. ", "page_idx": 3}, {"type": "text", "text": "Neural Network symmetries. One of the major difficulties with working with function parameters directly is that the same function can be represented with more than one parameter, i.e. there exists transformations that when applied to any parameter $(G,\\theta)$ , keep the represented function intact. Formally, an NN symmetry is induced by a set $\\Psi$ of transformations $\\psi:{\\mathcal{G}}\\times{\\Theta}\\rightarrow{\\mathcal{G}}\\times{\\Theta},$ such that $u_{G,\\pmb{\\theta}}(\\mathbf{x})\\,=\\,u_{\\psi(G,\\pmb{\\theta})}(\\mathbf{x}),\\forall\\mathbf{x}\\,\\in\\,\\mathcal{X},\\forall(G,\\pmb{\\theta})\\,\\in\\,\\mathcal{G}\\,\\times\\,\\Theta$ . If for a pair parameters $(G,\\theta)$ , $(G^{\\prime},\\theta^{\\prime})$ , $\\exists\\psi$ such that ${(G,\\pmb\\theta)}\\,=\\,\\psi(G^{\\prime},\\pmb\\theta^{\\prime})$ , we will call the two parameters equivalent and write $(G,\\pmb\\theta)\\simeq(G^{\\prime},\\pmb\\theta^{\\prime})$ . To appropriately represent a functional $\\mathfrak{F}$ , a hypothesis (metanetwork) $\\hat{f}$ should be invariant to transformations in $\\Psi$ $:{\\hat{f}}\\left(\\psi\\left(G,\\pmb\\theta\\right)\\right)={\\hat{f}}(G,\\pmb\\theta)$ . For operators, $\\hat{f}$ should be equivariant to transformations: $f\\left(\\psi\\left(G,\\pmb\\theta\\right)\\right)=\\dot{\\psi}\\left(\\ddot{f}(\\dot{G},\\pmb\\theta)\\right)$ , such that identical functions map to identical functions. ", "page_idx": 3}, {"type": "text", "text": "Permutation symmetries (connectionist structure). For a fixed computational graph $G$ , perhaps the most well-known symmetry of FFNNs are those induced by hidden neuron permutations [28]. As far as metanetworks are concerned it is to date the only NN symmetry that has been accounted for - see Section 2. This symmetry implies that permuting hidden neurons (along with their biases and incoming and outgoing weights) within each layer preserves the NN function (regardless of the activation function). This reads: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{W}_{\\ell}^{\\prime}=\\mathbf{P}_{\\ell}\\mathbf{W}_{\\ell}\\mathbf{P}_{\\ell-1}^{-1},\\;\\mathbf{b}_{\\ell}^{\\prime}=\\mathbf{P}_{\\ell}\\mathbf{b}_{\\ell}\\Longrightarrow\\big(\\mathbf{W}_{\\ell}^{\\prime},\\mathbf{b}_{\\ell}^{\\prime}\\big)_{\\ell=1}^{L}=\\pmb{\\theta}^{\\prime}\\simeq\\pmb{\\theta}=\\big(\\mathbf{W}_{\\ell},\\mathbf{b}_{\\ell}\\big)_{\\ell=1}^{L},}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where $\\ell\\in\\{1,\\ldots,L\\}$ , $\\mathbf{P}_{0}=\\mathbf{P}_{L}=\\mathbf{I}$ and $\\mathbf{P}_{\\ell}\\in\\mathbb{R}^{d_{\\ell}\\times d_{\\ell}}$ are arbitrary permutation matrices. Observe that they are different for each layer, with the input and output neurons held fixed. ", "page_idx": 3}, {"type": "text", "text": "Graph Metanetworks (GMNs). A recently introduced weight space architecture [33, 44], takes advantage of the permutation symmetries and treats FFNNs (among others, e.g. CNNs) as graphs, processing them with conventional GNNs. In particular, let $G=(\\boldsymbol{\\nu},\\boldsymbol{\\mathcal{E}})$ be the computational graph, $i\\in\\mathcal{V}$ an arbitrary vertex in the graph (neuron) and $(i,j)\\in\\mathcal{E}$ an arbitrary edge from vertex $j$ to vertex $i$ .4 Additionally, let $\\mathbf{x}_{V}\\in\\mathbb{R}^{|\\mathcal{V}|\\times d_{v}}$ be the vertex features and $\\mathbf{x}_{E}\\in\\mathbb{R}^{|\\mathcal{E}|\\times d_{e}}$ the edge features (i.e. biases and weights resp. in a FFNN). The general form of a $T$ iteration (layer) GMN reads: ", "page_idx": 3}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{h}_{V}^{0}(i)=\\mathrm{INIT}_{V}\\left(\\mathbf{x}_{V}\\left(i\\right)\\right),\\quad\\mathbf{h}_{E}^{0}(i,j)=\\mathrm{INIT}_{E}\\left(\\mathbf{x}_{E}\\left(i,j\\right)\\right)}\\\\ &{\\mathbf{m}_{V}^{t}(i)=\\bigoplus_{j\\in\\mathcal{N}(i)}\\mathrm{MSG}_{V}^{t}\\left(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{h}_{V}^{t-1}(j),\\mathbf{h}_{E}^{t-1}(i,j)\\right)}\\\\ &{\\mathbf{h}_{V}^{t}(i)=\\mathrm{IPD}_{V}^{t}\\left(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{m}_{V}^{t}(i)\\right),\\quad\\mathbf{h}_{E}^{t}(i,j)=\\mathrm{UPD}_{E}^{t}\\big(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{h}_{V}^{t-1}(j),\\mathbf{h}_{E}^{t-1}(i,j)\\big)}\\\\ &{\\mathbf{h}_{G}=\\mathrm{READ}\\Big(\\big\\{\\mathbf{h}_{V}^{T}(i)\\big\\}_{i\\in\\mathcal{V}}\\Big),\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad(\\mathrm{I})}\\end{array}\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "where ${\\bf h}_{V}^{t},{\\bf h}_{E}^{t}$ are vertex and edge representations at iteration $t$ and $\\mathbf{h}_{G}$ is the overall graph (NN) representation. INIT, MSG, UPD are general function approximators (e.g. MLPs), while READ is a permutation invariant aggregator (e.g. DeepSets [81]). The above equations have appeared with several variations in the literature, e.g. in some cases the edge representations are not updated or the readout might involve edge representations as well. Another frequent strategy is to use positional encodings $\\ensuremath{\\mathbf{p}}_{V},\\ensuremath{\\mathbf{p}}_{E}$ to break undesired symmetries. In FFNNs, Eq. (2) reveals that input and output vertices are not permutable, while vertices cannot be permuted across layers. Therefore, vertices (or edges) that are permutable share the same positional encoding (see Appendix A.1.2 for more details). Remark: Although, typically, the neighbourhood $\\mathcal{N}(i)$ contains both incoming and outgoing edges, in Section 5 we will illustrate our method using only incoming edges: forward neighbourhood $\\mathcal{N}_{\\mathrm{FW}}(i)=\\{j\\in\\mathcal{V}\\,|\\,$ layer $(i)-\\mathrm{layer}\\left(j\\right)=1\\}$ and backward where layer $(i)$ gives the layer neuron $i$ belongs. Backward neighbourhoods $\\mathcal{N}_{\\mathrm{BW}}(i)$ are defined defined similarly. In Appendix A.2, we show a more elaborate bidirectional version of our method, with both neighbourhoods considered. ", "page_idx": 4}, {"type": "text", "text": "4 Scaling symmetries in Feedforward Neural Networks ", "text_level": 1, "page_idx": 4}, {"type": "text", "text": "Scaling symmetries (activation functions). Intuitively, permutation symmetries stem from the graph structure of neural networks, or put differently, from the fact that hidden neurons do not possess any inherent ordering. Apart from the affine layers $\\mathbf{W}_{\\ell}$ that give rise to the graph structure, it is frequently the case that activation functions $\\sigma_{\\ell}$ have inherent symmetries that are bestowed to the NN. ", "page_idx": 4}, {"type": "text", "text": "Let us dive into certain illustrative examples: for the ReLU activation $\\sigma(x)=\\operatorname*{max}(x,0)$ it holds that $\\sigma(a x)=\\mathrm{max}(a x,0)=a\\,\\mathrm{max}(x,0)$ , $\\forall a>0$ . For the tanh and sine activations $\\sigma(x)=\\operatorname{tanh}(x)$ , $\\sigma(x)=\\sin(x)$ respectively, it holds that $\\sigma(a x)=a\\sigma(x)$ , $\\forall a\\in\\{-1,1\\}$ . In a slightly more complex example, polynomial activations $\\sigma(x)=x^{k}$ , we have $\\sigma(a x)=a^{d}\\sigma(x)$ , i.e. the multiplier differs between input and output. In general, we will be talking about scaling symmetries whenever there exist pairs $(a,b)$ for which it holds that $\\sigma(a x)\\,=\\,b\\sigma(\\bar{x})$ . To see how such properties affect NN symmetries, let us focus on FFNNs (see Appendix A.3 for CNNs): for a neuron $i$ (we omit layer subscripts) we have $\\sigma\\big(a\\mathbf{W}(i,:)\\mathbf{x}+a\\mathbf{b}(i)\\big)\\overset{\\cdot}{=}b\\sigma\\big(\\mathbf{W}(i,:)\\mathbf{x}+\\mathbf{b}(i)\\big).$ , i.e. multiplying its bias and all incoming weights with a constant a results in scaling its output with a corresponding constant $b$ Generalising this to linear transformations, we may ask the following: which are the pairs of matrices $(\\mathbf{A},\\mathbf{B})$ for which we have $\\sigma\\left(\\mathbf{AWx}+\\mathbf{Ab}\\right)=\\mathbf{B}\\dot{\\sigma}\\left(\\mathbf{Wx}+\\mathbf{b}\\right)?$ Godfrey et al. [25] provide an answer for any activation that respects certain conditions. We restate here their most important results: ", "page_idx": 4}, {"type": "text", "text": "Proposition 4.1 (Lemma 3.1. and Theorem E.14 from [25]). Consider an activation function $\\sigma:\\mathbb{R}\\rightarrow\\mathbb{R}$ . Under mild conditions,5 the following hold: ", "page_idx": 4}, {"type": "text", "text": "\u2022 For any $d\\;\\in\\;\\mathbb{N}^{+}$ , there exists a (non-empty) group of invertible matrices defined as: $I_{\\sigma,d}=\\mathbf{\\widetilde{\\Omega}}\\mathbf{A}\\in\\mathbb{R}^{d\\times d}$ : invertible $|\\ \\exists\\ \\mathbf{B}\\in\\ {\\dot{\\mathbb{R}}}^{{\\dot{d}}\\times{\\dot{d}}}$ invertible, such that: $\\sigma(\\mathbf{Ax})=\\mathbf{\\dot{B}}\\sigma(\\mathbf{x})\\mathbf{\\right\\}$ (intertwiner group), and a mapping function $\\phi_{\\sigma,d}$ such that $\\mathbf{B}=\\phi_{\\sigma,d}(\\mathbf{A})$ . \u2022 Every $\\mathbf{A}\\in I_{\\sigma,d}$ is of the form PQ, where $\\mathbf{P}$ : permutation matrix and $\\mathbf{Q}=d i a g\\left(q_{1},\\ldots q_{d}\\right)$ diagonal, with $q_{i}\\in D_{\\sigma}=\\{a\\in\\mathbb{R}\\backslash\\{0\\}\\mid\\sigma(a x)=\\phi_{\\sigma,1}(a)\\sigma(x)\\}$ : the $^{\\,l}$ -dimensional group, and $\\phi_{\\sigma,d}(\\mathbf{A})=\\mathbf{P}d i a g{\\bigl(}\\phi_{\\sigma,1}(q_{1}),\\ldots\\phi_{\\sigma,1}(q_{d}){\\bigr)}$ . ", "page_idx": 4}, {"type": "text", "text": "This is a powerful result that completely answers the question above for most practical activation functions. Importantly, not only does it recover permutation symmetries, but also reveals symmetries to diagonal matrix groups, which can be identified by solely examining $\\phi_{\\sigma,1}$ , i.e. the one-dimensional case and the set $D_{\\sigma}$ (easily proved to be a group) we have already discussed in our examples above. ", "page_idx": 4}, {"type": "text", "text": "Using this statement, Godfrey et al. [25] characterised various activation functions (or recovered existing results), e.g. ReLU: $I_{\\sigma,d}$ contains generalised permutation matrices with positive entries of the form $\\mathbf{PQ}$ , $\\mathbf{Q}=\\mathrm{diag}(q_{1},\\ldots,q_{d})$ , $q_{i}>0$ and $\\bar{\\phi_{\\sigma,d}}(\\mathbf{PQ})=\\mathbf{PQ}$ [56]. Additionally, here we characterise the intertwiner group of sine (used in the popular SIREN architecture [70] for INRs). Not surprisingly, it has the same intertwiner group with tanh [11, 21] (we also recover this here using Proposition 4.1). Formally, (proof in Appendix A.7.1): ", "page_idx": 4}, {"type": "text", "text": "Corollary 4.2. Hyperbolic tangent $\\sigma(x)=\\operatorname{tanh}(x)$ and sine activation $\\sigma(x)=\\sin(\\omega x),$ , satisfy the conditions of Proposition 4.1, when (for the latter) $\\omega\\neq k\\pi,k\\in\\mathbb{Z}$ . Additionally, $I_{\\sigma,d}$ contains signed permutation matrices of the form $\\mathbf{PQ},$ , with $\\mathbf{Q}=\\operatorname{diag}(q_{1},\\ldots,q_{d})$ , $q_{i}=\\pm1$ and $\\dot{\\phi}_{\\sigma_{d}}(\\mathbf{PQ})=\\mathbf{\\bar{PQ}}.$ . ", "page_idx": 4}, {"type": "text", "text": "It is straightforward to see that the symmetries of Proposition 4.1, induce equivalent parameterisations for FNNNs. In particular, it follows directly from Proposition 3.4. in [25], that for activation functions $\\sigma_{\\ell}$ satisfying the conditions of Proposition 4.1 and when $\\phi_{\\sigma,\\ell}(\\mathbf{Q})=\\mathbf{Q}$ , we have that: ", "page_idx": 5}, {"type": "text", "text": "$\\begin{array}{r}{\\mathbf{W}_{\\ell}^{\\prime}=\\mathbf{P}_{\\ell}\\mathbf{Q}_{\\ell}\\mathbf{W}_{\\ell}\\mathbf{Q}_{\\ell-1}^{-1}\\mathbf{P}_{\\ell-1}^{-1},\\;\\mathbf{b}_{\\ell}^{\\prime}=\\mathbf{P}_{\\ell}\\mathbf{Q}_{\\ell}\\mathbf{b}_{\\ell}\\implies(\\mathbf{W}_{\\ell}^{\\prime},\\mathbf{b}_{\\ell}^{\\prime})_{\\ell=1}^{L}=\\theta^{\\prime}\\simeq\\theta=(\\mathbf{W}_{\\ell},\\mathbf{b}_{\\ell})_{\\ell=1}^{L},}\\end{array}$ where again $\\ell\\in\\{1,\\ldots,L\\}$ , $\\mathbf{P}_{0}=\\mathbf{Q}_{0}=\\mathbf{P}_{L}=\\mathbf{Q}_{L}=\\mathbf{I}.$ . ", "page_idx": 5}, {"type": "text", "text": "5 Scale Equivariant Graph MetaNetworks ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "As previously mentioned, the metanetworks operating on weight spaces that have been proposed so far, either do not take any symmetries into account or are invariant/equivariant to permutations alone as dictated by Eq. (2). In the following section, we introduce an architecture invariant/equivariant to permutations and scalings, adhering to Eq. (3). An important motivation for this is that in various setups, these are the only function-preserving symmetries, i.e. for a fixed graph $u_{G,\\pmb\\theta}=u_{G,\\pmb\\theta^{\\prime}}\\Rightarrow$ $(\\theta,\\theta^{\\prime})$ satisfy Eq. (3) - e.g. see [21] for the conditions for tanh and [61, 26] for ReLU. ", "page_idx": 5}, {"type": "text", "text": "Main idea. Our framework is similar in spirit to most works on equivariant and invariant NNs [10]. In particular, we build equivariant GMNs that will preserve both symmetries at vertex- and edge-level, i.e. vertex representations will have the same symmetries with the biases and edge representations with the weights. To see this, suppose two parameter vectors are equivalent according to Eq. (3). Then, the hidden neurons representations - the discussion on input/output neurons is postponed until Appendix A.1.4 - should respect the following (the GMN iteration $t$ is omitted to simplify notation): ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathbf{h}_{V}^{\\prime}(i)=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)\\mathbf{h}_{V}\\left(\\pi_{\\ell}\\left(i\\right)\\right),\\quad\\ell=\\mathrm{layer}\\left(i\\right)\\in\\{1,\\ldots,L-1\\}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "equation", "text": "$$\n\\mathbf{h}_{E}^{\\prime}(i,j)=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)\\mathbf{h}_{E}\\left(\\pi_{\\ell}\\left(i\\right),\\pi_{\\ell-1}\\left(j\\right)\\right)q_{\\ell-1}^{-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right),\\;\\ell=\\mathrm{layer}\\left(i\\right)\\in\\{2,\\ldots,L-1\\},\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\pi_{\\ell}\\;:\\;\\mathcal{V}_{\\ell}\\;\\leftrightarrow\\;\\mathcal{V}_{\\ell}$ permutes the vertices of layer $\\ell$ (denoted with $\\nu_{\\ell}$ ) according to $\\mathbf{P}_{\\ell}$ and $q_{\\ell}\\,:\\,\\mathcal{V}_{\\ell}\\,\\to\\,\\mathbb{R}\\setminus\\{0\\}$ scales the vertex representations of layer $\\ell$ according to $\\mathbf{Q}_{\\ell}$ . We will refer to the latter as forward scaling in Eq. (4) and bidirectonal scaling in Eq. (5). To approximate operators (equivariance), we compose multiple equivariant GMN layers/iterations and in the end, project vertex/edge representations to the original NN weight space, while to approximate functionals (invariance), we compose a final invariant one in the end summarising the input to a scalar/vector. ", "page_idx": 5}, {"type": "text", "text": "To ease exposition, we will first discuss our approach w.r.t. vertex representations. Assume that vertex representation symmetries are preserved by the initialisation of the MPNN - Eq. (Init) - and so are edge representation symmetries for all MPNN layers. Therefore, we can only focus on the message passing and vertex update steps - Eq. (Msg) and Eq. (Upd). Additionally, let us first focus on hidden neurons and assume only forward neighbourhoods. The following challenges arise: ", "page_idx": 5}, {"type": "text", "text": "Challenge 1 - Scale Invariance / Equivariance. First off, the message and the update function $\\mathbf{MSG}_{V}$ , ${\\mathrm{UPD}}_{V}$ should be equivariant to scaling - in this case to the forward scaling using the multiplier of the central vertex $q_{\\ell}(i)$ . Additionally, the readout READ, apart from being permutation invariant should also be invariant to the different scalar multipliers of each vertex . Dealing with this requires devising functions of the following form: ", "page_idx": 5}, {"type": "equation", "text": "$$\ng_{i}{\\big(}q_{1}\\mathbf{x}_{1},\\ldots,q_{n}\\mathbf{x}_{n}{\\big)}=q_{i}g_{i}(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{n}),\\forall q_{i}\\in D_{i},i\\in\\{1,\\ldots,n\\}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $D_{i}$ a 1-dimensional scaling group as defined in Proposition 4.1. Common examples are those discussed in Section 4, e.g. $D_{i}=\\{1,-1\\}$ or $D_{i}=\\mathbb{R}^{+}$ . The first case, i.e. sign symmetries, has been discussed in recent work [43, 40]. Here we generalise their architecture into arbitrary scaling groups. In specific, Scale Equivariant networks follow the methodology of [40], i.e. they are compositions of multiple linear transformations multiplied elementwise with the output of Scale Invariant functions: ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathsf{S c a l e l n v}^{k}(\\mathbf{X})=\\rho^{k}\\left(\\tilde{\\mathbf{x}}_{1},\\ldots,\\tilde{\\mathbf{x}}_{n}\\right),}\\\\ &{\\mathsf{S c a l e E q}=\\mathsf{f}^{K}\\circ\\cdots\\circ\\mathsf{f}^{1},\\;\\mathsf{f}^{k}(\\mathbf{X})=\\left(\\Gamma_{1}^{k}\\mathbf{x}_{1},\\ldots,\\Gamma_{n}^{k}\\mathbf{x}_{n}\\right)\\odot\\mathsf{S c a l e l n v}^{k}(\\mathbf{X}),}\\end{array}\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "where $\\rho^{k}\\,:\\,\\prod_{i=1}^{n}\\mathcal{X}_{i}\\,\\to\\,\\mathbb{R}^{\\sum_{i=1}^{n}d_{i}^{k}}$ universal approximators (e.g. MLPs), $\\Gamma_{i}^{k}:\\mathcal{X}_{i}\\rightarrow\\mathbb{R}^{d_{i}^{k}}$ linear transforms ( for each of the $k$ invariant/equivariant layers resp - in practice, we observed experimentally that a single layer $K=1$ was sufficient), and $\\tilde{\\mathbf{x}}_{i}$ are explained in detail in the following paragraph. ", "page_idx": 5}, {"type": "text", "text": "Central to our method is defining a way to achieve invariance. One option is canonicalisation, i.e. by defining a function canon : $\\mathcal X\\rightarrow\\mathcal X$ that maps all equivalent vectors x to a representative (obviously non-equivalent vectors have different representatives): Iff $\\mathbf{x}\\simeq\\mathbf{y}\\in\\mathcal{X}$ , then $\\begin{array}{r l}{\\mathbf{x}\\simeq\\mathsf{c a n o n}(\\mathbf{x})=}&{{}}\\end{array}$ canon $\\bf\\delta(y)$ . In certain cases, these are easy to define and differentiable almost everywhere, for example for positive scaling: canon(x) = \u2225xx\u2225 .6 For sign symmetries, this is not as straightforward: in 1-dimension one can use $|x|$ , but for arbitrary dimensions, a more complex procedure is required, as recently discussed in [49, 48]. Since the group is small - two elements - one can use symmetrisation instead [79], as done by Lim et al. [41]: $\\begin{array}{r}{\\mathsf{s y m m}(\\mathbf{x})=\\sum_{\\mathbf{y}:\\mathbf{y}\\simeq\\mathbf{x}}\\mathrm{MLP}(\\mathbf{y})}\\end{array}$ , i.e. for sign: $\\mathsf{s y m m}(\\mathbf{x})=$ $\\mathrm{MLP}({\\bf x})\\!+\\!\\mathrm{MLP}(-{\\bf x})$ . Therefore, we define: ${\\sf S c a l e l n v}^{k}({\\bf X})=\\rho^{k}\\left(\\tilde{\\bf x}_{1},\\ldots,\\tilde{\\bf x}_{n}\\right)$ , with $\\tilde{\\mathbf{x}}_{i}=\\mathsf{c a n o n}(\\mathbf{x}_{i})$ or $\\tilde{\\mathbf{x}}_{i}=\\mathsf{s y m m}(\\mathbf{x}_{i})$ . Importantly, it is known that both cases allow for universality, see [8, 29] and [79, 62] respectively. ", "page_idx": 5}, {"type": "text", "text": "", "page_idx": 6}, {"type": "text", "text": "Challenge 2 - Rescaling: Different multipliers. Scale equivariance alone is not sufficient, since the input vectors of the message function $\\mathbf{M}\\mathbf{S}\\mathbf{G}_{V}$ are scaled by different multipliers - central vertex: $q_{\\ell}(i)$ , neighbour: $q_{\\ell-1}(j)$ , edge: $q\\ell^{(i)}q_{\\ell-1}^{-1}(j)$ , while its output should be scaled differently as well - $q_{\\ell}(i)$ . We refer to this problem as rescaling. Dealing with Challenge 2 requires functions of the form: ", "page_idx": 6}, {"type": "equation", "text": "$$\ng\\big(q_{1}\\mathbf{x}_{1},\\dots q_{n}\\mathbf{x}_{n}\\big)=g\\big(\\mathbf{x}_{1},\\dots\\mathbf{x}_{n}\\big)\\prod_{i=1}^{n}q_{i},\\forall q_{i}\\in D_{i}.\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "We call these functions rescale equivariant. Note, that this is an unusual symmetry in equivariant NN design. Our approach is based on the observation that any $n$ -other monomial containing variables from all vectors $\\mathbf{x}_{i}$ is rescale-equivariant. Collecting all these monomials into a single representation is precisely the outer product ${\\pmb X}_{n}={\\bf x}_{1}\\otimes\\cdot\\cdot\\cdot\\otimes{\\bf x}_{n}$ , where $\\begin{array}{r}{\\pmb{\\mathsf{X}}_{n}(j_{1},\\dotsc,j_{n})=\\prod_{i=1}^{n}\\mathsf{\\tilde{x}}_{i}(j_{i})}\\end{array}$ . Therefore, the general form of our proposed Rescale Equivariant Network is as follow s: ", "page_idx": 6}, {"type": "equation", "text": "$$\n{\\mathsf{R e S c a l e E q}}(\\mathbf{x}_{1},\\ldots\\mathbf{x}_{n})={\\mathsf{S c a l e E q}}\\left({\\mathsf{v e c}}(\\mathbf{X}_{n})\\right).\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "In practice, given that the size of $\\pmb{\\ X}_{n}$ grows polynomially with $n$ , we resort to a more computationally friendly subcase, i.e. hadamard products, i.e. ReScaleEq $\\left(\\mathbf{x}_{1},.\\;.\\;.\\;.\\;\\mathbf{x}_{n}\\right)=\\odot_{i=1}^{n}\\mathbf{T}_{i}\\mathbf{x}_{i}$ , $\\Gamma_{i}^{\\,\\,^{\\,\\lambda}}:\\mathcal{X}_{i}\\rightarrow\\mathbb{R}^{\\tilde{d}}$ . Contrary to the original formulation, the latter is linear (lack of multiplication with an invariant layer). ", "page_idx": 6}, {"type": "text", "text": "Scale Equivariant Message Passing. We are now ready to define our message-passing scheme. Starting with the message function, we require each message vector $\\mathbf{m}_{V}(i)$ to have the same symmetries as the central vertex $i$ . Given the scaling symmetries of the neighbour and the edge, for forward neighbourhoods, this reads: $\\mathbf{MSG}_{V}$ $\\left(q_{x}\\mathbf{x},\\breve{q_{y}}\\breve{\\mathbf{y}},q_{x}q_{y}^{-1}\\mathbf{e}\\right)=q_{x}\\mathrm{MS}\\breve{\\mathrm{G}_{V}}\\left(\\mathbf{x},\\mathbf{y},\\mathbf{e}\\right).$ . In this case, we opt to eliminate $q_{y}$ by multiplication as follows: ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\mathrm{MSG}_{V}\\left(\\mathbf{x},\\mathbf{y},\\mathbf{e}\\right)=\\mathsf{S c a l e E q}\\left(\\left[\\mathbf{x},\\mathsf{R e S c a l e E q}\\left(\\mathbf{y},\\mathbf{e}\\right)\\right]\\right),\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "where $[\\cdot,\\cdot]$ denotes concatenation, ReScaleEq $(q_{y}\\mathbf{y},q_{x}q_{y}^{-1}\\mathbf{e})=q_{x}\\mathsf{R e S c a l e E q}(\\mathbf{y},\\mathbf{e})$ . In our experiments, we used only $\\mathbf{y}$ and $\\mathbf{e}$ , since we did not observe significant performance gains by including the central vertex x. Now, the update function is straightforward to implement since it receives vectors with the same symmetry, i.e. it should hold that: $\\mathrm{UPD}_{V}\\big(q_{x}\\mathbf{x},q_{x}\\mathbf{\\dot{m}}\\big)=q_{x}\\mathrm{UPD}_{V}\\big(\\mathbf{x},\\mathbf{m}\\big)$ which is straightforward to implement with a scale equivariant network, after concatenating $\\mathbf{x}$ and $\\mathbf{m}$ : ", "page_idx": 6}, {"type": "equation", "text": "$$\n\\mathrm{UPD}_{V}\\left(\\mathbf{x},\\mathbf{m}\\right)=\\mathsf{S c a l e E q}\\left(\\left[\\mathbf{x},\\mathbf{m}\\right]\\right).\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "Finally, to summarise our graph into a single scalar/vector we require a scale and permutationinvariant readout. The former is once more achieved using canonicalised/symmetrised versions of the vertex representations of hidden neurons, while the latter using a DeepSets architecture as usual: ", "page_idx": 6}, {"type": "equation", "text": "$$\n{\\mathrm{READ}}_{V}\\left(\\mathbf{X}\\right):={\\mathsf{D e e p S e t s}}\\left({\\tilde{\\mathbf{x}}}_{1},\\ldots,{\\tilde{\\mathbf{x}}}_{n}\\right),\\quad{\\tilde{\\mathbf{x}}}_{i}={\\mathsf{c a n o n}}_{i}\\left(\\mathbf{x}_{i}\\right){\\mathrm{~or}}\\,{\\tilde{\\mathbf{x}}}_{i}={\\mathsf{s y m m}}_{i}\\left(\\mathbf{x}_{i}\\right)\n$$", "text_format": "latex", "page_idx": 6}, {"type": "text", "text": "In Appendix A.1, we show how to handle symmetries in the rest of the architecture components (i.e. initialisation, positional encodings, edge updates and i/o vertices) and provide an extension of our method to bidirectional message-passing (Appendix A.2), which includes backward neighbourhoods. ", "page_idx": 6}, {"type": "text", "text": "Expressive power. Throughout this section, we discussed only scaling symmetries and not permutation symmetries. However, it is straightforward to conclude that ScaleGMN is also permutation equivariant/invariant, since it is a subcase of GMNs; if one uses universal approximators in their message/update functions (MLP), our corresponding functions will be expressible by this architecture, which was proved to be permutation equivariant in [44]. Although this implies that GMN can express ScaleGMN, this is expected since $\\mathbf{PQ}$ symmetries are more restrictive than just $\\mathbf{P}$ . Note that these symmetries are always present in FFNNs, and thus it is desired to explicitly model them, to introduce a more powerful inductive bias. Formally, on symmetry preservation (proved in Appendix A.7.2): ", "page_idx": 6}, {"type": "table", "img_path": "8Fxqn1tZM1/tmp/48f660dcf66d70f0768c3b1496179fe699d3618d520da4e99516762ac99c040b.jpg", "table_caption": ["Table 1: INR classification on MNIST, F-MNIST, CIFAR-10 and Aug. CIFAR-10. We train all methods on 3 seeds and report the mean and std. (\\*) denotes the baselines trained by us and we report the rest as in the corresponding papers. Colours denote First, Second and Third. "], "table_footnote": [], "page_idx": 7}, {"type": "table", "img_path": "8Fxqn1tZM1/tmp/2ab4faa98120ae3b6085b826f8981757fa68f4cb45d01fa91759a64b312d393c.jpg", "table_caption": ["Table 2: Generalization pred.: Kendall- $\\tau$ on subsets of SmallCNN Zoo w/ ReLU/Tanh activations. ", "Proposition 5.1. ScaleGMN is permutation & scale equivariant. Additionally, ScaleGMN is permutation & scale invariant when using a readout with the same symmetries. "], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "Finally, we analysed the ability of ScaleGMN to evaluate the input FFNN and its gradients, i.e. simulate the forward and the backward pass of an input FFNN. To see why this is a desired inductive bias, recall that a functional/operator can often be written as a function of input-output pairs (e.g. via an integral on the entire domain) or of the input function\u2019s derivatives (e.g. via a differential equation). By simulating the FFNN, one can reconstruct function evaluations and gradients, which an additional module can later combine. Formally (proof and precise statement in Appendix A.7.2): ", "page_idx": 7}, {"type": "text", "text": "Theorem 5.2. Consider an FFNN as per Eq. (1) with activation functions respecting the conditions of Proposition 4.1. Assume a Bidirectional-ScaleGMN with sufficiently expressive message and vertex update functions. Then, ScaleGMN can simulate both the forward and the backward pass of the FFNN for arbitrary inputs, when ScaleGMN\u2019s iterations (depth) are L and 2L respectively. ", "page_idx": 7}, {"type": "text", "text": "6 Experiments ", "text_level": 1, "page_idx": 7}, {"type": "text", "text": "Datasets. We evaluate ScaleGMN on datasets containing NNs with three popular activation functions: sine, ReLU and tanh. The former is prevalent in INRs, which in turn are the most appropriate testbed for GMNs. We experiment with the tasks of (1) INR classification (invariant task), i.e. classifying functions (signals) represented as INRs and (2) INR editing (equivariant), i.e. transforming those functions. Additionally, ReLU and tanh are common in neural classifiers/regressors. A popular GMN benchmark for those is (3) generalisation prediction (invariant), i.e. predicting a classifier\u2019s test accuracy. Here, classifiers instead of FFNNs are typically CNNs (for computer vision tasks) and to this end, we extend our method to the latter in Appendix A.3. We use existing datasets that have been constructed by the authors of relevant methods, are publicly released and have been repeatedly used in the literature (8 datasets in total, 4 for each task). Finally, we follow established protocols: we perform a hyperparameter search and use the best-achieved validation metric throughout training to select our final model. We report the test metric on the iteration where the best validation is achieved. ", "page_idx": 7}, {"type": "table", "img_path": "8Fxqn1tZM1/tmp/6538f0cd1446f3cd262a59c040f9b00944efcf97f10a70cab3c78d446390d1db.jpg", "table_caption": ["Table 3: Dilating MNIST INRs. MSE between the reconstructed and ground-truth image. "], "table_footnote": [], "page_idx": 8}, {"type": "table", "img_path": "8Fxqn1tZM1/tmp/d3b48104834c8730b3786aa3c983c97b92d6ec701800a77d2732e1fbc57b98ba.jpg", "table_caption": ["Table 4: Ablation: Permutation equivariant models $^+$ scaling augmentations. "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "Baselines. DWS [54] is a non-local metanetwork that uses all linear permutation equivariant/invariant layers interleaved with non-linearities. $\\mathrm{NFN}_{\\mathrm{HNP}}$ [85] is mathematically equivalent to DWS, while $\\mathrm{NFN_{NP}}$ [85] makes stronger symmetry assumptions in favour of parameter efficiency. The two variants are also designed to process CNNs contrary to DWS. NG-GNN [33] converts each input NN to a graph (similar to our work) and employs a GNN (in specific PNA [15]). Importantly, the last three methods transform the input parameters with random Fourier features while all methods perform input normalisations to improve performance and facilitate training. These tricks are in general not equivariant to scaling and were unnecessary in the ScaleGMN experiments (more details in Appendix A.4). On INR classification we include a naive MLP on the flattened parameter vector and Inr2Vec [47], a task-specific non-equivariant method. For generalization prediction, we also compare to StatNN [74], which predicts NN accuracy based on statistical features of its weights/biases. ", "page_idx": 8}, {"type": "text", "text": "INR classification. We design a ScaleGMN with permutation & sign equivariant components (and invariant readout). Additionally, we experiment with the bidirectional version denoted as ScaleGMN$B$ . We use the following datasets of increasing difficulty: MNIST INR, $F$ -MNIST INR (grayscale images) and CIFAR10-INR, Aug. CIFAR10-INR.: INRs representing images from the MNIST [38], FashionMNIST [76] and CIFAR [35] datasets resp. and an augmented version of CIFAR10-INR containing 20 different INRs for each image, trained from different initialisations (often called views). The reported metric is test accuracy. Note that [85, 86] use only the augmented dataset and hence we rerun all baselines for the original version. All input NNs correspond to functions $u_{G,\\pmb\\theta}:\\mathbb{R}^{2}\\rightarrow\\mathbb{R}^{c}$ , i.e. pixel coordinate to GS/RGB value. Further implementation details can be found in Appendix A.4.1. As shown in Table 1, ScaleGMN consistently outperforms all baselines in all datasets considered, with performance improvements compared to the state-of-the-art ranging from approx. $3\\%$ (CIFAR-10) to $13\\%$ (F-MNIST). While previous methods often resort to additional engineering strategies, such as probe features and advanced architectures [33] or extra training samples [85] to boost performance, in our case this was possible using vanilla ScaleGMNs. For example, in MNIST and F-MNIST, NG-GNN achieves $94.7\\pm0.3$ and $74.2\\pm0.4$ with 64 probe features which is apprpx. $2\\%$ and $6\\%$ below our best performance. The corresponding results for NG-T [33] (transformer) were $97.3\\!\\pm\\!0.2$ and $74.8\\pm0.9$ , still on par or approx. $6\\%$ below ScaleGMN. Note that all the above are orthogonal to our work and can be used to further improve performance. ", "page_idx": 8}, {"type": "text", "text": "Predicting CNN Generalization from weights. As in prior works. we consider datasets of image classifiers and measure predictive performance using Kendall\u2019s $\\tau$ [30]. We select the two datasets used in [85], namely CIFAR-10-GS and SVHN-GS originally from Small CNN Zoo [74]. These contain CNNs with ReLU or tanh activations, which exhibit scale and sign symmetries respectively. To assess the performance of our method (1) on each activation function individually and (2) on a dataset with heterogeneous activation functions we discern distinct paths for this experiment. In the first case, we split each dataset into two subsets each containing the same activation and evaluate all baselines. As shown in Table 2, once again ScaleGMN outperforms all the baselines in all the examined datasets. This highlights the ability of our method to be used across different activation functions and architectures. Performance improvements here are less prominent due to the hardness of the task, a phenomenon also observed in the comparisons between prior works. Note that in this case, additional symmetries arise by the softmax classifier [36], which are currently not accounted for by none of the methods. We additionally evaluate our method on heterogeneous activation functions. ", "page_idx": 8}, {"type": "text", "text": "In principle, our method does not impose limitations regarding the homogeneity of the activation functions of the input NNs - all one needs is to have a different canonicalisation/symmetrisation module for each activation. Experiments on CIFAR-10-GS show that ScaleGMN yields superior performance compared to the baselines, significantly exceeding the performance of the next-best model. Further implementation details can be found in Appendix A.4.2. ", "page_idx": 9}, {"type": "text", "text": "INR editing. Here, our goal is to transform the weights of the input NN, to modify the underlying signal to a new one. In this case, our method should be equivariant to the permutation and scaling symmetries, such that every pair of equivalent input NNs is mapped to a pair of equivalent output NNs. Hence, we employ a ScaleGMN similar to the above experiments but omit the invariant readout layer. Following [33], we evaluate our method on the MNIST dataset and train our model to dilate the encoded MNIST digits. Further implementation details can be found in Appendix A.4.3. As shown in Table 3, our bidirectional ScaleGMN-B achieves an MSE test loss $(\\bar{10}^{-2})$ equal to 1.891, surpassing all permutation equivariant baselines. Notably, our method also outperforms the NG-GNN [33] baseline that uses 64 probe features. Additionally, our forward variant, ScaleGMN, performs on par with the previous permutation equivariant baselines with an MSE loss of 2.56. Note that the performance gap between the forward and the bidirectional model is probably expected for equivariant tasks: here we are required to compute representations for every node of the graph, yet in the forward variant, the earlier the layer of the node, the smaller the amount of information it receives. This observation corroborates the design choices of the baselines, which utilize either bidirectional mechanisms (NG-GNN [33]) or non-local operations (NFN [85]). ", "page_idx": 9}, {"type": "text", "text": "Ablation study: Scaling data augmentations. We baseline our method with permutation equivariant methods trained with scaling augmentations: For every training datapoint, at each training iteration, we sample a diagonal scaling matrix for every hidden layer of the input NN and multiply it with the weights/bias matrices as per Eq. (3) (omitting the permutation matrices). We sample the elements of the matrices independently as follows: Sign symmetry: Bernoulli distribution with probability 0.5. Positive scaling: Exponential distribution where the coefficient $\\lambda$ is a hyperparameter that we tune on the validation set. Observe here that designing augmentations in the latter case is a particularly challenging task since we have to sample from a continuous and unbounded distribution. Our choice of the exponential was done by consulting the norm plots where in some cases the histogram resembles an exponential Fig. 1. Nevertheless, regardless of the distribution choice we cannot guarantee that the augmentations will be sufficient to achieve (approximate) scaling equivariance, due to the lack of upper bound. We evaluate on the F-MNIST dataset for the sign symmetry and on the CIFAR-10-GS-ReLU for the positive scale. As shown in Table 4, regarding the former, augmenting the training set leads consistently to better results when compared to the original baselines. None of these methods however achieved results on par with ScaleGMN and ScaleGMN-B. On the other hand, we were unable to even surpass the original baselines regarding the latter task. This indicates that designing an effective positive scaling augmentation might be a non-trivial task. ", "page_idx": 9}, {"type": "text", "text": "Limitations. A limitation of our work is that it is currently designed for FFNNs and CNNs and does not cover other layers that either modify the computational graph (e.g. skip connections) or introduce additional symmetries (e.g. softmax and normalisation layers). In both cases, in future work, we plan to characterise scaling symmetries (certain steps were made in [25]) and modify ScaleGMN for general computational graphs as in [44, 88]. Additionally, a complete characterisation of the functions that can be expressed by our scale/rescale equivariant building blocks is an open question (except for sign [40]). Finally, an important theoretical matter is a complete characterisation of the expressive power of ScaleGMN, similar to all equivariant metanetworks. ", "page_idx": 9}, {"type": "text", "text": "7 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In this work, we propose ScaleGMN a metanetwork framework that introduces to the field of NN processing a stronger inductive bias: accounting for function-preserving scaling symmetries that arise from activation functions. ScaleGMN can be applied to NNs with various activation functions by modifying any graph metanetwork, is proven to enjoy desirable theoretical guarantees and empirically demonstrates the significance of scaling by improving the state-of-the-art in several datasets. With our work, we aspire to introduce a new research direction, i.e. incorporating into metanetworks various NN symmetries beyond permutations, aiming to improve their generalisation capabilities and broaden their applicability in various NN processing domains. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgements ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "IK, GB and YP were partially supported by project MIS 5154714 of the National Recovery and Resilience Plan Greece 2.0 funded by the European Union under the NextGenerationEU Program. This work was partially supported by a computational resources grant from The Cyprus Institute (HPC system \u201cCyclone\u201d) as well as from an AWS credits grant provided by GRNET \u2013 National Infrastructures for Research and Technology. ", "page_idx": 10}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[1] Samuel K. Ainsworth, Jonathan Hayase, and Siddhartha S. Srinivasa. Git re-basin: Merging models modulo permutation symmetries. In The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023. OpenReview.net, 2023.   \n[2] Francesca Albertini and Eduardo D Sontag. Identifiability of discrete-time neural networks. In Proc. European Control Conference, pages 460\u2013465. Springer Berlin, 1993.   \n[3] Francesca Albertini and Eduardo D Sontag. For neural networks, function determines form. Neural networks, 6(7):975\u2013990, 1993.   \n[4] Shun-Ichi Amari. Natural gradient works efficiently in learning. Neural computation, 10(2): 251\u2013276, 1998.   \n[5] Marco Armenta, Thierry Judge, Nathan Painchaud, Youssef Skandarani, Carl Lemaire, Gabriel Gibeau Sanchez, Philippe Spino, and Pierre-Marc Jodoin. Neural teleportation. Mathematics, 11(2):480, 2023.   \n[6] Vijay Badrinarayanan, Bamdev Mishra, and Roberto Cipolla. Understanding symmetries in deep networks. NIPS Workshop on Optimization for Machine Learning (OPT2015), 2015.   \n[7] Matthias Bauer, Emilien Dupont, Andy Brock, Dan Rosenbaum, Jonathan Richard Schwarz, and Hyunjik Kim. Spatial functa: Scaling functa to imagenet classification and generation. arXiv preprint arXiv: 2302.03130, 2023.   \n[8] Benjamin Bloem-Reddy, Yee Whye, et al. Probabilistic symmetries and invariant neural networks. Journal of Machine Learning Research, 21(90):1\u201361, 2020.   \n[9] L\u00e9on Bottou and Patrick Gallinari. A framework for the cooperation of learning algorithms. Advances in neural information processing systems, 3, 1990.   \n[10] Michael M Bronstein, Joan Bruna, Taco Cohen, and Petar Velic\u02c7kovic\u00b4. Geometric deep learning: Grids, groups, graphs, geodesics, and gauges. arXiv preprint arXiv:2104.13478, 2021.   \n[11] An Mei Chen, Haw-minn Lu, and Robert Hecht-Nielsen. On the geometry of feedforward neural network error surfaces. Neural computation, 5(6):910\u2013927, 1993.   \n[12] Tianlong Chen, Xiaohan Chen, Wuyang Chen, Howard Heaton, Jialin Liu, Zhangyang Wang, and Wotao Yin. Learning to optimize: A primer and a benchmark. Journal of Machine Learning Research, 23(189):1\u201359, 2022.   \n[13] Zhiqin Chen and Hao Zhang. Learning implicit fields for generative shape modeling. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 5939\u20135948, 2019.   \n[14] Minhyung Cho and Jaehyung Lee. Riemannian approach to batch normalization. Advances in Neural Information Processing Systems, 30, 2017.   \n[15] Gabriele Corso, Luca Cavalleri, Dominique Beaini, Pietro Li\u00f2, and Petar Velic\u02c7kovic\u00b4. Principal neighbourhood aggregation for graph nets. Advances in Neural Information Processing Systems, 33:13260\u201313271, 2020.   \n[16] Laurent Dinh, Razvan Pascanu, Samy Bengio, and Yoshua Bengio. Sharp minima can generalize for deep nets. In International Conference on Machine Learning, pages 1019\u20131028. PMLR, 2017.   \n[17] Simon S Du, Wei Hu, and Jason D Lee. Algorithmic regularization in learning deep homogeneous models: Layers are automatically balanced. Advances in neural information processing systems, 31, 2018.   \n[18] Emilien Dupont, Hyunjik Kim, S. M. Ali Eslami, Danilo Jimenez Rezende, and Dan Rosenbaum. From data to functa: Your data point is a function and you can treat it like one. In Kamalika Chaudhuri, Stefanie Jegelka, Le Song, Csaba Szepesvari, Gang Niu, and Sivan Sabato, editors, Proceedings of the 39th International Conference on Machine Learning, volume 162 of Proceedings of Machine Learning Research, pages 5694\u20135725. PMLR, 17\u201323 Jul 2022. URL https://proceedings.mlr.press/v162/dupont22a.html.   \n[19] Gabriel Eilertsen, Daniel J\u00f6nsson, Timo Ropinski, Jonas Unger, and Anders Ynnerman. Classifying the classifier: Dissecting the weight space of neural networks. In ECAI 2020 - 24th European Conference on Artificial Intelligence, Frontiers in Artificial Intelligence and Applications, pages 1119\u20131126. IOS Press, 2020.   \n[20] Rahim Entezari, Hanie Sedghi, Olga Saukh, and Behnam Neyshabur. The role of permutation invariance in linear mode connectivity of neural networks. In The Tenth International Conference on Learning Representations, ICLR 2022, Virtual Event, April 25-29, 2022. OpenReview.net, 2022.   \n[21] Charles Fefferman and Scott Markel. Recovering a feed-forward net from its output. Advances in neural information processing systems, 6, 1993.   \n[22] Jonathan Frankle and Michael Carbin. The lottery ticket hypothesis: Finding sparse, trainable neural networks. In International Conference on Learning Representations, 2019. URL https://openreview.net/forum?id=rJl-b3RcF7.   \n[23] Cedric Gegout, Bernard Girau, and Fabrice Rossi. A mathematical model for feed-forward neural networks: theoretical description and parallel applications. PhD thesis, Laboratoire de l\u2019informatique du parall\u00e9lisme, 1995.   \n[24] Justin Gilmer, Samuel S. Schoenholz, Patrick F. Riley, Oriol Vinyals, and George E. Dahl. Neural message passing for quantum chemistry. In Doina Precup and Yee Whye Teh, editors, Proceedings of the 34th International Conference on Machine Learning, ICML 2017, Sydney, NSW, Australia, 6-11 August 2017, volume 70 of Proceedings of Machine Learning Research, pages 1263\u20131272. PMLR, 2017. URL http://proceedings.mlr.press/v70/gilmer17a. html.   \n[25] Charles Godfrey, Davis Brown, Tegan Emerson, and Henry Kvinge. On the symmetries of deep learning models and their internal representations. Advances in Neural Information Processing Systems, 35:11893\u201311905, 2022.   \n[26] Elisenda Grigsby, Kathryn Lindsey, and David Rolnick. Hidden symmetries of relu networks. In International Conference on Machine Learning, pages 11734\u201311760. PMLR, 2023.   \n[27] David Ha, Andrew M. Dai, and Quoc V. Le. Hypernetworks. In International Conference on Learning Representations, 2017. URL https://openreview.net/forum?id $=$ rkpACe1lx.   \n[28] Robert Hecht-Nielsen. On the algebraic structure of feedforward network weight spaces. In Advanced Neural Computers, pages 129\u2013135. Elsevier, 1990.   \n[29] S\u00e9kou-Oumar Kaba, Arnab Kumar Mondal, Yan Zhang, Yoshua Bengio, and Siamak Ravanbakhsh. Equivariance with learned canonicalization functions. In International Conference on Machine Learning, pages 15546\u201315566. PMLR, 2023.   \n[30] Maurice G Kendall. A new measure of rank correlation. Biometrika, 30(1/2):81\u201393, 1938.   \n[31] Boris Knyazev, Michal Drozdzal, Graham W Taylor, and Adriana Romero Soriano. Parameter prediction for unseen deep architectures. Advances in Neural Information Processing Systems, 34:29433\u201329448, 2021.   \n[32] Boris Knyazev, Doha Hwang, and Simon Lacoste-Julien. Can we scale transformers to predict parameters of diverse imagenet models? In International Conference on Machine Learning, pages 17243\u201317259. PMLR, 2023.   \n[33] Miltiadis Kofinas, Boris Knyazev, Yan Zhang, Yunlu Chen, Gertjan J. Burghouts, Efstratios Gavves, Cees G. M. Snoek, and David W. Zhang. Graph neural networks for learning equivariant representations of neural networks. In The Twelfth International Conference on Learning Representations, 2024. URL https://openreview.net/forum?id=oO6FsMyDBt.   \n[34] Nikola Kovachki, Zongyi Li, Burigede Liu, Kamyar Azizzadenesheli, Kaushik Bhattacharya, Andrew Stuart, and Anima Anandkumar. Neural operator: Learning maps between function spaces with applications to pdes. Journal of Machine Learning Research, 24(89):1\u201397, 2023.   \n[35] Alex Krizhevsky, Geoffrey Hinton, et al. Learning multiple layers of features from tiny images.(2009), 2009.   \n[36] Daniel Kunin, Javier Sagastuy-Brena, Surya Ganguli, Daniel LK Yamins, and Hidenori Tanaka. Neural mechanics: Symmetry and broken conservation laws in deep learning dynamics. In International Conference on Learning Representations, 2021.   \n[37] Ve\u02c7ra Ku\u02darkov\u00e1 and Paul C Kainen. Functionally equivalent feedforward neural networks. Neural Computation, 6(3):543\u2013558, 1994.   \n[38] Yann LeCun, L\u00e9on Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11):2278\u20132324, 1998.   \n[39] Derek Lim, Joshua Robinson, Stefanie Jegelka, and Haggai Maron. Expressive sign equivariant networks for spectral geometric learning. In Alice Oh, Tristan Naumann, Amir Globerson, Kate Saenko, Moritz Hardt, and Sergey Levine, editors, Advances in Neural Information Processing Systems 36: Annual Conference on Neural Information Processing Systems 2023, NeurIPS 2023, New Orleans, LA, USA, December 10 - 16, 2023, 2023. URL http://papers.nips.cc/paper_files/paper/2023/hash/ 3516aa3393f0279e04c099f724664f99-Abstract-Conference.html.   \n[40] Derek Lim, Joshua Robinson, Stefanie Jegelka, and Haggai Maron. Expressive sign equivariant networks for spectral geometric learning. In Thirty-seventh Conference on Neural Information Processing Systems, 2023. URL https://openreview.net/forum?id=UWd4ysACo4.   \n[41] Derek Lim, Joshua David Robinson, Lingxiao Zhao, Tess Smidt, Suvrit Sra, Haggai Maron, and Stefanie Jegelka. Sign and basis invariant networks for spectral graph representation learning. In The Eleventh International Conference on Learning Representations, 2023.   \n[42] Derek Lim, Joshua David Robinson, Lingxiao Zhao, Tess E. Smidt, Suvrit Sra, Haggai Maron, and Stefanie Jegelka. Sign and basis invariant networks for spectral graph representation learning. In The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023. OpenReview.net, 2023. URL https://openreview.net/ pdf?id=Q-UHqMorzil.   \n[43] Derek Lim, Joshua David Robinson, Lingxiao Zhao, Tess E. Smidt, Suvrit Sra, Haggai Maron, and Stefanie Jegelka. Sign and basis invariant networks for spectral graph representation learning. In The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023. OpenReview.net, 2023. URL https://openreview.net/ pdf?id= $\\because\\mathsf{Q}$ -UHqMorzil.   \n[44] Derek Lim, Haggai Maron, Marc T. Law, Jonathan Lorraine, and James Lucas. Graph metanetworks for processing diverse neural architectures. In The Twelfth International Conference on Learning Representations (ICLR), 2024.   \n[45] Hanxiao Liu, Karen Simonyan, and Yiming Yang. DARTS: Differentiable architecture search. In International Conference on Learning Representations, 2019. URL https://openreview. net/forum?id $\\cdot$ S1eYHoC5FX.   \n[46] Lu Lu, Pengzhan Jin, Guofei Pang, Zhongqiang Zhang, and George Em Karniadakis. Learning nonlinear operators via DeepONet based on the universal approximation theorem of operators. Nature Machine Intelligence, 3(3):218\u2013229, 2021.   \n[47] Luca De Luigi, Adriano Cardace, Riccardo Spezialetti, Pierluigi Zama Ramirez, Samuele Salti, and Luigi Di Stefano. Deep learning on implicit neural representations of shapes. In The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023. OpenReview.net, 2023. URL https://openreview.net/pdf?id $\\equiv$ OoOIW-3uadi.   \n[48] George Ma, Yifei Wang, Derek Lim, Stefanie Jegelka, and Yisen Wang. A canonization perspective on invariant and equivariant learning. arXiv preprint arXiv:2405.18378, 2024.   \n[49] George Ma, Yifei Wang, and Yisen Wang. Laplacian canonization: A minimalist approach to sign and basis invariant spectral embedding. Advances in Neural Information Processing Systems, 36, 2024.   \n[50] Haggai Maron, Heli Ben-Hamu, Nadav Shamir, and Yaron Lipman. Invariant and equivariant graph networks. In 7th International Conference on Learning Representations, ICLR 2019, New Orleans, LA, USA, May 6-9, 2019. OpenReview.net, 2019. URL https://openreview.net/ forum?id $\\equiv$ Syx72jC9tm.   \n[51] Qi Meng, Shuxin Zheng, Huishuai Zhang, Wei Chen, Qiwei Ye, Zhi-Ming Ma, Nenghai Yu, and Tie-Yan Liu. G-SGD: optimizing relu neural networks in its positively scale-invariant space. In 7th International Conference on Learning Representations, ICLR 2019, New Orleans, LA, USA, May 6-9, 2019. OpenReview.net, 2019.   \n[52] Lars Mescheder, Michael Oechsle, Michael Niemeyer, Sebastian Nowozin, and Andreas Geiger. Occupancy networks: Learning 3d reconstruction in function space. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 4460\u20134470, 2019.   \n[53] Ben Mildenhall, Pratul P. Srinivasan, Matthew Tancik, Jonathan T. Barron, Ravi Ramamoorthi, and Ren Ng. Nerf: representing scenes as neural radiance fields for view synthesis. Commun. ACM, 65(1):99\u2013106, 2022.   \n[54] Aviv Navon, Aviv Shamsian, Idan Achituve, Ethan Fetaya, Gal Chechik, and Haggai Maron. Equivariant architectures for learning in deep weight spaces. In International Conference on Machine Learning, pages 25790\u201325816. PMLR, 2023.   \n[55] Aviv Navon, Aviv Shamsian, Ethan Fetaya, Gal Chechik, Nadav Dym, and Haggai Maron. Equivariant deep weight space alignment. In Forty-first International Conference on Machine Learning, ICML 2024, Vienna, Austria, July 21-27, 2024, 2024. URL https://openreview. net/forum?id $=$ nBPnmk6EeO.   \n[56] Behnam Neyshabur, Russ R Salakhutdinov, and Nati Srebro. Path-sgd: Path-normalized optimization in deep neural networks. Advances in neural information processing systems, 28, 2015.   \n[57] Jeong Joon Park, Peter Florence, Julian Straub, Richard Newcombe, and Steven Lovegrove. Deepsdf: Learning continuous signed distance functions for shape representation. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 165\u2013174, 2019.   \n[58] William Peebles, Ilija Radosavovic, Tim Brooks, Alexei Efros, and Jitendra Malik. Learning to learn with generative models of neural network checkpoints. arXiv preprint arXiv:2209.12892, 2022.   \n[59] Fidel A Guerrero Pe\u00f1a, Heitor Rapela Medeiros, Thomas Dubail, Masih Aminbeidokhti, Eric Granger, and Marco Pedersoli. Re-basin via implicit sinkhorn differentiation. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 20237\u201320246, 2023.   \n[60] Tobias Pfaff, Meire Fortunato, Alvaro Sanchez-Gonzalez, and Peter W. Battaglia. Learning mesh-based simulation with graph networks. In 9th International Conference on Learning Representations, ICLR 2021. OpenReview.net, 2021.   \n[61] Mary Phuong and Christoph H. Lampert. Functional vs. parametric equivalence of re{lu} networks. In International Conference on Learning Representations, 2020.   \n[62] Omri Puny, Matan Atzmon, Edward J. Smith, Ishan Misra, Aditya Grover, Heli Ben-Hamu, and Yaron Lipman. Frame averaging for invariant and equivariant network design. In The Tenth International Conference on Learning Representations, ICLR 2022, Virtual Event, April 25-29, 2022. OpenReview.net, 2022.   \n[63] Charles R Qi, Hao Su, Kaichun Mo, and Leonidas J Guibas. Pointnet: Deep learning on point sets for 3d classification and segmentation. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 652\u2013660, 2017.   \n[64] David Rolnick and Konrad Kording. Reverse-engineering deep relu networks. In International conference on machine learning, pages 8178\u20138187. PMLR, 2020.   \n[65] J\u00fcrgen Schmidhuber. Learning to control fast-weight memories: An alternative to dynamic recurrent networks. Neural Computation, 4(1):131\u2013139, 1992.   \n[66] Konstantin Sch\u00fcrholt, Dimche Kostadinov, and Damian Borth. Self-supervised representation learning on neural network weights for model characteristic prediction. Advances in Neural Information Processing Systems, 34:16481\u201316493, 2021.   \n[67] Konstantin Sch\u00fcrholt, Boris Knyazev, Xavier Gir\u00f3-i Nieto, and Damian Borth. Hyperrepresentations as generative models: Sampling unseen neural network weights. Advances in Neural Information Processing Systems, 35:27906\u201327920, 2022.   \n[68] Louis Serrano, Lise Le Boudec, Armand Kassa\u00ef Koupa\u00ef, Thomas X Wang, Yuan Yin, Jean-No\u00ebl Vittaut, and Patrick Gallinari. Operator learning with neural fields: Tackling pdes on general geometries. Advances in Neural Information Processing Systems, 36, 2024.   \n[69] Sidak Pal Singh and Martin Jaggi. Model fusion via optimal transport. Advances in Neural Information Processing Systems, 33:22045\u201322055, 2020.   \n[70] Vincent Sitzmann, Julien Martel, Alexander Bergman, David Lindell, and Gordon Wetzstein. Implicit neural representations with periodic activation functions. Advances in neural information processing systems, 33:7462\u20137473, 2020.   \n[71] Pierre Stock, Benjamin Graham, R\u00e9mi Gribonval, and Herv\u00e9 J\u00e9gou. Equi-normalization of neural networks. In 7th International Conference on Learning Representations, ICLR 2019, New Orleans, LA, USA, May 6-9, 2019. OpenReview.net, 2019.   \n[72] Veronika Thost and Jie Chen. Directed acyclic graph neural networks. In International Conference on Learning Representations, 2021. URL https://openreview.net/forum? id=JbuYF437WB6.   \n[73] Hoang V Tran, Thieu N Vo, Tho H Tran, An T Nguyen, and Tan Minh Nguyen. Monomial matrix group equivariant neural functional networks. arXiv preprint arXiv:2409.11697, 2024.   \n[74] Thomas Unterthiner, Daniel Keysers, Sylvain Gelly, Olivier Bousquet, and Ilya Tolstikhin. Predicting neural network accuracy from weights. arXiv preprint arXiv:2002.11448, 2020.   \n[75] Mitchell Wortsman, Gabriel Ilharco, Samir Ya Gadre, Rebecca Roelofs, Raphael Gontijo-Lopes, Ari S Morcos, Hongseok Namkoong, Ali Farhadi, Yair Carmon, Simon Kornblith, et al. Model soups: averaging weights of multiple fine-tuned models improves accuracy without increasing inference time. In International conference on machine learning, pages 23965\u201323998. PMLR, 2022.   \n[76] Han Xiao, Kashif Rasul, and Roland Vollgraf. Fashion-mnist: a novel image dataset for benchmarking machine learning algorithms. arXiv preprint arXiv:1708.07747, 2017.   \n[77] Saining Xie, Alexander Kirillov, Ross Girshick, and Kaiming He. Exploring randomly wired neural networks for image recognition. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 1284\u20131293, 2019.   \n[78] Dejia Xu, Peihao Wang, Yifan Jiang, Zhiwen Fan, and Zhangyang Wang. Signal processing for implicit neural representations. In Advances in Neural Information Processing Systems 35: Annual Conference on Neural Information Processing Systems 2022, NeurIPS 2022, New Orleans, LA, USA, November 28 - December 9, 2022, 2022. URL http://papers.nips.cc/paper_files/paper/2022/hash/ 575c450013d0e99e4b0ecf82bd1afaa4-Abstract-Conference.html.   \n[79] Dmitry Yarotsky. Universal approximations of invariant maps by neural networks. Constructive Approximation, 55(1):407\u2013474, 2022.   \n[80] Jiaxuan You, Jure Leskovec, Kaiming He, and Saining Xie. Graph structure of neural networks. In Hal Daum\u00e9 III and Aarti Singh, editors, Proceedings of the 37th International Conference on Machine Learning, volume 119 of Proceedings of Machine Learning Research, pages 10881\u2013 10891. PMLR, 13\u201318 Jul 2020. URL https://proceedings.mlr.press/v119/you20b. html.   \n[81] Manzil Zaheer, Satwik Kottur, Siamak Ravanbakhsh, Barnabas Poczos, Russ R Salakhutdinov, and Alexander J Smola. Deep sets. Advances in neural information processing systems, 30, 2017.   \n[82] Muhan Zhang, Shali Jiang, Zhicheng Cui, Roman Garnett, and Yixin Chen. D-vae: A variational autoencoder for directed acyclic graphs. Advances in neural information processing systems, 32, 2019.   \n[83] Bo Zhao, Nima Dehmamy, Robin Walters, and Rose Yu. Symmetry teleportation for accelerated optimization. Advances in neural information processing systems, 35:16679\u201316690, 2022.   \n[84] Bo Zhao, Robert M. Gower, Robin Walters, and Rose Yu. Improving convergence and generalization using parameter symmetries. In The Twelfth International Conference on Learning Representations, 2024. URL https://openreview.net/forum?id=L0r0GphlIL.   \n[85] Allan Zhou, Kaien Yang, Kaylee Burns, Adriano Cardace, Yiding Jiang, Samuel Sokota, J Zico Kolter, and Chelsea Finn. Permutation equivariant neural functionals. Advances in Neural Information Processing Systems, 36, 2023.   \n[86] Allan Zhou, Kaien Yang, Yiding Jiang, Kaylee Burns, Winnie Xu, Samuel Sokota, J Zico Kolter, and Chelsea Finn. Neural functional transformers. In Thirty-seventh Conference on Neural Information Processing Systems, 2023. URL https://openreview.net/forum?id= JdhyIa0azI.   \n[87] Allan Zhou, Chelsea Finn, and James Harrison. Universal neural functionals. CoRR, abs/2402.05232, 2024. URL https://doi.org/10.48550/arXiv.2402.05232.   \n[88] Allan Zhou, Chelsea Finn, and James Harrison. Universal neural functionals. arXiv preprint arXiv:2402.05232, 2024. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "", "page_idx": 14}, {"type": "text", "text": "", "page_idx": 15}, {"type": "text", "text": "A Appendix / supplemental material ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "A.1 Additional practical considerations of ScaleGMN ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "In the following section, we describe the additional practical considerations that were omitted from Section 5. For the purposes of this section, we introduce the functions layer $(i)$ and pos $(i)$ which return the layer of a vertex $i$ and its position within this layer respectively. ", "page_idx": 16}, {"type": "text", "text": "A.1.1 Initialisation ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "As previously discussed, all vertex/edge representations throughout the network should respect the symmetries given by Eqs. (4), (5). This is straightforward to achieve at initialisation, by using the NN biases and weights (similarly to [33]). It is possible to use a scale equivariant layer here as well, e.g. a linear layer, which is what was performed in our empirical evaluation. For notation convenience, denote the biases and weights of Eq. (1), with $\\tilde{\\mathbf{b}},\\tilde{\\mathbf{W}}$ , such that $\\tilde{\\mathbf{b}}(i)=\\mathbf{b}_{\\mathrm{layer}(i)}\\left(\\mathrm{pos}\\left(i\\right)\\right)$ , $\\begin{array}{r}{\\tilde{\\mathbf{W}}(i,j)=\\mathbf{W}_{\\mathrm{layer}(i)}\\left(\\mathrm{pos}\\left(i\\right),\\mathrm{pos}\\left(j\\right)\\right)}\\end{array}$ . Now we can define the initialisation: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathrm{INIT}_{V}\\left(\\mathbf{x}_{V}\\left(i\\right)\\right)=\\mathbf{I}_{V}\\mathbf{x}_{V}(i),\\quad\\mathbf{x}_{V}(i)=\\left\\{\\tilde{\\mathbf{b}}\\left(i\\right),\\mathrm{~if~layer}\\left(i\\right)\\in\\{1,\\ldots,L\\},}\\\\ {1,\\mathrm{~if~layer}\\left(i\\right)=0.}\\end{array}\\right.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathrm{INIT}_{E}\\left(\\mathbf{x}_{E}\\left(i,j\\right)\\right)=\\mathbf{{T}}_{E}\\mathbf{x}_{E}(i,j),\\quad\\mathbf{x}_{E}(i,j)=\\tilde{\\mathbf{W}}\\left(i,j\\right),\\;\\mathrm{if}\\;\\mathrm{layer}\\left(i\\right)\\in\\{1,\\ldots,L\\}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Note that the above is different from the initialisation/graph construction used in [44]. For example, in this work, an extra vertex is created for each bias, which is connected to its corresponding neuron vertex with an edge initialised with the bias value. However, this strategy would complicate scaling symmetry preservation and was thus not used in our work. ", "page_idx": 16}, {"type": "text", "text": "A.1.2 Positional Encodings ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "As discussed in Section 3, not all vertices/edges of an FFNN are permutable. In particular, vertices corresponding to the input and output neurons are fixed, while vertices corresponding to hidden neurons can be permuted only within the same layer. Similarly, edges originating from an input neuron are permutable only with edges originating from the same neuron, and the same holds for edges terminating at an output neuron, while edges of hidden layers can be only permuted within the same layer. ", "page_idx": 16}, {"type": "text", "text": "To adhere to the above, we need to devise a symmetry-breaking mechanism, to ensure that the GMN is not equivariant to undesired symmetries (e.g. permuting output neurons). This is the role of positional encodings, which are learnable vectors (in the literature fixed vectors have been also used), shared across all input graphs, that take part in message-passing. In particular, for vertex positional encodings the following holds: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{p}_{V}(i)=\\mathbf{p}_{V}(j),\\;\\mathrm{if}\\;\\mathrm{layer}\\left(i\\right)=\\mathrm{layer}\\left(j\\right)\\neq\\{0,L\\},\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "and for edge positional encodings: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{p}_{E}(i,j)=\\mathbf{p}_{E}(i^{\\prime},j^{\\prime}),\\;\\mathrm{if~}\\left\\{\\begin{array}{l l}{j=j^{\\prime},\\mathrm{layer}\\left(j\\right)\\in\\{0,L\\},}\\\\ {\\log\\mathrm{er}\\left(j\\right)=\\mathrm{layer}\\left(j^{\\prime}\\right)\\neq0,\\mathrm{layer}\\left(i\\right)=\\mathrm{layer}\\left(i^{\\prime}\\right)\\neq L,}\\\\ {i=i^{\\prime},\\mathrm{layer}\\left(i\\right)\\in\\{0,L\\},}\\end{array}\\right.}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "while otherwise, the positional encodings are free to take different values. Symmetry-breaking usually happens at initialisation (which is then inherited by the subsequent message-passing layers) and Eq. (Init) becomes: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\mathbf{h}_{V}^{0}(i)=\\mathrm{INIT}_{V}\\left(\\mathbf{x}_{V}\\left(i\\right),\\mathbf{p}_{V}(i)\\right),\\quad\\mathbf{h}_{E}^{0}(i)=\\mathrm{INIT}_{E}\\left(\\mathbf{x}_{E}\\left(i,j\\right),\\mathbf{p}_{E}(i,j)\\right),\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "or alternatively, it can be performed at all layers, where Eqs. (Msg) and (Upd) become: ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{{\\bf m}_{V}^{t}(i)=\\bigoplus_{j\\in\\mathcal{N}(i)}\\mathrm{MSG}_{V}^{t}\\left({\\bf h}_{V}^{t-1}(i),{\\bf h}_{V}^{t-1}(j),{\\bf h}_{E}^{t-1}(i,j),{\\bf p}_{V}(i),{\\bf p}_{V}(j),{\\bf p}_{E}(i,j)\\right)}\\\\ &{{\\bf h}_{V}^{t}(i)=\\mathrm{UPD}_{V}^{t}\\left({\\bf h}_{V}^{t-1}(i),{\\bf m}_{V}^{t}(i),{\\bf p}_{V}(i)\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Challenge 3 - Incorporating positional encodings into scale equivariant layers. Although the above formulation allows for the preservation of valid permutation symmetries, special treatment is needed to preserve valid scaling symmetries as well. Since the positional encodings are fixed across datapoints, they do not have the same scaling symmetries as vertex/edge representations. Therefore, message-passing components do not need to be equivariant to scaling of the positional encodings. In particular, the following should hold: ${\\mathrm{INIT}}_{V}$ $(q\\mathbf{x},\\mathbf{p})\\;=\\;$ $q\\mathrm{INIT}_{V}$ $\\left(\\mathbf{x},\\mathbf{p}\\right)$ , $\\begin{array}{r l r}{\\mathrm{INIT}_{E}\\left(q\\mathbf{e},\\mathbf{p}\\right)}&{{}=}&{q\\mathrm{INIT}_{E}\\left(\\mathbf{e},\\mathbf{p}\\right)}\\end{array}$ , $\\mathbf{MSG}_{V}$ $\\begin{array}{r l}{\\left(q_{x}\\mathbf{x},q_{y}\\mathbf{y},q_{x}q_{y}^{-1}\\mathbf{e},\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e}\\right)}&{{}=}\\end{array}$ $q_{x}\\mathrm{MSG}_{V}\\left(\\mathbf{x},\\mathbf{y},\\mathbf{e},\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e}\\right)$ and $\\mathrm{JPD}_{V}\\left(q_{x}\\mathbf{x},q_{x}\\mathbf{m},\\mathbf{p}\\right)=q_{x}\\mathrm{UPD}_{V}\\left(\\mathbf{x},\\mathbf{m},\\mathbf{p}\\right)$ . ", "page_idx": 17}, {"type": "text", "text": "Therefore, Eqs. (15), (16), (17) introduce a new challenge (apart from those discussed in Section 5): being scale equivariant w.r.t. one argument and not equivariant. w.r.t. another one. Interestingly, our ScaleNet formalism can straightforwardly deal with this case, by defining the canonicalisation function for the non-symmetric argument to be the identity (since in the absence of symmetry equivalent points must be equal). To discern this from the classical scale invariant/equivariant layers, we will refer to it augmented scale invariant/equivariant layer and it is formalised as follows: ", "page_idx": 17}, {"type": "equation", "text": "$$\n{\\mathsf{A u g S c a l e l n v}}^{k}(\\mathbf{X},\\mathbf{p})=\\rho^{k}\\left({\\tilde{\\mathbf{x}}}_{1},\\ldots,{\\tilde{\\mathbf{x}}}_{n},\\mathbf{p}\\right),\\quad{\\mathsf{\\tilde{x}}}_{i}={\\mathsf{c a n o n}}(\\mathbf{x}_{i}){\\mathrm{~or~}}{\\tilde{\\mathbf{x}}}_{i}={\\mathsf{s y m m}}(\\mathbf{x}_{i})\n$$", "text_format": "latex", "page_idx": 17}, {"type": "equation", "text": "$$\n{\\mathsf{A u g S c a l e E q}}={\\mathsf{f}}^{K}\\circ\\cdots\\circ{\\mathsf{f}}^{1},{\\mathsf{f}}^{k}(\\mathbf{X})=\\left(\\mathbf{I}_{1}^{k}\\mathbf{x}_{1},\\ldots,\\mathbf{I}_{n}^{k}\\mathbf{x}_{n}\\right)\\odot{\\mathsf{A u g S c a l e l n v}}^{k}(\\mathbf{X},\\mathbf{p}).\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "Concluding, we obtain the new learnable functions, by simply replacing scale equivariant with augmented scale equivariant layers: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathrm{INIT}_{V}\\left(\\mathbf{x},\\mathbf{p}\\right)=\\mathsf{A u g S c a l e E q}\\left(\\mathbf{x},\\mathbf{p}\\right),\\quad\\mathrm{INIT}_{E}\\left(\\mathbf{e},\\mathbf{p}\\right)=\\mathsf{A u g S c a l e E q}\\left(\\mathbf{e},\\mathbf{p}\\right),}\\\\ &{\\mathrm{MSG}_{V}\\left(\\mathbf{x},\\mathbf{y},\\mathbf{e},\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e}\\right)=\\mathsf{A u g S c a l e E q}\\left(\\left[\\mathbf{x},\\mathsf{R e S c a l e E q}\\left(\\mathbf{y},\\mathbf{e}\\right)\\right],\\left[\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e}\\right]\\right),}\\\\ &{\\mathrm{UPD}_{V}\\left(\\mathbf{x},\\mathbf{m},\\mathbf{p}_{x}\\right)=\\mathsf{A u g S c a l e E q}\\left(\\left[\\mathbf{x},\\mathbf{m}\\right],\\mathbf{p}_{x}\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "A.1.3 Edge Updates. ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "To respect the symmetries given by Eq. (5), for edges $(i,j)$ , with layer $(i)~\\in~\\{2,\\ldots,L-1\\}$ the edge update function should have the following property: $\\begin{array}{r l}{\\mathrm{UPD}_{E}\\big(q_{x}\\mathbf{x},q_{y}\\mathbf{y},q_{x}q_{y}^{-1}\\mathbf{e}\\big)}&{=}\\end{array}$ $q_{x}q_{y}^{-1}\\mathrm{UPD}_{E}(\\mathbf{x},\\mathbf{y},\\mathbf{e})$ . Observe, that this is once again reminiscent of the rescaling problems discussed in Section 5, but with the difference that $q_{y}$ appears both as a multiplier and as a divisor. The most straightforward solution would be to elementwise invert $\\mathbf{y}$ and then proceed as in the message function of Eq. (8), i.e. : ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathrm{UPD}_{E}\\left(\\mathbf{x},\\mathbf{y},\\mathbf{e}\\right)=\\mathsf{S c a l e E q}\\left(\\left[\\mathbf{e},\\mathsf{R e S c a l e E q}\\left(\\mathbf{x},\\mathbf{1}\\otimes\\mathbf{y}\\right)\\right]\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "In our experiments though, we opt for a simpler solution due to the numerical instabilities (highmagnitude gradients) produced by the element-wise division and choose an invariant layer for the arguments $\\mathbf x,\\mathbf y$ . Formally: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\mathrm{UPD}_{E}\\left(\\mathbf{x},\\mathbf{y},\\mathbf{e}\\right)=\\mathsf{A u g S c a l e E q}\\left(\\mathbf{e},\\mathsf{S c a l e l n v}\\left(\\mathbf{x},\\mathbf{y}\\right)\\right).\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "When we include positional encodings into the edge updates, Eq. (Upd) (RHS) becomes: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\mathbf{h}_{E}^{t}(i,j)=\\mathrm{UPD}_{E}^{t}\\Big(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{h}_{V}^{t-1}(j),\\mathbf{h}_{E}^{t-1}(i,j),\\mathbf{p}_{V}(i),\\mathbf{p}_{V}(j),\\mathbf{p}_{E}(i,j)\\Big),\\,\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "and Eq. (24) is further modified into: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathrm{UPD}_{E}\\left(\\mathbf{x},\\mathbf{y},\\mathbf{e},\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e}\\right)=\\mathsf{A u g S c a l e E q}\\left(\\mathbf{e},[\\mathsf{S c a l e l n v}\\left(\\mathbf{x},\\mathbf{y}\\right),\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e}]\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "A.1.4 Updates on input and output vertices ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "So far, we have only discussed how vertex/edge representations corresponding to hidden neurons are updated, since Eqs. (4), (5) do not hold for input and output neurons. In particular, there exist no valid scaling or permutation symmetries for these neurons, while for the corresponding edges, permutations and scalings are unilateral - see Eq. (3). Therefore, we require the following: ", "page_idx": 17}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\mathbf{h}_{V}^{\\prime}(i)=\\mathbf{h}_{V}\\left(i\\right),\\quad\\ell=\\mathrm{layer}\\left(i\\right)\\in\\{0,L\\},\\quad\\mathrm{(No~equivariance)}}\\\\ &{\\mathbf{h}_{E}^{\\prime}(i,j)=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)\\mathbf{h}_{E}\\left(\\pi_{\\ell}\\left(i\\right),j\\right),\\quad\\ell=\\mathrm{layer}\\left(i\\right)=1,}\\\\ &{\\mathbf{h}_{E}^{\\prime}(i,j)=\\mathbf{h}_{E}\\left(i,\\pi_{\\ell-1}\\left(j\\right)\\right)q_{\\ell-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right),\\quad\\ell=\\mathrm{layer}\\left(i\\right)=L.}\\end{array}\n$$", "text_format": "latex", "page_idx": 17}, {"type": "text", "text": "This implies that the conditions for the learnable functions should change for i/o neurons. In particular, the following should be non-scale-equivariant: ${\\mathrm{INIT}}_{V,0}$ , $\\mathrm{MSG}_{V,0}{}^{7}$ , ${\\mathrm{UPD}}_{V,0}$ , $\\mathrm{INIT}_{V,L}$ , ${\\mathrm{UPD}}_{V,L}$ . The same should hold for $\\mathrm{MSG}_{V,L}$ , but with the additional requirement of invariance to rescaling: $\\mathrm{MSG}_{V,L}(\\mathbf{x},q_{y}\\mathbf{y},q_{y}^{-1}\\mathbf{e},\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e})=\\mathrm{MSG}_{V,L}(\\mathbf{x},\\mathbf{y},\\mathbf{e},\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e})$ ", "page_idx": 18}, {"type": "text", "text": "In traditional GNNs, where only permutation symmetries are taken into account, symmetry-breaking can be efficiently handled by positional encodings as discussed in Appendix A.1.2. However, this is not the case here, since positional encodings only break permutation symmetries, but not scaling symmetries. Instead, we resort to a simpler solution (albeit incurring an increased number of parameters): we use different initialisation, message and update functions for input/output neurons. ${\\mathrm{INIT}}_{V,0}$ , $\\mathrm{MSG}_{V,0}$ , ${\\mathrm{UPD}}_{V,0}$ , ${\\mathrm{INIT}}_{V,L}$ , ${\\mathrm{UPD}}_{V,L}$ are general function approximators (MLPs), while $\\mathrm{MSG}_{V,L}(\\mathbf{x},\\mathbf{y},\\mathbf{e},\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e})=\\mathrm{MLP}\\left(\\mathbf{x},\\mathsf{R e S c a l e E q}\\left(\\mathbf{y},\\mathbf{e}\\right),\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e}\\right).$ ", "page_idx": 18}, {"type": "text", "text": "As for the i/o edge representations, the following should hold at initialisation: $\\begin{array}{r l r}{\\mathrm{INIT}_{E,1}(q_{x}\\mathbf{e},\\mathbf{p})}&{{}=}&{\\phantom{-}q_{x}\\mathrm{INIT}_{E,1}(\\mathbf{e},\\mathbf{p}),\\mathrm{INIT}_{E,L}(q_{y}^{-1}\\mathbf{e},\\mathbf{p})\\quad=\\quad q_{y}^{-1}\\mathrm{INIT}_{E,L}(\\mathbf{e},\\mathbf{p}).}\\end{array}$ , and for the edge updates: $\\begin{array}{r l r}{\\mathrm{UPD}_{E,1}\\big(q_{x}{\\bf x},{\\bf y},q_{x}{\\bf e},{\\bf p}_{x},{\\bf p}_{y},{\\bf p}_{e}\\big)}&{{}=}&{q_{x}\\mathrm{UP}}\\end{array}$ $q_{x}\\mathrm{\\UPD}_{E,1}({\\bf x},{\\bf y},{\\bf e},{\\bf p}_{x},{\\bf p}_{y},{\\bf p}_{e})$ , $\\begin{array}{r l r}{\\mathrm{UPD}_{E,L}({\\bf x},q_{y}{\\bf y},q_{y}^{-1}{\\bf e},{\\bf p}_{x},{\\bf p}_{y},{\\bf p}_{e})}&{\\!=\\!}&{q_{y}^{-1}\\mathrm{UPD}_{E,L}({\\bf x},{\\bf y},{\\bf e},{\\bf p}_{x},{\\bf p}_{y},{\\bf p}_{e})}\\end{array}$ . Therefore, edge initialisation should be equivariant to the edge scale and therefore can remain as is - Eq. (20). The same holds for the edge updates - Eq. (26), which allows us to retain the same architecture in our experiments, although the interested reader may observe that one can use more powerful architectures since there is no need for rescaling here. ", "page_idx": 18}, {"type": "text", "text": "A.1.5 Readout ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Regarding the readout, we devise a permutation and scale invariant aggregator as follows: ", "page_idx": 18}, {"type": "equation", "text": "$$\n\\mathrm{READ}_{V}\\left(\\mathbf{X}\\right)=\\mathrm{MLP}\\left(\\left[\\mathsf{D e e p S e t s}\\left(\\tilde{\\mathbf{x}}_{1},\\ldots,\\tilde{\\mathbf{x}}_{n}\\right),\\mathbf{X}_{0},\\mathbf{X}_{L}\\right]\\right),\\tilde{\\mathbf{x}}_{i}=\\mathsf{c a n o n}\\!\\left(\\mathbf{x}_{i}\\right)\\,\\mathsf{o r}\\,\\tilde{\\mathbf{x}}_{i}=\\tilde{\\mathbf{x}}_{i}\\,,\n$$", "text_format": "latex", "page_idx": 18}, {"type": "text", "text": "This means that we aggregate all scale canonicalised/symmetrised representations of hidden neurons with a permutation invariant aggregator (Deepsets [81]), concatenate the result with all $\\mathrm{i/o}$ neuron representations (that cannot be permuted or scaled) and transform the result with a universal function approximator. A simpler alternative is to only concatenate the output neuron representations (or also the input for the bidirectional version) since after sufficient message-passing iterations they are expected to have collected information from the entire graph. We include and evaluate both choices in our hyperparameter grid. ", "page_idx": 18}, {"type": "text", "text": "A.2 Bidirectional ScaleGMN ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "Undoubtedly, using only forward neighbourhoods, although convenient and aligned with the computational graph of the input datapoint, may restrict the expressive power of ScaleGMN. This is self-explanatory since vertices receive information only from parts of the graph that belong to earlier layers. This might be detrimental, especially for equivariant tasks (operators). Additionally, it is contrary to the first works on weight space networks [54, 86], where vertices/edges collect information from the entire graph, while backward neighbourhoods are crucial for GMNs to express NP-NFN [86] as shown in Proposition 3 in Lim et al. [44]. ", "page_idx": 18}, {"type": "text", "text": "However, making bidirectional message passing scale equivariant is challenging since backward messages have different symmetries than forward ones. In particular, preserving the same assumptions for the symmetries of vertex/edge representations, the input triplet to a message function $\\mathbf{h}_{V}(i),\\mathbf{h}_{V}(j),\\mathbf{h}_{E}(j,i)$ , with $\\textit{j}\\in\\bar{\\mathcal{N}}_{B}(\\bar{\\boldsymbol{i}})$ and $\\ell\\ =\\ \\mathrm{layer}\\,\\bar{(}i)$ is equivalent to $q_{\\ell}(i)\\mathbf{h}_{V}(i),q_{\\ell+1}(j)\\mathbf{h}_{V}(j),q_{\\ell+1}(j)\\mathbf{h}_{E}(j,i)q_{\\ell}^{-1}(i)$ (we have omitted permutations here for simplicity). Therefore, doing the same rescaling as before is inappropriate since it does not preserve the desired scaling coefficient $q_{\\ell}(i)$ . ", "page_idx": 18}, {"type": "text", "text": "There are several options one may follow to circumvent this discrepancy. However, most involve an elementwise division of a certain representation, which we experimentally observed to face numerical instabilities. The simplest one is to add backward edges and initialise them with inverted features: ", "page_idx": 18}, {"type": "text", "text": "", "page_idx": 19}, {"type": "equation", "text": "$$\n\\mathrm{INIT}_{E}\\left(\\mathbf{x}_{E}\\left(j,i\\right)\\right)=\\mathbf{r}_{E}\\mathbf{1}\\oslash\\mathbf{x}_{E}(j,i),\\quad\\mathbf{x}_{E}(j,i)=\\tilde{\\mathbf{W}}\\left(j,i\\right),\\ \\mathrm{if~}0\\leq\\mathrm{layer}\\left(j\\right)<\\mathrm{layer}\\left(i\\right)\\leq L.\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "In this case, we have that $\\mathrm{INIT}_{E}\\left(q_{\\ell+1}(j)q_{\\ell}^{-1}(i)\\mathbf{x}_{E}\\left(j,i\\right)\\right)\\,=\\,q_{\\ell}(i)q_{\\ell+1}^{-1}(j)\\mathrm{INIT}_{E}\\left(\\mathbf{x}_{E}\\left(j,i\\right)\\right)$ , and thus $(j,i)$ are initialised with the same symmetries as $(i,j)$ . Now one can proceed as before with the message and update functions. In particular, we introduce a backward message function to discern the two message directions (alternatively this can be done with edge positional encodings to reduce the number of parameters): ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{m}_{V,\\mathrm{BW}}^{t}(i)=\\displaystyle\\bigoplus_{j\\in\\mathcal{N}_{B}(i)}\\mathrm{MSG}_{V,\\mathrm{BW}}^{t}(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{h}_{V}^{t-1}(j),\\mathbf{h}_{E}^{t-1}(j,i),\\mathbf{p}_{V}(i),\\mathbf{p}_{V}(j),\\mathbf{p}_{E}(j,i))}\\\\ &{\\mathrm{MSG}_{V,\\mathrm{BW}}(\\mathbf{x},\\mathbf{y},\\mathbf{e},\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e})=\\mathsf{A u g S c a l e E q}\\left([\\mathbf{x},\\mathsf{R e S c a l e E q}\\left(\\mathbf{y},\\mathbf{e}\\right)],\\left[\\mathbf{p}_{x},\\mathbf{p}_{y},\\mathbf{p}_{e}\\right]\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "It is easy to see that: ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\mathrm{MSG}_{V,\\mathrm{BW}}(q_{x}{\\bf x},q_{y}{\\bf y},q_{y}^{-1}q_{x}{\\bf e},{\\bf p}_{x},{\\bf p}_{y},{\\bf p}_{e})=q_{x}\\mathrm{MSG}_{V,\\mathrm{BW}}({\\bf x},{\\bf y},{\\bf e},{\\bf p}_{x},{\\bf p}_{y},{\\bf p}_{e}).\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Now to incorporate backward messages into the update function we simply concatenate the outputs of the two message functions and apply a scale equivariant layer as usual: ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{h}_{V}^{t}(i)=\\mathrm{UPD}_{V}^{t}\\Big(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{m}_{V,\\mathrm{FW}}^{t}(i),\\mathbf{m}_{V,\\mathrm{BW}}^{t}(i),\\mathbf{p}_{V}(i)\\Big),}\\\\ &{\\mathrm{UPD}_{V}\\left(\\mathbf{x},\\mathbf{m}_{\\mathrm{FW}},\\mathbf{m}_{\\mathrm{BW}},\\mathbf{p}_{x}\\right)=\\mathsf{A u g S c a l e E q}\\left(\\left[\\mathbf{x},\\mathbf{m}_{\\mathrm{FW}},\\mathbf{m}_{\\mathrm{BW}}\\right],\\mathbf{p}_{x}\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Once, again the desired symmetries are preserved: ", "page_idx": 19}, {"type": "equation", "text": "$$\n\\mathrm{UPD}_{V}\\big(q_{x}\\mathbf{x},q_{x}\\mathbf{m}_{\\mathrm{FW}},q_{x}\\mathbf{m}_{\\mathrm{BW}},\\mathbf{p}_{x}\\big)=q_{x}\\mathrm{UPD}_{V}\\big(\\mathbf{x},\\mathbf{m}_{\\mathrm{FW}},\\mathbf{m}_{\\mathrm{BW}},\\mathbf{p}_{x}\\big).\n$$", "text_format": "latex", "page_idx": 19}, {"type": "text", "text": "Bidirectional ScaleGMN for sign symmetries. Importantly, the above edge weight inversion of Eq. (31) is not necessary when dealing with sign symmetries. In particular, for any $q\\in\\{-1,1\\}$ it holds that ${\\scriptstyle{\\frac{1}{q}}}=q$ . Therefore, one can proceed with the above formulation but initialise the edge weights as before -Eq. (12). We found this crucial in our experimental evaluation since weight inversion led to an unusual distribution of input features: since typically the weight distribution was nearly Gaussian, the distribution of the inverses was close to reciprocal normal distribution, a bimodal distribution with undefined mean and higher-order moments. This frequently led to numerical instabilities as well (albeit less so compared to computing reciprocals of neuron/edge representations), which explains why it was easier to train bidirectional models for sign symmetric NNs compared to positive-scale symmetric ones. ", "page_idx": 19}, {"type": "text", "text": "A.3 Extension to CNNs ", "text_level": 1, "page_idx": 19}, {"type": "text", "text": "A similar methodology to Section 5 can be applied to Convolutional Neural Networks with only a few changes. As observed by prior works on metanetworks (Zhou et al. [85], Kofinas et al. [33]), the permutation symmetries in a CNN arise similarly to MLPs; permuting the filters (output channels) of a hidden convolutional layer, while also permuting the input channels of each filter in the subsequent layer does not alter the underlying function of the network. This is easy to see since convolution is nothing else but a linear layer with weight sharing. Weight sharing constrains the valid permutations as far as pixels/input coordinates are concerned (e.g. one cannot permute the representations corresponding to different pixels), but allows for permutations of input/output channels, except for the input/output layers as always. ", "page_idx": 19}, {"type": "text", "text": "Similar rules apply to scaling: one may scale the output channels of a hidden convolutional layer, while also scaling the input channels of each filter in the subsequent layer as per Proposition 4.1. Note here that, again, all weights corresponding to the same input channel can only be scaled with the same multiplier for all pixels/input coordinates, due to weight sharing. Below, we describe our implementation for all CNN layers, which closely follows [33]. ", "page_idx": 19}, {"type": "text", "text": "Convolution. Being the main building block of CNNs, convolutional layers consist of kernels and biases. For a hidden layer $i$ we can write the former as $\\mathbf{W}_{i}\\in\\mathbb{R}^{d_{\\ell}\\times d_{\\ell-1}\\times k_{\\ell}^{'}}$ and the latter as $\\mathbf{b}_{i}\\in\\mathbb{R}^{d_{\\ell}}$ following the FFNN notation. Aligning with the procedure of [33], we construct one vertex for each i/o channel and the input graph has the following node and edge features: $\\mathbf{x}_{V}(i)=\\tilde{\\mathbf{b}}(i)\\in\\mathbb{R}$ , $\\mathbf{x}_{E}(i,j)=\\tilde{\\mathbf{W}}(i,j)\\in\\mathbb{R}^{w_{\\operatorname*{max}}^{\\bar{\\mathbf{\\alpha}}}\\cdot h_{\\operatorname*{max}}^{\\bar{\\mathbf{\\alpha}}}}$ respectively, where $w_{\\mathrm{max}},h_{\\mathrm{max}}$ are the maximum width and height of the kernels across layers (zero-padding is used to allow for fixed-size edge representations across all vertices in the graph). Again here, the positional encodings are responsible for the permutation symmetry breaking mechanisms within the CNN. As with FFNNs, the CNN input and output neurons are not permutable, while the hidden neurons are permutable only within the layer they belong. Given that fliter positions are not permutable and are associated with a single neuron, they are represented as vectors on the edge features. ", "page_idx": 19}, {"type": "text", "text": "", "page_idx": 20}, {"type": "text", "text": "Average Pooling. Average pooling is commonly placed after the last convolutional layer (typical in modern CNNs instead of flattening $^+$ linear layer to allow for variable-size images) and is responsible for pooling the output feature map in a single feature vector. First off, since it is a linear operation, it is amenable to scaling symmetries. It is easy to see this by perceiving average pooling as a $K x K$ convolution with no learnable parameters (equal to $\\frac{1}{K^{2}}$ , where $K$ the dimension of the image, and a single output channel. Hence, no additional modifications are required, similarly to [33]. ", "page_idx": 20}, {"type": "text", "text": "Linear layer. Commonly used as the last layer of CNNs to extract a vector representation of an image, linear layers require a different approach within CNNs compared to the one in MLPs, as in the former case the edge features are vectors, while in the latter scalars. Aligning with the method proposed by [33], the simplest solution is to zero-pad the linear layers to the maximum kernel size and consequently flatten them to meet the dimension of the rest of the edge features. By handling linear layers this way, no additional measures are needed to ensure permutation and scale equivariance. ", "page_idx": 20}, {"type": "text", "text": "A.4 Implementation Details ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "A.4.1 INR Classification ", "text_level": 1, "page_idx": 20}, {"type": "text", "text": "Datasets: We evaluated our method on three INR datasets. Provided as open-source by Navon et al. [54], the datasets MNIST and FashionMNIST contain a single INR for each image of the datasets MNIST [38] and FashionMNIST [76] respectively. The selection of these datasets was encouraged by the fact that they were also selected by prior works, establishing them as a useful first benchmark on INR metanetworks. As a third INR dataset, we use CIFAR-10, publicly available by Zhou et al. [85], which contains one INR per image from CIFAR10 [35]. Regarding the last dataset, the authors also provide an augmented training dataset, consisting of 20 additional copies of each INR network, but with different initializations. Training on such a bigger dataset allows them to achieve better results, probably because it allows them to counteract overfitting. To demonstrate the capabilities of our method we train ScaleGMN both on the \"original\" dataset as well as on the augmented one, achieving better results in both cases. In the latter case we carefully follow the training and evaluation procedure used in [85], i.e. we train for 20000 steps and evaluate every 3000 steps. In all the above datasets, we use the same splits as in prior works, we train for 150 epochs and report the test accuracy based on the validation split, following the same procedure as Navon et al. [54]. ", "page_idx": 20}, {"type": "text", "text": "Hyperparameters: The GNN used for ScaleGMN is a traditional Message Passing Neural Network [24], with carefully designed update and message functions that ensure sign equivariance. We optimise the following hyperparameters: batch size in $\\{64,128,256\\}$ , hidden dimension for node/edge features in $\\{64,1\\bar{2}8,\\bar{2}56\\}$ . We also search learning rates in $\\{0.0{\\dot{0}}1,0.0005,0.0001\\}$ , weight decay in $\\{0.01,0.001\\}$ , dropout in $\\{0,0.1,0.2\\}$ and number of GNN layers in $\\{2,3,4,5\\}$ . Moreover, we experiment with using only vertex positional encodings or also employing edge positional encodings. We apply layer normalization within each MLP and use skip connections between each GNN layer. The last two steps were proven valuable to stabilise training. Finally, for each MLP within the architecture we use SiLU activation function, one hidden layer and no activation function after the last layer. All the experiments were conducted on NVIDIA GeForce RTX 4090. ", "page_idx": 20}, {"type": "text", "text": "As mentioned above, the core of all building blocks, i.e. Scale Invariant Net is designed to be invariant to sign flips. In our experiments, we explore two means of designing sign equivariance, either by elementwise absolute value $|\\mathbf{x}|$ (canonicalization only in 1-dimension), or symmetrisation, $\\mathsf{s y m m}(\\mathbf{x})=\\mathbf{M}\\mathbf{L}\\mathbf{P}(\\mathbf{x})+\\mathbf{M}\\mathbf{L}\\mathbf{P}(-\\mathbf{x})$ . Although the former leads to reduced expressivity, in some cases we observed better performance. A possible explanation could point to the extra training parameters that are added because of the additional MLP. ", "page_idx": 20}, {"type": "text", "text": "Results: As shown in table Table 1, our method is able to push the state-of-the-art in all the datasets considered. Notably, many additional techniques that were employed by previous works in order to achieve good results were not required in our method. Specifically, probe features when inserted into the node features as in [33] were proven to boost the performance much higher, and could potentially enhance the performance of ScaleGMN too. In the reported results we compare with variants of [33] that do not use probe features and rely solely on the parameters of the input network, although our method outperforms even the probe features variants. Moreover, [85] and [33] also apply random Fourier features during the initialization of the weight and bias features, which in our experiments showcased better performance when used in a traditional MPNN framework, but were not employed for our method. In our framework, we also do not include any normalization of the input as conducted by previous works, where the normalization is applied either on parameter level ([85], [54]) or on layer level [33], computing the mean and standard deviation. Although this step typically leads to better performance, it could not be applied in our scale and permutation equivariant framework. Nevertheless, even without all the above techniques, ScaleGMN achieves remarkable results. Finally, opting for a Transformer, as in [33], instead of a GNN layer is also an orthogonal to our work addition that could enhance the performance of ScaleGMN. ", "page_idx": 20}, {"type": "text", "text": "", "page_idx": 21}, {"type": "text", "text": "A.4.2 Predicting CNN Generalization from weights ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "For evaluating our method on the CNN Generalization task, we select CIFAR-10-GS and SVHN-GS datasets from [74], following the evaluation of prior works (Zhou et al. [85], Zhou et al. [86], Lim et al. [44], Kofinas et al. [33]). The above datasets contain CNNs trained with ReLU and Tanh activation functions. In order to assess our method separately for each of these activation functions, as they introduce different symmetries, we distinguish two different types of experiments. In the first case we deviate from the path of previous evaluations and split each of these datasets into two subsets. The first one contains CNNs trained with ReLU activation function and the second networks with Tanh. In order to compare with previous methods, we train them on each subset and report Kendall\u2019s correlation $\\tau$ metric [30] as originally proposed by Zhou et al. [85]. ", "page_idx": 21}, {"type": "text", "text": "Heterogeneous activation functions: In the second case, we evaluate ScaleGMN on the whole CIFAR-10-GS and SVHN-GS datasets. We are able to do so, as our method does not impose any limitations regarding the homogeneity of the activation functions of the input neural networks. The sole necessary modification lies in the construction of the invariant layer. Specifically, following the notation of Eq. (Scale Equiv. Net), each equivariant layer $\\mathsf{f}^{k}$ is now equipped with two invariant fnuetnsc, $\\mathsf{S c a l e l n v}_{r e l u}^{k}$ vaenlyd. ${\\sf S c a l e l n v}_{t a n h}^{k}$ ,h et oa rbceh aitpepcltiuerde  oren mthaei nds atthaep osianmtse .with ReLU and Tanh activation ", "page_idx": 21}, {"type": "text", "text": "Hyperparameters: For the ReLU datasets we implement scale equivariant update and message functions, while for the Tanh sign equivariant. In all of our experiments we use MSE training loss. Regarding the hyperparameters we search: batch size in $\\{32,64,128\\}$ , hidden dimension for node/edge features in $\\{64,128,256\\}$ . We also search learning rates in $\\{0.001,0.0005,0.0001\\}$ , weight decay in $\\{0.01,0.\\dot{0}01\\}$ , dropout in $\\{0,0.1,0.2\\}$ and number of GNN layers in $\\{2,3,4,5\\}$ . Again, we experiment with using only node positional encodings or also employing edge positional encodings and apply layer normalization within each MLP. For the Tanh datasets, we also experiment with the applying canonicalization or symmetrization of the sign symmetry. Finally, for the experiments with heterogeneous activation functions, we apply the same hyperparameter search as above. ", "page_idx": 21}, {"type": "text", "text": "A.4.3 INR editing ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "To evaluate the performance of ScaleGMN on equivariant tasks we opted for the task of INR editing. Aligning with the setup of [33], we utilize the MNIST INR dataset provided by Navon et al. [54] and evaluate our method on dilating the encoded MNIST digits. Specifically, for each image $i$ of the dataset, where $i\\in[N]$ , we compute the ground truth dilated image using the OpenCV image processing library and denote it as $f_{i}$ , where $f_{i}:\\mathbb{R}^{2}\\rightarrow\\mathbb{R}$ . Let $\\theta_{i}$ denote the INR parameters of the $i$ -th image and $f_{!}$ SIREN the encoded function. Then, $f_{\\mathrm{SIREN}}(x,y;\\pmb{\\theta}_{i})$ is the output of the INR at the $(x,y)$ coordinates, when parameterized by $\\theta_{i}$ . The updated INR weights are computed as: $\\pmb{\\theta}_{i}^{\\prime}=\\pmb{\\theta}_{i}+\\gamma\\cdot\\mathrm{ScaleGMN}(\\pmb{\\theta}_{i})$ , where $\\gamma$ a learned scalar initialized to 0.01. Finally, we minimize the mean squared error on the function space, that is: ", "page_idx": 21}, {"type": "equation", "text": "$$\n\\mathcal{L}=\\frac{1}{N\\cdot d^{2}}\\sum_{i=1}^{N}\\sum_{x,y}^{d}\\Vert f_{\\mathrm{SIREN}}(x,y;\\pmb{\\theta}_{i}^{\\prime})-f_{i}(x,y)\\Vert_{2}^{2}\n$$", "text_format": "latex", "page_idx": 21}, {"type": "text", "text": "Simply put, we compare the reconstructed new INR with the dilated ground truth image. Again, we do not apply any normalizations nor feed the model samples of the encoded input image (probe features). ", "page_idx": 22}, {"type": "text", "text": "Hyperparameters: The GNN used for ScaleGMN is a traditional Message Passing Neural Network [24], with carefully designed update and message functions that ensure sign equivariance. In contrast to the above experiments we do not add a final readout layer, as we do not compute any final graph embedding. We optimise the following hyperparameters: batch size in $\\{64,128,256\\}$ , hidden dimension for node/edge features in 64, 128, 256 and number of GNN layers in $\\{8,9,10,11\\}$ . We also search learning rates in $\\{0.001,0.0005,0.0001\\}$ , weight decay in $\\{0.01,0.00\\dot{1}\\}$ and dropout in $\\{0,0.1,0.2\\}$ . Moreover, we experiment with using only vertex positional encodings or also employing edge positional encodings. We apply layer normalization within each MLP and use skip connections between each GNN layer. The last two steps were proven valuable to stabilise training. Finally, for each MLP within the architecture we use SiLU activation function, one hidden layer and no activation function after the last layer. The learned scalar $\\gamma$ , also used in previous work Zhou et al. [85], was always initialized at the same value 0.001 and consistently led to better results. All the experiments were conducted on NVIDIA GeForce RTX 4090. ", "page_idx": 22}, {"type": "text", "text": "Results: As shown in Table 3, the bidirectional variant achieves better results than all the previous works on metanetworks, without incorporating any of the additional techniques described above. Notably, ScaleGMN-B surpasses the performance of the graph-based permutation equivariant baseline NG-GNN equipped with 64 probe features [33]. Interestingly, our method demonstrated much better results as we added more GNN layers. This experimental observation possibly corroborates with the findings of Theorem 5.2. Regarding our forward variant, we can see that although it is able to perform on par with the previous baselines, it struggles to match the results achieved by the bidirectional variant. This behaviour, observed exclusively in this task, is theoretically anticipated for equivariant tasks. Specifically, in the forward case, neurons of layer $\\ell$ only receive information from layers $\\ell^{\\prime}<\\ell$ , which hinders the computation of meaningful embeddings for nodes of the first layers. Taking into account that the INR models are rather shallow (only 2 hidden layers of 32 neurons each), then a big proportion of the whole set of nodes is being updated with less meaningfull information. ", "page_idx": 22}, {"type": "text", "text": "A.4.4 Extra symmetries of the sine activation function ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Regarding the sine activation function, one can easily show the presence of an additional symmetry due to the periodicity of harmonic functions. To see this, recall from Eq. (1) the formula for a feedforward $L$ -layer SIREN: ", "page_idx": 22}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{x}_{0}=\\mathbf{x},\\quad\\mathbf{x}_{\\ell}(i)=\\sin\\big(\\omega_{0}\\mathbf{W}_{\\ell}(i,:)\\mathbf{x}_{\\ell-1}+\\mathbf{b}_{\\ell}(i)\\big).}\\end{array}\n$$", "text_format": "latex", "page_idx": 22}, {"type": "text", "text": "We will prove that the following guarantees function preservation: ", "page_idx": 22}, {"type": "equation", "text": "$$\n\\mathbf{W}_{\\ell}^{\\prime}=\\mathbf{Q}_{\\ell}\\mathbf{W}_{\\ell},\\;\\mathbf{b}_{\\ell}^{\\prime}=\\mathbf{Q}_{\\ell}\\mathbf{b}_{\\ell}+\\mathbf{O}_{\\ell}\\boldsymbol{\\pi}\\;\\Rightarrow\\big(\\mathbf{W}_{\\ell}^{\\prime},\\mathbf{b}_{\\ell}^{\\prime}\\big)_{\\ell=1}^{L}\\simeq\\big(\\mathbf{W}_{\\ell},\\mathbf{b}_{\\ell}\\big)_{\\ell=1}^{L},\n$$", "text_format": "latex", "page_idx": 22}, {"type": "text", "text": "with $\\mathbf{Q}_{\\ell}$ defined as diagonal sign matrices, $\\begin{array}{r c l}{{{\\bf O}_{\\ell}}}&{{=}}&{{2{\\bf M}_{\\ell}\\ +\\ \\mathrm{inv-sign}({\\bf Q}_{\\ell})}}\\end{array}$ , where $\\mathbf{M}_{\\ell}\\quad=$ $\\mathrm{diag}\\big(m_{\\ell}(1),\\ldots m_{\\ell}(d_{\\ell})\\big),m_{\\ell}(i)\\in{\\bf Z}$ and we defined inv- $\\mathrm{sign}(q)=\\left\\{0,\\:q\\geq0\\right.$ for compactness (we have omitted permutation matrices here for brevity). Observe here that the matrix transformations are \u201csingle-sided\u201d, contrary to Eq. (3). We show by induction that, when Eq. (34) holds, then $\\mathbf{x}_{\\ell}^{\\prime}=\\mathbf{x}_{\\ell}$ Base case: $\\mathbf{x}_{0}^{\\prime}\\;=\\;\\mathbf{x}_{0}$ by defintion. Induction step: Assume $\\mathbf{x}_{\\ell-1}^{\\prime}\\;=\\;\\mathbf{x}_{\\ell-1}$ . In order to have $\\mathbf{x}_{\\ell}^{\\prime}=\\mathbf{x}_{\\ell}$ , $\\forall\\mathbf{x}\\in\\mathcal{X}$ , it suffices that $\\exists m_{\\ell}(i)\\in\\mathbb{Z},q_{\\ell}(i)\\in\\{-1,1\\}$ : ", "page_idx": 22}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\omega_{0}\\mathbf{W}_{\\ell}^{\\prime}(i,:)\\mathbf{x}_{\\ell-1}+\\mathbf{b}_{\\ell}^{\\prime}\\left(i\\right)=\\left(\\omega_{0}\\mathbf{W}_{\\ell}(i,:)\\mathbf{x}_{\\ell-1}+\\mathbf{b}_{\\ell}\\left(i\\right)\\right)q_{\\ell}(i)+\\left(2m_{\\ell}+\\mathrm{inv}.\\mathrm{sign}(q_{\\ell}(i))\\right)\\pi}\\\\ &{:=\\mathbf{W}_{\\ell}^{\\prime}(i,:)=q_{\\ell}(i)\\mathbf{W}_{\\ell}(i,:),\\quad\\mathbf{b}_{\\ell}^{\\prime}\\left(i\\right)=q_{\\ell}(i)\\mathbf{b}_{1}\\left(i\\right)+\\left(2m_{\\ell}(i)+\\mathrm{inv}.\\mathrm{sign}(q_{\\ell}(i))\\right)\\pi.}\\end{array}\n$$", "text_format": "latex", "page_idx": 22}, {"type": "text", "text": "This can be straightforwardly extended to include permutations. ", "page_idx": 22}, {"type": "text", "text": "To account for those symmetries, in this paper, we opted for a simple solution, based on the observation that they cannot exist if the biases are bounded. In particular, $i f\\mathbf{\\dot{b}}_{\\ell}^{\\prime}(i),\\mathbf{b}_{\\ell}(i)\\in(-\\pi/2,\\pi/2]$ , then $m$ must be 0 and $q$ must be 1 in all cases: For $q_{\\ell}(i)=\\bar{1}$ , since $0\\leq|\\mathbf{b}_{\\ell}(i)-\\mathbf{b}_{\\ell}(i)|<\\pi$ , it must be that $0\\leq|2m_{\\ell}(i)|<1\\Leftrightarrow0\\leq|m_{\\ell}(i)|<1/2\\Rightarrow m=0.$ For $q_{\\ell}(i)=-1$ , since $-\\pi<{\\bf b}_{\\ell}(i)\\!+\\!{\\bf b}_{\\ell}(i)\\le\\pi$ , it must be that $\\begin{array}{r}{-1\\,<\\,2m_{\\ell}(i)\\,+\\,1\\,\\leq\\,1\\,\\Leftrightarrow\\,-1\\,<\\,m_{\\ell}(i)\\,\\leq\\,0\\,\\Rightarrow\\,m_{\\ell}(i)\\,=\\,0}\\end{array}$ . Further, since the equality holds only when both biases are equal to $\\pi/2$ , then the case $q_{\\ell}(i)=-1,m=0$ reduces to $\\bar{q_{\\ell}^{\\prime}}(i)=1,m=0$ . ", "page_idx": 22}, {"type": "image", "img_path": "8Fxqn1tZM1/tmp/5325ecb9a40f54cb723184a5b8bf21afaa8c820af04e1a47fdf808000f1cd135.jpg", "img_caption": [], "img_footnote": [], "page_idx": 23}, {"type": "text", "text": "", "page_idx": 23}, {"type": "text", "text": "Overall, by constraining the biases in the $(-\\pi/2,\\pi/2]$ interval, these symmetries are eliminated. In all datasets considered, this constraint was already satisfied. For completeness, we provide Algorithm 1 that illustrates a method to shift biases in the desired interval. ", "page_idx": 23}, {"type": "text", "text": "A.5 Additional ablation studies ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "A.5.1 Distribution of Scaling coefficients ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "Empirically, accounting for a given symmetry might not prove fruitful if the given dataset is by construction canonicalised, e.g. if all parameters were already positive or negative in the presence of sign symmetries. To ensure the occurrence of the studied symmetries within the used datasets, we explore their statistics. Regarding the positive-scaling symmetry, the distribution of norms of weights and biases within each network layer in the CIFAR-10-GS-ReLU dataset is shown in Fig. 1. Concerning sign symmetries, we similarly plot the distribution of the sign values for the MNIST-INR dataset in Fig. 2 and the CIFAR-10-GS-tanh dataset in Fig. 3. Observe that in the former case, the distribution has relatively high variance, showcasing that the weights/biases are not by training scale-normalised. Even more prominently, in the latter case, the probability of each sign value is close to $1/2$ which corroborates our claims on the need for sign equivariance/invariance. ", "page_idx": 23}, {"type": "text", "text": "A.6 Additional Considerations ", "text_level": 1, "page_idx": 23}, {"type": "text", "text": "In the following section, we explore key questions raised by the reviewers during the evaluation process. These questions touch upon interesting aspects of our methodology that merit in-depth exploration. ", "page_idx": 23}, {"type": "text", "text": "Complexity and performance (runtime) degradation between ScaleGMN and ScaleGMN-B In the bidirectional case, we add backward edges to our graph and introduce a backward message function to discern the two message directions. Subsequently, we concatenate the outputs of the two message functions and apply the UPD function. Consequently, the additional complexity of ScaleGMN-B is introduced solely by the extra message function, with a complexity of $O(E)$ . Given that ScaleGMN has the complexity of a standard GNN model $O(V+E)$ , the final complexity of ScaleGMN-B is $O(V+2E)$ . ", "page_idx": 23}, {"type": "image", "img_path": "8Fxqn1tZM1/tmp/fe34f8307442948a12d3409d64fd62497ccc78ca95f8e318a4cff487c5ae0b98.jpg", "img_caption": ["Figure 1: Norm distribution on the weights and biases in the CIFAR-10-GS-ReLU dataset. "], "img_footnote": [], "page_idx": 24}, {"type": "image", "img_path": "8Fxqn1tZM1/tmp/c41018f03f163eaef1afdbd9f130a8681a5c5a17e8b525a210bcc6a6ea09bac9.jpg", "img_caption": ["Figure 2: Sign distribution of the weights and biases in the MNIST INR dataset. "], "img_footnote": [], "page_idx": 24}, {"type": "image", "img_path": "8Fxqn1tZM1/tmp/050e7eb65274950b882059e3684202e5311fd550fc1d77f4f5ec8421929f2a12.jpg", "img_caption": ["Figure 3: Sign distribution of the weights and biases in the CIFAR-10-GS-tanh dataset. "], "img_footnote": [], "page_idx": 25}, {"type": "text", "text": "", "page_idx": 25}, {"type": "text", "text": "Trainable parameters: GMN vs ScaleGMN(-B)? Going from a GMN model to ScaleGMN requires adapting the MSG and UPD functions to be scale equivariant, leading to more learnable parameters, as opposed to using plain MLPs. Another design choice of ScaleGMN that introduces more parameters is using different MLPs for the I/O nodes (A.1.4). ", "page_idx": 25}, {"type": "text", "text": "Are there any limitations on the choice of activations of the ScaleGMN network? Importantly, our method does not impose any limitations on the choice of the activation functions. We are able to select any activation function, because these are only applied within the MLPs of the invariant modules. As discussed in Section 5, the MLPs (equipped with non-linearities) are only applied after the canonicalization/symmetrization function. In case one chose to place activations in a different computational part of ScaleGMN, this would indeed limit their options so as not to compromise scale equivariance. However, this is not the case in our method. ", "page_idx": 25}, {"type": "text", "text": "Canon/symm mappings for all activation functions. In general, we cannot guarantee that canonicalization/symmetrization mappings are easy to construct for any activation function, since it is currently unknown if we can provide a general characterisation of the possible symmetries that may arise. Our results extend to all positively homogeneous activations, $\\sigma(\\lambda x)=\\lambda{\\dot{\\sigma}}(x),\\lambda>0$ , and all odd ones, $\\sigma(-x)=-\\sigma(x)$ . We refer the reviewer to Table 1 of Godfrey et al. [25], where we can see that LeakyReLU also falls in the first category. Regarding polynomial activations, which demonstrate non-zero scaling symmetries, one option would be: (1) norm division to canonicalise scale, and (2) sign symm/canon as discussed in this paper. The above, cover a fairly broad spectrum of common activation functions. ", "page_idx": 25}, {"type": "text", "text": "A.7 Deferred Proofs ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "A.7.1 Characterisation of symmetries ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "First we restate Proposition 4.1 and provided the detailed conditions for the activation function $\\sigma$ . ", "page_idx": 26}, {"type": "text", "text": "Proposition A.1 (Proposition 4.1 restated). Consider an activation function $\\sigma:\\mathbb{R}\\rightarrow\\mathbb{R}$ . ", "page_idx": 26}, {"type": "text", "text": "\u2022 (Lemma 3.1. [25].) If the matrix $\\sigma(\\mathbf{I}_{d})$ is invertible, then, for any $d\\in\\{1,2,\\dots\\}$ , there exists $a$ (non-empty) group of matrices, called the intertwiner group of $\\sigma_{d}$ defined as follows: $I_{\\sigma,d}=\\{\\mathbf{A}\\in\\mathbb{R}^{d\\times d}$ : invertible $|\\exists\\,\\mathbf{B}\\in\\mathbb{R}^{d\\times d}$ invertible, such that: $\\sigma(\\mathbf{Ax})=\\mathbf{B}\\sigma(\\mathbf{x})\\mathbf{\\right\\}$ , and a group homomorphism $\\phi_{\\sigma,d}~:~I_{\\sigma,d}~\\to~\\mathrm{GL}_{d}(\\mathbb{R}),$ , such that $\\mathbf{B}\\ =\\ \\phi_{\\sigma,d}(\\mathbf{A})\\ =$ $\\sigma(\\mathbf{A})\\sigma(\\mathbf{I}_{d})^{-1}$ .   \n\u2022 (Theorem E.14. [25].) Additionally, if $\\sigma$ is non-constant, non-linear and differentiable on a dense open set with finite complement, then every $\\textbf{A}\\in~I_{\\sigma,d}$ is of the form PQ, where $\\mathbf{P}$ : permutation matrix and $\\mathbf{Q}=d i a g{\\bigl(}q_{1},\\ldots{\\boldsymbol{q}}_{d}{\\bigr)}$ diagonal matrix, with $\\phi_{\\sigma,d}(\\mathbf{A})=$ $P d i a g\\big(\\phi_{\\sigma,1}(q_{1}),\\dots\\phi_{\\sigma,1}(q_{d})\\big)$ ", "page_idx": 26}, {"type": "text", "text": "Note that $\\mathbf{I}_{d}$ is the identity matrix $\\operatorname{GL}_{d}(\\mathbb{R})$ is the general linear group. The above two statements are proven in [25]. The exact form of $\\phi_{\\sigma,d}(\\mathbf{A})$ is not precisely given, but it is easy to derive: $\\phi_{\\sigma,d}$ is a group homomorphism and therefore $\\phi_{\\sigma,d}({\\bf P Q})\\;\\stackrel{!}{=}\\;\\;\\stackrel{\\cdot}{\\phi}_{\\sigma,d}({\\bf P})\\phi_{\\sigma,d}({\\bf Q})\\;\\;\\stackrel{\\cdot}{=}$ $\\mathrm{Pdiag}\\big(\\phi_{\\sigma,1}(q_{1}),\\dots\\phi_{\\sigma,1}(q_{d})\\big)$ , where we also used Lemma E.10. from [25] which states that $\\phi_{\\sigma,d}(\\mathbf{P})=\\mathbf{P}$ for permutation matrices. ", "page_idx": 26}, {"type": "text", "text": "Proposition A.2 (restated). Hyperbolic tangent activation function $\\sigma(x)=\\operatorname{tanh}(x)$ and SIREN activation function, i.e. $\\sigma(x)=\\sin(\\omega x)$ , satisfy the conditions of Proposition 4.1, when (for the latter) $\\omega\\neq k\\pi,k\\in\\mathbb{Z}$ . Additionally, $I_{\\sigma,d}$ contains signed permutation matrices of the form PQ, with $\\mathbf{Q}=\\operatorname{diag}(q_{1},\\ldots,q_{d})$ , $q_{i}=\\pm1$ and $\\phi_{\\sigma,d}(\\mathbf{PQ})=\\mathbf{PQ}$ . ", "page_idx": 26}, {"type": "text", "text": "Proof. Example 1: $\\sigma(x)=\\sin(\\omega x)$ , with $\\omega>0$ constant: ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "This is the most common activation function for INRs [70]. We can easily find the conditions under which $\\sigma(\\mathbf{I}_{d})$ is invertible invoking Lemma E.7. from Godfrey et al. [25]. In particular, the latter states that if $\\sigma(1)\\overset{\\cdot}{\\neq}\\sigma(0)$ , $\\sigma(1)\\neq-(\\bar{d}-1)\\sigma(0)$ , then $\\sigma(\\mathbf{I}_{d})$ is invertible. ", "page_idx": 26}, {"type": "text", "text": "In our case, $\\sigma(0)=\\sin(\\omega0)=0,\\sigma(1)=\\sin(\\omega)$ . Therefore, it should hold that $\\omega\\neq k\\pi,k\\in\\mathbb{Z},$ otherwise $\\sigma(\\mathbf{I}_{d})$ is an all-zeros matrix. Additionally, $\\sigma$ is non-constant, non-linear and differentiable everywhere. Thus, as dictated by Proposition 4.1, we can characterise the intertwiner group, by identifying the function $\\phi_{\\sigma,1}(a)$ . In particular, $b=\\phi_{\\sigma,1}(a)$ if the following holds: ", "page_idx": 26}, {"type": "equation", "text": "$$\n\\begin{array}{r l r}&{}&{\\sin(\\omega a x)=b\\sin(\\omega x)\\Rightarrow\\sin^{2}(\\omega a x)=b^{2}\\sin^{2}(\\omega x)\\Rightarrow1-\\cos^{2}(\\omega a x)=b^{2}\\sin^{2}(\\omega x)}\\\\ &{}&{\\omega a\\cos(\\omega a x)=b\\omega\\cos(\\omega x)\\Rightarrow a^{2}\\cos^{2}(\\omega a x)=b^{2}\\cos^{2}(\\omega x),}\\end{array}\n$$", "text_format": "latex", "page_idx": 26}, {"type": "text", "text": "where in the second line we took the derivative of each side since the equation holds for all $x\\in\\mathbb R$ and divided by $\\omega\\neq0$ . Now summing up the two equations we obtain: ", "page_idx": 26}, {"type": "equation", "text": "$$\n1+\\cos^{2}(\\omega a x){\\big(}a^{2}-1)=b^{2}\\Rightarrow\\cos^{2}(\\omega a x){\\big(}a^{2}-1)=b^{2}-1\\Rightarrow a^{2}-1=b^{2}-1=0.\n$$", "text_format": "latex", "page_idx": 26}, {"type": "text", "text": "The above is true because if $a^{2}\\neq1$ , then one would conclude that $\\cos^{2}(\\omega a x)=$ constant. Thus, $a=\\pm1$ and $b=\\pm1$ . Additionally $a$ cannot be different than $b$ , since in that case we would have e.g. $\\sin(\\omega x)=-\\sin(\\omega x)\\Rightarrow\\sin(\\omega x)=0$ . Therefore: ", "page_idx": 26}, {"type": "equation", "text": "$$\n\\phi_{\\sigma,1}(a)=a,\\quad a=\\{-1,1\\}\\,\\,\\,\\mathrm{and}\\;\\phi_{\\sigma,d}(\\mathbf{PQ})=\\mathbf{PQ},\\quad\\mathbf{PQ}:\\,\\,\\mathrm{signed}\\;\\mathrm{permutation~matrices}.\n$$", "text_format": "latex", "page_idx": 26}, {"type": "text", "text": "Example 2: $\\sigma(x)=\\operatorname{tanh}(x)$ : ", "page_idx": 26}, {"type": "text", "text": "We can easily verify that $\\sigma(\\mathbf{I}_{d})$ is invertible invoking the same Lemma E.7. from Godfrey et al. [25] as before. We have, $\\begin{array}{r}{\\sigma(0)\\,=\\,\\operatorname{tanh}(0)\\,=\\,0,\\sigma(1)\\,=\\,\\operatorname{tanh}(1)\\,=\\,\\frac{e^{2}-1}{e^{2}+1}\\,\\neq\\,0}\\end{array}$ . Additionally, $\\sigma$ is non-constant, non-linear and differentiable everywhere. Thus, again as dictated by Proposition 4.1, we ", "page_idx": 26}, {"type": "text", "text": "will characterise the intertwiner group, by identifying the function $\\phi_{\\sigma,1}(a)$ . In particular, $b=\\phi_{\\sigma,1}(a)$ if the following holds: ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\begin{array}{c}{{\\operatorname{tanh}(a x)=b\\operatorname{tanh}(x)\\Rightarrow\\operatorname{tanh}^{2}(a x)=b^{2}\\operatorname{tanh}^{2}(x)}}\\\\ {{a\\big(1-\\operatorname{tanh}^{2}(a x)\\big)=b\\big(1-\\operatorname{tanh}^{2}(x),\\;\\;}}\\end{array}\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "where in the second line we took the derivative of each side since the equation holds for all $x\\in\\mathbb{R}$ . Now summing up the two equations we obtain: ", "page_idx": 27}, {"type": "equation", "text": "$$\na+\\operatorname{tanh}^{2}(a x){\\big(}1-a)=b+\\operatorname{tanh}^{2}(x){\\big(}b^{2}-b)\\Rightarrow\\operatorname{tanh}^{2}(x){\\big(}1-\\alpha-b^{2}+b)=b-a\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "The above is true because if $b^{2}-b+a-1\\neq0$ , then one would conclude that $\\operatorname{tanh}^{2}(a x)=\\,$ constant. Therefore: ", "page_idx": 27}, {"type": "text", "text": "$\\phi_{\\sigma,1}(a)=a,\\quad a=\\{-1,1\\}\\,\\,\\,\\mathrm{and}\\,\\,\\phi_{\\sigma,d}(\\mathbf{PQ})=\\mathbf{PQ},\\quad\\mathbf{PQ}:\\,\\,\\mathrm{signed}\\,\\,\\mathrm{perm}$ utation matrices. (36) ", "page_idx": 27}, {"type": "text", "text": "A.7.2 Theoretical analysis of ScaleGMN ", "text_level": 1, "page_idx": 27}, {"type": "text", "text": "Proposition A.3 (Proposition 5.1 restated). ScaleGMN is permutation/scale equivariant or permutation/scale invariant when using a readout with the same symmetries. ", "page_idx": 27}, {"type": "text", "text": "Proof. We will prove this by induction. In particular, consider two equivalent parameterisations $\\pmb{\\theta}^{\\prime},\\pmb{\\theta}$ as in Eq. (3). This implies that vertex/edge features will have the same symmetries, i.e. starting with the hidden neurons: ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{x}_{V}^{\\prime}(i)=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)\\mathbf{x}_{V}\\left(\\pi_{\\ell}\\left(i\\right)\\right),\\quad\\ell=\\mathrm{layer}\\left(i\\right)\\in\\{1,\\ldots,L-1\\}}\\\\ &{\\mathbf{x}_{E}(i,j)=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)\\mathbf{x}_{E}\\left(\\pi_{\\ell}\\left(i\\right),\\pi_{\\ell-1}\\left(j\\right)\\right)q_{\\ell-1}^{-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right),\\;\\ell=\\mathrm{layer}\\left(i\\right)\\in\\{2,\\ldots,L-1\\},}\\end{array}\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "We will show that these symmetries are propagated to representations for every $t\\geq0$ , i.e. that Eq. (4) and Eq. (5). Let us start with the base $t=0$ . ", "page_idx": 27}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{h}_{V}^{\\prime_{0}}(i)=\\mathrm{INT}_{V}\\left(\\mathbf{x}_{V}^{\\prime}\\left(i\\right),\\mathbf{p}_{V}(i)\\right)=\\mathrm{INT}_{V}\\left(q_{\\ell}\\left(\\pi\\left(i\\right)\\right)\\mathbf{x}_{V}\\left(\\pi_{\\ell}\\left(i\\right)\\right),\\mathbf{p}_{V}(i)\\right)}\\\\ &{\\quad\\quad\\quad=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)\\mathrm{INT}_{V}\\left(\\mathbf{x}_{V}\\left(\\pi_{\\ell}\\left(i\\right)\\right),\\mathbf{p}_{V}(i)\\right)=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)\\mathbf{h}_{V}^{0}\\left(\\pi_{\\ell}\\left(i\\right)\\right),}\\\\ &{\\mathbf{h}_{E}^{\\prime_{0}}(i)=\\mathrm{INT}_{E}\\left(\\mathbf{x}_{E}^{\\prime}\\left(i,j\\right),\\mathbf{p}_{E}(i,j)\\right)}\\\\ &{\\quad\\quad\\quad=\\mathrm{INT}_{E}\\left(q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)\\mathbf{x}_{E}\\left(\\pi_{\\ell}\\left(i\\right),\\pi_{\\ell-1}\\left(j\\right)\\right)q_{\\ell-1}^{-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right),\\mathbf{p}_{E}(i,j)\\right)}\\\\ &{\\quad\\quad\\quad=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)q_{\\ell-1}^{-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right)\\mathrm{INT}_{E}\\left(\\mathbf{x}_{E}\\left(\\pi_{\\ell}\\left(i\\right),\\pi_{\\ell-1}\\left(j\\right)\\right),\\mathbf{p}_{E}(i,j)\\right)}\\\\ &{\\quad\\quad\\quad=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)q_{\\ell-1}^{-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right)\\mathbf{h}_{E}^{0}\\left(\\pi_{\\ell}\\left(i\\right),\\pi_{\\ell-1}\\left(j\\right)\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 27}, {"type": "text", "text": "This is due to the properties of the initialisation functions - see Eq. (20). Now we proceed with the induction step. Suppose Eq. (4) and Eq. (5) hold for $t-1$ . We will show this implies they hold for $t$ : ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\mathbf{m}_{p}^{\\star}(t)=\\bigoplus_{\\substack{\\ell\\in\\mathcal{N}_{D}(\\cdot)\\,\\mathbf{R}\\leq T}}\\mathbf{a}_{\\ell}(\\mathbf{k}_{\\ell}^{\\mathrm{-}}(t),\\mathbf{k}_{\\ell}^{\\mathrm{-}}(t),\\mathbf{k}_{\\ell}^{\\mathrm{-}}(t),j)}\\\\ {=\\bigoplus_{\\substack{\\ell\\in\\mathcal{N}_{D}(\\cdot)\\,\\mathbf{R}\\leq T}}\\mathbf{a}_{\\ell}^{\\mathrm{BC}}\\Big(\\mathbf{e}_{\\ell}(\\tau(\\ell),\\mathbf{k}_{\\ell}^{\\mathrm{-}})(\\tau_{\\ell}(\\ell),\\mathbf{j}_{\\ell})\\Big)\\mathbf{b}_{\\ell}^{\\star\\rightarrow1}(\\tau_{\\ell-1}(j))\\Big\\}}\\\\ {\\Leftrightarrow}&{\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\times\\mathbf{q}_{\\ell}^{\\mathrm{BC}}\\Big(\\tau_{\\ell-1}(j),\\mathbf{j}_{\\ell})(\\tau_{\\ell-1}(j))\\Big)}\\\\ {=\\bigoplus_{\\substack{\\ell\\in\\mathcal{N}_{D}(\\cdot)\\,\\mathbf{R}\\leq T}}\\Big(\\mathbf{a}_{\\ell}(\\tau(\\ell))\\mathbf{k}_{\\ell}^{\\mathrm{BC}}\\Big(\\mathbf{r}_{\\ell}^{\\mathrm{-}}(\\tau_{\\ell}(\\ell),\\mathbf{j}_{\\ell})\\Big)\\mathbf{b}_{\\ell}^{\\star\\rightarrow1}(\\tau_{\\ell-1}(j))\\Big)\\mathbf{b}_{\\ell}^{\\star\\rightarrow1}(\\tau_{\\ell}(\\ell),\\mathbf{r}_{\\ell-1}(j))}\\\\ {=\\varphi_{\\ell}(\\tau(\\ell))\\bigoplus_{\\substack{\\ell\\in\\mathcal{N}_{D}(\\cdot)\\,\\mathbf{R}\\leq T}}\\mathbf{b}_{\\ell}^{\\mathrm{BC}}\\Big(\\mathbf{b}_{\\ell}^{\\star\\rightarrow1}(\\tau_{\\ell}(\\ell)),\\mathbf{b}_{\\ell}^{\\star\\rightarrow1}(\\tau_{\\ell}(\\ell),\\mathbf{j}_{\\ell})\\Big)\\mathbf{b}_{\\ell}^{\\star\\rightarrow1}(\\tau_{\\ell}(\\ell),\\mathbf{j}_{\\ell})}\\\\ {=\\varphi(\\tau(\\ell))\\mathbf{b}_{\\ell}^{\\star}(\\tau_{\\ell}(\\ell))\\Big(\\mathbf{a}_{\\ell}^{\\mathrm{BD}}\\Big)\\qquad\\qquad\\qquad\\qquad\\\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Therefore we have shown the desideratum for hidden neurons, where again we used the properties of the message and update functions (we omitted positional encodings here for brevity). Now for the input neurons, we have: ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\mathbf{x}_{V}^{\\prime}(i)=\\mathbf{x}_{V}(i),\\quad\\ell=\\mathrm{layer}\\left(i\\right)=1}\\\\ &{\\mathbf{x}_{E}(i,j)=q_{\\ell}\\left(\\pi_{\\ell}\\left(i\\right)\\right)\\mathbf{x}_{E}\\left(\\pi_{\\ell}\\left(i\\right),j\\right),\\;\\ell=\\mathrm{layer}\\left(i\\right)=1,}\\end{array}\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Further, we perform the induction again for Eq. (27) and Eq. (28) hold. Base case $t=0$ . ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{{\\mathbf{h}_{V}^{'0}}(i)=\\mathrm{INIT}_{V,0}\\left({\\mathbf{x}_{V}^{\\prime}}\\left(i\\right),{\\mathbf{p}_{V}}(i)\\right)=\\mathrm{INIT}_{V,0}\\left({\\mathbf{x}_{V}}(i),{\\mathbf{p}_{V}}(i)\\right)}\\\\ &{\\qquad\\quad=\\mathrm{INIT}_{V,0}\\left({\\mathbf{x}_{V}}(i),{\\mathbf{p}_{V}}(i)\\right)={\\mathbf{h}_{V}^{0}}\\left(i\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Induction step: ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{m}_{V}^{'t}(i)=\\mathbf{0}=\\mathbf{m}_{V}^{t}(i).}\\\\ &{\\mathbf{h}_{V}^{'t}(i)=\\mathrm{UPD}_{V}^{t}\\big(\\mathbf{h}_{V}^{'t-1}(i),\\mathbf{m}_{V}^{'t}(i)\\big)=\\mathrm{UPD}_{V}^{t}\\big(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{m}_{V}^{t}(i)\\big)=\\mathbf{h}_{V}^{t}(i),}\\end{array}\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "since input vertices do not have any incoming edge. Finally, for the output neurons, we have: ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\quad\\mathbf{x}_{V}^{\\prime}(i)=\\mathbf{x}_{V}(i),\\quad\\ell=\\mathrm{layer}\\left(i\\right)=L}\\\\ &{\\quad\\mathbf{x}_{E}(i,j)=q_{\\ell-1}^{-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right)\\mathbf{x}_{E}\\left(i,\\pi_{\\ell-1}\\left(j\\right)\\right),\\;\\ell=\\mathrm{layer}\\left(i\\right)=L,}\\end{array}\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "Induction for Eq. (27) and Eq. (29). Base case $t=0$ . ", "page_idx": 28}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{h}_{V}^{\\prime_{0}}(i)=\\mathrm{INT}_{V,L}\\left(\\mathbf{x}_{V}^{\\prime}\\left(i\\right),\\mathbf{p}_{V}(i)\\right)=\\mathrm{INT}_{V,L}\\left(\\mathbf{x}_{V}(i),\\mathbf{p}_{V}(i)\\right)}\\\\ &{\\quad\\quad\\quad=\\mathrm{INT}_{V,L}\\left(\\mathbf{x}_{V}(i),\\mathbf{p}_{V}(i)\\right)=\\mathbf{h}_{V}^{0}\\left(i\\right),}\\\\ &{\\mathbf{h}_{E}^{\\prime_{0}}(i)=\\mathrm{INT}_{E,L}\\left(\\mathbf{x}_{E}^{\\prime}\\left(i,j\\right),\\mathbf{p}_{E}(i,j)\\right)}\\\\ &{\\quad\\quad\\quad=\\mathrm{INT}_{E,L}\\left(q_{\\ell-1}^{-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right)\\mathbf{x}_{E}\\left(i,\\pi_{\\ell-1}\\left(j\\right)\\right),\\mathbf{p}_{E}(i,j)\\right)}\\\\ &{\\quad\\quad\\quad=q_{\\ell}^{-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right)\\mathrm{INI}_{E,L}\\left(\\mathbf{x}_{E}\\left(i,\\pi_{\\ell-1}\\left(j\\right)\\right),\\mathbf{p}_{E}(i,j)\\right)}\\\\ &{\\quad\\quad\\quad=q_{\\ell}^{-1}\\left(\\pi_{\\ell-1}\\left(j\\right)\\right)\\mathbf{h}_{E}^{0}\\left(i,\\pi_{\\ell-1}\\left(j\\right)\\right).}\\end{array}\n$$", "text_format": "latex", "page_idx": 28}, {"type": "text", "text": "And the induction step: ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\mathbf{m}_{\\mathcal{N}}^{\\dagger}(i)=\\bigoplus_{\\substack{\\phi\\leq\\infty}}\\mathrm{ASG}_{\\mathcal{N}}^{\\dagger}\\left(\\mathbf{b}_{\\mathcal{N}}^{\\dagger}-(i)\\mathbf{,~}\\mathbf{b}_{\\mathcal{N}}^{\\dagger}-(i)\\mathbf{,~}\\mathbf{b}_{\\mathcal{N}}^{\\dagger}-(i)\\mathbf{,~}\\mathbf{b}_{\\mathcal{N}}^{\\dagger}\\right)}\\\\ &{\\qquad-\\bigoplus_{\\substack{\\phi\\leq\\infty}}\\mathrm{ASG}_{\\mathcal{N}}^{\\dagger}\\left(\\mathbf{b}_{\\mathcal{N}}^{\\dagger}-(i)\\mathbf{,~}\\mathbf{g}_{\\mathcal{N}-1}^{\\dagger}\\left(\\mathbf{,~}\\mathbf{g}_{i}-\\mathbf{1}\\right)\\mathbf{1}\\mathbf{b}_{\\mathcal{N}}^{\\dagger}\\mathbf{\\scriptscriptstyle\\prime}(\\mathbf{\\cdot}\\mathbf{\\Lambda}_{\\mathcal{N}-1}\\mathbf{\\;(}i))\\right),}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\mathbf{b}_{\\mathcal{N}}^{\\dagger}=(i)\\mathbf{,}}\\\\ &{=\\bigoplus_{\\substack{\\phi\\leq\\infty}}\\mathrm{ASG}_{\\mathcal{N}}^{\\dagger}\\left(\\mathbf{b}_{\\mathcal{N}}^{\\dagger}-(i)\\mathbf{,~}\\mathbf{b}_{\\mathcal{N}}^{\\dagger}-(\\mathbf{\\cdot}\\mathbf{\\Lambda}_{\\mathcal{N}})\\mathbf{1}\\mathbf{b}_{\\mathcal{N}}^{\\dagger}\\mathbf{\\scriptscriptstyle\\prime}(\\mathbf{\\cdot}\\mathbf{\\Lambda}_{\\mathcal{N}-1}\\mathbf{\\;(}i))\\right)}\\\\ &{\\qquad-\\bigoplus_{\\substack{\\phi\\leq\\infty}}\\mathrm{ASG}_{\\mathcal{N}}^{\\dagger}\\left(\\mathbf{b}_{\\mathcal{N}}^{\\dagger}-(i)\\mathbf{,~}\\mathbf{b}_{\\mathcal{N}}^{\\dagger}\\mathbf{\\scriptscriptstyle\\prime}(\\mathbf{\\cdot}\\mathbf{\\Lambda}_{\\mathcal{N}})\\mathbf{1}\\mathbf{b}_{\\mathcal{N}}^{\\dagger}\\mathbf{\\scriptscriptstyle\\prime}(i,j)\\right)}\\\\ &{\\qquad-\\underset{\\mathcal{N}}{\\to}}\\\\ &{\\mathbf{b}_{\\mathcal{N}}^{\\dagger}(i)=\\mathbf{U}^{\\dagger}(i),\\,\\,}\\\\ {\\mathbf{b}_{\\mathcal{N}}^{\\dagger}(i)=\\mathbf{U}^{\\dagger}\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\n$$", "text_format": "latex", "page_idx": 29}, {"type": "text", "text": "Again we used the properties of the message and update functions we defined in Appendix A.1.4. And with that, we conclude the proof. \u53e3 ", "page_idx": 29}, {"type": "text", "text": "Theorem A.4 (restated). Consider a FFNN as per Eq. (1) with activation functions respecting the conditions of Proposition 4.1. Assume a Bidirectional-ScaleGMN with vertex update functions that can express the activation functions $\\sigma_{\\ell}$ and their derivatives $\\sigma_{\\ell}^{\\prime}$ . Further, assume that ScaleGMN has access to the inputs $\\mathbf{x}_{\\mathrm{0}}$ and the gradients of an (optional) loss function $\\mathcal{L}$ w.r.t. to the output $\\nabla_{\\mathbf{x}_{L}}\\mathcal{L}_{:}$ , via its positional encodings. Then, ScaleGMN can simulate both a forward and a backward pass of the FFNN, by storing pre-activations, post-activations and their gradients at the vertex representations. In particular, to compute the forward pass at the FFNN layer $\\ell$ , $t\\geq\\ell$ ScaleGMN layers are required, while for the corresponding backward, the requirement is $t\\geq2L-\\ell$ . ", "page_idx": 29}, {"type": "text", "text": "Proof. Consider a loss function $\\mathcal{L}:\\mathbb{R}^{d_{\\mathrm{out}}}\\times\\mathbb{R}^{d_{\\mathrm{out}}}\\rightarrow\\mathbb{R}$ , which is computed on the output of the FFNN $\\mathcal{L}(\\mathbf{x}_{L},\\cdot)$ . The second argument is optional and is used when we have labelled data - we will omit it in our derivations for brevity. Our proof strategy is based on two observations: ", "page_idx": 29}, {"type": "text", "text": "First, the pre-activations of each layer (denoted here as $\\mathbf{z}_{\\ell}\\;=\\;\\mathbf{W}_{\\ell}\\mathbf{x}_{\\ell-1}\\,+\\,\\mathbf{b}_{\\ell})$ have the same symmetries as the biases. This is straightforward to see by induction: ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\begin{array}{r l r}&{\\mathbf{z}_{0}^{\\prime}=\\mathbf{x}_{0}=\\mathbf{z}_{0},\\quad\\mathbf{x}_{0}^{\\prime}=\\mathbf{x}_{0}}&{\\mathrm{(base~case~}}\\\\ &{\\mathbf{z}_{1}^{\\prime}=\\mathbf{A}_{1}\\mathbf{W}_{1}\\mathbf{x}_{0}+\\mathbf{A}_{1}\\mathbf{b}_{1}=\\mathbf{A}_{1}\\mathbf{z}_{1},\\quad\\mathbf{x}_{1}^{\\prime}=\\sigma_{1}(\\mathbf{A}_{1}\\mathbf{z}_{1})=\\phi_{\\sigma_{1}}(\\mathbf{A}_{1})\\mathbf{x}_{1}}&{\\mathrm{(base~case~}}\\\\ &{\\mathbf{z}_{\\ell}^{\\prime}=\\mathbf{A}_{\\ell}\\mathbf{W}_{\\ell}\\phi_{\\sigma_{\\ell-1}}\\big(\\mathbf{A}_{\\ell-1}^{-1}\\big)\\mathbf{x}_{\\ell-1}^{\\prime}+\\mathbf{A}_{\\ell}\\mathbf{b}_{\\ell}=\\mathbf{A}_{\\ell}\\mathbf{W}_{\\ell}\\phi_{\\sigma_{\\ell-1}}\\big(\\mathbf{A}_{\\ell-1}^{-1}\\big)\\phi_{\\sigma_{\\ell-1}}\\big(\\mathbf{A}_{\\ell-1}\\big)\\mathbf{x}_{\\ell-1}+\\mathbf{A}_{\\ell}\\mathbf{b}_{\\ell}}&\\\\ &{\\quad=\\mathbf{A}_{\\ell}\\mathbf{z}_{\\ell},\\quad\\mathbf{x}_{\\ell}^{\\prime}=\\phi_{\\sigma_{\\ell}}(\\mathbf{A}_{\\ell})\\mathbf{x}_{\\ell}}&{\\mathrm{(induction~sterson~}\\mathrm{(~\\forall~\\ell~\\leq~\\sigma~1~)})}\\end{array}\n$$", "text_format": "latex", "page_idx": 29}, {"type": "text", "text": "Second, the gradients of $\\mathcal{L}$ w.r.t. the pre-activations of each layer (denoted here as $\\nabla_{\\mathbf{z}_{\\ell}}\\mathcal{L}(\\mathbf{x}_{L})=$ $\\begin{array}{r}{\\big(\\frac{\\partial\\mathbf{z}_{\\ell+1}}{\\partial\\mathbf{z}_{\\ell}}\\big)^{\\top}\\nabla_{\\mathbf{z}_{\\ell+1}}\\mathcal{L}(\\mathbf{x}_{L})}\\end{array}$ , where the dependence of $\\mathbf{x}_{L}$ on $\\mathbf{z}_{\\ell}$ is implied - sometimes we will omit the argument $\\mathbf{x}_{L}$ for brevity ) have the inverted $^+$ transpose symmetries of the biases. This is due to the invariance of the output to the symmetries considered: ", "page_idx": 29}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}^{\\prime}\\right)=\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}\\right)\\Longleftrightarrow\\mathcal{L}\\left(\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}^{\\prime}\\right)\\right)=\\mathcal{L}\\left(\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}\\right)\\right)}\\\\ &{\\quad\\quad\\quad\\quad\\quad\\Longleftrightarrow\\nabla_{\\mathbf{z}_{\\ell}}\\mathcal{L}\\left(\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}^{\\prime}\\right)\\right)=\\nabla_{\\mathbf{z}_{\\ell}}\\mathcal{L}\\left(\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}\\right)\\right)}\\\\ &{\\quad\\quad\\quad\\quad\\quad\\Longleftrightarrow(\\frac{\\partial\\mathbf{z}_{\\ell}^{\\prime}}{\\partial\\mathbf{z}_{\\ell}})^{\\top}\\nabla_{\\mathbf{z}_{\\ell}^{\\prime}}\\mathcal{L}\\left(\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}^{\\prime}\\right)\\right)=\\nabla_{\\mathbf{z}_{\\ell}}\\mathcal{L}\\left(\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}\\right)\\right)}\\\\ &{\\quad\\quad\\quad\\quad\\quad\\Longleftrightarrow\\mathbf{A}_{\\ell}^{\\top}\\nabla_{\\mathbf{z}_{\\ell}^{\\prime}}\\mathcal{L}\\left(\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}^{\\prime}\\right)\\right)=\\nabla_{\\mathbf{z}_{\\ell}}\\mathcal{L}\\left(\\mathbf{x}_{L}\\left(\\mathbf{z}_{\\ell}\\right)\\right)\\Longleftrightarrow\\nabla_{\\mathbf{z}_{\\ell}^{\\prime}}\\mathcal{L}=\\left(\\mathbf{A}_{\\ell}^{\\top}\\right)^{-1}\\nabla_{\\mathbf{z}_{\\ell}}\\mathcal{L},}\\end{array}\n$$", "text_format": "latex", "page_idx": 29}, {"type": "text", "text": "and similarly $\\nabla_{\\mathbf{x}_{\\ell}^{\\prime}}\\mathcal{L}=\\big(\\phi_{\\sigma_{\\ell}}(\\mathbf{A}_{\\ell})^{\\top}\\big)^{-1}\\nabla_{\\mathbf{x}_{\\ell}}\\mathcal{L}.$ ", "page_idx": 30}, {"type": "text", "text": "Now recall that in the cases we consider in this work, $\\phi_{\\sigma_{\\ell}}(\\mathbf{A})=\\mathbf{A}$ and $\\mathbf{A}=\\mathbf{P}\\mathbf{Q}$ . Therefore, given that $(\\mathbf{P}^{\\top})^{-1}=\\mathbf{P}$ and $(\\mathbf{Q}^{\\top})^{-1}=\\mathbf{Q}^{-1}$ , we have: ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{z}_{\\ell}^{\\prime}=\\mathbf{P}_{\\ell}\\mathbf{Q}_{\\ell}\\mathbf{z}_{\\ell},\\quad\\mathbf{x}_{\\ell}^{\\prime}=\\mathbf{P}_{\\ell}\\mathbf{Q}_{\\ell}\\mathbf{x}_{\\ell},\\quad\\nabla_{\\mathbf{z}_{\\ell}^{\\prime}}\\mathcal{L}=\\mathbf{P}_{\\ell}\\mathbf{Q}_{\\ell}^{-1}\\nabla_{\\mathbf{z}_{\\ell}}\\mathcal{L},\\quad\\nabla_{\\mathbf{x}_{\\ell}^{\\prime}}\\mathcal{L}=\\mathbf{P}_{\\ell}\\mathbf{Q}_{\\ell}^{-1}\\nabla_{\\mathbf{x}_{\\ell}}\\mathcal{L}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "The latter is what motivates us to enforce vertex representations to have the same symmetries with the biases: Assuming sufficient expressive power of ScaleGMN, we can anticipate that vertex representations will be able to reconstruct (1) the pre- or post-activations and (2) the elementwise-inverse of the pre- or post-activation gradients. ", "page_idx": 30}, {"type": "text", "text": "Now recall the formulas that we want to recover: ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{z}_{\\ell}(i)=\\displaystyle\\sum_{j\\in{\\cal N}_{F}(i)}\\mathbf{W}_{\\ell}(i,j)\\mathbf{x}_{\\ell-1}(j)+\\mathbf{b}_{\\ell}(i)=\\displaystyle\\sum_{j\\in{\\cal N}_{F}(i)}\\mathbf{W}_{\\ell}(i,j)\\sigma_{\\ell-1}\\big(\\mathbf{z}_{\\ell-1}(j)\\big)+\\mathbf{b}_{\\ell}(i)}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\times(i)=\\sigma_{\\ell}\\left(\\mathbf{z}_{\\ell}\\left(i\\right)\\right)=\\sigma_{\\ell}\\left(\\displaystyle\\sum_{j\\in{\\cal N}_{F}(i)}\\mathbf{W}_{\\ell}(i,j)\\mathbf{x}_{\\ell-1}(j)+\\mathbf{b}_{\\ell}(i)\\right)}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\nabla_{z_{\\ell}(i)}\\mathcal{L}=\\Big(\\big(\\displaystyle\\frac{\\partial\\mathbf{z}_{\\ell+1}}{\\partial\\mathbf{z}_{\\ell}}\\big)^{\\top}\\nabla_{\\mathbf{z}_{\\ell+1}}\\mathcal{L}\\Big)(i)=\\sigma_{\\ell}^{\\prime}\\big(\\mathbf{z}_{\\ell}(i)\\big)\\displaystyle\\sum_{j\\in{\\cal N}_{B}(i)}\\mathbf{W}_{\\ell}(j,i)\\nabla_{\\mathbf{z}_{\\ell+1}(j)}\\mathcal{L}}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\times(i)\\mathcal{L}}\\\\ &{\\qquad\\nabla_{\\mathbf{x}_{\\ell}(i)}\\mathcal{L}=\\Big(\\big(\\displaystyle\\frac{\\partial\\mathbf{z}_{\\ell+1}}{\\partial\\mathbf{x}_{\\ell}}\\big)^{\\top}\\nabla_{\\mathbf{z}_{\\ell+1}}\\mathcal{L}\\Big)(i)=\\displaystyle\\sum_{j\\in{\\cal N}_{B}(i)}\\mathbf{W}_{\\ell}(j,i)\\nabla_{\\mathbf{z}_{\\ell+1}(j)}\\mathcal{L}}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "Now let us proceed to the proof. We will show that there exists a parameterization of ScaleGMN, such that after $t=\\ell$ layers of message-passing, all vertices $i$ with layer $(i)\\le\\ell$ will have stored in a part of their representation the pre-/post-activations for one or more inputs to the datapoint NN. Additionally, we will show that after $t=2L-\\ell$ layers of message-passing, all vertices $i$ with layer $(i)\\geq\\ell$ will have stored in a part of their representation the pre-/post-activation gradients for one or more inputs to the datapoint NN. Therefore, $L$ layers of (forward) message-passing are needed to compute the output of the datapoint NN, and $2L$ layers of (bidirectional) message passing to calculate the gradients of the output/loss w.r.t. the input. ", "page_idx": 30}, {"type": "text", "text": "For reasons that will become clearer as we proceed with the proof, we construct the below parameterization of ScaleGMN. First off, recall the input vertex and edge representations are given by: ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{x}_{V}\\left(i\\right)=\\left\\{1,\\mathrm{layer}\\left(i\\right)=0,\\right.}\\\\ {\\left.\\mathbf{b}_{\\mathrm{layer}\\left(i\\right)}(\\mathrm{pos}\\left(i\\right)),\\mathrm{layer}\\left(i\\right)\\in[L],\\right.}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "equation", "text": "$$\n\\mathbf{x}_{E}(i,j)=\\mathbf{W}_{\\mathrm{layer}(i)}(\\mathrm{pos}\\ (i)\\,,\\mathrm{pos}\\ (j)),i>j\\quad\\mathbf{x}_{E}(j,i)=\\mathbf{1}\\oslash\\mathbf{W}_{\\mathrm{layer}(j)}(\\mathrm{pos}\\ (j)\\,,\\mathrm{pos}\\ (i)),i>j\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "Then, we use the vertex positional encodings to store the information of the input values and the gradients w.r.t the outputs: ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{p}_{V}(i)=\\left\\{\\begin{array}{l l}{\\left[\\mathbf{z}_{0}\\left(\\mathrm{pos}\\left(i\\right)\\right),\\mathbf{x}_{0}\\left(\\mathrm{pos}\\left(i\\right)\\right)\\right],\\mathrm{layer}\\left(i\\right)=0}\\\\ {\\left[0,0\\right],\\mathrm{layer}\\left(i\\right)\\in\\left[L-1\\right]}\\\\ {\\left[\\left(\\nabla_{\\mathbf{z}_{L}\\left(\\mathrm{pos}\\left(i\\right)\\right)}\\mathcal{L}\\right)^{-1},\\left(\\nabla_{\\mathbf{x}_{L}\\left(\\mathrm{pos}\\left(i\\right)\\right)}\\mathcal{L}\\right]\\right)^{-1},\\mathrm{layer}\\left(i\\right)=L}\\end{array}\\right.}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "Throughout the network, the vertex representations will be 5-dimensional: we will use one to relay its neuron\u2019s bias across ScaleGMN\u2019s layers, two for the pre-and post-activations and two for their respective gradients. One can repeat the process for m inputs, in which case the dimension will be $m+1$ . The edge representations will be $^{\\,l}$ -dimensional and will be simply used to relay the NN\u2019s weights throughout the network. ", "page_idx": 30}, {"type": "text", "text": "Now, let us define the vertex initialisation functions. ", "page_idx": 30}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathrm{INIT}_{V,0}\\left(\\mathbf{x},\\mathbf{p}_{x}\\right)=\\mathrm{MLP}\\left(\\mathbf{x},\\mathbf{p}\\right)=\\left[\\mathbf{x}[1],\\mathbf{p}_{x}[1],\\mathbf{p}_{x}[2],0,0\\right],}\\\\ &{\\mathrm{INIT}_{V,L}\\left(\\mathbf{x},\\mathbf{p}_{x}\\right)=\\mathrm{MLP}\\left(\\mathbf{x},\\mathbf{p}_{x}\\right)=\\left[\\mathbf{x}[1],0,0,\\mathbf{p}_{x}[1],\\mathbf{p}_{x}[2]\\right]}\\\\ &{\\quad\\mathrm{INIT}_{V}\\left(\\mathbf{x},\\mathbf{p}\\right)=\\mathsf{A u g S c a}|\\mathsf{e E q}\\left(\\mathbf{x},\\mathbf{p}\\right)=\\left[\\mathbf{x}[1],0,0,0,0\\right].}\\end{array}\n$$", "text_format": "latex", "page_idx": 30}, {"type": "text", "text": "Regarding the first two functions, it is obvious that can be expressed by an MLP. Regarding the third one, it can be expressed by AugScaleEq as follows: AugScaleEq $(\\mathbf{x},\\mathbf{p})\\ =\\ \\mathbf{\\bar{T}}_{x}\\mathbf{x}\\ \\tilde{\\odot}$ $\\mathsf{A u g S c a l e l n v}(\\mathbf{x},\\mathbf{p})\\,=\\,[1,0,0,0,0]^{\\top}\\mathbf{x}[1]\\odot[1,1,1,1]^{\\top}.$ , where the the constant vector can be expressed by AugScaleInv since it is invariant to the first argument. Further, for all edge initialisation and update functions (forward and backward): ", "page_idx": 31}, {"type": "equation", "text": "$$\n\\mathrm{INIT}_{E,*}\\left(\\mathbf{e},\\mathbf{p}_{e}\\right)=\\mathbf{e},\\quad\\mathrm{UPD}_{E,*}^{t}(\\mathbf{x},\\mathbf{y},\\mathbf{e})=\\mathbf{e}\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "which can both be expressed by AugScaleEq using the identity as linear transform and an AugScaleInv with constant output. ", "page_idx": 31}, {"type": "text", "text": "We will not use positional encodings in the message and update functions, therefore we use their definitions of Eq. (8), Eq. (9). In particular, the forward/backward message functions: ", "page_idx": 31}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathrm{MSG}_{V,\\mathrm{FW}}^{t}\\Big(\\mathbf{x},\\mathbf{y},\\mathbf{e}\\Big)=\\mathsf{S c a l e E q}\\left(\\big[\\mathbf{x},\\mathsf{R e S c a l e E q}\\left(\\mathbf{y},\\mathbf{e}\\right)\\big]\\right)=\\mathbf{y}[3]\\cdot\\mathbf{e}[1]}\\\\ &{\\mathrm{MSG}_{V,\\mathrm{BW}}^{t}\\Big(\\mathbf{x},\\mathbf{y},\\mathbf{e}\\Big)=g_{m}(\\mathbf{y}[4]\\cdot\\mathbf{e}[1]),}\\end{array}\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "where $g(\\cdot)={\\sf S c a l e E q}\\left(\\cdot\\right)$ an arbitrarily expressive scale equivariant function. In the first case, this can be expressed as follows: zero linear transform on $\\mathbf{x}$ (since it\u2019s unnecessary), identity transform on the output of ReScaleEq and a ScaleInv with constant output (ones). Then what remains is ReScaleEq $(\\mathbf{y},\\mathbf{e})=\\mathbf{\\Gamma}_{y}\\mathbf{y}\\odot\\mathbf{\\dot{r}}_{e}\\mathbf{e}=[0,0,1,0,0]^{\\top}\\mathbf{y}\\cdot\\mathbf{e}[1]=\\mathbf{y}[3]\\cdot\\mathbf{e}[1]$ . ", "page_idx": 31}, {"type": "text", "text": "Finally, the vertex update functions: ", "page_idx": 31}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathrm{UPD}_{V,0}^{t}(\\mathbf{x},\\mathbf{m}_{\\mathrm{FW}},\\mathbf{m}_{\\mathrm{BW}})=\\mathrm{MLP}(\\mathbf{x},\\mathbf{m}_{\\mathrm{FW}},\\mathbf{m}_{\\mathrm{BW}})}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad=\\left[\\mathbf{x}[1],\\mathbf{x}[2],\\mathbf{x}[3],(\\sigma_{0}^{\\prime}(\\mathbf{x}[2])^{-1}\\cdot g_{U}(\\mathbf{m}_{\\mathrm{BW}}[1]),g_{U}(\\mathbf{m}_{\\mathrm{BW}}[1])\\right]}\\\\ &{\\mathrm{UPD}_{V,L}^{t}(\\mathbf{x},\\mathbf{m}_{\\mathrm{FW}},\\mathbf{m}_{\\mathrm{BW}})=\\mathrm{MLP}(\\mathbf{x},\\mathbf{m}_{\\mathrm{FW}},\\mathbf{m}_{\\mathrm{BW}})}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad=\\left[\\mathbf{x}[1],\\mathbf{x}[1]+\\mathbf{m}_{\\mathrm{FW}}[1],\\sigma_{L}\\left(\\mathbf{x}[1]+\\mathbf{m}_{\\mathrm{FW}}[1]\\right),\\mathbf{x}[4],\\mathbf{x}[5]\\right]}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad=\\mathrm{Scalef}_{0}([\\mathbf{x},\\mathbf{m}_{\\mathrm{FW}},\\mathbf{m}_{\\mathrm{BW}}])}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad=\\left[\\mathbf{x}[1],\\mathbf{x}[1]+\\mathbf{m}_{\\mathrm{FW}}[1],\\sigma\\left(\\mathbf{x}[1]+\\mathbf{m}_{\\mathrm{FW}}[1]\\right),}\\\\ &{\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\left(\\sigma^{\\prime}(\\mathbf{x}[2])^{-1}\\cdot g_{U}(\\mathbf{m}_{\\mathrm{BW}}[1]),g_{U}\\left(\\mathbf{m}_{\\mathrm{BW}}[1]\\right)\\right],}\\end{array}\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "where $g_{U}(\\cdot)\\,=\\,{\\sf S c a l e E q}(\\cdot)$ an arbitrarily expressive scale equivariant function. The first two can obviously be expressed by an MLP (note also that usually $\\sigma_{0},\\sigma_{L}$ are the identity). Regarding the third, first, we assumed a common activation function $\\sigma$ across hidden layers. In case the activation is not shared, a different update function should be used per layer. This is because, as we will see below, the activation and its derivative need to be learned for ScaleGMN to simulate the forward and the backward passes. Now, let\u2019s see how its element can be expressed by ScaleEq. Recall that $\\mathsf{S c a l e E q}(\\mathbf{a})=\\Gamma\\mathbf{a}\\,\\odot\\,\\mathsf{S c a l e l n v}(\\mathbf{a}$ ). Here, $\\mathbf{T}\\in\\mathbb{R}^{5\\times7}$ (7 inputs, 5 outputs). The first element (which will be the bias), the second (pre-activation) can be expressed by a ScaleInv with constant output (ones) and $\\mathbf{\\Gamma}_{\\mathbf{\\Gamma}}(1)$ an all-zero vector except for the ${1}s t$ or the ${\\mathit{1}}s t$ and 6th coordinates respectively. ", "page_idx": 31}, {"type": "text", "text": "The third (post-activation), fourth (pre-activation gradient) and the fifth (post-activation gradient) elements are not straightforward to simulate with elementary operations. However, one can observe that all are scale equivariant. In particular, the third: $\\sigma(q x+q y)=q\\sigma(x+y)$ (by assumption about the symmetries of the activation function). Additionally, the fourth (assuming a scale equivariant $g_{U}$ ): $\\begin{array}{r}{\\frac{g_{U}(\\dot{q}\\dot{y})}{\\sigma^{\\prime}(q x)}=\\frac{q\\cdot g_{U}(y)}{\\sigma^{\\prime}(x)}}\\end{array}$ - this is because the derivative of a scale equivariant activation function is scale invariant.8 The fifth is by definition scale equivariant. Therefore, $i f$ ScaleEq is sufficiently expressive, so as to contain all scale equivariant functions, then it can express the third to fifth elements. ", "page_idx": 31}, {"type": "text", "text": "It remains to establish a few last statements that will be necessary in our induction. First, the edge representations are constant throughout ScaleGMN and equal to the weights of the input NN: ", "page_idx": 31}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{h}_{E}^{0}(i,j)=\\mathrm{INIT}_{E,*}^{t}\\left(\\mathbf{x}_{E}\\left(i,j\\right),\\mathbf{p}_{E}(i,j)\\right)=\\mathbf{x}_{E}\\left(i,j\\right)=\\mathbf{W}_{\\mathrm{layer}(i)}(\\mathrm{pos}\\left(i\\right),\\mathrm{pos}\\left(j\\right))}\\\\ &{\\mathbf{h}_{E}^{t}(i,j)=\\mathrm{UPD}_{E,*}^{t}\\left(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{h}_{V}^{t-1}(j),\\mathbf{h}_{E}^{t-1}(i,j)\\right)=\\mathbf{h}_{E}^{t-1}(i,j)=\\cdot\\cdot=\\mathbf{h}_{E}^{0}(i,j).}\\end{array}\n$$", "text_format": "latex", "page_idx": 31}, {"type": "text", "text": "Second, the first element of the vertex representations is constant throughout ScaleGMN and equal to the biases of the input NN: ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{h}_{V}^{0}(i)[1]=\\mathrm{INT}_{V,*}^{t}\\left(\\mathbf{x}_{V}\\left(i\\right),\\mathbf{p}_{V}(i)\\right)[1]=\\mathbf{x}_{V}(i)[1]=\\left\\{\\mathbf{1},\\mathrm{layer}\\left(i\\right)=0,\\right.}\\\\ &{\\mathbf{h}_{V}^{t}(i)[1]=\\mathrm{UPD}_{V,*}^{t}\\left(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{m}_{V,\\mathrm{FW}}^{t}(i),\\mathbf{m}_{V,\\mathrm{BW}}^{t}(i)\\right)=\\mathbf{h}_{V}^{t-1}(i)[1]=\\cdots=\\mathbf{h}_{V}^{0}(i)[1]}\\end{array}\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "Now, our first induction hypothesis is the following: If for all vertices with layer $(i)=\\ell$ and $t\\geq\\ell$ we have that $\\mathbf{h}_{V}^{t}(i)[2:3]\\stackrel{}{=}[\\mathbf{z}_{\\ell}(p o s\\left(i\\right)),\\mathbf{\\dot{x}}_{\\ell}(p o s\\left(i\\right))]$ , then the same should hold for vertices with layer $(i)=\\ell+\\mathrm{1}$ when $t\\geq\\ell+1$ . ", "page_idx": 32}, {"type": "text", "text": "\u2022 (Base case:) If layer $(i)=0$ : ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{h}_{V}^{t}(i)[2:3]=\\mathrm{UPD}_{V,0}^{t}\\left(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{m}_{V}^{t}(i)\\right)[2:3]}\\\\ &{\\quad\\quad\\quad\\quad=\\mathbf{h}_{V}^{t-1}(i)[2:3]=\\cdot\\cdot\\cdot=\\mathbf{h}_{V}^{0}(i)[2:3]}\\\\ &{\\quad\\quad\\quad\\quad=\\mathrm{INIT}_{V,0}\\left(\\mathbf{x}_{V}\\left(i\\right),\\mathbf{p}_{V}(i)\\right)[2:3]}\\\\ &{\\quad\\quad\\quad\\quad=\\left[\\mathbf{z}_{0}\\left(\\mathrm{pos}\\left(i\\right)\\right),\\mathbf{x}_{0}\\left(\\mathrm{pos}\\left(i\\right)\\right)\\right]}\\end{array}\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "Therefore, the hypothesis holds for $t\\geq0=\\log\\!\\;\\!\\left(i\\right)$ for the base case. ", "page_idx": 32}, {"type": "text", "text": "\u2022 (Induction step:) Suppose the hypothesis holds for vertices with layer $(i)\\,=\\,\\ell\\,-1\\,<\\,L$ . Now, if layer $(i)=\\ell$ , for $t\\geq\\ell$ we have: ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\mathbf{m}_{V,\\mathrm{FW}}^{t}(i)=\\bigoplus_{j\\in\\mathcal{N}_{F}(i)}\\mathbf{M}\\mathbf{S}\\mathbf{G}_{V,\\mathrm{FW}}^{t}\\mathbf{\\Big(h}_{V}^{t-1}(i),\\mathbf{h}_{V}^{t-1}(j),\\mathbf{h}_{E}^{t-1}(i,j)\\Big)}&{}\\\\ {=\\sum_{j\\in\\mathcal{N}_{F}(i)}\\mathbf{h}_{V}^{t-1}(j)[3]\\cdot\\mathbf{h}_{E}^{t-1}(i,j)[1]}&{\\mathrm{(aper}\\,(j)=\\ell-1,t-1\\ge\\ell-1)}\\\\ {=\\sum_{j\\in\\mathcal{N}_{F}(i)}\\mathbf{x}_{\\ell-1}\\left(\\mathbf{p}_{0}\\otimes\\left(j\\right)\\right)\\cdot\\mathbf{W}_{\\ell}\\big(\\mathbf{pos}\\,(i),\\,\\mathrm{pos}\\,(j)\\big)}&{}\\\\ {\\mathbf{h}_{V}^{t}(i)[2:3]=\\boldsymbol{\\mathrm{UPD}}_{V}^{t}\\big(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{m}_{V}^{t}(i)\\big)[2:3]}&{}\\\\ {=\\big[\\mathbf{h}_{V}^{t-1}(i)[1]+\\mathbf{m}_{V,\\mathrm{FW}}^{t}(i),\\sigma\\big(\\mathbf{h}_{V}^{t-1}(i)[1]+\\mathbf{m}_{V,\\mathrm{FW}}^{t}(i)\\big)\\big]}&{}\\\\ {=\\big[\\mathbf{b}_{\\ell}(\\mathtt{p o s}\\,(i))+\\sum_{j\\in\\mathcal{N}_{F}(i)}\\mathbf{x}_{\\ell-1}\\left(\\mathtt{p o s}\\,(j)\\right)\\cdot\\mathbf{W}_{\\ell}\\big(\\mathtt{p o s}\\,(i)\\,,\\mathrm{pos}\\,(j)\\big),}&{}\\\\ {\\sigma_{\\ell}\\left(\\mathbf{h}_{V}^{t-1}(i)[1]+\\mathbf{m}_{V,\\mathrm{FW}}^{t-1}(i)\\right)\\big]}&{}\\\\ {=\\big[\\mathbf{z}_{\\ell}\\left(\\mathtt{p o s}\\,(i)\\right),\\sigma_{\\ell}\\left(\\mathbf{z}_{\\ell}\\left(\\mathtt{p o s}\\,(i)\\right)\\right)\\big]=\\big[\\mathbf{z}_{\\ell}\\left(\\mathtt{p o s}\\,(i)\\right),\\mathbf{x}_{\\ell}\\left(\\mathtt{p o s}\\,(i)\\right)\\big].}\\end{array}\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "Similarly for the vertices with layer $(i)=L$ ", "page_idx": 32}, {"type": "text", "text": "Our second induction hypothesis is the following: If for all vertices with layer $(i)=\\ell$ and $t\\geq2L-\\ell$ we have that $\\mathbf{h}_{V}^{t}(i)[4:5]=\\left[(\\nabla_{\\mathbf{z}_{\\ell}(p o s(i))}\\mathcal{L})^{-1},(\\nabla_{\\mathbf{x}_{\\ell}(p o s(i))}\\mathcal{L})^{-1}\\right]$ , then the same should hold for vertices with layer $(i)=\\ell-1$ when $t\\geq2L-\\ell+1$ . ", "page_idx": 32}, {"type": "text", "text": "\u2022 (Base case:) If layer $(i)=L$ : ", "page_idx": 32}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{\\mathbf{h}_{V}^{t}(i)[4:5]=\\mathrm{UPD}_{V,L}^{t}\\left(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{m}_{V}^{t}(i)\\right)[4:5]}\\\\ &{\\quad\\quad\\quad\\quad=\\mathbf{h}_{V}^{t-1}(i)[4:5]=\\cdot\\cdot-\\mathbf{h}_{V}^{0}(i)[4:5]}\\\\ &{\\quad\\quad\\quad\\quad=\\mathrm{INIT}_{V,L}\\left(\\mathbf{x}_{V}\\left(i\\right),\\mathbf{p}_{V}(i)\\right)[4:5]}\\\\ &{\\quad\\quad\\quad\\quad=[(\\nabla_{\\mathbf{z}_{L}\\left(\\mathrm{pos}(i)\\right)}\\mathcal{L})^{-1},(\\nabla_{\\mathbf{x}_{L}\\left(\\mathrm{pos}(i)\\right)}\\mathcal{L})^{-1}]}\\end{array}\n$$", "text_format": "latex", "page_idx": 32}, {"type": "text", "text": "Therefore, the hypothesis holds for $t\\geq L=\\log\\!\\operatorname{er}\\left(i\\right)$ for the base case. ", "page_idx": 32}, {"type": "text", "text": "\u2022 (Induction step:) Suppose the hypothesis holds for vertices with layer $(i)=\\ell+1$ . Now, if layer $(i)=\\ell$ , for $t\\geq2L-\\ell$ we have: ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\mathbf{m}_{V,\\mathrm{Bw}}^{t}(i)=\\bigoplus_{j\\in\\mathcal{N}_{N}(i)}\\mathrm{MSG}_{V,\\mathrm{Bw}}^{t}\\Big(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{h}_{V}^{t-1}(j),\\mathbf{h}_{E}^{t-1}(i,j)\\Big)}&{}\\\\ {=\\sum_{j\\in\\mathcal{N}_{D}(i)}g_{m}\\big(\\mathbf{h}_{V}^{t-1}(j)[i]\\cdot\\mathbf{h}_{E}^{t-1}(i,j)[1]\\big)\\,(t-1\\ge2L-(\\ell+1))}&{}\\\\ {=\\sum_{j\\in\\mathcal{N}_{D}(i)}g_{m}\\big((\\nabla_{\\Xi^{t+1}(\\mathrm{Pos})}(j)\\mathcal{L})^{-1}\\cdot\\mathbf{W}_{\\ell}^{t-1}(\\mathrm{pos}\\,(j),\\mathrm{pos}\\,(i))\\big).}&{}\\\\ {\\mathbf{h}_{V}^{t}(i)[i:\\mathbb{S}]=\\mathrm{UP}_{V}^{t}\\big(\\mathbf{h}_{V}^{t-1}(i),\\mathbf{m}_{V}^{t}(i)\\big)[4:\\mathbb{S}]}&{}\\\\ {=\\Bigg[\\frac{g_{V}\\big(\\mathbf{m}_{V,\\mathrm{Bw}}^{t}(i)\\big)}{\\sigma_{\\ell}^{\\prime}},g_{V}\\big(\\mathbf{m}_{V,\\mathrm{Bw}}^{t}(i)\\big)\\Bigg]}&{}\\\\ {=\\Bigg[\\frac{1}{\\sigma_{\\ell}^{\\prime}}(\\mathbf{g}_{\\ell}^{\\top}(\\mathbf{pos}(i))\\nabla_{\\mathcal{N}_{\\ell}(\\mathrm{pos}(i))}^{t-1})^{\\ell}\\,\\big(\\nabla_{\\Xi_{\\ell}(\\mathrm{pos}(i))}\\mathcal{L}\\big)^{-1}\\Bigg]}&{}\\\\ {=\\Big[(\\nabla_{\\Xi^{\\prime}(\\mathrm{pos}(i))}\\mathcal{L})^{-1}\\,\\big(\\nabla_{\\Xi^{\\prime}(\\mathrm{pos}(i))}\\mathcal{L}\\big)^{-1}\\Big]\\,.}\\end{array}\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "In the last step, we assumed the following: $g_{U}\\big(\\sum_{\\mathbf{\\lambda}}g_{m}(x)\\big)$ is a sufficiently expressive scale equivariant and permutation invariant function. This is in order to express the following: ", "page_idx": 33}, {"type": "equation", "text": "$$\n\\begin{array}{r}{(\\nabla_{\\mathbf{x}_{\\ell}(\\mathrm{pos}(i))}\\mathcal{L})^{-1}=\\left(\\sum_{j\\in\\mathcal{N}_{B}(i)}\\nabla_{\\mathbf{z}_{\\ell+1}(\\mathrm{pos}(j))}\\mathcal{L}\\cdot\\mathbf{W}_{\\ell}(\\mathrm{pos}\\left(j\\right),\\mathrm{pos}\\left(i\\right))\\right)^{-1}\\vee}\\end{array}\n$$", "text_format": "latex", "page_idx": 33}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{(\\nabla_{q_{\\ell}(i)\\mathbf{x}_{\\ell}(\\mathrm{pos}(i))}\\mathcal{L})^{-1}=\\left(\\sum_{q\\ell+1}(j)^{-1}\\nabla_{\\mathbf{z}_{\\ell+1}(\\mathrm{pos}(j))}\\mathcal{L}\\cdot\\frac{q_{\\ell+1}(j)}{q_{\\ell}(i)}\\mathbf{W}_{\\ell}(\\mathrm{pos}\\left(j\\right),\\mathrm{pos}\\left(i\\right))\\right)^{-1}}\\\\ &{\\qquad\\qquad\\qquad\\qquad=\\frac{q_{\\ell}(i)}{\\sum_{\\ell}\\nabla_{\\mathbf{z}_{\\ell+1}(\\mathrm{pos}(j))}\\mathcal{L}\\cdot\\mathbf{W}_{\\ell}(\\mathrm{pos}\\left(j\\right),\\mathrm{pos}\\left(i\\right)))}}\\\\ &{\\qquad\\qquad\\qquad=q_{\\ell}(i)(\\nabla_{\\mathbf{x}_{\\ell}(\\mathrm{pos}(i))}\\mathcal{L})^{-1}.}\\end{array}\n$$", "text_format": "latex", "page_idx": 33}, {"type": "text", "text": "Therefore if all $\\begin{array}{r}{g_{U}\\big(\\sum g_{m}(q x)\\big)=q\\cdot g_{U}\\big(\\sum g_{m}(x)\\big)}\\end{array}$ can be expressed by $g_{U},g_{m}$ , then so is the inverse of the gradient. ", "page_idx": 33}, {"type": "text", "text": "Following a similar rationale we can prove the case for the vertices with layer $(i)=0$ . ", "page_idx": 33}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 34}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 34}, {"type": "text", "text": "Justification: The main contribution of this paper is the design and evaluation of an NN processing architecture (metanetwork) that accounts not only for NN permutation symmetries but also scaling. The abstract and introduction introduce the reader to scaling symmetries for certain NN architectures (FFNNs and CNNs) and explain our main technical innovations to achieve our goal. The importance of scaling symmetries as an inductive bias is showcased in our theoretical and empirical results, as explained in the abstract and introduction. ", "page_idx": 34}, {"type": "text", "text": "Guidelines: ", "page_idx": 34}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 34}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? Answer: [Yes] ", "page_idx": 34}, {"type": "text", "text": "Justification: Yes, the limitations of our work (applicable input NN layers/architectures and open questions regarding expressivity) are discussed thoroughly in the last paragraph before the conclusion. ", "page_idx": 34}, {"type": "text", "text": "Guidelines: ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 34}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 35}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 35}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 35}, {"type": "text", "text": "Justification: All assumptions, precise statements and detailed proofs of our theoretical results are provided and presented thoroughly in Appendix A.7.2. ", "page_idx": 35}, {"type": "text", "text": "Guidelines: ", "page_idx": 35}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 35}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 35}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 35}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 35}, {"type": "text", "text": "Justification: We describe our architecture in detail and all the details needed to fully reproduce our results are provided in Section 6, Appendix A.1 and Appendix A.4. Additionally, our code, including used configurations, and modified datasets will be made publicly available at a later stage. ", "page_idx": 35}, {"type": "text", "text": "Guidelines: ", "page_idx": 35}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). ", "page_idx": 35}, {"type": "text", "text": "(d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 36}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 36}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 36}, {"type": "text", "text": "Answer: [No] ", "page_idx": 36}, {"type": "text", "text": "Justification: The datasets are already public (we simply split two datasets into two datasets based on the contained activation functions). The code will be made publicly available at a later stage after all the required steps are taken for proper documentation to make it easy to use for the interested user. ", "page_idx": 36}, {"type": "text", "text": "Guidelines: ", "page_idx": 36}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 36}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 36}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 36}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 36}, {"type": "text", "text": "Justification: Yes, the training and testing procedure are carefully described in the Appendix A.4. ", "page_idx": 36}, {"type": "text", "text": "Guidelines: ", "page_idx": 36}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 36}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 36}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 36}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 36}, {"type": "text", "text": "Justification: Yes, each method we ran (including baselines) was tested for 3 different random seeds and the mean and standard deviation were reported. ", "page_idx": 37}, {"type": "text", "text": "Guidelines: ", "page_idx": 37}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 37}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 37}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 37}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 37}, {"type": "text", "text": "Justification: Yes, we provide sufficient technical details in Appendix A.4. Guidelines: ", "page_idx": 37}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 37}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 37}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 37}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 37}, {"type": "text", "text": "Justification: Yes, we do. Guidelines: ", "page_idx": 37}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 37}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 37}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 37}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 38}, {"type": "text", "text": "Justification: We do not foresee and negative societal impact and therefore it is not discussed in the manuscript. ", "page_idx": 38}, {"type": "text", "text": "Guidelines: ", "page_idx": 38}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster.   \n\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology.   \n\u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 38}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 38}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 38}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 38}, {"type": "text", "text": "Justification: The paper poses no such risks. ", "page_idx": 38}, {"type": "text", "text": "Guidelines: ", "page_idx": 38}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 38}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 38}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 38}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 38}, {"type": "text", "text": "Justification: We do not use existing assets. Regarding code and data, all works were properly cited. ", "page_idx": 38}, {"type": "text", "text": "Guidelines: \u2022 The answer NA means that the paper does not use existing assets. ", "page_idx": 38}, {"type": "text", "text": "\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 39}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 39}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 39}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 39}, {"type": "text", "text": "Justification: The paper does not release new assets. ", "page_idx": 39}, {"type": "text", "text": "Guidelines: ", "page_idx": 39}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 39}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 39}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 39}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 39}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. Guidelines: ", "page_idx": 39}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 39}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "page_idx": 39}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 39}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 39}, {"type": "text", "text": "Justification: The paper does not involve crowdsourcing nor research with human subjects. ", "page_idx": 39}, {"type": "text", "text": "Guidelines: ", "page_idx": 40}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 40}]