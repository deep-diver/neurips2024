[{"type": "text", "text": "DuQuant: Distributing Outliers via Dual Transformation Makes Stronger Quantized LLMs ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Haokun Lin\u22171,3,4, Haobo $\\mathbf{Xu}^{*\\,2}$ , Yichen $\\mathbf{W}\\mathbf{u}^{*\\,4}$ , Jingzhi $\\mathbf{Cui^{2}}$ , Yingtao Zhang2, Linzhan $\\mathbf{Mou^{5}}$ , Linqi $\\mathbf{Song^{4}}$ , Zhenan Sun\u2020 1,3, Ying Wei\u2020 4,5 ", "page_idx": 0}, {"type": "text", "text": "1 School of Artificial Intelligence, University of Chinese Academy of Sciences 2 Tsinghua University 3 NLPR & MAIS, Institute of Automation, CAS 4 City University of Hong Kong 5 Zhejiang University ", "page_idx": 0}, {"type": "text", "text": "haokun.lin@cripac.ia.ac.cn xuhb20@mails.tsinghua.edu.cn wuyichen.am97@gmail.com znsun@nlpr.ia.ac.cn ying.wei@zju.edu.cn ", "page_idx": 0}, {"type": "text", "text": "Abstract ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Quantization of large language models (LLMs) faces significant challenges, particularly due to the presence of outlier activations that impede efficient low-bit representation. Traditional approaches predominantly address Normal Outliers, which are activations across all tokens with relatively large magnitudes. However, these methods struggle with smoothing Massive Outliers that display significantly larger values, which leads to significant performance degradation in low-bit quantization. In this paper, we introduce DuQuant, a novel approach that utilizes rotation and permutation transformations to more effectively mitigate both massive and normal outliers. First, DuQuant starts by constructing the rotation matrix, using specific outlier dimensions as prior knowledge, to redistribute outliers to adjacent channels by block-wise rotation. Second, We further employ a zigzag permutation to balance the distribution of outliers across blocks, thereby reducing block-wise variance. A subsequent rotation further smooths the activation landscape, enhancing model performance. DuQuant simplifies the quantization process and excels in managing outliers, outperforming the state-of-the-art baselines across various sizes and types of LLMs on multiple tasks, even with 4-bit weight-activation quantization. Our code is available at https://github.com/Hsu1023/DuQuant. ", "page_idx": 0}, {"type": "text", "text": "1 Introduction ", "text_level": 1, "page_idx": 0}, {"type": "text", "text": "Large language models (LLMs) [52, 7, 51] have demonstrated exceptional performance across a wide range of natural language processing tasks. However, their billions of parameters present considerable deployment challenges on resource-constrained edge devices, particularly in terms of memory usage and inference speed [23, 15, 57]. In response to these challenges, network quantization methods [20, 24] have been extensively explored to minimize memory usage by converting floatingpoint parameters into low-bit formats [18, 33, 8], and to expedite inference by quantizing both activations and weights for accelerating the matrix multiplication process [65, 35, 76]. ", "page_idx": 0}, {"type": "text", "text": "Among LLM quantization methods, a primary issue is the presence of activation outliers, which enlarge the quantization step sizes and subsequently cause significant accuracy loss [60]. To mitigate this problem, current research has developed various methods to address Normal Outliers in activations, which are persistent in several channels across all tokens [13, 65]. However, besides Normal Outliers, there exists another type of activation outlier [49, 36], termed Massive Outliers. ", "page_idx": 0}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/af1feb20c29b726f1d8f3b466600a13b98bc3342efb06652a0b4a0c23eaa4698.jpg", "img_caption": ["Figure 1: Visualizations of Outliers in LLaMA2-7B. (a) Input activation of Layer1 attention key projection shows Normal Outliers with relatively high magnitudes across all token sequences. (b) Input activation of Layer1 FFN down projection reveals Massive Outliers, presenting extremely high magnitudes (around 1400) at very few tokens. (c) Application of SmoothQuant on FFN down projection, illustrating its struggle with massive outliers in the Activation matrix. (d) Corresponding weight changes with SmoothQuant, highlighting the emergence of new outliers. "], "img_footnote": [], "page_idx": 1}, {"type": "text", "text": "These outliers are characterized by their exceedingly high values and limited occurrence in a subset of tokens, as depicted in Figure 1(b). Unfortunately, existing LLM quantization methods struggle to effectively address these Massive Outliers. For instance, SmoothQuant [65], despite using a smooth factor to shift some of the activation outliers to the weight part, still cannot effectively handle Massive Outliers with extremely large values, as shown in Figure 1(c)(d). OmniQuant [48] and AffineQuant [40], on the other hand, exhibit training instability issues [35] due to the presence of Massive Outliers. Consequently, there is a pressing need for an LLM quantization approach that effectively addresses both Normal and Massive Outliers. ", "page_idx": 1}, {"type": "text", "text": "To tackle this challenge, we propose the Dual transformations Quantization (DuQuant) method. Our motivation is to redistribute the activation outlier values across different channels, facilitating easier quantization. Specifically, we construct the orthogonal rotation matrix and the orthogonal permutation matrix. By multiplying these matrices with the activations, we can effectively perform column transformations on the activations, which in turn allows for the redistribution of outliers. For the rotation transformation aspect, we first identify specific dimensions of outliers as the prior knowledge and employ a greedy algorithm to construct the rotation matrix. To enhance the multiplication efficiency, we utilize diagonal block-wise rotation matrices, with each matrix responsible for a small portion of the activations. However, this approach may result in uneven outlier magnitudes across different blocks. Therefore, we propose the zigzag permutation for reordering the activation channels, which promotes a more uniform distribution across different blocks. Concretely, we distribute the channels with the highest activations across the blocks in a back-and-forth pattern. After establishing blocks with uniformly distributed outlier magnitudes, we employ another rotation transformation to further redistribute the outliers within each block. Note that we multiply the weight matrix with the transpose of the rotation and permutation matrices at the same time, preserving the linear layer equivalence and smoothing weights. Theoretical analysis confirms that the rotation and permutation transformations greatly mitigate quantization challenges induced by outliers. ", "page_idx": 1}, {"type": "text", "text": "As a result, DuQuant offers several clear advantages over QuaRot [2]: (1) DuQuant\u2019s optimal rotation matrix, derived through a greedy search guided by prior knowledge, surpasses QuaRot\u2019s Hadamard rotation in managing outliers; (2) our unique zigzag permutation significantly reduces activation variance across blocks, providing a distinct advantage for handling massive outliers; and (3) by jointly smoothing weights and activations, DuQuant avoids time-consuming GPTQ algorithm in QuaRot. Extensive evaluations demonstrate that our DuQuant approach significantly outperforms existing 4-bit weight-activation quantization baselines across various benchmarks. Notably, DuQuant achieves a $5\\%$ improvement in Commonsense QA tasks across all LLaMA model sizes and a $10\\%$ increase in zero-shot MMLU benchmarks for the Vicuna-v1.5-13B. Moreover, in practical applications with the LLaMA2-7B model, DuQuant not only accelerates pre-fliling phase by up to $2.08\\times$ but also reduces memory usage during decoding phase by $3.50\\times$ , with minimal impact on performance: only a 0.61 increase in perplexity and a $2.71\\%$ drop in accuracy compared to the FP16 model. These results highlight the effectiveness of DuQuant in enhancing the efficiency and capacity of quantized LLMs. ", "page_idx": 1}, {"type": "text", "text": "2 Motivation ", "text_level": 1, "page_idx": 1}, {"type": "text", "text": "Normal Outliers and Massive Outliers. Previous works [13, 74, 33] have highlighted the challenge posed by activation outliers in LLMs for model compression. These outlier features consistently manifest large values across specific feature dimensions and are present in all token sequences [65], which we refer to as Normal Outliers. Recently, a distinct type of outlier [49, 36], termed Massive Outliers, has been observed in LLMs. The primary distinctions between normal and massive outliers are: 1) Normal outliers persist across all token sequences, whereas massive outliers are confined to a limited number of tokens. 2) Massive outliers exhibit significantly larger magnitudes, often surpassing 100 and being approximately 1000 times greater than the median of other activations [49]. In our study, we delve deeper into the impact of these two distinct types of outliers on quantization. ", "page_idx": 1}, {"type": "text", "text": "", "page_idx": 2}, {"type": "text", "text": "Massive Outliers Exist at the Second Linear Layer of FFN Module. In contrast to previous studies [49, 36] that observe massive outliers at the output of Transformer blocks, we first discover that these extremely large activations exist at the input of the down-projection layer within the FFN module. As depicted in Figure 1, the input of the down-projection layer in the LLaMA2-7B model Layer 1 contains a single activation of significant magnitude (approximately 1400). This activation is isolated to one token and therefore classified as one of massive activations. This phenomenon is consistently observed across different layers and sizes of models, as illustrated in Appendix I. ", "page_idx": 2}, {"type": "text", "text": "Massive Outliers Enlarge Quantization Difficulty. Although previous studies [65, 48, 40, 1] have proposed various approaches to eliminate outlier features, they still face challenges in effectively managing massive outliers. SmoothQuant [65], for instance, attempts to shift the quantization difficulty from activations to weights by dividing the activation by a per-channel smoothing factor and multiplying it to the weight matrix. Nevertheless, we observe that this transfer at the input of the down-projection layer can cause the weights of the down-projection to display noticeable outliers, as demonstrated in Figure 1 . This issue arises because massive outliers cause the smoothing factor to become significantly large. Moreover, extremely large outliers can lead optimization-based methods to encounter problems with loss explosion. Both OmniQuant [48] and AffineQuant [40] have had to exclude their learnable parameters for the down projection layer due to unstable gradients. Given the poor accuracy observed with 4-bit quantization, QUIK [1] opts to use INT8 quantization for the down projection layer and Atom [76] applies INT8 quantization for 128 outlier channels. Consequently, massive outliers introduce new challenges to the quantization process that existing methods cannot fully address. This observation has motivated us to develop rotation and permutation transformations, which effectively handles both massive and normal outliers and achieves state-of-the-art performance. ", "page_idx": 2}, {"type": "text", "text": "3 Method ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "In this section, we delve into the distribution of outliers and introduce our proposed DuQuant method. The DuQuant method is built on two key components: 1) the block-diagonal rotation matrix, tasked with the local redistribution of feature outliers, and 2) the zigzag permutation, responsible for the global reordering of outliers across different blocks. ", "page_idx": 2}, {"type": "text", "text": "3.1 Preliminaries ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "As the common modules within each transformer block of LLMs, both Multi-head Self-Attention (MSA) and Feed-Forward Network (FFN) fundamentally consist of basic linear layers, which can be represented as, $\\mathbf{Y}=\\mathbf{X}\\cdot\\mathbf{W}\\in\\mathbb{R}^{T\\times C_{o u t}}$ . Here, $\\mathbf{X}\\in\\dot{\\mathbb{R}}^{T\\times C_{i n}}$ is the activation input and $\\textbf{W}\\in$ $\\mathbb{R}^{C_{i n}}{}^{\\star}\\!C_{o u t}$ denotes the weight matrix. In this paper, we focus on integer uniform quantization [26] of both activation and weight, aiming to achieve better hardware support. Specifically, the $b$ -bit quantization process maps the FP16 tensor $\\mathbf{X}$ to low-bit integer $\\mathbf{X}_{q}$ : ", "page_idx": 2}, {"type": "equation", "text": "$$\n\\mathbf{X}_{q}=\\operatorname{clamp}\\left(\\left\\lfloor{\\frac{\\mathbf{X}}{\\Delta}}\\right\\rfloor+z,0,2^{b}-1\\right),{\\mathrm{where~}}\\Delta={\\frac{\\operatorname*{max}(\\mathbf{X})-\\operatorname*{min}(\\mathbf{X})}{2^{b}-1}},z=-\\left\\lfloor{\\frac{\\operatorname*{min}(\\mathbf{X})}{\\Delta}}\\right\\rceil.\n$$", "text_format": "latex", "page_idx": 2}, {"type": "text", "text": "The notation $\\lfloor\\cdot\\rceil$ means the nearest rounding operation, $\\Delta$ is the quantization step size and $z$ represents the zero point. Following [65, 48, 35, 40], we employ per-token quantization for activation and per-channel quantization for weight, which entails assigning different step sizes to individual tokens of activations $\\stackrel{\\wedge}{\\Delta}\\mathbf{x}\\in\\mathbb{R}^{T\\times1},$ ) and different output channels of weights $(\\dot{\\Delta\\mathbf{w}}\\in\\mathbb{R}^{1\\times C_{o u t}})$ ). ", "page_idx": 2}, {"type": "text", "text": "3.2 The proposed DuQuant Method ", "text_level": 1, "page_idx": 2}, {"type": "text", "text": "To address the Normal Outliers issue stated in Section 2, current quantization methods, such as SmoothQuant [65] and OmniQuant [65], usually adopt the smooth technique. Concretely, it involves the utilization of a per-channel smoothing diagonal matrix, denoted as $\\Lambda$ , to scale the input activation and weight matrix. The adjustment allows us to rewrite the original linear layer as $\\mathbf{Y}={\\dot{\\mathbf{X}}}\\mathbf{\\cdot}\\mathbf{W}=(\\mathbf{X}\\mathbf{\\cdot}$ $\\mathbf{A})(\\mathbf{A}^{-1}{\\boldsymbol{\\cdot}}\\mathbf{W})$ . The diagonal element $\\Lambda_{j}$ within $\\Lambda$ is computed as $\\mathbf{\\Lambda}_{\\mathbf{\\Lambda}_{j}}=\\operatorname*{max}(|\\mathbf{X}_{j}|)^{\\alpha}/\\operatorname*{max}(|\\mathbf{W}_{j}|)^{1-\\alpha}$ , where $\\alpha$ is a hyper-parameter representing the migration strength. However, despite the ability of this smoothing technique to shift the quantization challenge from activations to weights, it still faces difficulties in effectively managing Massive Outliers, as depicted in Figure 1. This challenge stems from the extremely large massive outliers inducing large scaling factors $\\pmb{\\Lambda}_{j}$ , which in turn introduce new outliers in the weight matrix and result in significant performance declines in 4-bit quantization. ", "page_idx": 2}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/31c9b8a4a948f0b77157bb47d1c8bbf126a3a1e4e9cc4d8708772d9974f2bdb8.jpg", "img_caption": ["Figure 2: Transformation Steps for Activation Matrices after smooth technique. (a) Sequential transformations on Normal Outliers: $\\textcircled{1}$ initial rotation to reduce outliers within blocks, $\\circledcirc$ permutation to evenly distribute outliers across blocks, and $\\circled{3}$ a second rotation for further smoothing. (b) Activation changes for Massive Outliers before and after DuQuant. (c) A sample matrix for highlighting the continual reduction of outliers through rotation and permutation, with outliers marked in dark blue. "], "img_footnote": [], "page_idx": 3}, {"type": "text", "text": "", "page_idx": 3}, {"type": "text", "text": "According to these findings, we propose the DuQuant method, which includes the Rotation and Permutation transformations based on the smooth technique. By combining rotation transformation and channel permutation, our DuQuant method aims to redistribute these features within the activation space, thereby mitigating the effects of both Normal and Massive Outliers. ", "page_idx": 3}, {"type": "text", "text": "The Rotation Transformation. In contrast to the smooth technique, our aim is to apply a rotation matrix for row or column transformations, mitigating the impact of both Normal and Massive outliers. The ideal rotation matrix, denoted as $\\mathbf{R}$ , should possess the following properties: 1) $\\mathbf{R}$ is an orthogonal matrix satisfying $\\mathbf{R}\\mathbf{R}^{\\top}=\\mathbf{I}$ and $|\\mathbf{R}|=\\pm1$ . This allows us to reformulate the linear layer within the transformer as $\\mathbf{Y}=\\mathbf{X}\\cdot\\mathbf{W}=(\\mathbf{X}\\mathbf{R})(\\mathbf{R}^{\\top}\\mathbf{W});2)\\,\\mathbf{R}$ should be capable of effectively target the positions of outliers and effectively mitigating them through matrix multiplication. However, due to the Massive Outliers are usually randomly distributed within the activation space, it is challenging to directly identify the optimal rotation matrix $\\mathbf{R}$ capable of mitigating outliers through a single rotation transformation. To address this problem, we employ a greedy search with prior knowledge to compute a rotation matrix $\\hat{\\mathbf{R}}$ , thereby approximating the ideal rotation matrix $\\mathbf{R}$ . Specifically, the calculation of $\\hat{\\mathbf{R}}$ involves the following steps, ", "page_idx": 3}, {"type": "text", "text": "$\\circ$ Identify the feature dimension $d^{(1)}$ where the outlier are primarily concentrated, i.e., $d^{(1)}=$ arg $\\operatorname*{max}_{j}(\\operatorname*{max}_{i}|\\mathbf{X}_{i j}|)$ . Here, $\\mathbf{X}_{i j}$ represents the element in the $i$ -th row and $j$ -th column of $\\mathbf{X}$ . $\\circ$ Based on the searched dimensions $d^{(1)}$ , we construct the rotation matrix as follows, ", "page_idx": 3}, {"type": "equation", "text": "$$\n{\\bf R}^{1}={\\bf E}_{d^{(1)}}\\tilde{{\\bf R}}{\\bf Q}{\\bf E}_{d^{(1)}},\\qquad{\\bf Q}=\\left[\\!\\!\\begin{array}{c c}{{1}}&{{{\\bf O}}}\\\\ {{{\\bf O}}}&{{{\\bf Q}^{\\prime}}}\\end{array}\\!\\!\\right].\n$$", "text_format": "latex", "page_idx": 3}, {"type": "text", "text": "Here, $\\mathbf{E}_{d^{(1)}}$ is the switching matrix used to swap the first and the $d^{(1)}$ -th columns of the activation, and $\\tilde{\\mathbf{R}}$ represents an orthogonal initialized rotation matrix, in which the first row is specifically uniformly distributed. The motivation behind this is to mitigate outliers in the first column after the transformation by $\\mathbf{E}_{d^{(1)}}$ . To further increase the randomness of the rotation operation, ", "page_idx": 3}, {"type": "text", "text": "we retain the first column, where outliers have been mitigated, and randomly rotate the other columns by multiplying them with a random orthogonal matrix $\\mathbf{Q^{\\prime}}$ . \u25e6 Let $N$ denote the greedy search steps, then the approximated rotation matrix $\\hat{\\mathbf{R}}=\\mathbf{R}^{1}\\mathbf{R}^{2}\\cdot\\cdot\\cdot\\mathbf{R}^{n}$ , where $n=\\arg\\operatorname*{min}_{k\\in[1:N]}$ $\\left(\\operatorname*{max}_{i,j}\\,\\vert(\\mathbf{X}\\mathbf{R}^{1}\\cdot\\cdot\\cdot\\mathbf{\\hat{R}}^{k})_{i j}\\vert\\right)$ . Each $\\mathbf{R}^{i}$ is constructed according to Eqn. (2) and the identified feature dimension $d^{(i)}$ . Appendix $\\mathrm{G}$ provides detailed pseudo code. ", "page_idx": 4}, {"type": "text", "text": "Through this construction manner, we can ensure that the approximated optimal rotation matrix $\\hat{\\mathbf{R}}$ can effectively mitigate outliers with large magnitudes, as opposed to merely using a randomly selected orthogonal rotation matrix. Nevertheless, directly constructing the entire rotation matrix is timeconsuming and results in substantial memory overhead. For fast matrix multiplication, following [64], we approximate the rotation matrix $\\hat{\\mathbf{R}}\\in\\mathbb{R}^{\\dot{C}_{i n}\\times C_{i n}}$ in a block-wise manner, ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\hat{\\bf R}=\\mathrm{\\bf~BlockDiag}(\\hat{\\bf R}_{b_{1}},...,\\hat{\\bf R}_{b_{K}}),}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where $\\hat{\\bf R}_{b_{i}}\\in\\mathbb{R}^{2^{n}\\times2^{n}}$ denotes a square matrix of the $i$ -th block, which is constructed following the three steps mentioned above. And the block numbers $K$ is calculated by $K=C_{i n}/2^{n}$ . ", "page_idx": 4}, {"type": "text", "text": "The Permutation Transformation. Despite adopting the block-diagonal rotation matrix $\\hat{\\mathbf{R}}$ for its time and storage efficiency, its focus on local information introduces a potential limitation in further reducing the outliers. This is because the rotation transformation, conducted within each small block, cannot integrate the information across different blocks to further minimize outliers. Consequently, one block may have relatively larger outliers while another block has smaller outliers, resulting in high variance among different blocks, as shown in Figure 2. This limitation explains that merely utilizing the block-diagonal rotation matrix is insufficient to effectively reduce the overall outliers. ", "page_idx": 4}, {"type": "text", "text": "To effectively mitigate the overall outliers, it is essential to balance the outliers\u2019 magnitudes among various blocks. Specifically, within each small block, we denote the largest outlier in dimension $d_{j}$ as $O_{j}$ . Meanwhile, $M_{b_{i}}$ represents the mean value of all $O_{j}$ in the $i^{\\th}$ -th block, where $i=1,2,...,\\bar{K}$ . Then the variance in activation magnitudes across various blocks can be expressed as, ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\operatorname{Var}([M_{b_{1}},M_{b_{2}},...,M_{b_{K}}]).\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "To minimize this variance and further reduce the overall outliers, we introduce the zigzag permutation. Concretely, we generate a zigzag sequence that starts by assigning channels with the highest activations to the first block. The process continues by assigning channels with the next highest activations to the subsequent blocks in descending order until the end of block $K$ . Upon reaching the final block, the order reverses, starting from the channel with the next highest activation and proceeding in ascending order. This back-and-forth patterning continues throughout all the blocks, ensuring that no single block consistently receives either the highest or lowest activation channels. It is worth noting that the constructed permutation is an orthogonal matrix, which we denote as $\\mathbf{P}$ , satisfying the conditions $\\mathbf{P}\\mathbf{P}^{\\top}=\\mathbf{I}$ and $\\left\\lceil\\mathbf{P}\\right\\rceil=\\pm1$ . By employing the zigzag permutation, we achieve a balanced distribution of outliers across different blocks. This allows us to use an additional rotation transformation to further smooth the outliers. Figure 2 provides an illustration of outlier mitigation. ", "page_idx": 4}, {"type": "text", "text": "The Overall DuQuant Method. To effectively mitigate both Normal and Massive Outliers, we first employ the smooth technique to shift the quantization challenge from activations to weights. Next, we introduce the block-diagonal rotation matrix $\\hat{\\mathbf{R}}$ to locally redistribute feature outliers within the activation space. We then propose the zigzag permutation matrix for globally balancing the outliers across different blocks, followed by another application of the block-diagonal rotation transformation. To sum up, the linear layers within the transformer can be rewrite as, ", "page_idx": 4}, {"type": "equation", "text": "$$\n\\begin{array}{r}{\\mathbf{Y}=\\mathbf{X}\\cdot\\mathbf{W}=[(\\mathbf{X}\\cdot\\underbrace{\\mathbf{A})\\hat{\\mathbf{R}}_{(1)}\\cdot\\mathbf{P}\\cdot\\hat{\\mathbf{R}}_{(2)}}_{\\mathbf{G}}]\\cdot[\\underbrace{\\hat{\\mathbf{R}}_{(2)}^{\\top}\\cdot\\mathbf{P}^{\\top}\\cdot\\hat{\\mathbf{R}}_{(1)}^{\\top}(\\mathbf{A}^{-1}\\cdot\\mathbf{W})}_{\\mathbf{G}^{-1}}],}\\end{array}\n$$", "text_format": "latex", "page_idx": 4}, {"type": "text", "text": "where the notation $\\mathbf{P}$ denotes the orthogonal permutation matrix learned via the zigzag manner, the $\\hat{\\mathbf{R}}_{(1)}$ and $\\hat{\\mathbf{R}}_{(2)}$ represent the first and second block-diagonal rotation matrix, respectively. ", "page_idx": 4}, {"type": "text", "text": "Remark 1. It is worth noting that the proposed DuQuant method can simultaneously smooth the weight matrix. While the commonly adopted smooth technique is effective, it can cause the weight matrix of the down-projection layer to exhibit pronounced outliers, leading to performance degradation. However, in the proposed DuQuant method, the rotation transformation we designed is applied to not only the activation input but also the weight matrix. As a result, the outliers induced by the smooth technique can be mitigated through our approximated rotation matrix \u02c6R, yielding a smoother, more quantization-friendly weight matrix. Moreover, this approach eliminates the reliance on complex weight quantization techniques, such as GPTQ [18] used in Atom [76] and QuaRot [2]. ", "page_idx": 4}, {"type": "text", "text": "", "page_idx": 5}, {"type": "text", "text": "Remark 2. To further decrease the computation and memory costs, we initially construct the $k$ -th block rotation matrix $\\hat{\\mathbf{R}}_{b_{k}}$ , with the $k$ -th block containing the largest outlier. We then assign $\\hat{\\mathbf{R}}_{b_{i}}=\\mathbf{\\Psi}$ $\\hat{\\mathbf{R}}_{b_{k}}$ for all $1\\leq i\\leq K$ . This strategy not only effectively mitigates the impact of outliers, but also reduces the number of block rotation matrices from $K$ to 1, significantly reducing computation and memory requirements. Importantly, incorporating the invertible matrix $\\mathbf{G}$ from Eqn. (5) significantly eases the quantization challenges for $\\mathbf{X}$ and $\\mathbf{W}$ . Consequently, the quantization process acts as ${\\bf Y}=({\\bf X}{\\bf G})({\\bf G}^{-1}{\\bf W})=\\hat{\\bf X}\\cdot\\hat{\\bf W}\\approx\\Delta_{\\hat{\\bf X}}\\Delta_{\\hat{\\bf W}}(\\hat{\\bf X}_{q}-z_{\\hat{\\bf X}})(\\hat{\\bf W}_{q}-z_{\\hat{\\bf W}})$ . ", "page_idx": 5}, {"type": "text", "text": "", "page_idx": 5}, {"type": "text", "text": "3.3 Theoretical Analysis ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "To further demonstrate the effectiveness of the proposed DuQuant method, we conduct a theoretical analysis of the rotation and permutation transformations. Theorem 1 shows that within each block, the constructed rotation matrix effectively mitigates the maximum outlier, thereby reducing the outlier magnitude through a greedy search. Theorem 2 reveals that the employed zigzag permutation ensures a balanced upper bound shared among different blocks. This suggests that the zigzag permutation effectively reduces the variance shown in Eqn. (4) and thus assists the rotation matrix in further decreasing the outliers. Please refer to Appendix B for detailed proofs. ", "page_idx": 5}, {"type": "text", "text": "Theorem 1 (Rotation). For the activation input $\\mathbf{X}\\in\\mathbb{R}^{T\\times C_{i n}}$ , $\\hat{\\mathbf{R}}\\in\\mathbb{R}^{2^{n}\\times2^{n}}$ is a diagonal block matrix constructed as per Eqn. (3). For a specific block $b_{i}$ , let $O_{j}(\\cdot)$ represent the maximum outlier of the $j$ -th dimension $d_{j}$ within the input. Then, we can deduce that, ", "page_idx": 5}, {"type": "equation", "text": "$$\n\\operatorname*{max}_{1\\leq j\\leq2^{n}}\\ O_{j}(\\mathbf X_{b_{i}}\\hat{\\mathbf{R}}_{b_{i}})\\leq\\operatorname*{max}_{1\\leq j\\leq2^{n}}\\ O_{j}(\\mathbf X_{b_{i}}).\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "Theorem 2 (Zigzag Permutation). For the activation input $\\mathbf{X}\\in\\mathbb{R}^{T\\times C_{i n}}$ , it can be divided into $K$ blocks, where $K=C_{i n}/2^{n}$ . Let $O_{j}$ denote the max outlier of the dimension $d_{j}$ in $\\mathbf{X}$ , the reordered outliers from large to small is expressed as $O^{(1)},O^{(2)},...,O^{(C_{i n})}$ . Moreover, the $M_{b_{i}}$ represents the mean value of all $O_{j}$ in the $i$ -th block, $i=1,2,...,K$ . Let $\\delta:=\\operatorname*{max}\\{|O^{(i+1)}-O^{(i)}|\\},i=$ $1,2,...,C_{i n}\\!-\\!1$ . Then, following the zigzag permutation described in Section 3.2, the mean value $M_{b_{i}}$ within each $i$ -th block consistently satisfies, ", "page_idx": 5}, {"type": "equation", "text": "$$\nM_{b_{i}}\\le O^{(1)}+\\frac{(2^{n}K-1)(2^{n-1}-1)}{2^{n}}\\delta,\\qquad i=1,2,3,...,K.\n$$", "text_format": "latex", "page_idx": 5}, {"type": "text", "text": "4 Experiment ", "text_level": 1, "page_idx": 5}, {"type": "text", "text": "Models and Evaluations. We apply our DuQuant on pre-trained LLMs: LLaMA (7B-65B) [52], LLaMA2 (7B-70B) [53], LLaMA3 (8B, 70B), Mistral, Phi2 and instruction-tuned LLMs: Vicunav1.5 (7B-13B) [10]. We evaluate quantized pre-trained LLMs on language generation tasks and commonsense QA tasks. Specifically, we assess the perplexity on WikiText2 [41] and C4 [45] datasets, as well as the zero-shot accuracy on PIQA [6], ARC [12], BoolQ [11], HellaSwag [71], and WinoGrande [46] datasets. Moreover, we evaluate quantized Vicuna models on MMLU [22] and MT-Bench [78] benchmarks, as well as their long-form generative capabilities on LongBench [4]. ", "page_idx": 5}, {"type": "text", "text": "Implementation Details. In line with prior studies [35, 48, 40], we apply per-token activation quantization and per-channel weight quantization. Given that W8A8 quantization has been established as lossless in precision by SmoothQuant [65], our primary evaluation in this paper focuses on 4-bit and 6-bit quantization for weights and activations. As for details, we quantize all intermediate activations, excluding the SoftMax output. Moreover, we have developed two types of quantized models, denoted as DuQuant and DuQuant+LWC . For DuQuant, we employ round-to-nearest quantization, using a clipping ratio of 0.9 for activations and 0.8 for weights. To improve weight matrix quantization, DuQuant+LWC integrates the learnable weight clipping (LWC) technique from OmniQuant. Concretely, LWC adjusts weights by training parameters $\\gamma,\\beta\\in[0,1]$ to compute step size $\\begin{array}{r}{\\Delta=\\frac{\\gamma\\operatorname*{max}(\\mathbf{X})-\\beta\\operatorname*{min}(\\mathbf{X})}{2^{b}-1}}\\end{array}$ in Eqn. (1). Notably, the smoothing diagonal matrix and the learned weight clipping factor can be integrated into the quantized weights, introducing no additional computational or memory costs. More details and hyperparameters are left in Appendix C. ", "page_idx": 5}, {"type": "text", "text": "Baselines. We compare with state-of-the-art (SOTA) weight-activation PTQ methods, including SmoothQuant [65], Outlier Supression $^{+}$ [60], OmniQuant [48], QLLM [35], AffineQuant [40], and Atom [76]. For Atom, we reproduce the results with no group-wise asymmetric quantization. ", "page_idx": 5}, {"type": "text", "text": "Table 1: Perplexity (\u2193) results under 4-bit weight-activation quantization. The results for W6A6 can be found in Table D8. Atom and OmniQuant unprocessed group-query attention for LLaMA2-70B. ", "page_idx": 6}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/89f17e3838d960e236397372b5573054e94df2428c828bc0da7870bd3a124e64.jpg", "table_caption": [], "table_footnote": [], "page_idx": 6}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/0dafcc115c861b0d333b95f6dd7d7aff342bda641c02144d16dc2b4024e15272.jpg", "table_caption": ["Table 2: Zero-shot QA (\u2191) results of LLaMA1 models under 4-bit weight-activation quantization. The results for LLaMA2 models and W6A6 quantization can be found in Table D1 D9, and D10. "], "table_footnote": [], "page_idx": 6}, {"type": "text", "text": "4.1 Main Results ", "text_level": 1, "page_idx": 6}, {"type": "text", "text": "Quantization of LLaMA1 and LLaMA2 Models. We conduct a comprehensive comparison of our DuQuant with several SOTA baselines on LLaMA1 and LLaMA2 models. Results for W4A4 quantization are presented in this Section, while results for W6A6 quantization are provided in ", "page_idx": 6}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/b921432811cb435d4c28fa6638398c976f4cd3295ccb3ff3395601b2bf65a6b0.jpg", "table_caption": ["Table 3: Zero-shot and five-shot results on the MMLU benchmark for Vicuna-v1.5-13B under 4-bit weight-activation quantization. The results for Vicuna-v1.5-7b can be found in Table D2. "], "table_footnote": [], "page_idx": 7}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/97bec822c5a8c3aaf24833fd8d68f1ab9f6dbcdfde12b78b937fec872ce28d9b.jpg", "table_caption": ["Table 4: Long-context generation results for 4-bit Vicuna models on the LongBench benchmark. "], "table_footnote": [], "page_idx": 7}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/e0efae3f234f4be80bf70b93d1a94f5e2c7f8710f69646e6c98fcb5582491d8e.jpg", "table_caption": ["Table 5: Perplexity and QA results of LLaMA3-8B under 4-bit/6-bit weight-activation quantization. "], "table_footnote": [], "page_idx": 7}, {"type": "text", "text": "Appendix D. Table 1 indicates that our DuQuant quantized models notably outperform other baselines on both the WikiText2 and C4 datasets. Notably, LWC technique further enhances model capacity, with our DuQuant+LWC achieving comparable performance with FP16 models. Table 2 and Table D1 showcase the zero-shot accuracy of W4A4 quantization on Commonsense QA tasks, where DuQuant significantly improves the average accuracy. Our method surpasses QLLM by $+9\\%$ , and Atom by $+5\\%$ for all model sizes. These results demonstrate the superiority of our rotation and permutation transformation, which establishes new SOTA performance by effectively eliminating outlier features. ", "page_idx": 7}, {"type": "text", "text": "Quantization of Instruction-tuned Models. We quantize Vicuna-v1.5 [10] models to assess the generalizability of our DuQuant. Table 3 illustrates that our quantized models surpass the baselines across all task categories on MMLU benchmark. For Vicuna-13B, our DuQuant+LWC surpasses Atom by $10.01\\%$ under zero-shot settings and $6.95\\%$ under five-shot settings. Moreover, we compare our DuQuant with Atom and OmniQuant using MT-Bench and utilize GPT-4 to evaluate the answers from quantized models. As shown in Figure 3, DuQuant quantized models significantly outperform both Atom and OmniQuant in win rates. Specifically, for Vicuna-7B, DuQuant only lost 16 and 1 times to Atom and OmniQuant, respectively, while achieving 68 and 155 wins against them. ", "page_idx": 7}, {"type": "text", "text": "Evaluation of Long-context Generation. To further evaluate the long-text generative capabilities, we follow [38, 34, 56] and conduct a comprehensive comparison of DuQuant against state-of-the-art baselines on the LongBench [4], which includes a variety of generative tasks to provide a broader evaluation. We set the maximum sequence length to 3500 for Vicuna models, with results presented in Table 4. DuQuant achieves performance comparable to FP16 models, demonstrating the effectiveness of our dual transformations. More detailed results on different subtasks are listed in Table D3, D4. ", "page_idx": 7}, {"type": "text", "text": "Quantization of LLaMA3 Models. LLaMA3, known for its superior performance in various tasks, faces significant degradation in low-bit quantization [25]. To address this, we apply our DuQuant to quantize LLaMA3-8B. Table 5 displays the perplexity and zero-shot accuracy results. Notably, under W6A6 setting, our DuQuant achieves performance comparable to FP16 model. Furthermore, unlike other methods that show weaker results under W4A4 setting, our DuQuant maintains competitive performance, indicating its robustness with LLaMA3. We attribute this success to the advanced handling of outliers achieved through dual transformations, which is not restricted to specific models. ", "page_idx": 7}, {"type": "text", "text": "4.2 Ablation Study ", "text_level": 1, "page_idx": 8}, {"type": "text", "text": "Module-wise Impact. We ablate four distinct operations within DuQuant: 1) only the smoothing technology like SmoothQuant; 2) one rotation following the smoothing operation; 3) a sequence of rotation, permutation, and another rotation without smoothing; and k4) full DuQuant approach. Table 6 shows that the smoothing operation plays a basic role in our DuQuant by shifting activation outliers to weight. The initial rotation significantly enhances model performance, yielding competitive PPL results. Finally, permutation combined with a second rotation further enhances the quantized model. ", "page_idx": 8}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/2559ad7d9f9911ff31a1a81ea6605c3a280838b36c0c4e330f6aa4cfa8f84a4e.jpg", "table_caption": ["Table 6: Influence of different components in DuQuant under 4-bit weight-activation quantization. "], "table_footnote": [], "page_idx": 8}, {"type": "text", "text": "Influence of Normal/Massive Outliers. In this section, we comprehensively explore the influence of massive and normal outliers on quantization. Notably, we observe that massive outliers primarily occur at the down-projection of the FFN module. To isolate their effect, we remove the rotation and permutation transformations, applying only the smoothing technique to all down-projection inputs. The resulting perplexity for LLaMA2-7B and LLaMA-13B showed significant degradation, presented in Table 7. Conversely, when we eliminate the rotation and permutation transformations for normal outliers, the performance decrease was noticeable but less severe compared to massive outliers. These findings indicate that: 1) massive outliers exert a more substantial impact on quantization, corroborating our claims in Section 2; 2) the smoothing technique alone struggles to fully mitigate the influence of outliers, particularly massive ones; and 3) our rotation and permutation methods prove highly effective against both types of outliers, leading to superior performance. ", "page_idx": 8}, {"type": "text", "text": "Table 7: Outliers impact on quantization. We only apply the smooth technique on Normal and Massive outliers for W4A4 quantization. ", "page_idx": 8}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/308dd513422301c3e2863e8f7cdb780389fdc5b2f5a14c56ec5649deeda7df0c.jpg", "table_caption": [], "table_footnote": [], "page_idx": 8}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/77dcca7749063ce2e84fe99a62a00985e48f6caad5872ab6543720ed5a582ac8.jpg", "img_caption": ["Figure 3: GPT-4 evaluation on the MT-Bench. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "Comparison with QuaRot [2] In light of the recent introduction of Hadamard rotations by QuaRot[2] to eliminate outlier features, we have undertaken a detailed analysis to highlight the key differences between our DuQuant and QuaRot. To ensure a balanced evaluation, we have reimplemented QuaRot in accordance with our quantization settings. The results demonstrate that 1) the rotation matrix constructed by DuQuant outperforms QuaRot\u2019s approach of simply selecting a randomly initialized Hadamard matrix. As depicted in Figure 10, our DuQuant more effectively smooths activations than QuaRot. This is attributed to the prior knowledge utilized by DuQuant to accurately target the outliers; 2) As demonstrated by the perplexity in Table 8, QuaRot employs GPTQ for their weight quantization method, whereas our DuQuant, with its sophisticated outlier management, attains competitive results using RTN quantization. The superiority proves the effectiveness of our zigzag permutation to enhance capacity. For a more comprehensive comparison, please refer to Appendix F. ", "page_idx": 8}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/015858193a78a8aea71d495c45e5eb385aaa39fc6ee62cb228d0ef67e79d7c88.jpg", "table_caption": ["Table 8: PPL (\u2193) comparison under W4A4 setting. "], "table_footnote": [], "page_idx": 8}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/4f15c0e744cb8305dae08bd6efa15d2fe901a4d60646b8bc5459c03c4c6e0612.jpg", "img_caption": ["Figure 4: LLaMA2-7B Attention key_proj. "], "img_footnote": [], "page_idx": 8}, {"type": "text", "text": "Permutation Frequency. We conduct ablations on the rotation and permutation frequencies in DuQuant. As shown in Figure 5, \u201cPerm 1\u201d (two rotations with one permutation) achieves stronger performance compared with ${}^{\\;\\bullet}\\mathrm{Perm}\\,0^{\\bullet}{}^{\\;}$ (no permutation), while incurring an additional $8.9\\%$ computational cost on LLaMA2-7B and $9.3\\%$ on LLaMA2-13B compared to the W4A4 setup. Considering the approximately $2\\times$ speedup and the impressive performance, these additional costs are deemed acceptable. Further permutations, like \u201cPerm 2,\u201d do not improve performance and reduce inference efficiency. Consequently, \u201cPerm 1\u201d strikes the best balance between perplexity and inference speed, making it the optimal configuration for DuQuant. ", "page_idx": 8}, {"type": "text", "text": "", "page_idx": 9}, {"type": "text", "text": "Inference Speedup. To assess the inference speedup delivered by our DuQuant, we adopt the measurement strategy and W4A4 kernel from [2]. We evaluate the layer-wise speedup of LLaMA2 models on one NVIDIA 3090 GPU, with results detailed in Table 9 and 10. We set the pre-filling sequence length at 2048 and decode for 128 steps. In the pre-fliling stage, DuQuant achieves a $2.08\\times$ speedup over FP16 for LLaMA2-7B and a $2.34\\times$ speedup for LLaMA2-13B, with slight variations across different batch sizes. In the decoding stage, batching the token generation phase yields high throughput without any downside [44]. Consequently, we enlarge the batch size to 64 and the results for LLaMA2-7B in Table 10 prove DuQuant achieves speedup comparable to QuaRot. More detailed analyses and end-to-end speedup are available in Appendix E.1. ", "page_idx": 9}, {"type": "text", "text": "Table 9: Layer-wise speedup during pre-filling stage for 4-bit weight-activation quantization. ", "page_idx": 9}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/dccfdf7cb7e3734c3ef6e0f86ce69e94508cda49a30d5d6bbf43cc61d1791518.jpg", "table_caption": [], "table_footnote": [], "page_idx": 9}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/3bb5a934078fa108c2a658d9a56e8a342d1d8777e62d6586044dfeba10f72bc4.jpg", "img_caption": [], "img_footnote": [], "page_idx": 9}, {"type": "text", "text": "Memory Consumption. We measure the peak memory usage of DuQuant with the W4A4 kernel on LLaMA2-7B using a single NVIDIA 3090 GPU. We process 2048 tokens for pre-fliing and run 128 decoding steps, with the results listed in Table 11. In the pre-filling stage, DuQuant, SmoothQuant, and QuaRot achieve up to $3.2\\times$ memory reduction, while QLLM performs worse. In the decoding stage, DuQuant maintains strong memory efficiency, with superior performance. ", "page_idx": 9}, {"type": "text", "text": "Table 10: Decoding stage. ", "page_idx": 9}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/742dd61eaca38fd0e8d8bcabc3504533fe2109c590f9646fbba19fd5f791e6a2.jpg", "table_caption": ["Figure 5: Computational overhead analysis. ", "Table 11: Peak memory usage with a batch size of 1. "], "table_footnote": [], "page_idx": 9}, {"type": "text", "text": "Runtime. Our DuQuant stands out for its efficiency, surpassing other baselines [48, 35, 40, 76]. The blockwise rotation ensures fast multiplication between the rotation and activation matrices. Zigzag permutation, ", "page_idx": 9}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/9e83d52fa1327f91244ce84414af0469cffbdeabc67e0a60cbbd11e988ac890f.jpg", "table_caption": ["Table 12: Quantization runtime on one NVIDIA A100. "], "table_footnote": [], "page_idx": 9}, {"type": "text", "text": "involving simple channel swaps, is much faster than complex algorithms like Simulated Annealing, as discussed in Appendix E.3. Moreover, the advanced management of outliers makes DuQuant not rely on GPTQ or gradient-based training. Hence, DuQuant enables a rapid quantization process shown in Table F24, e.g., we successfully quantize LLaMA2-13B in just 71s with superior performance. ", "page_idx": 9}, {"type": "text", "text": "5 Conclusion ", "text_level": 1, "page_idx": 9}, {"type": "text", "text": "In conclusion, this paper presents DuQuant, an innovative quantization strategy for large language models (LLMs) that effectively addresses the challenge of outlier activations. By integrating rotation and permutation transformations, DuQuant effectively mitigates the impacts of both massive and normal outliers. This strategic redistribution of outliers not only simplifies the quantization process but also leads to substantial improvements in model performance. Consequently, DuQuant establishes new state-of-the-art results in 4-bit weight-activation quantization scenarios. This advancement enhances the deployment of efficient LLMs in resource-constrained environments. ", "page_idx": 9}, {"type": "text", "text": "Acknowledgements ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "This work is supported in part by the National Natural Science Foundation of China (Grant No. U23B2054, 62276263, and 62371411), the Research Grants Council of the Hong Kong SAR under Grant GRF 11217823 and Collaborative Research Fund C1042-23GF, InnoHK initiative, the Government of the HKSAR, Laboratory for AI-Powered Financial Technologies. ", "page_idx": 10}, {"type": "text", "text": "References ", "text_level": 1, "page_idx": 10}, {"type": "text", "text": "[1] Saleh Ashkboos, Ilia Markov, Elias Frantar, Tingxuan Zhong, Xincheng Wang, Jie Ren, Torsten Hoefler, and Dan Alistarh. Towards end-to-end 4-bit inference on generative large language models. arXiv preprint arXiv:2310.09259, 2023.   \n[2] Saleh Ashkboos, Amirkeivan Mohtashami, Maximilian L Croci, Bo Li, Martin Jaggi, Dan Alistarh, Torsten Hoefler, and James Hensman. Quarot: Outlier-free 4-bit inference in rotated llms. arXiv preprint arXiv:2404.00456, 2024.   \n[3] Haoli Bai, Wei Zhang, Lu Hou, Lifeng Shang, Jing Jin, Xin Jiang, Qun Liu, Michael Lyu, and Irwin King. Binarybert: Pushing the limit of bert quantization. arXiv preprint arXiv:2012.15701, 2020.   \n[4] Yushi Bai, Xin Lv, Jiajie Zhang, Hongchang Lyu, Jiankai Tang, Zhidian Huang, Zhengxiao Du, Xiao Liu, Aohan Zeng, Lei Hou, et al. Longbench: A bilingual, multitask benchmark for long context understanding. arXiv preprint arXiv:2308.14508, 2023.   \n[5] Yoshua Bengio, Nicholas L\u00e9onard, and Aaron Courville. Estimating or propagating gradients through stochastic neurons for conditional computation. arXiv preprint arXiv:1308.3432, 2013.   \n[6] Yonatan Bisk, Rowan Zellers, Jianfeng Gao, Yejin Choi, et al. Piqa: Reasoning about physical commonsense in natural language. In Proceedings of the AAAI conference on artificial intelligence, volume 34, pages 7432\u20137439, 2020.   \n[7] Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language models are few-shot learners. Advances in neural information processing systems, 33:1877\u20131901, 2020.   \n[8] Jerry Chee, Yaohui Cai, Volodymyr Kuleshov, and Christopher M De Sa. Quip: 2-bit quantization of large language models with guarantees. Advances in Neural Information Processing Systems, 36, 2024.   \n[9] Mengzhao Chen, Wenqi Shao, Peng Xu, Jiahao Wang, Peng Gao, Kaipeng Zhang, Yu Qiao, and Ping Luo. Efficientqat: Efficient quantization-aware training for large language models. arXiv preprint arXiv:2407.11062, 2024.   \n[10] Wei-Lin Chiang, Zhuohan Li, Zi Lin, Ying Sheng, Zhanghao Wu, Hao Zhang, Lianmin Zheng, Siyuan Zhuang, Yonghao Zhuang, Joseph E Gonzalez, et al. Vicuna: An open-source chatbot impressing gpt-4 with $90\\%*$ chatgpt quality. See https://vicuna. lmsys. org (accessed 14 April 2023), 2023.   \n[11] Christopher Clark, Kenton Lee, Ming-Wei Chang, Tom Kwiatkowski, Michael Collins, and Kristina Toutanova. Boolq: Exploring the surprising difficulty of natural yes/no questions. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 2924\u20132936, 2019.   \n[12] Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. Think you have solved question answering? try arc, the ai2 reasoning challenge. arXiv preprint arXiv:1803.05457, 2018.   \n[13] Tim Dettmers, Mike Lewis, Younes Belkada, and Luke Zettlemoyer. Llm.int8(): 8-bit matrix multiplication for transformers at scale. In Conference on Neural Information Processing Systems, 2022.   \n[14] Tim Dettmers, Ruslan A. Svirschevski, Vage Egiazarian, Denis Kuznedelev, Elias Frantar, Saleh Ashkboos, Alexander Borzunov, Torsten Hoefler, and Dan Alistarh. SpQR: A sparse-quantized representation for near-lossless LLM weight compression. In The Twelfth International Conference on Learning Representations, 2024.   \n[15] Peijie Dong, Lujun Li, Zhenheng Tang, Xiang Liu, Xinglin Pan, Qiang Wang, and Xiaowen Chu. Pruner-zero: Evolving symbolic pruning metric from scratch for large language models. In Proceedings of the 41st International Conference on Machine Learning. PMLR, 2024. URL https://arxiv.org/abs/2406.02924. [arXiv: 2406.02924].   \n[16] Dayou Du, Yijia Zhang, Shijie Cao, Jiaqi Guo, Ting Cao, Xiaowen Chu, and Ningyi Xu. Bitdistiller: Unleashing the potential of sub-4-bit llms via self-distillation. arXiv preprint arXiv:2402.10631, 2024.   \n[17] Haojie Duanmu, Zhihang Yuan, Xiuhong Li, Jiangfei Duan, Xingcheng Zhang, and Dahua Lin. Skvq: Sliding-window key and value cache quantization for large language models. arXiv preprint arXiv:2405.06219, 2024.   \n[18] Elias Frantar, Saleh Ashkboos, Torsten Hoefler, and Dan Alistarh. Gptq: Accurate post-training quantization for generative pre-trained transformers. arXiv preprint arXiv:2210.17323, 2022.   \n[19] Yuxin Guo, Siyang Sun, Shuailei Ma, Kecheng Zheng, Xiaoyi Bao, Shijie Ma, Wei Zou, and Yun Zheng. Crossmae: Cross-modality masked autoencoders for region-aware audio-visual pre-training. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 26721\u201326731, 2024.   \n[20] Song Han, Huizi Mao, and William J Dally. Deep compression: Compressing deep neural networks with pruning, trained quantization and huffman coding. arXiv preprint arXiv:1510.00149, 2015.   \n[21] Yefei He, Luoming Zhang, Weijia Wu, Jing Liu, Hong Zhou, and Bohan Zhuang. Zipcache: Accurate and efficient kv cache quantization with salient token identification. arXiv preprint arXiv:2405.14256, 2024.   \n[22] Dan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt. Measuring massive multitask language understanding. In International Conference on Learning Representations, 2020.   \n[23] Jung Hwan Heo, Jeonghoon Kim, Beomseok Kwon, Byeongwook Kim, Se Jung Kwon, and Dongsoo Lee. Rethinking channel dimensions to isolate outliers for low-bit weight quantization of large language models. arXiv preprint arXiv:2309.15531, 2023.   \n[24] Lu Hou, Quanming Yao, and James T Kwok. Loss-aware binarization of deep networks. arXiv preprint arXiv:1611.01600, 2016.   \n[25] Wei Huang, Xudong Ma, Haotong Qin, Xingyu Zheng, Chengtao Lv, Hong Chen, Jie Luo, Xiaojuan Qi, Xianglong Liu, and Michele Magno. How good are low-bit quantized llama3 models? an empirical study. arXiv preprint arXiv:2404.14047, 2024.   \n[26] Benoit Jacob, Skirmantas Kligys, Bo Chen, Menglong Zhu, Matthew Tang, Andrew Howard, Hartwig Adam, and Dmitry Kalenichenko. Quantization and training of neural networks for efficient integer-arithmetic-only inference. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 2704\u20132713, 2018.   \n[27] Mojan Javaheripi, S\u00e9bastien Bubeck, Marah Abdin, Jyoti Aneja, Sebastien Bubeck, Caio C\u00e9sar Teodoro Mendes, Weizhu Chen, Allie Del Giorno, Ronen Eldan, Sivakanth Gopi, et al. Phi-2: The surprising power of small language models. Microsoft Research Blog, 2023.   \n[28] Albert Q Jiang, Alexandre Sablayrolles, Arthur Mensch, Chris Bamford, Devendra Singh Chaplot, Diego de las Casas, Florian Bressand, Gianna Lengyel, Guillaume Lample, Lucile Saulnier, et al. Mistral 7b. arXiv preprint arXiv:2310.06825, 2023.   \n[29] Sehoon Kim, Coleman Hooper, Amir Gholami, Zhen Dong, Xiuyu Li, Sheng Shen, Michael W Mahoney, and Kurt Keutzer. Squeezellm: Dense-and-sparse quantization. arXiv preprint arXiv:2306.07629, 2023.   \n[30] Liang Li, Qingyuan Li, Bo Zhang, and Xiangxiang Chu. Norm tweaking: High-performance low-bit quantization of large language models. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 38, pages 18536\u201318544, 2024.   \n[31] Shiyao Li, Xuefei Ning, Luning Wang, Tengxuan Liu, Xiangsheng Shi, Shengen Yan, Guohao Dai, Huazhong Yang, and Yu Wang. Evaluating quantized large language models. arXiv preprint arXiv:2402.18158, 2024.   \n[32] Haokun Lin, Haoli Bai, Zhili Liu, Lu Hou, Muyi Sun, Linqi Song, Ying Wei, and Zhenan Sun. Mope-clip: Structured pruning for efficient vision-language models with module-wise pruning error metric. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 27370\u201327380, 2024.   \n[33] Ji Lin, Jiaming Tang, Haotian Tang, Shang Yang, Xingyu Dang, and Song Han. Awq: Activation-aware weight quantization for llm compression and acceleration. arXiv preprint arXiv:2306.00978, 2023.   \n[34] Akide Liu, Jing Liu, Zizheng Pan, Yefei He, Gholamreza Haffari, and Bohan Zhuang. Minicache: Kv cache compression in depth dimension for large language models. arXiv preprint arXiv:2405.14366, 2024.   \n[35] Jing Liu, Ruihao Gong, Xiuying Wei, Zhiwei Dong, Jianfei Cai, and Bohan Zhuang. QLLM: Accurate and efficient low-bitwidth quantization for large language models. In The Twelfth International Conference on Learning Representations, 2024. URL https://openreview. net/forum?id $=$ FIplmUWdm3.   \n[36] Ruikang Liu, Haoli Bai, Haokun Lin, Yuening Li, Han Gao, Zhengzhuo Xu, Lu Hou, Jun Yao, and Chun Yuan. Intactkv: Improving large language model quantization by keeping pivot tokens intact. arXiv preprint arXiv:2403.01241, 2024.   \n[37] Zechun Liu, Barlas Oguz, Changsheng Zhao, Ernie Chang, Pierre Stock, Yashar Mehdad, Yangyang Shi, Raghuraman Krishnamoorthi, and Vikas Chandra. Llm-qat: Data-free quantization aware training for large language models. arXiv preprint arXiv:2305.17888, 2023.   \n[38] Zirui Liu, Jiayi Yuan, Hongye Jin, Shaochen Zhong, Zhaozhuo Xu, Vladimir Braverman, Beidi Chen, and Xia Hu. Kivi: A tuning-free asymmetric 2bit quantization for kv cache. arXiv preprint arXiv:2402.02750, 2024.   \n[39] Shijie Ma, Fei Zhu, Zhun Zhong, Wenzhuo Liu, Xu-Yao Zhang, and Cheng-Lin Liu. Happy: A debiased learning framework for continual generalized category discovery. arXiv preprint arXiv:2410.06535, 2024.   \n[40] Yuexiao Ma, Huixia Li, Xiawu Zheng, Feng Ling, Xuefeng Xiao, Rui Wang, Shilei Wen, Fei Chao, and Rongrong Ji. Affinequant: Affine transformation quantization for large language models. arXiv preprint arXiv:2403.12544, 2024.   \n[41] Stephen Merity, Caiming Xiong, James Bradbury, and Richard Socher. Pointer sentinel mixture models. In International Conference on Learning Representations, 2016.   \n[42] Markus Nagel, Rana Ali Amjad, Mart Van Baalen, Christos Louizos, and Tijmen Blankevoort. Up or down? adaptive rounding for post-training quantization. In International Conference on Machine Learning, pages 7197\u20137206. PMLR, 2020.   \n[43] Davide Paglieri, Saurabh Dash, Tim Rockt\u00e4schel, and Jack Parker-Holder. Outliers and calibration sets have diminishing effect on quantization of modern llms. arXiv preprint arXiv:2405.20835, 2024.   \n[44] Pratyush Patel, Esha Choukse, Chaojie Zhang, Aashaka Shah, \u00cd\u00f1igo Goiri, Saeed Maleki, and Ricardo Bianchini. Splitwise: Efficient generative llm inference using phase splitting. In 2024 ACM/IEEE 51st Annual International Symposium on Computer Architecture (ISCA), pages 118\u2013132. IEEE, 2024.   \n[45] Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. Exploring the limits of transfer learning with a unified text-to-text transformer. The Journal of Machine Learning Research, 21(1):5485\u20135551, 2020.   \n[46] Keisuke Sakaguchi, Ronan Le Bras, Chandra Bhagavatula, and Yejin Choi. Winogrande: An adversarial winograd schema challenge at scale. Communications of the ACM, 64(9):99\u2013106, 2021.   \n[47] Yuzhang Shang, Zhihang Yuan, and Zhen Dong. PB-LLM: Partially binarized large language models. In The Twelfth International Conference on Learning Representations, 2024.   \n[48] Wenqi Shao, Mengzhao Chen, Zhaoyang Zhang, Peng Xu, Lirui Zhao, Zhiqian Li, Kaipeng Zhang, Peng Gao, Yu Qiao, and Ping Luo. Omniquant: Omnidirectionally calibrated quantization for large language models. In The Twelfth International Conference on Learning Representations, 2023.   \n[49] Mingjie Sun, Xinlei Chen, J Zico Kolter, and Zhuang Liu. Massive activations in large language models. arXiv preprint arXiv:2402.17762, 2024.   \n[50] Chaofan Tao, Lu Hou, Wei Zhang, Lifeng Shang, Xin Jiang, Qun Liu, Ping Luo, and Ngai Wong. Compression of generative pre-trained language models via quantization. arXiv preprint arXiv:2203.10705, 2022.   \n[51] Chaofan Tao, Qian Liu, Longxu Dou, Niklas Muennighoff, Zhongwei Wan, Ping Luo, Min Lin, and Ngai Wong. Scaling laws with vocabulary: Larger models deserve larger vocabularies. arXiv preprint arXiv:2407.13623, 2024.   \n[52] Hugo Touvron, Thibaut Lavril, Gautier Izacard, Xavier Martinet, Marie-Anne Lachaux, Timoth\u00e9e Lacroix, Baptiste Rozi\u00e8re, Naman Goyal, Eric Hambro, Faisal Azhar, et al. Llama: Open and efficient foundation language models. arXiv preprint arXiv:2302.13971, 2023.   \n[53] Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288, 2023.   \n[54] Albert Tseng, Jerry Chee, Qingyao Sun, Volodymyr Kuleshov, and Christopher De Sa. Quip#: Even better llm quantization with hadamard incoherence and lattice codebooks. arXiv preprint arXiv:2402.04396, 2024.   \n[55] Zhongwei Wan, Xin Wang, Che Liu, Samiul Alam, Yu Zheng, Zhongnan Qu, Shen Yan, Yi Zhu, Quanlu Zhang, Mosharaf Chowdhury, et al. Efficient large language models: A survey. arXiv preprint arXiv:2312.03863, 1, 2023.   \n[56] Zhongwei Wan, Xinjian Wu, Yu Zhang, Yi Xin, Chaofan Tao, Zhihong Zhu, Xin Wang, Siqi Luo, Jing Xiong, and Mi Zhang. D2o: Dynamic discriminative operations for efficient generative inference of large language models. arXiv preprint arXiv:2406.13035, 2024.   \n[57] Zhongwei Wan, Ziang Wu, Che Liu, Jinfa Huang, Zhihong Zhu, Peng Jin, Longyue Wang, and Li Yuan. Look-m: Look-once optimization in kv cache for efficient multimodal long-context inference. arXiv preprint arXiv:2406.18139, 2024.   \n[58] Haoxuan Wang, Yuzhang Shang, Zhihang Yuan, Junyi Wu, and Yan Yan. Quest: Low-bit diffusion model quantization via efficient selective finetuning. arXiv preprint arXiv:2402.03666, 2024.   \n[59] Xin Wang, Yu Zheng, Zhongwei Wan, and Mi Zhang. Svd-llm: Truncation-aware singular value decomposition for large language model compression. arXiv preprint arXiv:2403.07378, 2024.   \n[60] Xiuying Wei, Yunchen Zhang, Yuhang Li, Xiangguo Zhang, Ruihao Gong, Jinyang Guo, and Xianglong Liu. Outlier suppression+: Accurate quantization of large language models by equivalent and effective shifting and scaling. In Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing, pages 1648\u20131665, 2023.   \n[61] Junyi Wu, Haoxuan Wang, Yuzhang Shang, Mubarak Shah, and Yan Yan. Ptq4dit: Post-training quantization for diffusion transformers. arXiv preprint arXiv:2405.16005, 2024.   \n[62] Yichen Wu, Long-Kai Huang, and Ying Wei. Adversarial task up-sampling for meta-learning. Advances in Neural Information Processing Systems, 35:31102\u201331115, 2022.   \n[63] Yichen Wu, Long-Kai Huang, Renzhen Wang, Deyu Meng, and Ying Wei. Meta continual learning revisited: Implicitly enhancing online hessian approximation via variance reduction. In The Twelfth International Conference on Learning Representations, 2024.   \n[64] Haocheng Xi, Changhao Li, Jianfei Chen, and Jun Zhu. Training transformers with 4-bit integers. Advances in Neural Information Processing Systems, 36:49146\u201349168, 2023.   \n[65] Guangxuan Xiao, Ji Lin, Mickael Seznec, Hao Wu, Julien Demouth, and Song Han. Smoothquant: Accurate and efficient post-training quantization for large language models. In International Conference on Machine Learning, pages 38087\u201338099. PMLR, 2023.   \n[66] Haobo Xu, Yuchen Yan, Dingsu Wang, Zhe Xu, Zhichen Zeng, Tarek F Abdelzaher, Jiawei Han, and Hanghang Tong. Slog: An inductive spectral graph neural network beyond polynomial filter. In Forty-first International Conference on Machine Learning, 2024.   \n[67] Jaewoo Yang, Hayun Kim, and Younghoon Kim. Mitigating quantization errors due to activation spikes in glu-based llms. arXiv preprint arXiv:2405.14428, 2024.   \n[68] Lianwei Yang, Zhikai Li, Junrui Xiao, Haisong Gong, and Qingyi Gu. Mgrq: Post-training quantization for vision transformer with mixed granularity reconstruction. arXiv preprint arXiv:2406.09229, 2024.   \n[69] Zhewei Yao, Reza Yazdani Aminabadi, Minjia Zhang, Xiaoxia Wu, Conglong Li, and Yuxiong He. Zeroquant: Efficient and affordable post-training quantization for large-scale transformers. In Conference on Neural Information Processing Systems, 2022.   \n[70] Zhihang Yuan, Lin Niu, Jiawei Liu, Wenyu Liu, Xinggang Wang, Yuzhang Shang, Guangyu Sun, Qiang Wu, Jiaxiang Wu, and Bingzhe Wu. Rptq: Reorder-based post-training quantization for large language models. arXiv preprint arXiv:2304.01089, 2023.   \n[71] Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. Hellaswag: Can a machine really finish your sentence? In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 4791\u20134800, 2019.   \n[72] Renrui Zhang, Dongzhi Jiang, Yichi Zhang, Haokun Lin, Ziyu Guo, Pengshuo Qiu, Aojun Zhou, Pan Lu, Kai-Wei Chang, Peng Gao, et al. Mathverse: Does your multi-modal llm truly see the diagrams in visual math problems? arXiv preprint arXiv:2403.14624, 2024.   \n[73] Wei Zhang, Lu Hou, Yichun Yin, Lifeng Shang, Xiao Chen, Xin Jiang, and Qun Liu. Ternarybert: Distillation-aware ultra-low bit bert. arXiv preprint arXiv:2009.12812, 2020.   \n[74] Yingtao Zhang, Haoli Bai, Haokun Lin, Jialin Zhao, Lu Hou, and Carlo Vittorio Cannistraci. Plug-and-play: An efficient post-training pruning method for large language models. In The Twelfth International Conference on Learning Representations, 2024. URL https:// openreview.net/forum?id $\\cdot^{=}$ Tr0lPx9woF.   \n[75] Tianchen Zhao, Xuefei Ning, Tongcheng Fang, Enshu Liu, Guyue Huang, Zinan Lin, Shengen Yan, Guohao Dai, and Yu Wang. Mixdq: Memory-efficient few-step text-to-image diffusion models with metric-decoupled mixed precision quantization. arXiv preprint arXiv:2405.17873, 2024.   \n[76] Yilong Zhao, Chien-Yu Lin, Kan Zhu, Zihao Ye, Lequn Chen, Size Zheng, Luis Ceze, Arvind Krishnamurthy, Tianqi Chen, and Baris Kasikci. Atom: Low-bit quantization for efficient and accurate llm serving. arXiv preprint arXiv:2310.19102, 2023.   \n[77] Zhenghao Zhao, Yuzhang Shang, Junyi Wu, and Yan Yan. Dataset quantization with active learning based adaptive sampling. arXiv preprint arXiv:2407.07268, 2024.   \n[78] Lianmin Zheng, Wei-Lin Chiang, Ying Sheng, Siyuan Zhuang, Zhanghao Wu, Yonghao Zhuang, Zi Lin, Zhuohan Li, Dacheng Li, Eric Xing, et al. Judging llm-as-a-judge with mt-bench and chatbot arena. arXiv preprint arXiv:2306.05685, 2023. ", "page_idx": 10}, {"type": "text", "text": "", "page_idx": 11}, {"type": "text", "text": "", "page_idx": 12}, {"type": "text", "text": "", "page_idx": 13}, {"type": "text", "text": "", "page_idx": 14}, {"type": "text", "text": "Appendix Overview ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "\u2022 Section A: Related work.   \n\u2022 Section B: Theory proofs.   \n\u2022 Section C: Additional implementation details.   \n\u2022 Section D: More empirical results.   \n\u2022 Section E: More detailed ablation studies.   \n\u2022 Section F: Detailed comparison with QuaRot.   \n\u2022 Section G: Algorithm for rotation matrix.   \n\u2022 Section H: Limitations and broader impacts.   \n\u2022 Section I: More visualization examples. ", "page_idx": 15}, {"type": "text", "text": "A Related Work ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "A.1 Network Quantization ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Neural networks achieve great success in recent years [32, 66, 72, 39, 62, 19, 63], quantization [1, 64, 68, 76, 58, 77] is a widely utilized technique aimed at reducing model size and memory usage. Research in this area generally falls into two main categories: quantization-aware training (QAT) [73, 3, 50] and post-training quantization (PTQ) [42, 61, 75]. QAT involves training quantized model weights using additional data, often with the assistance of a straight-through estimator (STE) [5]. However, the computational cost associated with QAT poses challenges, particularly for large language models (LLMs) with millions of parameters, which necessitate significant amounts of data for retraining [37, 16, 9]. In contrast, PTQ has gained popularity for LLMs [55, 23, 70, 59, 38, 21] due to its efficient approach, involving the training of quantized models using a small amount of data, known as calibration data [18]. However, PTQ often leads to significant performance degradation, especially when employing low-bit settings [18, 54, 47, 31]. Consequently, our work focuses on enhancing the performance of low-bit PTQ quantized models. ", "page_idx": 15}, {"type": "text", "text": "A.2 Post Training Quantization of LLM ", "text_level": 1, "page_idx": 15}, {"type": "text", "text": "Post-training quantization for LLMs can be categorized into weight-only quantization [33, 14, 29, 30] and weight-activation quantization [69, 65, 76]. We focus on 4-bit weight-activation quantization due to the actual speedup it provides with low-bit quantization kernels [1]. Quantizing LLMs faces challenges due to activation outlier features persisting across different tokens and layers [13, 65]. Some approaches [13, 76] retain a small portion of crucial outlier channels at high precision (e.g., INT8), which poses challenges to hardware compatibility and leads to additional memory footprint. Other methods [65, 60, 48] attempt to shift quantization difficulty from activation to weight channels. However, the learnable equivalent transformation in OmniQuant [48] and the affine transform matrix in AffineQuant [40] exhibit instability as discussed in Section 2. The channel disassembly and assembly in QLLM [35], coupled with LoRA-tuning, incur significant time costs. Notably, these methods demonstrate poor performance under W4A4 quantization. We attribute this degradation to the ineffective handling of outlier features, especially massive outliers. Hence, we propose DuQuant to effectively eliminate outlier features through rotation matrices and channel permutation, achieving state-of-the-art performance. In contrast with QuaRot [2] also utilizing Hadamard matrices to enhance weight-activation quantization, our approach uniquely incorporates knowledge about the actual outlier channels. Furthermore, unlike QuaRot, which relies on GPTQ [18] for weight quantization, our permutation transformation has been proven helpful and efficient, facilitating a faster quantization process. The more detailed analysis and comparison with QuaRot are left in Appendix F. In addition, unlike RPTQ [70] and SKVQ [17], which use channel reordering to cluster similar activations, our method employs Permutation transformations with a fundamentally different goal: to evenly distribute outliers across blocks. This balanced distribution is crucial for enabling effective secondary rotations, ultimately leading to smoother activations that facilitate easier quantization. ", "page_idx": 15}, {"type": "text", "text": "B Proofs ", "text_level": 1, "page_idx": 16}, {"type": "text", "text": "Theorem 1 (Rotation). For the activation input $\\mathbf{X}\\in\\mathbb{R}^{T\\times C_{i n}}$ , $\\hat{\\mathbf{R}}\\in\\mathbb{R}^{2^{n}\\times2^{n}}$ is a diagonal block matrix constructed as per Eqn. (3). For a specific block $b_{i}$ , let $O_{j}(\\cdot)$ represent the maximum outlier of the $j$ -th dimension $d_{j}$ within the input. Then, we can deduce that, ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\operatorname*{max}_{1\\leq j\\leq2^{n}}\\ O_{j}(\\mathbf X_{b_{i}}\\hat{\\mathbf{R}}_{b_{i}})\\leq\\operatorname*{max}_{1\\leq j\\leq2^{n}}\\ O_{j}(\\mathbf X_{b_{i}}).\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Proof. In the case of a specific block $b_{i}$ , the potential maximum value $O_{j}(\\mathbf{X}_{b_{i}}\\hat{\\mathbf{R}}_{b_{i}})$ , where $\\mathbf{X}_{b_{i}}\\in$ $\\mathbb{R}^{T\\times2^{n}}$ , can be achieved by ensuring that the different $j$ -th column outliers $O_{j}(\\mathbf{X}_{b_{i}})$ are located in the same $t$ -th row of the activation input $\\mathbf{X}_{b_{i}}$ . This can be formally defined as follows, ", "page_idx": 16}, {"type": "text", "text": "$\\operatorname*{max}_{1\\leq j\\leq2^{n}}\\;O_{j}\\big(\\mathbf{X}_{b_{i}}\\hat{\\mathbf{R}}_{b_{i}}\\big)=O_{1}\\big(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}}\\big)\\cdot\\frac{1}{\\sqrt{M}}+O_{2}\\big(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}}\\big)\\cdot\\delta_{1}+...+O_{M}\\big(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}}\\big)\\delta_{M},$ where $M=2^{n}$ and $\\|{\\frac{1}{2^{n}}}+\\delta_{2}^{2}+...+\\delta_{M}^{2}\\|=1,\\qquad\\ (\\hat{\\bf R}_{b_{i}}\\mathrm{is\\orthogonal})$ ", "page_idx": 16}, {"type": "text", "text": "Without loss of generality, let\u2019s assume that $\\delta_{i}\\geq0$ and define $m:=\\arg\\operatorname*{max}_{i}\\ \\delta_{i}^{2}$ . Then we can derive that $\\begin{array}{r}{\\delta_{m}\\geq\\frac{1}{\\sqrt{2^{n}}}}\\end{array}$ . Consequently, we can obtain the following inequality, ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}{\\displaystyle\\operatorname*{max}_{1\\leq j\\leq2^{n}}\\ O_{j}(\\mathbf{X}_{b_{i}}\\hat{\\mathbf{R}}_{b_{i}})=O_{1}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}})\\cdot\\frac{1}{\\sqrt{2^{n}}}+O_{2}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}})\\cdot\\delta_{1}+...+O_{M}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}})\\delta_{M}}\\\\ {\\leq O_{1}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}})\\cdot\\frac{1}{\\sqrt{2^{n}}}+(O_{2}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}})+...+O_{M}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}}))\\delta_{m}}\\\\ {\\overset{(1)}{\\leq}O_{1}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}})\\cdot\\frac{1}{\\sqrt{2^{n}}}+O_{1}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}})\\cdot\\frac{\\sqrt{2^{n}}-1}{\\sqrt{2^{n}}}=O_{1}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}})}\\\\ {=\\displaystyle\\operatorname*{max}_{1\\leq j\\leq2^{n}}\\ O_{j}(\\mathbf{X}_{b_{i}}).}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "The inequality (1) holds because the switch matrix $\\mathbf{E}_{d^{(1)}}$ has swap the largest outliers $O_{1}({\\bf X}_{b_{i}})$ in the first column, i.e., $O_{1}(\\mathbf{X}_{b_{i}}\\mathbf{E}_{d^{(1)}})>\\operatorname*{max}_{2\\leq m\\leq M}O_{m}(\\mathbf{X}_{b_{i}}\\mathbf{\\bar{E}}_{d^{(1)}})$ . ", "page_idx": 16}, {"type": "text", "text": "Theorem 2 (Zigzag Permutation). For the activation input $\\mathbf{X}\\in\\mathbb{R}^{T\\times C_{i n}}$ , it can be divided into $K$ blocks, where $K=C_{i n}/2^{n}$ . Let $O_{j}$ denote the max outlier of the dimension $d_{j}$ in $\\mathbf{X}$ , the reordered outliers from large to small is expressed as $O^{(1)},O^{(2)},...,O^{(C_{i n})}$ . Moreover, the $M_{b_{i}}$ represents the mean value of all $O_{j}$ in the $i$ -th block, $i=1,2,...,K$ . Let $\\delta:=\\operatorname*{max}\\{|O^{(i+1)}-O^{(i)}|\\},i=$ $1,2,...,C_{i n}\\!-\\!1$ . Then, following the zigzag permutation described in Section 3.2, the mean value $M_{b_{i}}$ within each $i$ -th block consistently satisfies, ", "page_idx": 16}, {"type": "equation", "text": "$$\nM_{b_{i}}\\le{\\cal O}^{(1)}+\\frac{(2^{n}K-1)(2^{n-1}-1)}{2^{n}}\\delta,\\qquad i=1,2,3,...,K.\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Proof. According to the zigzag permutation described in Section 3.2, and considering the reordered outliers $O^{(1)},O^{(2)},...,O^{(C_{i n})}$ , we can redistribute the channels they occupy (i.e., $O_{c}^{(i)}$ )across different blocks. Specifically, for the $i$ -th block, it contains the following channels, ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{b_{i}=\\{O_{c}^{2m K+i},O^{2(m+1)K-i+1}|m=0,1,...,2^{n-1}-1\\}}\\\\ &{\\quad=\\{O_{c}^{(i)},O_{c}^{(2K-i+1)},...,O_{c}^{2^{n}K+K},O^{(2^{n}K+K+1)}\\}}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Since $\\delta=\\operatorname*{max}\\{|O^{(i+1)}-O^{(i)}|\\},i=1,2,...,C_{i n}-1$ , then we can get ", "page_idx": 16}, {"type": "equation", "text": "$$\n\\begin{array}{r l}&{M_{b_{1}}=\\cfrac{1}{2^{n}}\\lbrace O^{(1)}+O^{(2k)}+\\ldots+O^{2^{n}-2k+1}+O^{2^{n}K}\\rbrace}\\\\ &{\\qquad\\leq\\cfrac{1}{2^{n}}\\lbrace O^{(1)}+(4K-1)\\delta+(8K-1)\\delta+\\lbrack(2^{n+1}-4)K-1\\rbrack\\delta+(2^{n}K-1)\\delta\\rbrace}\\\\ &{\\qquad\\leq O^{(1)}+\\cfrac{(2^{n}K-1)(2^{n-1}-1)}{2^{n}}\\delta.}\\end{array}\n$$", "text_format": "latex", "page_idx": 16}, {"type": "text", "text": "Similarly, we can deduce that all $M_{b_{i}}\\;(i=1,2,...,K)$ share the same upper bound after applying our zigzag permutation. \u53e3 ", "page_idx": 16}, {"type": "text", "text": "C Additional Implementation Details ", "text_level": 1, "page_idx": 17}, {"type": "text", "text": "In this work, all experiments are done on NVIDIA RTX 3090 GPUs for small-scale models and NVIDIA A100 GPUs for large-scale models. We set sequence length to 2048 for all evaluation tasks. ", "page_idx": 17}, {"type": "text", "text": "For calibration data, following [48, 40, 35], we randomly select 128 sampled sequences from the WikiText2 dataset, with the sequence length of 2048. For rotation and permutation transformations, the rotation block size $2^{n}$ is set to 128, and maximum greedy search steps $N$ equals 256. We adopt once permutation times for efficiency. We conduct detailed ablation studies in Appendix E.2, E.3, E.4. ", "page_idx": 17}, {"type": "text", "text": "Regarding quantization details, for multiplications between activations in MSA, such as Query and Key, attention outputs and Value, we apply a Hadamard rotation matrix for rapid and straightforw\u221aard processing. A Hadamard matrix is an orthogonal and symmetric matrix fliled with elements $\\pm1/{\\sqrt{2^{n}}}$ . For smooth parameter $\\alpha$ , we set it to 0.6 for DuQuant and 0.5 DuQuant+LWC. We clip the maximum activation values in all projection blocks, and the clipping ratio is set to 0.9. For DuQuant we also clip the maximum values in weight matrices, with a clipping ratio of 0.8. For LWC, we keep the same default epoch numbers of 20, batch size as 1, learning rate as 5e-3, and zero weight decay, as [48]. ", "page_idx": 17}, {"type": "text", "text": "D More Empirical Results ", "text_level": 1, "page_idx": 17}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/e2b7f080cb73033169dc7d3ec19357dea5376857ae6eb75051e230e6f20a2527.jpg", "table_caption": ["Table D1: Zero-shot common-sense QA (\u2191) results of LLaMA2 models under 4-bit WA quantization. "], "table_footnote": [], "page_idx": 17}, {"type": "text", "text": "Zero-shot QA Results for 4-bit LLaMA2 Models. Table D1 showcases the zero-shot commonsense QA results for INT4 quantized LLaMA2 models. Our DuQuant method excels across various model sizes and datasets, demonstrating state-of-the-art performance in commonsense reasoning tasks. For example, DuQuant outperforms Atom by $5.43\\%$ for the LLaMA2-7B model and by $5.18\\%$ for the LLaMA2-13B model. In contrast to Atom [76], which relies on GPTQ for weight quantization and maintains 128 channels at INT8, thereby increasing memory usage, our method offers a rapid and more efficient weight-activation quantization solution through Rotation and Permutation. ", "page_idx": 17}, {"type": "text", "text": "MMLU Results for 4-bit Vicuna-v1.5-7B. Vicuna-v1.5 models [10], fine-tuned from LLaMA2 models using high-quality user-shared conversations, are considered state-of-the-art chatbots. Table D2 displays the INT4 quantization results for Vicuna-v1.5-7B on the MMLU benchmarks. In comparison to SmoothQuant, OmniQuant, and Atom, our DuQuant method exhibits the smallest ", "page_idx": 17}, {"type": "text", "text": "performance decline and maintains competitive capacities in both zero-shot and five-shot settings.   \nThese results demonstrate the effectiveness of DuQuant in generalizing to instruction-tuned models. ", "page_idx": 18}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/c0a508844b3e196353e5e5f1b8a09d92068a8e2ebd43a367c62562a99edb9b1e.jpg", "table_caption": ["Table D2: Zero-shot and five-shot results on the MMLU benchmark for quantized Vicuna-v1.5-7B. "], "table_footnote": [], "page_idx": 18}, {"type": "text", "text": "Long-context Evaluation Results. LongBench [4] is proposed to access the long-context generation ability of LLMs, which covers several key long-text application scenarios. We evaluate the 4-bit quantized Vicuna models on five different tasks. Specifically, Qasper, MultiFieldQA, and NarrativeQA (F1 score) are Single-Document QA tasks; DuReader (Rouge-L score) and 2WikiMultihopQA (F1 score) are Multi-Document QA tasks; QMSum, GovReport (F1 score) and MultiNews (Rouge-L score) are Summarization tasks; TREC (Accuracy CLS), TriviaQA (F1 score), and SAMSum (Rouge-L score) are Few-shot Learning tasks; and RepoBench-P (similarity score) is Code Completion task. Table D3 and Table D4 show that our DuQuant outperforms other baselines by a clear margin, maintaining the ability for long context generation tasks compared with FP16 models. ", "page_idx": 18}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/dc5acba04eb2f35c2d29132010a390ff9d72271c16ab78e994c18baa43486751.jpg", "table_caption": ["Table D3: Long-context generation results on the LongBench benchmark for 4-bit Vicuna-v1.5-7B. "], "table_footnote": [], "page_idx": 18}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/2341b655eb01d99372dc869ba2961d085a72686f4ce221724109f6048464e6a8.jpg", "table_caption": ["Table D4: Long-context generation results on the LongBench benchmark for 4-bit Vicuna-v1.5-13B. "], "table_footnote": [], "page_idx": 18}, {"type": "text", "text": "Comparison with FP16 models on MT-Bench. ", "text_level": 1, "page_idx": 18}, {"type": "text", "text": "We conducted additional comparisons using the MT-Bench between our INT4 quantized models and the FP16 models. As shown in Table D5, for both 7B and 13B models, our DuQuant performs ", "page_idx": 18}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/9227d041c520c2d0bc867e18393e6d3ae7f1e6236727e36940073aaf4cd635e0.jpg", "table_caption": ["Table D5: More results on MT-Bench. "], "table_footnote": ["comparably to FP16, which further underscores the effectiveness of dual transformations in maintaining high accuracy even with reduced precision. "], "page_idx": 18}, {"type": "text", "text": "Results for 4-bit Mistral-7B and Phi2-2.8B. We have extended the application of DuQuant to include Mistral [28] and Phi2 [27] under 4-bit WA quantization. From Table D6, we can observe that ", "page_idx": 18}, {"type": "text", "text": "DuQuant largely surpasses other baselines, particularly with Mistral-7B. Regarding the Phi2-2.8B model, it often experiences instability in matrix multiplication between queries and values, leading to overflow issues and posing great challenges to quantization. However, while DuQuant may not perform as well as FP models, it still significantly outperforms other baselines. In addition, we have visualized the massive outliers in the down projection layer of the Mistral-7B model and the feature space after our dual transformations. These visualizations are shown in Figure I9. It can be observed that our DuQuant perfectly eliminates these outliers. These results underscore the effectiveness of our dual transformation approach in addressing massive outliers across various types of LLMs. ", "page_idx": 19}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/5f164fa4e4365f77a8bc140a85ae8991e967bb7e512ee06a94af7b3ffcbccc9c.jpg", "table_caption": ["Table D6: Perplexity results of Mistral-7B and Phi2-2.8B under 4-bit weight-activation quantization. "], "table_footnote": [], "page_idx": 19}, {"type": "text", "text": "Results for 4-bit LLaMA3-70B. As LLaMA3 models have proven to be sensitive to quantization, we apply our DuQuant to the LLaMA3-70B and present the results in Table D7. Due to time constraints, we do not add learnable weight clipping. The results demonstrate that our DuQuantquantized models outperform SmoothQuant by $12.9\\%$ on Commonsense QA tasks and significantly reduce perplexity across the WikiText2, C4, and PTB datasets. These improvements underscore the robustness of our DuQuant method when applied to the LLaMA3-70B model. ", "page_idx": 19}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/12bac79e99946fd2897e09f8501be814f562902f4e012843b197652b2263631d.jpg", "table_caption": ["Table D7: Perplexity and QA results of LLaMA3-70B under 4-bit weight-activation quantization. "], "table_footnote": [], "page_idx": 19}, {"type": "text", "text": "W6A6 Quantization Results. To thoroughly evaluate the effectiveness of our DuQuant models, we conduct comprehensive assessments under the W6A6 quantization setting. The perplexity results for language generation tasks are displayed in Table D8, while the zero-shot accuracy for Commonsense QA tasks is detailed in Tables D9 and D10. Our findings reveal that DuQuant not only surpasses other baselines but also achieves nearly lossless performance with FP16 models in these tasks. Interestingly, in several instances, DuQuant slightly outperforms DuQuant+LWC . This suggests that the Rotation and Permutation transformations alone are sufficient to create highly competitive quantized models under W6A6 settings, without the need for additional enhancements such as the learnable weight clipping (LWC) technique. These outcomes highlight the exceptional versatility and robustness of DuQuant across various quantization scenarios, confirming its potential as a leading solution in post-training quantization for large language models. ", "page_idx": 19}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/0db8a2d603b543fd975bd3b71cf764f2b3ff28fade4af644fb3c0e4f084f6b8a.jpg", "table_caption": ["Table D8: Preplexity $\\left(\\downarrow\\right)$ results on the WikiText2 and C4 datasets under 6-bit WA quantization. "], "table_footnote": [], "page_idx": 19}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/42a75cc26fec6f70c1304e39d84a6a83b095e9bbc8a3e5c0780fbf582bf39c1c.jpg", "table_caption": ["Table D9: Zero-shot common-sense QA (\u2191) results of LLaMA1 models under 6-bit WA quantization. "], "table_footnote": [], "page_idx": 20}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/530fced8c1701f0aedff96020dc3e7e552d6c6b7bcf0a27c21a0f1dd9c337b68.jpg", "table_caption": ["Table D10: Zero-shot common-sense QA (\u2191) results of LLaMA2 models under 6-bit WA quantization. "], "table_footnote": [], "page_idx": 20}, {"type": "text", "text": "E More Ablation Studies ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "E.1 Time Speedup and Memory Saving ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "The current generation of LLMs usually splits into pre-filling and decoding phases and deploys on two separate machines [44]. Here, we present more speedup and memory-saving results for these two phases achieved with the LLaMA2-7B model on a single NVIDIA RTX 3090 GPU. We set the input sequence length to 2048 and the decoding steps to 256. End-to-end results for time speedup and memory savings during the pre-filling stage are shown in Table E11 and E12. We can observe that DuQuant achieves a maximum speedup of $2.01\\times$ during the pre-filling phase, with speedup increasing as the batch size grows. From Table E12, DuQuant demonstrates significant memory savings, effectively reducing memory usage by up to $3.20\\times$ through quantization. For the decoding phase, we enlarge the batch size to 64 and measure speedup along with memory usage for one LLaMA2-7B layer, constrained by the 24 GB memory of the GPU. As shown in Table E13, DuQuant maintains speedup and memory usage comparable to QuaRot. These results underscore the efficiency of DuQuant in optimizing resource utilization, highlighting its potential to enhance performance and reduce costs in deploying large language models, particularly in resource-constrained environments. ", "page_idx": 21}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/8416ae335ed58403274cbf121b9db71ff9aa8786716431cfcddce3395d1835cf.jpg", "table_caption": ["Table E11: End-to-end pre-filling speedup on LLaMA2-7B model. "], "table_footnote": [], "page_idx": 21}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/5b58d62dfd04d0a62123573e82c2661c2c10a33d10763b931b8544829e7d370e.jpg", "table_caption": ["Table E12: Peak memory usage during pre-filling phase of LLaMA2-7B model. "], "table_footnote": [], "page_idx": 21}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/0667a7761d9227025cbb6be14bb58d4a0dba354ccbe7390d4be0df5b5cbe3ab7.jpg", "table_caption": ["Table E13: Decoding phase results of one LLaMA2-7B layer with a batch size of 64. "], "table_footnote": [], "page_idx": 21}, {"type": "text", "text": "E.2 Effects of Rotation Matrix ", "text_level": 1, "page_idx": 21}, {"type": "text", "text": "Ablation of Rotation Block Size. To further explore the impact of rotation block size, we apply varying block sizes in the rotation matrices to both LLaMA2-7B and LLaMA2-13B models and evaluate the perplexity of the quantized models. The results, presented in Table E14, indicate that increasing block sizes generally improves model performance. This improvement occurs because larger block sizes allow outliers to be distributed across more channels, evening out values throughout the activation/weight matrix thereby enhancing quantization accuracy and performance. Additionally, quantization runtime decreases with larger block sizes, likely due to more efficient transformations during the reshaping of original activation/weight matrices. Consequently, we adopt 128 as our rotation block size for all experiments for efficiency and effectiveness. ", "page_idx": 21}, {"type": "text", "text": "Ablation of Rotation Times. Identifying the optimal rotation matrix $\\mathbf{R}$ is a complex challenge, so we employ a greedy search algorithm to approximate the matrix as $\\hat{\\mathbf{R}}$ . We conduct an ablation study on the number of greedy steps $N$ and summarize the results in Table E15. Initially, as $N$ increases, the model performance improves, reflecting our ability to determine \u02c6R more effectively. However, when $N$ reaches 1024, the model begins to overfit. Consequently, we have chosen $N=256$ for all our experiments, as it offers the optimal balance between model performance and time usage. ", "page_idx": 21}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/640bc2007c42cf960003a6a293aa57feed7ba1cc5416c98d079102bde7734461.jpg", "table_caption": ["Table E14: Impact of rotation block size. "], "table_footnote": [], "page_idx": 22}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/393a67cf880a8c28ab620ecaad81e26cf6d6e6c89080848d278ead97d29c80a6.jpg", "table_caption": ["Table E15: Impact of rotation times. "], "table_footnote": [], "page_idx": 22}, {"type": "text", "text": "E.3 Effects of Permutation Algorithm. ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "As discussed in Section 3.2, rotation transformations within each block are limited and unable to redistribute outliers across different blocks. To address this, we introduce a permutation transformation aimed at balancing outliers more comprehensively. Our primary goal is to minimize the variance among different blocks, as outlined in Eqn. (4). We explore several optimization algorithms, with the results detailed in Table E16. Note that the variance values are measured on activation values of the query project in the first layer of each model, and the time in the table represents the runtime of calibration. The Zigzag permutation notably reduces the variance to $3.0\\mathrm{e}{-4}$ , achieving this with minimal time expenditure and yielding competitive perplexity results. While Simulated Annealing slightly outperforms Zigzag in terms of perplexity for the LLaMA2-7B model, it was significantly more time-consuming, and the marginal gains did not justify the additional complexity. Therefore, we select Zigzag permutation as our preferred method, leading to smoother outlier distribution and more effective quantized models. ", "page_idx": 22}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/7f39290b62d4a8897431298e66085b4a4c98e6c8bf40e06970dccb56390d0f86.jpg", "table_caption": ["Table E16: Impact of channel permutation algorithm. "], "table_footnote": [], "page_idx": 22}, {"type": "text", "text": "E.4 Effects of Calibration Datasets ", "text_level": 1, "page_idx": 22}, {"type": "text", "text": "Ablation of Different Calibration Datasets. We apply our DuQuant to quantize the LLaMA2-7B model using different calibration datasets, with results presented in Table E17. It can be observed that the selection of calibration datasets has a relatively minor impact on quantization performance. This is because our method uses the calibration data solely to identify outlier channels, rather than for gradient-based parameter learning as seen in methods like OmniQuant [48] and AffineQuant [40]. This ablation study underscores the robustness of our DuQuant method. ", "page_idx": 22}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/94bc55e8d50d75c8823f4f9579c5ff295417c0998efbae8f751251c716070252.jpg", "table_caption": ["Table E17: Ablation of calibration datasets. "], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "Calibration-free Quantization. To further explore the robustness of DuQuant under varying calibration conditions, we generate random calibration data within the vocabulary range of the model, setting the sample count to 256. The results, shown in Table E18, indicate that even in calibrationfree settings, our method continues to perform well, achieving results that are competitively close to those obtained with actual calibration data. This demonstrates that DuQuant could provide a viable solution in real-world scenarios where obtaining specific calibration data is challenging or impossible. In addition, our findings suggest that outliers are inherent to certain model layers, reflecting characteristics of the model weights or modules, especially in recent LLMs. This aligns with concurrent research: [67] identified consistent massive outliers at the FFN down projection layer in GLU-based LLMs, such as LLaMA, Mistral, Mixtral, SOLAR, and Gemma, while [43] reported that, although OPT models are sensitive to different calibration sets, newer models demonstrate robustness to outliers and maintain stable activations. These insights reinforce the idea that outliers are more linked to the internal structure of model weights and modules than to calibration data. DuQuant\u2019s ability to deliver high performance without relying on traditional calibration data creates opportunities for deploying quantized models in environments with stringent privacy requirements or limited data availability. This highlights a promising direction for future research, focusing on improving model adaptability and deployment flexibility. ", "page_idx": 23}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/102217cfcfc5330293b8fc2ddc9968a1f05fa23a387e7d916682b58fa938cfbb.jpg", "table_caption": ["Table E18: Calibration-free quantization, where we generate random data within vocabulary range. "], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "Ablation of Different Numbers of Calibration Samples. We utilize our DuQuant to quantize the LLaMA2-7B model using varying numbers of calibration samples from the WikiText2 dataset, with results detailed in Table E19. Interestingly, the quantization performance shows a low correlation with the number of samples, demonstrating the robustness of DuQuant\u02d9This stability arises because we utilize the mean activation values from these samples to construct our rotation matrices. Since we average the activations, the influence of any single, potentially non-representative sample is minimized, ensuring consistent performance. Notably, as we use mean values, the time cost of our quantization process remains constant regardless of the number of samples, enhancing the efficiency. ", "page_idx": 23}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/cecb981b36f0787dcfa4ea97579791339b9fafcfec2d522f5dcc46889db73bd2.jpg", "table_caption": ["Table E19: Ablation of different numbers in the calibration dataset. "], "table_footnote": [], "page_idx": 23}, {"type": "text", "text": "F Detailed Comparison with QuaRot ", "text_level": 1, "page_idx": 24}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/d7728353366c434d85e012238eb3016f52342ba2b0ed09a5a3c8e1fc76db5299.jpg", "table_caption": ["Table F20: Comparison of quantization settings between QuaRot and DuQuant. "], "table_footnote": [], "page_idx": 24}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/fc2c9c9d3a70a19b3044a6bc0dbf6251f6cc51ee1d7fba292947b856520661e5.jpg", "table_caption": ["Table F21: Evaluation results between QuaRot and DuQuant under DuQuant settings. "], "table_footnote": [], "page_idx": 24}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/48eb3f2807d55bdc300f924034ac95951b705932a44c65aaf1c9d472d8fc1630.jpg", "table_caption": ["Table F22: Evaluation results between QuaRot and DuQuant under QuaRot settings. "], "table_footnote": [], "page_idx": 24}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/4f5b7b09408f14e5ed0192d742e0cd6cca901f437681eb5b67a5df9bbc40de66.jpg", "table_caption": ["Table F23: Matrices comparison between DuQuant and QuaRot under W4A4 quantization. "], "table_footnote": [], "page_idx": 24}, {"type": "table", "img_path": "mp8u2Pcmqz/tmp/9d08c4c6fc852a6fb6896eaf932ed18cbf6efb3f64873ed7782633bedbf9b538.jpg", "table_caption": ["Table F24: Quantization runtime comparison on a single NVIDIA A100 80G GPU. "], "table_footnote": [], "page_idx": 24}, {"type": "text", "text": "In this section, we present a detailed comparison between our DuQuant and QuaRot [2]. QuaRot employs Hadamard matrices to mitigate outliers in activations and utilizes the GPTQ algorithm for weight quantization to achieve competitive performance. However, our DuQuant method demonstrates several distinct advantages: ", "page_idx": 24}, {"type": "text", "text": "\u2022 Effective Use of Prior Knowledge: DuQuant leverages prior knowledge to accurately target and eliminate outliers through multiple rotations, achieving a smoother activation distribution compared to the Hadamard transformation, as demonstrated in Figure 10. ", "page_idx": 24}, {"type": "text", "text": "\u2022 Efficient Channel Permutation: Our channel permutation not only further smooths outlier features but also benefits from rapid implementation, enhancing overall performance. ", "page_idx": 25}, {"type": "text", "text": "\u2022 Simultaneous Weight Matrix Smoothing: Unlike QuaRot, DuQuant directly and efficiently smooths the weight matrix, avoiding the time-consuming GPTQ algorithm and accelerating the quantization process, as demonstrated high quantization efficiency in Table F24. ", "page_idx": 25}, {"type": "text", "text": "Experimental results underscore the superiority of DuQuant over QuaRot. We first summarize the experimental setting differences between the original paper of QuaRot with ours in Table $\\mathrm{F}20^{*}$ . For a fair comparison, we reproduce the QuaRot under 4-bit per-channel weight and per-token activation asymmetric quantization. Table F21 displays the perplexity (PPL) and zero-shot accuracy for models LLaMA1-7B, LLaMA2-7B, and LLaMA3-8B. Our DuQuant method consistently outperforms QuaRot-RTN across all benchmarks, showcasing our advanced weight matrix management. Furthermore, compared to QuaRot-GPTQ, DuQuant and DuQuant+LWC achieve better average accuracy across six QA tasks and demonstrate superior performance on the WikiText and C4 datasets, particularly for LLaMA3-8B. Moreover, we further provide the results of DuQuant under the setting utilized in the original paper of QuaRot in Table F22. DuQuant still surpasses QuaRot by a large margin. ", "page_idx": 25}, {"type": "text", "text": "Additionally, we assess the effectiveness of the rotation matrices utilized in DuQuant which incorporate prior knowledge against the Hadamard matrices used in QuaRot. We omit the permutation step in DuQuant and directly contrast it with QuaRot-RTN. Results in Table F23 show that our DuQuant without permutation outperforms QuaRot by a clear margin, which confirms that our rotation transformation is more effective than Hadamard by leveraging prior knowledge. It is worth noting that because a Hadamard matrix is orthogonal and symmetric, it multiplies by itself to yield the identity matrix. In other words, the Hadamard matrix is not suitable for greedy searches aimed at finding smaller outliers. These findings differentiate DuQuant from QuaRot and highlight the effectiveness of our approach in managing outliers for post-training quantization of large language models. ", "page_idx": 25}, {"type": "text", "text": "G Algorithm for Rotation Matrix ", "text_level": 1, "page_idx": 25}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/9acc522a7d3ece7da03cadad23223573e679cba9cc9d39f587c643bf4b479990.jpg", "img_caption": [], "img_footnote": [], "page_idx": 25}, {"type": "text", "text": "H Limitations and Broader Impacts ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "Limitations. The primary limitation of our method is the lack of a specialized strategy for calibration data selection. We adhere to established practices [48, 40, 35, 76, 2, 1] by randomly selecting 128 samples from the WikiText2 dataset to compute the mean embeddings that inform our rotation matrix and zigzag permutation order. We also explore the possibility of calibration-free quantization and show some promising results. However, further investigating more tailored choices for calibration data can potentially enhance the performance of our quantized models. We leave this for future study. ", "page_idx": 26}, {"type": "text", "text": "Broader Impacts. Our work identifies the presence of massive outliers in down-projection layer of FFN modules, which significantly complicates low-bit weight-activation quantization. To address this challenge, we implement a combination of rotation and permutation matrices to effectively smooth both massive and uniform outliers, proving both fast and effective. Consequently, we establish a new state-of-the-art for INT4 weight-activation post-training quantization methods. Our approach aims to accelerate large language models and reduce memory usage during deployment, offering substantial beneftis to the field of LLM research. These advancements could lead to more efficient and accessible LLM applications, facilitating broader usage and enabling more sustainable AI implementations. ", "page_idx": 26}, {"type": "text", "text": "I More Visualizations ", "text_level": 1, "page_idx": 26}, {"type": "text", "text": "We provide additional visualizations of normal and massive outliers in various models (LLaMA1, LLaMA2, Vicuna-v1.5, Mistral) from Figure I1 to Figure I9. In each figure except Mistral, the left side illustrates changes in normal outliers before and after applying our rotation and permutation transformations, while the right side shows the changes in massive outliers before and after transformations. It is evident that massive outliers consistently occur in the down-projection layer of the FFN module across all models, supporting our findings discussed in Section 2. Conversely, normal outliers appear in different modules within the transformation block. For instance, Figure I3 shows normal outliers at the up-projection layer of the FFN module in LLaMA1-13B. Significantly, both massive and normal outliers are reduced markedly after our rotation and permutation transformations, leading to easier quantization of activations. This underscores the effectiveness of our DuQuant in managing outlier features across diverse LLM models. ", "page_idx": 26}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/30321694b28a1ce910146146e71ab35ed20635f8c85b2b1b6f5c9e37b3349771.jpg", "img_caption": ["Figure I1: Activation change with the use of our DuQuant for LLaMA1-7B. "], "img_footnote": [], "page_idx": 26}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/708a2e1d869e210adc27d467b78247d2e16c60ec306a1b42c8eb4cb48399f431.jpg", "img_caption": ["Figure I2: Activation change with the use of our DuQuant for LLaMA1-13B. "], "img_footnote": [], "page_idx": 26}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/5aa1e98e9a6ea70dec7b1f3dee0976d03e128e3c699fcf28913eaa568b2f7104.jpg", "img_caption": ["Figure I3: More examples of activation change with the use of our DuQuant for LLaMA1-13B. "], "img_footnote": [], "page_idx": 27}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/310f9b6169fe9f15c3a09549cb97a72d3154f66cdf8db6c2d29a11938d72fb8d.jpg", "img_caption": ["Figure I4: Activation change with the use of our DuQuant for LLaMA1-65B. "], "img_footnote": [], "page_idx": 27}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/79a0fff8d0c759084f5a34d839e19f8696c59da498aaf832db02000692b19bb8.jpg", "img_caption": ["Figure I5: Activation change with the use of our DuQuant for LLaMA2-13B. "], "img_footnote": [], "page_idx": 27}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/465b7be96c3ca6b5abbb46da2a183e1ae7a960b0c2af772e8a04a70520faa81b.jpg", "img_caption": ["Figure I6: Activation change with the use of our DuQuant for LLaMA2-70B. "], "img_footnote": [], "page_idx": 28}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/8653a9ceb44053261a4714d70592db614231640e44617205552f3246a197c281.jpg", "img_caption": ["Figure I7: Activation change with the use of our DuQuant for Vicuna-v1.5-7B. "], "img_footnote": [], "page_idx": 28}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/6bacb2271d186f6f543f87485372b4c16c414f6dc390c83c2919adcdccfdadaa.jpg", "img_caption": ["Figure I8: Activation change with the use of our DuQuant for Vicuna-v1.5-13B. "], "img_footnote": [], "page_idx": 28}, {"type": "image", "img_path": "mp8u2Pcmqz/tmp/10b388a26121b583e15cc691e98b99a202b1cb03b3efb947c7e9645d37c0c39e.jpg", "img_caption": ["Figure I9: Massive activation change with the use of our DuQuant for Mistral7B. "], "img_footnote": [], "page_idx": 28}, {"type": "text", "text": "NeurIPS Paper Checklist ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "1. Claims ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Do the main claims made in the abstract and introduction accurately reflect the paper\u2019s contributions and scope? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 29}, {"type": "text", "text": "Justification: We state the contributions in the abstract and introduction sections. ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the abstract and introduction do not include the claims made in the paper.   \n\u2022 The abstract and/or introduction should clearly state the claims made, including the contributions made in the paper and important assumptions and limitations. A No or NA answer to this question will not be perceived well by the reviewers.   \n\u2022 The claims made should match theoretical and experimental results, and reflect how much the results can be expected to generalize to other settings.   \n\u2022 It is fine to include aspirational goals as motivation as long as it is clear that these goals are not attained by the paper. ", "page_idx": 29}, {"type": "text", "text": "2. Limitations ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: Does the paper discuss the limitations of the work performed by the authors? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Justification: We discuss the main limitations in Appendix H ", "page_idx": 29}, {"type": "text", "text": "Guidelines: ", "page_idx": 29}, {"type": "text", "text": "\u2022 The answer NA means that the paper has no limitation while the answer No means that the paper has limitations, but those are not discussed in the paper.   \n\u2022 The authors are encouraged to create a separate \"Limitations\" section in their paper.   \n\u2022 The paper should point out any strong assumptions and how robust the results are to violations of these assumptions (e.g., independence assumptions, noiseless settings, model well-specification, asymptotic approximations only holding locally). The authors should reflect on how these assumptions might be violated in practice and what the implications would be.   \n\u2022 The authors should reflect on the scope of the claims made, e.g., if the approach was only tested on a few datasets or with a few runs. In general, empirical results often depend on implicit assumptions, which should be articulated.   \n\u2022 The authors should reflect on the factors that influence the performance of the approach. For example, a facial recognition algorithm may perform poorly when image resolution is low or images are taken in low lighting. Or a speech-to-text system might not be used reliably to provide closed captions for online lectures because it fails to handle technical jargon.   \n\u2022 The authors should discuss the computational efficiency of the proposed algorithms and how they scale with dataset size.   \n\u2022 If applicable, the authors should discuss possible limitations of their approach to address problems of privacy and fairness.   \n\u2022 While the authors might fear that complete honesty about limitations might be used by reviewers as grounds for rejection, a worse outcome might be that reviewers discover limitations that aren\u2019t acknowledged in the paper. The authors should use their best judgment and recognize that individual actions in favor of transparency play an important role in developing norms that preserve the integrity of the community. Reviewers will be specifically instructed to not penalize honesty concerning limitations. ", "page_idx": 29}, {"type": "text", "text": "3. Theory Assumptions and Proofs ", "text_level": 1, "page_idx": 29}, {"type": "text", "text": "Question: For each theoretical result, does the paper provide the full set of assumptions and a complete (and correct) proof? ", "page_idx": 29}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 29}, {"type": "text", "text": "Justification: Please refer to Appendix B for related assumptions and proofs. Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include theoretical results.   \n\u2022 All the theorems, formulas, and proofs in the paper should be numbered and crossreferenced.   \n\u2022 All assumptions should be clearly stated or referenced in the statement of any theorems.   \n\u2022 The proofs can either appear in the main paper or the supplemental material, but if they appear in the supplemental material, the authors are encouraged to provide a short proof sketch to provide intuition.   \n\u2022 Inversely, any informal proof provided in the core of the paper should be complemented by formal proofs provided in appendix or supplemental material.   \n\u2022 Theorems and Lemmas that the proof relies upon should be properly referenced. ", "page_idx": 30}, {"type": "text", "text": "4. Experimental Result Reproducibility ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: Does the paper fully disclose all the information needed to reproduce the main experimental results of the paper to the extent that it affects the main claims and/or conclusions of the paper (regardless of whether the code and data are provided or not)? ", "page_idx": 30}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Justification: Implementation details are provided in Appendix C. We have released our code at https://github.com/Hsu1023/DuQuant. ", "page_idx": 30}, {"type": "text", "text": "Guidelines: ", "page_idx": 30}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 If the paper includes experiments, a No answer to this question will not be perceived well by the reviewers: Making the paper reproducible is important, regardless of whether the code and data are provided or not.   \n\u2022 If the contribution is a dataset and/or model, the authors should describe the steps taken to make their results reproducible or verifiable.   \n\u2022 Depending on the contribution, reproducibility can be accomplished in various ways. For example, if the contribution is a novel architecture, describing the architecture fully might suffice, or if the contribution is a specific model and empirical evaluation, it may be necessary to either make it possible for others to replicate the model with the same dataset, or provide access to the model. In general. releasing code and data is often one good way to accomplish this, but reproducibility can also be provided via detailed instructions for how to replicate the results, access to a hosted model (e.g., in the case of a large language model), releasing of a model checkpoint, or other means that are appropriate to the research performed.   \n\u2022 While NeurIPS does not require releasing code, the conference does require all submissions to provide some reasonable avenue for reproducibility, which may depend on the nature of the contribution. For example (a) If the contribution is primarily a new algorithm, the paper should make it clear how to reproduce that algorithm. (b) If the contribution is primarily a new model architecture, the paper should describe the architecture clearly and fully. (c) If the contribution is a new model (e.g., a large language model), then there should either be a way to access this model for reproducing the results or a way to reproduce the model (e.g., with an open-source dataset or instructions for how to construct the dataset). (d) We recognize that reproducibility may be tricky in some cases, in which case authors are welcome to describe the particular way they provide for reproducibility. In the case of closed-source models, it may be that access to the model is limited in some way (e.g., to registered users), but it should be possible for other researchers to have some path to reproducing or verifying the results. ", "page_idx": 30}, {"type": "text", "text": "5. Open access to data and code ", "text_level": 1, "page_idx": 30}, {"type": "text", "text": "Question: Does the paper provide open access to the data and code, with sufficient instructions to faithfully reproduce the main experimental results, as described in supplemental material? ", "page_idx": 30}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 31}, {"type": "text", "text": "Justification: We have released our code at https://github.com/Hsu1023/DuQuant. Guidelines: ", "page_idx": 31}, {"type": "text", "text": "\u2022 The answer NA means that paper does not include experiments requiring code.   \n\u2022 Please see the NeurIPS code and data submission guidelines (https://nips.cc/ public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 While we encourage the release of code and data, we understand that this might not be possible, so \u201cNo\u201d is an acceptable answer. Papers cannot be rejected simply for not including code, unless this is central to the contribution (e.g., for a new open-source benchmark).   \n\u2022 The instructions should contain the exact command and environment needed to run to reproduce the results. See the NeurIPS code and data submission guidelines (https: //nips.cc/public/guides/CodeSubmissionPolicy) for more details.   \n\u2022 The authors should provide instructions on data access and preparation, including how to access the raw data, preprocessed data, intermediate data, and generated data, etc.   \n\u2022 The authors should provide scripts to reproduce all experimental results for the new proposed method and baselines. If only a subset of experiments are reproducible, they should state which ones are omitted from the script and why.   \n\u2022 At submission time, to preserve anonymity, the authors should release anonymized versions (if applicable).   \n\u2022 Providing as much information as possible in supplemental material (appended to the paper) is recommended, but including URLs to data and code is permitted. ", "page_idx": 31}, {"type": "text", "text": "6. Experimental Setting/Details ", "text_level": 1, "page_idx": 31}, {"type": "text", "text": "Question: Does the paper specify all the training and test details (e.g., data splits, hyperparameters, how they were chosen, type of optimizer, etc.) necessary to understand the results? ", "page_idx": 31}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 31}, {"type": "text", "text": "Justification: Please refer to Section 4 and Appendix C for experimental settings. Guidelines: ", "page_idx": 31}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments. \u2022 The experimental setting should be presented in the core of the paper to a level of detail that is necessary to appreciate the results and make sense of them. \u2022 The full details can be provided either with the code, in appendix, or as supplemental material. ", "page_idx": 31}, {"type": "text", "text": "7. Experiment Statistical Significance ", "text_level": 1, "page_idx": 31}, {"type": "text", "text": "Question: Does the paper report error bars suitably and correctly defined or other appropriate information about the statistical significance of the experiments? ", "page_idx": 31}, {"type": "text", "text": "Answer: [No] ", "page_idx": 31}, {"type": "text", "text": "Justification: Our study used a fixed seed for all quantization operations, following standards in post-training quantization, and thus did not report statistical significance. ", "page_idx": 31}, {"type": "text", "text": "Guidelines: ", "page_idx": 31}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The authors should answer \"Yes\" if the results are accompanied by error bars, confidence intervals, or statistical significance tests, at least for the experiments that support the main claims of the paper.   \n\u2022 The factors of variability that the error bars are capturing should be clearly stated (for example, train/test split, initialization, random drawing of some parameter, or overall run with given experimental conditions).   \n\u2022 The method for calculating the error bars should be explained (closed form formula, call to a library function, bootstrap, etc.)   \n\u2022 The assumptions made should be given (e.g., Normally distributed errors).   \n\u2022 It should be clear whether the error bar is the standard deviation or the standard error of the mean.   \n\u2022 It is OK to report 1-sigma error bars, but one should state it. The authors should preferably report a 2-sigma error bar than state that they have a $96\\%$ CI, if the hypothesis of Normality of errors is not verified.   \n\u2022 For asymmetric distributions, the authors should be careful not to show in tables or figures symmetric error bars that would yield results that are out of range (e.g. negative error rates).   \n\u2022 If error bars are reported in tables or plots, The authors should explain in the text how they were calculated and reference the corresponding figures or tables in the text. ", "page_idx": 31}, {"type": "text", "text": "", "page_idx": 32}, {"type": "text", "text": "8. Experiments Compute Resources ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Question: For each experiment, does the paper provide sufficient information on the computer resources (type of compute workers, memory, time of execution) needed to reproduce the experiments? ", "page_idx": 32}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 32}, {"type": "text", "text": "Justification: All experiments are done on NVIDIA RTX 3090 GPUs and A100 GPUs. ", "page_idx": 32}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not include experiments.   \n\u2022 The paper should indicate the type of compute workers CPU or GPU, internal cluster, or cloud provider, including relevant memory and storage.   \n\u2022 The paper should provide the amount of compute required for each of the individual experimental runs as well as estimate the total compute.   \n\u2022 The paper should disclose whether the full research project required more compute than the experiments reported in the paper (e.g., preliminary or failed experiments that didn\u2019t make it into the paper). ", "page_idx": 32}, {"type": "text", "text": "9. Code Of Ethics ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Question: Does the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines? ", "page_idx": 32}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Justification: We confirm the research conducted in the paper conform, in every respect, with the NeurIPS Code of Ethics. ", "page_idx": 32}, {"type": "text", "text": "Guidelines: ", "page_idx": 32}, {"type": "text", "text": "\u2022 The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics.   \n\u2022 If the authors answer No, they should explain the special circumstances that require a deviation from the Code of Ethics.   \n\u2022 The authors should make sure to preserve anonymity (e.g., if there is a special consideration due to laws or regulations in their jurisdiction). ", "page_idx": 32}, {"type": "text", "text": "10. Broader Impacts ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Question: Does the paper discuss both potential positive societal impacts and negative societal impacts of the work performed? ", "page_idx": 32}, {"type": "text", "text": "Answer: [Yes] ", "text_level": 1, "page_idx": 32}, {"type": "text", "text": "Justification: We discuss the broader impacts of our work in Appendix H. ", "page_idx": 32}, {"type": "text", "text": "\u2022 The answer NA means that there is no societal impact of the work performed.   \n\u2022 If the authors answer NA or No, they should explain why their work has no societal impact or why the paper does not address societal impact.   \n\u2022 Examples of negative societal impacts include potential malicious or unintended uses (e.g., disinformation, generating fake profiles, surveillance), fairness considerations (e.g., deployment of technologies that could make decisions that unfairly impact specific groups), privacy considerations, and security considerations.   \n\u2022 The conference expects that many papers will be foundational research and not tied to particular applications, let alone deployments. However, if there is a direct path to any negative applications, the authors should point it out. For example, it is legitimate to point out that an improvement in the quality of generative models could be used to ", "page_idx": 32}, {"type": "text", "text": "generate deepfakes for disinformation. On the other hand, it is not needed to point out that a generic algorithm for optimizing neural networks could enable people to train models that generate Deepfakes faster. ", "page_idx": 33}, {"type": "text", "text": "\u2022 The authors should consider possible harms that could arise when the technology is being used as intended and functioning correctly, harms that could arise when the technology is being used as intended but gives incorrect results, and harms following from (intentional or unintentional) misuse of the technology. \u2022 If there are negative societal impacts, the authors could also discuss possible mitigation strategies (e.g., gated release of models, providing defenses in addition to attacks, mechanisms for monitoring misuse, mechanisms to monitor how a system learns from feedback over time, improving the efficiency and accessibility of ML). ", "page_idx": 33}, {"type": "text", "text": "11. Safeguards ", "text_level": 1, "page_idx": 33}, {"type": "text", "text": "Question: Does the paper describe safeguards that have been put in place for responsible release of data or models that have a high risk for misuse (e.g., pretrained language models, image generators, or scraped datasets)? ", "page_idx": 33}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 33}, {"type": "text", "text": "Justification: This work poses no such risks. ", "page_idx": 33}, {"type": "text", "text": "Guidelines: ", "page_idx": 33}, {"type": "text", "text": "\u2022 The answer NA means that the paper poses no such risks.   \n\u2022 Released models that have a high risk for misuse or dual-use should be released with necessary safeguards to allow for controlled use of the model, for example by requiring that users adhere to usage guidelines or restrictions to access the model or implementing safety filters.   \n\u2022 Datasets that have been scraped from the Internet could pose safety risks. The authors should describe how they avoided releasing unsafe images.   \n\u2022 We recognize that providing effective safeguards is challenging, and many papers do not require this, but we encourage authors to take this into account and make a best faith effort. ", "page_idx": 33}, {"type": "text", "text": "12. Licenses for existing assets ", "text_level": 1, "page_idx": 33}, {"type": "text", "text": "Question: Are the creators or original owners of assets (e.g., code, data, models), used in the paper, properly credited and are the license and terms of use explicitly mentioned and properly respected? ", "page_idx": 33}, {"type": "text", "text": "Answer: [Yes] ", "page_idx": 33}, {"type": "text", "text": "Justification: We cite all datasets and models utilized in our experiments. ", "page_idx": 33}, {"type": "text", "text": "Guidelines: ", "page_idx": 33}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not use existing assets.   \n\u2022 The authors should cite the original paper that produced the code package or dataset.   \n\u2022 The authors should state which version of the asset is used and, if possible, include a URL.   \n\u2022 The name of the license (e.g., CC-BY 4.0) should be included for each asset.   \n\u2022 For scraped data from a particular source (e.g., website), the copyright and terms of service of that source should be provided.   \n\u2022 If assets are released, the license, copyright information, and terms of use in the package should be provided. For popular datasets, paperswithcode.com/datasets has curated licenses for some datasets. Their licensing guide can help determine the license of a dataset.   \n\u2022 For existing datasets that are re-packaged, both the original license and the license of the derived asset (if it has changed) should be provided.   \n\u2022 If this information is not available online, the authors are encouraged to reach out to the asset\u2019s creators. ", "page_idx": 33}, {"type": "text", "text": "13. New Assets ", "text_level": 1, "page_idx": 33}, {"type": "text", "text": "Question: Are new assets introduced in the paper well documented and is the documentation provided alongside the assets? ", "page_idx": 33}, {"type": "text", "text": "Answer: [NA] ", "page_idx": 34}, {"type": "text", "text": "Justification: This work does not release new assets. ", "page_idx": 34}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not release new assets.   \n\u2022 Researchers should communicate the details of the dataset/code/model as part of their submissions via structured templates. This includes details about training, license, limitations, etc.   \n\u2022 The paper should discuss whether and how consent was obtained from people whose asset is used.   \n\u2022 At submission time, remember to anonymize your assets (if applicable). You can either create an anonymized URL or include an anonymized zip file. ", "page_idx": 34}, {"type": "text", "text": "14. Crowdsourcing and Research with Human Subjects ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Question: For crowdsourcing experiments and research with human subjects, does the paper include the full text of instructions given to participants and screenshots, if applicable, as well as details about compensation (if any)? ", "page_idx": 34}, {"type": "text", "text": "Answer: [NA] ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Justification: This work does not involve crowdsourcing nor research with human subjects. ", "page_idx": 34}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Including this information in the supplemental material is fine, but if the main contribution of the paper involves human subjects, then as much detail as possible should be included in the main paper.   \n\u2022 According to the NeurIPS Code of Ethics, workers involved in data collection, curation, or other labor should be paid at least the minimum wage in the country of the data collector. ", "page_idx": 34}, {"type": "text", "text": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with Human Subjects ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Question: Does the paper describe potential risks incurred by study participants, whether such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) approvals (or an equivalent approval/review based on the requirements of your country or institution) were obtained? ", "page_idx": 34}, {"type": "text", "text": "Answer: [NA] ", "text_level": 1, "page_idx": 34}, {"type": "text", "text": "Justification: This work does not involve crowdsourcing nor research with human subjects. ", "page_idx": 34}, {"type": "text", "text": "\u2022 The answer NA means that the paper does not involve crowdsourcing nor research with human subjects.   \n\u2022 Depending on the country in which research is conducted, IRB approval (or equivalent) may be required for any human subjects research. If you obtained IRB approval, you should clearly state this in the paper.   \n\u2022 We recognize that the procedures for this may vary significantly between institutions and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the guidelines for their institution.   \n\u2022 For initial submissions, do not include any information that would break anonymity (if applicable), such as the institution conducting the review. ", "page_idx": 34}]