[{"figure_path": "cFqAANINgW/figures/figures_1_1.jpg", "caption": "Figure 1: A flowgraph illustrates FUNCODER. FunCoder branches off new functions to have sub-goals tackled iteratively (left), re-composites sub-functions, and selects the best using functional consensus (right). Bottom-right figure shows how FUNCODER writes functions at hierarchy-level.", "description": "This figure illustrates the FUNCODER framework. The left side shows the divide-and-conquer process where the main function is recursively broken down into smaller sub-functions represented as a tree.  The right side shows how the sub-functions are recombined and the best one is selected using functional consensus, which compares the similarity of the functionality between multiple candidates. The bottom-right depicts the hierarchical function writing process.", "section": "2 FUNCODER: Divide-and-Conquer Meets Consensus"}, {"figure_path": "cFqAANINgW/figures/figures_2_1.jpg", "caption": "Figure 1: A flowgraph illustrates FUNCODER. FunCoder branches off new functions to have sub-goals tackled iteratively (left), re-composites sub-functions, and selects the best using functional consensus (right). Bottom-right figure shows how FUNCODER writes functions at hierarchy-level.", "description": "This figure illustrates the FUNCODER framework. The left side shows the divide-and-conquer process where the main function is recursively broken down into smaller sub-functions represented as a tree. Each sub-function addresses a specific sub-goal.  The right side demonstrates the conquer phase.  After the sub-functions are solved, FUNCODER recomposes them to achieve the main objective. Finally, FUNCODER uses functional consensus to select the best-performing function among multiple implementations.", "section": "2 FUNCODER: Divide-and-Conquer Meets Consensus"}, {"figure_path": "cFqAANINgW/figures/figures_5_1.jpg", "caption": "Figure 3: (a) Preliminary study on self-testing, the programs are evaluated using unit-tests generated by LLMs. (b) The effectiveness of different ranking strategies. We compute the Pass@k over top-k programs ranked by functional consensus, self-test, and random on 11 candidates. (higher is better)", "description": "This figure shows the results of two analyses. (a) shows a preliminary study on the effectiveness of using self-testing to evaluate the programs generated by Large Language Models (LLMs). The results are divided into different categories based on whether the programs and/or their self-tests passed or failed. (b) illustrates the effectiveness of different ranking strategies used in the paper to select the best-performing functions. The strategies are: functional consensus, self-testing, and random selection. The Pass@k metric is used to evaluate the top k functions. The results suggest that the functional consensus approach is superior to both the self-testing method and random selection.", "section": "3.1.3 Analysis"}, {"figure_path": "cFqAANINgW/figures/figures_7_1.jpg", "caption": "Figure 3: (a) Preliminary study on self-testing, the programs are evaluated using unit-tests generated by LLMs. (b) The effectiveness of different ranking strategies. We compute the Pass@k over top-k programs ranked by functional consensus, self-test, and random on 11 candidates. (higher is better)", "description": "This figure presents the results of two studies.  (a) shows a preliminary analysis of the reliability of self-testing in code generation. LLMs were used to generate unit tests for programs, and these programs were then evaluated on these generated tests.  The results show that the pass rate on these self-generated tests was much lower than on actual system tests. (b) compares the effectiveness of different ranking strategies in selecting the best program from a set of candidates. Three strategies were compared: functional consensus, self-testing, and random selection. The results demonstrate that functional consensus provides superior performance in identifying high-quality programs, particularly in Pass@k evaluation metrics.", "section": "3.1.3 Analysis"}, {"figure_path": "cFqAANINgW/figures/figures_20_1.jpg", "caption": "Figure 1: A flowgraph illustrates FUNCODER. FunCoder branches off new functions to have sub-goals tackled iteratively (left), re-composites sub-functions, and selects the best using functional consensus (right). Bottom-right figure shows how FUNCODER writes functions at hierarchy-level.", "description": "This figure illustrates the FUNCODER framework. The left side shows the divide-and-conquer strategy where the main function is recursively broken down into smaller sub-functions represented in a tree hierarchy.  The right side depicts the consensus mechanism, where multiple implementations of sub-functions are generated and the best one is selected based on functional similarity. The bottom-right shows how FUNCODER generates code by writing functions at different hierarchical levels.", "section": "2 FUNCODER: Divide-and-Conquer Meets Consensus"}]